>> The source files are:
>>> file_path: ../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/RunContainer.java
/*
 * (c) the authors Licensed under the Apache License, Version 2.0.
 */
package org.roaringbitmap;

import org.roaringbitmap.buffer.MappeableContainer;
import org.roaringbitmap.buffer.MappeableRunContainer;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.CharBuffer;
import java.util.Arrays;
import java.util.Iterator;


/**
 * This container takes the form of runs of consecutive values (effectively, run-length encoding).
 *
 * Adding and removing content from this container might make it wasteful so regular calls to
 * "runOptimize" might be warranted.
 */
public final class RunContainer extends Container implements Cloneable {
  private static final int DEFAULT_INIT_SIZE = 4;
  private static final boolean ENABLE_GALLOPING_AND = false;

  private static final long serialVersionUID = 1L;

  private static int branchyUnsignedInterleavedBinarySearch(final char[] array, final int begin,
      final int end, final char k) {
    int low = begin;
    int high = end - 1;
    while (low <= high) {
      final int middleIndex = (low + high) >>> 1;
      final int middleValue = (array[2 * middleIndex]);
      if (middleValue < (int) (k)) {
        low = middleIndex + 1;
      } else if (middleValue > (int) (k)) {
        high = middleIndex - 1;
      } else {
        return middleIndex;
      }
    }
    return -(low + 1);
  }

  // starts with binary search and finishes with a sequential search
  private static int hybridUnsignedInterleavedBinarySearch(final char[] array, final int begin,
      final int end, final char k) {
    int low = begin;
    int high = end - 1;
    // 16 in the next line matches the size of a cache line
    while (low + 16 <= high) {
      final int middleIndex = (low + high) >>> 1;
      final int middleValue = (array[2 * middleIndex]);
      if (middleValue < (int) (k)) {
        low = middleIndex + 1;
      } else if (middleValue > (int) (k)) {
        high = middleIndex - 1;
      } else {
        return middleIndex;
      }
    }
    // we finish the job with a sequential search
    int x = low;
    for (; x <= high; ++x) {
      final int val = (array[2 * x]);
      if (val >= (int) (k)) {
        if (val == (int) (k)) {
          return x;
        }
        break;
      }
    }
    return -(x + 1);
  }

  protected static int serializedSizeInBytes(int numberOfRuns) {
    return 2 + 2 * 2 * numberOfRuns; // each run requires 2 2-byte entries.
  }

  private static int unsignedInterleavedBinarySearch(final char[] array, final int begin,
      final int end, final char k) {
    if (Util.USE_HYBRID_BINSEARCH) {
      return hybridUnsignedInterleavedBinarySearch(array, begin, end, k);
    } else {
      return branchyUnsignedInterleavedBinarySearch(array, begin, end, k);
    }

  }

  private char[] valueslength;// we interleave values and lengths, so
  // that if you have the values 11,12,13,14,15, you store that as 11,4 where 4 means that beyond 11
  // itself, there are
  // 4 contiguous values that follows.
  // Other example: e.g., 1, 10, 20,0, 31,2 would be a concise representation of 1, 2, ..., 11, 20,
  // 31, 32, 33

  int nbrruns = 0;// how many runs, this number should fit in 16 bits.


  /**
   * Create a container with default capacity
   */
  public RunContainer() {
    this(DEFAULT_INIT_SIZE);
  }


  protected RunContainer(ArrayContainer arr, int nbrRuns) {
    this.nbrruns = nbrRuns;
    valueslength = new char[2 * nbrRuns];
    if (nbrRuns == 0) {
      return;
    }

    int prevVal = -2;
    int runLen = 0;
    int runCount = 0;

    for (int i = 0; i < arr.cardinality; i++) {
      int curVal = arr.content[i];
      if (curVal == prevVal + 1) {
        ++runLen;
      } else {
        if (runCount > 0) {
          setLength(runCount - 1, (char) runLen);
        }
        setValue(runCount, (char) curVal);
        runLen = 0;
        ++runCount;
      }
      prevVal = curVal;
    }
    setLength(runCount - 1, (char) runLen);
  }

  /**
   * Create an run container with a run of ones from firstOfRun to lastOfRun.
   *
   * @param firstOfRun first index
   * @param lastOfRun last index (range is exclusive)
   */
  public RunContainer(final int firstOfRun, final int lastOfRun) {
    this.nbrruns = 1;
    this.valueslength = new char[]{(char) firstOfRun, (char) (lastOfRun - 1 - firstOfRun)};
  }

  // convert a bitmap container to a run container somewhat efficiently.
  protected RunContainer(BitmapContainer bc, int nbrRuns) {
    this.nbrruns = nbrRuns;
    valueslength = new char[2 * nbrRuns];
    if (nbrRuns == 0) {
      return;
    }

    int longCtr = 0; // index of current long in bitmap
    long curWord = bc.bitmap[0]; // its value
    int runCount = 0;
    while (true) {
      // potentially multiword advance to first 1 bit
      while (curWord == 0L && longCtr < bc.bitmap.length - 1) {
        curWord = bc.bitmap[++longCtr];
      }

      if (curWord == 0L) {
        // wrap up, no more runs
        return;
      }
      int localRunStart = Long.numberOfTrailingZeros(curWord);
      int runStart = localRunStart + 64 * longCtr;
      // stuff 1s into number's LSBs
      long curWordWith1s = curWord | (curWord - 1);

      // find the next 0, potentially in a later word
      int runEnd;
      while (curWordWith1s == -1L && longCtr < bc.bitmap.length - 1) {
        curWordWith1s = bc.bitmap[++longCtr];
      }

      if (curWordWith1s == -1L) {
        // a final unterminated run of 1s (32 of them)
        runEnd = 64 + longCtr * 64;
        setValue(runCount, (char) runStart);
        setLength(runCount, (char) (runEnd - runStart - 1));
        return;
      }
      int localRunEnd = Long.numberOfTrailingZeros(~curWordWith1s);
      runEnd = localRunEnd + longCtr * 64;
      setValue(runCount, (char) runStart);
      setLength(runCount, (char) (runEnd - runStart - 1));
      runCount++;
      // now, zero out everything right of runEnd.
      curWord = curWordWith1s & (curWordWith1s + 1);
      // We've lathered and rinsed, so repeat...
    }
  }

  /**
   * Create an array container with specified capacity
   *
   * @param capacity The capacity of the container
   */
  public RunContainer(final int capacity) {
    valueslength = new char[2 * capacity];
  }


  private RunContainer(int nbrruns, char[] valueslength) {
    this.nbrruns = nbrruns;
    this.valueslength = Arrays.copyOf(valueslength, valueslength.length);
  }


  /**
   * Creates a new non-mappeable container from a mappeable one. This copies the data.
   *
   * @param bc the original container
   */
  public RunContainer(MappeableRunContainer bc) {
    this.nbrruns = bc.numberOfRuns();
    this.valueslength = bc.toCharArray();
  }

  /**
   * Construct a new RunContainer backed by the provided array. Note that if you modify the
   * RunContainer a new array may be produced.
   *
   * @param array array where the data is stored
   * @param numRuns number of runs (each using 2 shorts in the buffer)
   *
   */
  public RunContainer(final char[] array, final int numRuns) {
    if (array.length < 2 * numRuns) {
      throw new RuntimeException("Mismatch between buffer and numRuns");
    }
    this.nbrruns = numRuns;
    this.valueslength = array;
  }

  @Override
  public Container add(int begin, int end) {
    RunContainer rc = (RunContainer) clone();
    return rc.iadd(begin, end);
  }

  @Override
  public Container add(char k) {
    // TODO: it might be better and simpler to do return
    // toBitmapOrArrayContainer(getCardinality()).add(k)
    // but note that some unit tests use this method to build up test runcontainers without calling
    // runOptimize
    int index = unsignedInterleavedBinarySearch(valueslength, 0, nbrruns, k);
    if (index >= 0) {
      return this;// already there
    }
    index = -index - 2;// points to preceding value, possibly -1
    if (index >= 0) {// possible match
      int offset = (k) - (getValue(index));
      int le = (getLength(index));
      if (offset <= le) {
        return this;
      }
      if (offset == le + 1) {
        // we may need to fuse
        if (index + 1 < nbrruns) {
          if ((getValue(index + 1)) == (k) + 1) {
            // indeed fusion is needed
            setLength(index,
                (char) (getValue(index + 1) + getLength(index + 1) - getValue(index)));
            recoverRoomAtIndex(index + 1);
            return this;
          }
        }
        incrementLength(index);
        return this;
      }
      if (index + 1 < nbrruns) {
        // we may need to fuse
        if ((getValue(index + 1)) == (k) + 1) {
          // indeed fusion is needed
          setValue(index + 1, k);
          setLength(index + 1, (char) (getLength(index + 1) + 1));
          return this;
        }
      }
    }
    if (index == -1) {
      // we may need to extend the first run
      if (0 < nbrruns) {
        if (getValue(0) == k + 1) {
          incrementLength(0);
          decrementValue(0);
          return this;
        }
      }
    }
    makeRoomAtIndex(index + 1);
    setValue(index + 1, k);
    setLength(index + 1, (char) 0);
    return this;
  }

  @Override
  public Container and(ArrayContainer x) {
    ArrayContainer ac = new ArrayContainer(x.cardinality);
    if (this.nbrruns == 0) {
      return ac;
    }
    int rlepos = 0;
    int arraypos = 0;

    int rleval = (this.getValue(rlepos));
    int rlelength = (this.getLength(rlepos));
    while (arraypos < x.cardinality) {
      int arrayval = (x.content[arraypos]);
      while (rleval + rlelength < arrayval) {// this will frequently be false
        ++rlepos;
        if (rlepos == this.nbrruns) {
          return ac;// we are done
        }
        rleval = (this.getValue(rlepos));
        rlelength = (this.getLength(rlepos));
      }
      if (rleval > arrayval) {
        arraypos = Util.advanceUntil(x.content, arraypos, x.cardinality, (char)rleval);
      } else {
        ac.content[ac.cardinality] = (char) arrayval;
        ac.cardinality++;
        arraypos++;
      }
    }
    return ac;
  }


  @Override
  public Container and(BitmapContainer x) {
    // could be implemented as return toBitmapOrArrayContainer().iand(x);
    int card = this.getCardinality();
    if (card <= ArrayContainer.DEFAULT_MAX_SIZE) {
      // result can only be an array (assuming that we never make a RunContainer)
      if (card > x.cardinality) {
        card = x.cardinality;
      }
      ArrayContainer answer = new ArrayContainer(card);
      answer.cardinality = 0;
      for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
        int runStart = (this.getValue(rlepos));
        int runEnd = runStart + (this.getLength(rlepos));
        for (int runValue = runStart; runValue <= runEnd; ++runValue) {
          if (x.contains((char) runValue)) {// it looks like contains() should be cheap enough if
                                             // accessed sequentially
            answer.content[answer.cardinality++] = (char) runValue;
          }
        }
      }
      return answer;
    }
    // we expect the answer to be a bitmap (if we are lucky)
    BitmapContainer answer = x.clone();
    int start = 0;
    for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
      int end = (this.getValue(rlepos));
      int prevOnes = answer.cardinalityInRange(start, end);
      Util.resetBitmapRange(answer.bitmap, start, end); // had been x.bitmap
      answer.updateCardinality(prevOnes, 0);
      start = end + (this.getLength(rlepos)) + 1;
    }
    int ones = answer.cardinalityInRange(start, BitmapContainer.MAX_CAPACITY);
    Util.resetBitmapRange(answer.bitmap, start, BitmapContainer.MAX_CAPACITY); // had been x.bitmap
    answer.updateCardinality(ones, 0);
    if (answer.getCardinality() > ArrayContainer.DEFAULT_MAX_SIZE) {
      return answer;
    } else {
      return answer.toArrayContainer();
    }
  }

  @Override
  public Container and(RunContainer x) {
    int maxRunsAfterIntersection = nbrruns + x.nbrruns;
    RunContainer answer = new RunContainer(new char[2 * maxRunsAfterIntersection], 0);
    if (isEmpty()) {
      return answer;
    }
    int rlepos = 0;
    int xrlepos = 0;
    int start = this.getValue(rlepos);
    int end = start + this.getLength(rlepos) + 1;
    int xstart = x.getValue(xrlepos);
    int xend = xstart + x.getLength(xrlepos) + 1;
    while (rlepos < this.nbrruns && xrlepos < x.nbrruns) {
      if (end <= xstart) {
        if (ENABLE_GALLOPING_AND) {
          rlepos = skipAhead(this, rlepos, xstart); // skip over runs until we have end > xstart (or
                                                    // rlepos is advanced beyond end)
        } else {
          ++rlepos;
        }

        if (rlepos < this.nbrruns) {
          start = this.getValue(rlepos);
          end = start + this.getLength(rlepos) + 1;
        }
      } else if (xend <= start) {
        // exit the second run
        if (ENABLE_GALLOPING_AND) {
          xrlepos = skipAhead(x, xrlepos, start);
        } else {
          ++xrlepos;
        }

        if (xrlepos < x.nbrruns) {
          xstart = x.getValue(xrlepos);
          xend = xstart + x.getLength(xrlepos) + 1;
        }
      } else {// they overlap
        final int lateststart = Math.max(start, xstart);
        int earliestend;
        if (end == xend) {// improbable
          earliestend = end;
          rlepos++;
          xrlepos++;
          if (rlepos < this.nbrruns) {
            start = this.getValue(rlepos);
            end = start + this.getLength(rlepos) + 1;
          }
          if (xrlepos < x.nbrruns) {
            xstart = x.getValue(xrlepos);
            xend = xstart + x.getLength(xrlepos) + 1;
          }
        } else if (end < xend) {
          earliestend = end;
          rlepos++;
          if (rlepos < this.nbrruns) {
            start = this.getValue(rlepos);
            end = start + this.getLength(rlepos) + 1;
          }

        } else {// end > xend
          earliestend = xend;
          xrlepos++;
          if (xrlepos < x.nbrruns) {
            xstart = x.getValue(xrlepos);
            xend = xstart + x.getLength(xrlepos) + 1;
          }
        }
        answer.valueslength[2 * answer.nbrruns] = (char) lateststart;
        answer.valueslength[2 * answer.nbrruns + 1] = (char) (earliestend - lateststart - 1);
        answer.nbrruns++;
      }
    }
    return answer.toEfficientContainer(); // subsequent trim() may be required to avoid wasted
                                          // space.
  }

  @Override
  public int andCardinality(ArrayContainer x) {
    if (this.nbrruns == 0) {
      return x.cardinality;
    }
    int rlepos = 0;
    int arraypos = 0;
    int andCardinality = 0;
    int rleval = (this.getValue(rlepos));
    int rlelength = (this.getLength(rlepos));
    while (arraypos < x.cardinality) {
      int arrayval = (x.content[arraypos]);
      while (rleval + rlelength < arrayval) {// this will frequently be false
        ++rlepos;
        if (rlepos == this.nbrruns) {
          return andCardinality;// we are done
        }
        rleval = (this.getValue(rlepos));
        rlelength = (this.getLength(rlepos));
      }
      if (rleval > arrayval) {
        arraypos = Util.advanceUntil(x.content, arraypos, x.cardinality, this.getValue(rlepos));
      } else {
        andCardinality++;
        arraypos++;
      }
    }
    return andCardinality;
  }


  @Override
  public int andCardinality(BitmapContainer x) {
    // could be implemented as return toBitmapOrArrayContainer().iand(x);
    int cardinality = 0;
    for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
      int runStart = this.getValue(rlepos);
      int runEnd = runStart + this.getLength(rlepos);
      cardinality += x.cardinalityInRange(runStart, runEnd + 1);
    }
    return cardinality;
  }

  @Override
  public int andCardinality(RunContainer x) {
    int cardinality = 0;
    int rlepos = 0;
    int xrlepos = 0;
    int start = (this.getValue(rlepos));
    int end = start + (this.getLength(rlepos)) + 1;
    int xstart = (x.getValue(xrlepos));
    int xend = xstart + (x.getLength(xrlepos)) + 1;
    while ((rlepos < this.nbrruns) && (xrlepos < x.nbrruns)) {
      if (end <= xstart) {
        if (ENABLE_GALLOPING_AND) {
          rlepos = skipAhead(this, rlepos, xstart); // skip over runs until we have end > xstart (or
                                                    // rlepos is advanced beyond end)
        } else {
          ++rlepos;
        }

        if (rlepos < this.nbrruns) {
          start = (this.getValue(rlepos));
          end = start + (this.getLength(rlepos)) + 1;
        }
      } else if (xend <= start) {
        // exit the second run
        if (ENABLE_GALLOPING_AND) {
          xrlepos = skipAhead(x, xrlepos, start);
        } else {
          ++xrlepos;
        }

        if (xrlepos < x.nbrruns) {
          xstart = (x.getValue(xrlepos));
          xend = xstart + (x.getLength(xrlepos)) + 1;
        }
      } else {// they overlap
        final int lateststart = Math.max(start, xstart);
        int earliestend;
        if (end == xend) {// improbable
          earliestend = end;
          rlepos++;
          xrlepos++;
          if (rlepos < this.nbrruns) {
            start = (this.getValue(rlepos));
            end = start + (this.getLength(rlepos)) + 1;
          }
          if (xrlepos < x.nbrruns) {
            xstart = (x.getValue(xrlepos));
            xend = xstart + (x.getLength(xrlepos)) + 1;
          }
        } else if (end < xend) {
          earliestend = end;
          rlepos++;
          if (rlepos < this.nbrruns) {
            start = (this.getValue(rlepos));
            end = start + (this.getLength(rlepos)) + 1;
          }

        } else {// end > xend
          earliestend = xend;
          xrlepos++;
          if (xrlepos < x.nbrruns) {
            xstart = (x.getValue(xrlepos));
            xend = xstart + (x.getLength(xrlepos)) + 1;
          }
        }
        // earliestend - lateststart are all values that are true.
        cardinality += earliestend - lateststart;
      }
    }
    return cardinality;
  }

  @Override
  public Container andNot(ArrayContainer x) {
    // when x is small, we guess that the result will still be a run container
    final int arbitrary_threshold = 32; // this is arbitrary
    if (x.getCardinality() < arbitrary_threshold) {
      return lazyandNot(x).toEfficientContainer();
    }
    // otherwise we generate either an array or bitmap container
    final int card = getCardinality();
    if (card <= ArrayContainer.DEFAULT_MAX_SIZE) {
      // if the cardinality is small, we construct the solution in place
      ArrayContainer ac = new ArrayContainer(card);
      ac.cardinality =
          Util.unsignedDifference(this.getCharIterator(), x.getCharIterator(), ac.content);
      return ac;
    }
    // otherwise, we generate a bitmap
    return toBitmapOrArrayContainer(card).iandNot(x);
  }

  @Override
  public Container andNot(BitmapContainer x) {
    // could be implemented as toTemporaryBitmap().iandNot(x);
    int card = this.getCardinality();
    if (card <= ArrayContainer.DEFAULT_MAX_SIZE) {
      // result can only be an array (assuming that we never make a RunContainer)
      ArrayContainer answer = new ArrayContainer(card);
      answer.cardinality = 0;
      for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
        int runStart = (this.getValue(rlepos));
        int runEnd = runStart + (this.getLength(rlepos));
        for (int runValue = runStart; runValue <= runEnd; ++runValue) {
          if (!x.contains((char) runValue)) {// it looks like contains() should be cheap enough if
                                              // accessed sequentially
            answer.content[answer.cardinality++] = (char) runValue;
          }
        }
      }
      return answer;
    }
    // we expect the answer to be a bitmap (if we are lucky)
    BitmapContainer answer = x.clone();
    int lastPos = 0;
    for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
      int start = (this.getValue(rlepos));
      int end = start + (this.getLength(rlepos)) + 1;
      int prevOnes = answer.cardinalityInRange(lastPos, start);
      int flippedOnes = answer.cardinalityInRange(start, end);
      Util.resetBitmapRange(answer.bitmap, lastPos, start);
      Util.flipBitmapRange(answer.bitmap, start, end);
      answer.updateCardinality(prevOnes + flippedOnes, end - start - flippedOnes);
      lastPos = end;
    }
    int ones = answer.cardinalityInRange(lastPos, BitmapContainer.MAX_CAPACITY);
    Util.resetBitmapRange(answer.bitmap, lastPos, BitmapContainer.MAX_CAPACITY);
    answer.updateCardinality(ones, 0);
    if (answer.getCardinality() > ArrayContainer.DEFAULT_MAX_SIZE) {
      return answer;
    } else {
      return answer.toArrayContainer();
    }
  }

  @Override
  public Container andNot(RunContainer x) {
    RunContainer answer = new RunContainer(new char[2 * (this.nbrruns + x.nbrruns)], 0);
    int rlepos = 0;
    int xrlepos = 0;
    int start = (this.getValue(rlepos));
    int end = start + (this.getLength(rlepos)) + 1;
    int xstart = (x.getValue(xrlepos));
    int xend = xstart + (x.getLength(xrlepos)) + 1;
    while ((rlepos < this.nbrruns) && (xrlepos < x.nbrruns)) {
      if (end <= xstart) {
        // output the first run
        answer.valueslength[2 * answer.nbrruns] = (char) start;
        answer.valueslength[2 * answer.nbrruns + 1] = (char) (end - start - 1);
        answer.nbrruns++;
        rlepos++;
        if (rlepos < this.nbrruns) {
          start = (this.getValue(rlepos));
          end = start + (this.getLength(rlepos)) + 1;
        }
      } else if (xend <= start) {
        // exit the second run
        xrlepos++;
        if (xrlepos < x.nbrruns) {
          xstart = (x.getValue(xrlepos));
          xend = xstart + (x.getLength(xrlepos)) + 1;
        }
      } else {
        if (start < xstart) {
          answer.valueslength[2 * answer.nbrruns] = (char) start;
          answer.valueslength[2 * answer.nbrruns + 1] = (char) (xstart - start - 1);
          answer.nbrruns++;
        }
        if (xend < end) {
          start = xend;
        } else {
          rlepos++;
          if (rlepos < this.nbrruns) {
            start = (this.getValue(rlepos));
            end = start + (this.getLength(rlepos)) + 1;
          }
        }
      }
    }
    if (rlepos < this.nbrruns) {
      answer.valueslength[2 * answer.nbrruns] = (char) start;
      answer.valueslength[2 * answer.nbrruns + 1] = (char) (end - start - 1);
      answer.nbrruns++;
      rlepos++;
      if (rlepos < this.nbrruns) {
        System.arraycopy(this.valueslength, 2 * rlepos, answer.valueslength, 2 * answer.nbrruns,
            2 * (this.nbrruns - rlepos));
        answer.nbrruns = answer.nbrruns + this.nbrruns - rlepos;
      }
    }
    return answer.toEfficientContainer();
  }

  // Append a value length with all values until a given value
  private void appendValueLength(int value, int index) {
    int previousValue = (getValue(index));
    int length = (getLength(index));
    int offset = value - previousValue;
    if (offset > length) {
      setLength(index, (char) offset);
    }
  }

  // To check if a value length can be prepended with a given value
  private boolean canPrependValueLength(int value, int index) {
    if (index < this.nbrruns) {
      int nextValue = (getValue(index));
      return nextValue == value + 1;
    }
    return false;
  }

  @Override
  public void clear() {
    nbrruns = 0;
  }

  @Override
  public Container clone() {
    return new RunContainer(nbrruns, valueslength);
  }

  @Override
  public boolean isEmpty() {
    return nbrruns == 0;
  }

  // To set the last value of a value length
  private void closeValueLength(int value, int index) {
    int initialValue = (getValue(index));
    setLength(index, (char) (value - initialValue));
  }

  @Override
  public boolean contains(char x) {
    int index = unsignedInterleavedBinarySearch(valueslength, 0, nbrruns, x);
    if (index >= 0) {
      return true;
    }
    index = -index - 2; // points to preceding value, possibly -1
    if (index != -1) {// possible match
      int offset = x - getValue(index);
      int le = getLength(index);
      return offset <= le;
    }
    return false;
  }

  @Override
  public boolean contains(int minimum, int supremum) {
    for (int i = 0; i < numberOfRuns(); ++i) {
      int start = getValue(i);
      int length = getLength(i);
      int stop = start + length + 1;
      if (start >= supremum) {
        break;
      }
      if (minimum >= start && supremum <= stop) {
        return true;
      }
    }
    return false;
  }

  @Override
  protected boolean contains(RunContainer runContainer) {
    int i1 = 0, i2 = 0;
    while(i1 < numberOfRuns() && i2 < runContainer.numberOfRuns()) {
      int start1 = (getValue(i1));
      int stop1 = start1 + (getLength(i1));
      int start2 = (runContainer.getValue(i2));
      int stop2 = start2 + (runContainer.getLength(i2));
      if(start1 > start2) {
        return false;
      } else {
        if(stop1 > stop2) {
          i2++;
        } else if(stop1 == stop2) {
          i1++;
          i2++;
        } else {
          i1++;
        }
      }
    }
    return i2 == runContainer.numberOfRuns();
  }

  @Override
  protected boolean contains(ArrayContainer arrayContainer) {
    final int cardinality = getCardinality();
    final int runCount = numberOfRuns();
    if (arrayContainer.getCardinality() > cardinality) {
      return false;
    }
    int ia = 0, ir = 0;
    while(ia < arrayContainer.getCardinality() && ir < runCount) {
      int start = (this.getValue(ir));
      int stop = start + (getLength(ir));
      int ac = (arrayContainer.content[ia]);
      if(ac < start) {
        return false;
      } else if (ac > stop) {
        ++ir;
      } else {
        ++ia;
      }
    }
    return ia == arrayContainer.getCardinality();
  }

  @Override
  protected boolean contains(BitmapContainer bitmapContainer) {
    final int cardinality = getCardinality();
    if (bitmapContainer.getCardinality() != -1 && bitmapContainer.getCardinality() > cardinality) {
      return false;
    }
    final int runCount = numberOfRuns();
    char ib = 0, ir = 0;
    while(ib < bitmapContainer.bitmap.length && ir < runCount) {
      long w = bitmapContainer.bitmap[ib];
      while (w != 0 && ir < runCount) {
        int start = (getValue(ir));
        int stop = start+ (getLength(ir));
        long t = w & -w;
        long r = ib * 64L + Long.numberOfTrailingZeros(w);
        if (r < start) {
          return false;
        } else if(r > stop) {
          ++ir;
        } else {
          w ^= t;
        }
      }
      if(w == 0) {
        ++ib;
      } else {
        return false;
      }
    }
    if(ib < bitmapContainer.bitmap.length) {
      for(; ib < bitmapContainer.bitmap.length ; ib++) {
        if(bitmapContainer.bitmap[ib] != 0) {
          return false;
        }
      }
    }
    return true;
  }


  // a very cheap check... if you have more than 4096, then you should use a bitmap container.
  // this function avoids computing the cardinality
  private Container convertToLazyBitmapIfNeeded() {
    // when nbrruns exceed ArrayContainer.DEFAULT_MAX_SIZE, then we know it should be stored as a
    // bitmap, always
    if (this.nbrruns > ArrayContainer.DEFAULT_MAX_SIZE) {
      BitmapContainer answer = new BitmapContainer();
      for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
        int start = (this.getValue(rlepos));
        int end = start + (this.getLength(rlepos)) + 1;
        Util.setBitmapRange(answer.bitmap, start, end);
      }
      answer.cardinality = -1;
      return answer;
    }
    return this;
  }



  // Push all values length to the end of the array (resize array if needed)
  private void copyToOffset(int offset) {
    final int minCapacity = 2 * (offset + nbrruns);
    if (valueslength.length < minCapacity) {
      // expensive case where we need to reallocate
      int newCapacity = valueslength.length;
      while (newCapacity < minCapacity) {
        newCapacity = (newCapacity == 0) ? DEFAULT_INIT_SIZE
            : newCapacity < 64 ? newCapacity * 2
                : newCapacity < 1024 ? newCapacity * 3 / 2 : newCapacity * 5 / 4;
      }
      char[] newvalueslength = new char[newCapacity];
      copyValuesLength(this.valueslength, 0, newvalueslength, offset, nbrruns);
      this.valueslength = newvalueslength;
    } else {
      // efficient case where we just copy
      copyValuesLength(this.valueslength, 0, this.valueslength, offset, nbrruns);
    }
  }

  private void copyValuesLength(char[] src, int srcIndex, char[] dst, int dstIndex, int length) {
    System.arraycopy(src, 2 * srcIndex, dst, 2 * dstIndex, 2 * length);
  }

  private void decrementLength(int index) {
    valueslength[2 * index + 1]--;// caller is responsible to ensure that value is non-zero
  }



  private void decrementValue(int index) {
    valueslength[2 * index]--;
  }

  @Override
  public void deserialize(DataInput in) throws IOException {
    nbrruns = Character.reverseBytes(in.readChar());
    if (valueslength.length < 2 * nbrruns) {
      valueslength = new char[2 * nbrruns];
    }
    for (int k = 0; k < 2 * nbrruns; ++k) {
      this.valueslength[k] = Character.reverseBytes(in.readChar());
    }
  }

  // not actually used anywhere, but potentially useful
  void ensureCapacity(int minNbRuns) {
    final int minCapacity = 2 * minNbRuns;
    if (valueslength.length < minCapacity) {
      int newCapacity = valueslength.length;
      while (newCapacity < minCapacity) {
        newCapacity = (newCapacity == 0) ? DEFAULT_INIT_SIZE
            : newCapacity < 64 ? newCapacity * 2
                : newCapacity < 1024 ? newCapacity * 3 / 2 : newCapacity * 5 / 4;
      }
      char[] nv = new char[newCapacity];
      copyValuesLength(valueslength, 0, nv, 0, nbrruns);
      valueslength = nv;
    }
  }

  @Override
  public boolean equals(Object o) {
    if (o instanceof RunContainer) {
      return equals((RunContainer) o);
    } else if (o instanceof ArrayContainer) {
      return equals((ArrayContainer) o);
    } else if (o instanceof Container) {
      if (((Container) o).getCardinality() != this.getCardinality()) {
        return false; // should be a frequent branch if they differ
      }
      // next bit could be optimized if needed:
      CharIterator me = this.getCharIterator();
      CharIterator you = ((Container) o).getCharIterator();
      while (me.hasNext()) {
        if (me.next() != you.next()) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  private boolean equals(RunContainer rc) {
    return ArraysShim.equals(valueslength, 0, 2 * nbrruns,
            rc.valueslength, 0, 2 * rc.nbrruns);
  }

  private boolean equals(ArrayContainer arrayContainer) {
    int pos = 0;
    for (char i = 0; i < nbrruns; ++i) {
      char runStart = getValue(i);
      int length = (getLength(i));
      if (pos + length >= arrayContainer.getCardinality()) {
        return false;
      }
      if (arrayContainer.content[pos] != runStart) {
        return false;
      }
      if (arrayContainer.content[pos + length] != (char)((runStart) + length)) {
        return false;
      }
      pos += length + 1;
    }
    return pos == arrayContainer.getCardinality();
  }

  @Override
  public void fillLeastSignificant16bits(int[] x, int i, int mask) {
    int pos = i;
    for (int k = 0; k < this.nbrruns; ++k) {
      final int limit = (this.getLength(k));
      final int base = (this.getValue(k));
      for (int le = 0; le <= limit; ++le) {
        x[pos++] = (base + le) | mask;
      }
    }
  }

  @Override
  public Container flip(char x) {
    if (this.contains(x)) {
      return this.remove(x);
    } else {
      return this.add(x);
    }
  }

  @Override
  public int getArraySizeInBytes() {
    return 2 + 4 * this.nbrruns; // "array" includes its size
  }


  @Override
  public int getCardinality() {
    int sum = nbrruns;// lengths are returned -1
    for (int k = 0; k < nbrruns; ++k) {
      sum = sum + (getLength(k))/* + 1 */;
    }
    return sum;
  }

  /**
   * Gets the length of the run at the index.
   * @param index the index of the run.
   * @return the length of the run at the index.
   * @throws ArrayIndexOutOfBoundsException if index is negative or larger than the index of the
   *     last run.
   */
  public char getLength(int index) {
    return valueslength[2 * index + 1];
  }

  @Override
  public PeekableCharIterator getReverseCharIterator() {
    return new ReverseRunContainerCharIterator(this);
  }

  @Override
  public PeekableCharIterator getCharIterator() {
    return new RunContainerCharIterator(this);
  }

  @Override
  public PeekableCharRankIterator getCharRankIterator() {
    return new RunContainerCharRankIterator(this);
  }

  @Override
  public ContainerBatchIterator getBatchIterator() {
    return new RunBatchIterator(this);
  }

  @Override
  public int getSizeInBytes() {
    return this.nbrruns * 4 + 4;
  }

  /**
   * Gets the value of the first element of the run at the index.
   * @param index the index of the run.
   * @return the value of the first element of the run at the index.
   * @throws ArrayIndexOutOfBoundsException if index is negative or larger than the index of the
   *     last run.
   */
  public char getValue(int index) {
    return valueslength[2 * index];
  }

  @Override
  public int hashCode() {
    int hash = 0;
    for (int k = 0; k < nbrruns * 2; ++k) {
      hash += 31 * hash + valueslength[k];
    }
    return hash;
  }

  @Override
  public Container iadd(int begin, int end) {
    // TODO: it might be better and simpler to do return
    // toBitmapOrArrayContainer(getCardinality()).iadd(begin,end)
    if(end == begin) {
      return this;
    }
    if ((begin > end) || (end > (1 << 16))) {
      throw new IllegalArgumentException("Invalid range [" + begin + "," + end + ")");
    }

    if (begin == end - 1) {
      add((char) begin);
      return this;
    }

    int bIndex = unsignedInterleavedBinarySearch(this.valueslength, 0, this.nbrruns, (char) begin);
    int eIndex =
        unsignedInterleavedBinarySearch(this.valueslength, 0, this.nbrruns, (char) (end - 1));

    if (bIndex >= 0 && eIndex >= 0) {
      mergeValuesLength(bIndex, eIndex);
      return this;

    } else if (bIndex >= 0) {
      eIndex = -eIndex - 2;

      if (canPrependValueLength(end - 1, eIndex + 1)) {
        mergeValuesLength(bIndex, eIndex + 1);
        return this;
      }

      appendValueLength(end - 1, eIndex);
      mergeValuesLength(bIndex, eIndex);
      return this;

    } else if (eIndex >= 0) {
      bIndex = -bIndex - 2;

      if (bIndex >= 0) {
        if (valueLengthContains(begin - 1, bIndex)) {
          mergeValuesLength(bIndex, eIndex);
          return this;
        }
      }
      prependValueLength(begin, bIndex + 1);
      mergeValuesLength(bIndex + 1, eIndex);
      return this;

    } else {
      bIndex = -bIndex - 2;
      eIndex = -eIndex - 2;

      if (eIndex >= 0) {
        if (bIndex >= 0) {
          if (!valueLengthContains(begin - 1, bIndex)) {
            if (bIndex == eIndex) {
              if (canPrependValueLength(end - 1, eIndex + 1)) {
                prependValueLength(begin, eIndex + 1);
                return this;
              }
              makeRoomAtIndex(eIndex + 1);
              setValue(eIndex + 1, (char) begin);
              setLength(eIndex + 1, (char) (end - 1 - begin));
              return this;

            } else {
              bIndex++;
              prependValueLength(begin, bIndex);
            }
          }
        } else {
          bIndex = 0;
          prependValueLength(begin, bIndex);
        }

        if (canPrependValueLength(end - 1, eIndex + 1)) {
          mergeValuesLength(bIndex, eIndex + 1);
          return this;
        }

        appendValueLength(end - 1, eIndex);
        mergeValuesLength(bIndex, eIndex);
        return this;

      } else {
        if (canPrependValueLength(end - 1, 0)) {
          prependValueLength(begin, 0);
        } else {
          makeRoomAtIndex(0);
          setValue(0, (char) begin);
          setLength(0, (char) (end - 1 - begin));
        }
        return this;
      }
    }
  }

  @Override
  public Container iand(ArrayContainer x) {
    return and(x);
  }

  @Override
  public Container iand(BitmapContainer x) {
    return and(x);
  }



  @Override
  public Container iand(RunContainer x) {
    return and(x);
  }


  @Override
  public Container iandNot(ArrayContainer x) {
    return andNot(x);
  }

  @Override
  public Container iandNot(BitmapContainer x) {
    return andNot(x);
  }

  @Override
  public Container iandNot(RunContainer x) {
    return andNot(x);
  }

  Container ilazyor(ArrayContainer x) {
    if (isFull()) {
      return this; // this can sometimes solve a lot of computation!
    }
    return ilazyorToRun(x);
  }

  private Container ilazyorToRun(ArrayContainer x) {
    if (isFull()) {
      return full();
    }
    final int nbrruns = this.nbrruns;
    final int offset = Math.max(nbrruns, x.getCardinality());
    copyToOffset(offset);
    int rlepos = 0;
    this.nbrruns = 0;
    PeekableCharIterator i = x.getCharIterator();
    while (i.hasNext() && (rlepos < nbrruns)) {
      if (getValue(rlepos + offset) - i.peekNext() <= 0) {
        smartAppend(getValue(rlepos + offset), getLength(rlepos + offset));
        rlepos++;
      } else {
        smartAppend(i.next());
      }
    }
    if (i.hasNext()) {
      /*
       * if(this.nbrruns>0) { // this might be useful if the run container has just one very large
       * run int lastval = (getValue(nbrruns + offset - 1)) +
       * (getLength(nbrruns + offset - 1)) + 1; i.advanceIfNeeded((char)
       * lastval); }
       */
      while (i.hasNext()) {
        smartAppend(i.next());
      }
    } else {
      while (rlepos < nbrruns) {
        smartAppend(getValue(rlepos + offset), getLength(rlepos + offset));
        rlepos++;
      }
    }
    return convertToLazyBitmapIfNeeded();
  }

  private void increaseCapacity() {
    int newCapacity = (valueslength.length == 0) ? DEFAULT_INIT_SIZE
        : valueslength.length < 64 ? valueslength.length * 2
            : valueslength.length < 1024 ? valueslength.length * 3 / 2
                : valueslength.length * 5 / 4;
    char[] nv = new char[newCapacity];
    System.arraycopy(valueslength, 0, nv, 0, 2 * nbrruns);
    valueslength = nv;
  }


  private void incrementLength(int index) {
    valueslength[2 * index + 1]++;
  }


  private void incrementValue(int index) {
    valueslength[2 * index]++;
  }

  // To set the first value of a value length
  private void initValueLength(int value, int index) {
    int initialValue = (getValue(index));
    int length = (getLength(index));
    setValue(index, (char) (value));
    setLength(index, (char) (length - (value - initialValue)));
  }

  @Override
  public Container inot(int rangeStart, int rangeEnd) {
    if (rangeEnd <= rangeStart) {
      return this;
    }

    // TODO: write special case code for rangeStart=0; rangeEnd=65535
    // a "sliding" effect where each range records the gap adjacent it
    // can probably be quite fast. Probably have 2 cases: start with a
    // 0 run vs start with a 1 run. If you both start and end with 0s,
    // you will require room for expansion.

    // the +1 below is needed in case the valueslength.length is odd
    if (valueslength.length <= 2 * nbrruns + 1) {
      // no room for expansion
      // analyze whether this is a case that will require expansion (that we cannot do)
      // this is a bit costly now (4 "contains" checks)

      boolean lastValueBeforeRange = false;
      boolean firstValueInRange;
      boolean lastValueInRange;
      boolean firstValuePastRange = false;

      // contains is based on a binary search and is hopefully fairly fast.
      // however, one binary search could *usually* suffice to find both
      // lastValueBeforeRange AND firstValueInRange. ditto for
      // lastVaueInRange and firstValuePastRange

      // find the start of the range
      if (rangeStart > 0) {
        lastValueBeforeRange = contains((char) (rangeStart - 1));
      }
      firstValueInRange = contains((char) rangeStart);

      if (lastValueBeforeRange == firstValueInRange) {
        // expansion is required if also lastValueInRange==firstValuePastRange

        // tougher to optimize out, but possible.
        lastValueInRange = contains((char) (rangeEnd - 1));
        if (rangeEnd != 65536) {
          firstValuePastRange = contains((char) rangeEnd);
        }

        // there is definitely one more run after the operation.
        if (lastValueInRange == firstValuePastRange) {
          return not(rangeStart, rangeEnd); // can't do in-place: true space limit
        }
      }
    }
    // either no expansion required, or we have room to handle any required expansion for it.

    // remaining code is just a minor variation on not()
    int myNbrRuns = nbrruns;

    RunContainer ans = this; // copy on top of self.
    int k = 0;
    ans.nbrruns = 0; // losing this.nbrruns, which is stashed in myNbrRuns.

    // could try using unsignedInterleavedBinarySearch(valueslength, 0, nbrruns, rangeStart) instead
    // of sequential scan
    // to find the starting location

    for (; (k < myNbrRuns) && ((this.getValue(k)) < rangeStart); ++k) {
      // since it is atop self, there is no copying needed
      // ans.valueslength[2 * k] = this.valueslength[2 * k];
      // ans.valueslength[2 * k + 1] = this.valueslength[2 * k + 1];
      ans.nbrruns++;
    }
    // We will work left to right, with a read pointer that always stays
    // left of the write pointer. However, we need to give the read pointer a head start.
    // use local variables so we are always reading 1 location ahead.

    char bufferedValue = 0, bufferedLength = 0; // 65535 start and 65535 length would be illegal,
                                                 // could use as sentinel
    char nextValue = 0, nextLength = 0;
    if (k < myNbrRuns) { // prime the readahead variables
      bufferedValue = getValue(k);
      bufferedLength = getLength(k);
    }

    ans.smartAppendExclusive((char) rangeStart, (char) (rangeEnd - rangeStart - 1));

    for (; k < myNbrRuns; ++k) {
      if (ans.nbrruns > k + 1) {
        throw new RuntimeException(
            "internal error in inot, writer has overtaken reader!! " + k + " " + ans.nbrruns);
      }
      if (k + 1 < myNbrRuns) {
        nextValue = getValue(k + 1); // readahead for next iteration
        nextLength = getLength(k + 1);
      }
      ans.smartAppendExclusive(bufferedValue, bufferedLength);
      bufferedValue = nextValue;
      bufferedLength = nextLength;
    }
    // the number of runs can increase by one, meaning (rarely) a bitmap will become better
    // or the cardinality can decrease by a lot, making an array better
    return ans.toEfficientContainer();
  }

  @Override
  public boolean intersects(ArrayContainer x) {
    if (this.nbrruns == 0) {
      return false;
    }
    int rlepos = 0;
    int arraypos = 0;
    int rleval = this.getValue(rlepos);
    int rlelength = this.getLength(rlepos);
    while (arraypos < x.cardinality) {
      int arrayval = (x.content[arraypos]);
      while (rleval + rlelength < arrayval) {// this will frequently be false
        ++rlepos;
        if (rlepos == this.nbrruns) {
          return false;
        }
        rleval = this.getValue(rlepos);
        rlelength = this.getLength(rlepos);
      }
      if (rleval > arrayval) {
        arraypos = Util.advanceUntil(x.content, arraypos, x.cardinality, this.getValue(rlepos));
      } else {
        return true;
      }
    }
    return false;
  }

  @Override
  public boolean intersects(BitmapContainer x) {
    for (int run = 0; run < this.nbrruns; ++run) {
      int runStart = this.getValue(run);
      int runEnd = runStart + this.getLength(run);
      if (x.intersects(runStart, runEnd + 1)) {
        return true;
      }
    }
    return false;
  }

  @Override
  public boolean intersects(RunContainer x) {
    int rlepos = 0;
    int xrlepos = 0;
    int start = this.getValue(rlepos);
    int end = start + this.getLength(rlepos) + 1;
    int xstart = x.getValue(xrlepos);
    int xend = xstart + x.getLength(xrlepos) + 1;
    while (rlepos < this.nbrruns && xrlepos < x.nbrruns) {
      if (end <= xstart) {
        if (ENABLE_GALLOPING_AND) {
          rlepos = skipAhead(this, rlepos, xstart); // skip over runs until we have end > xstart (or
                                                    // rlepos is advanced beyond end)
        } else {
          ++rlepos;
        }

        if (rlepos < this.nbrruns) {
          start = (this.getValue(rlepos));
          end = start + (this.getLength(rlepos)) + 1;
        }
      } else if (xend <= start) {
        // exit the second run
        if (ENABLE_GALLOPING_AND) {
          xrlepos = skipAhead(x, xrlepos, start);
        } else {
          ++xrlepos;
        }

        if (xrlepos < x.nbrruns) {
          xstart = (x.getValue(xrlepos));
          xend = xstart + (x.getLength(xrlepos)) + 1;
        }
      } else {// they overlap
        return true;
      }
    }
    return false;
  }

  @Override
  public boolean intersects(int minimum, int supremum) {
    if((minimum < 0) || (supremum < minimum) || (supremum > (1<<16))) {
      throw new RuntimeException("This should never happen (bug).");
    }
    for (int i = 0; i < numberOfRuns(); ++i) {
      int runFirstValue = getValue(i);
      int runLastValue = (char) (runFirstValue + getLength(i)) + 1;
      if (supremum > runFirstValue && minimum < runLastValue) {
        return true;
      }
    }
    return false;
  }

  @Override
  public Container ior(ArrayContainer x) {
    if (isFull()) {
      return this;
    }
    final int nbrruns = this.nbrruns;
    final int offset = Math.max(nbrruns, x.getCardinality());
    copyToOffset(offset);
    int rlepos = 0;
    this.nbrruns = 0;
    PeekableCharIterator i = x.getCharIterator();
    while (i.hasNext() && (rlepos < nbrruns)) {
      if (getValue(rlepos + offset) - i.peekNext() <= 0) {
        smartAppend(getValue(rlepos + offset), getLength(rlepos + offset));
        rlepos++;
      } else {
        smartAppend(i.next());
      }
    }
    if (i.hasNext()) {
      /*
       * if(this.nbrruns>0) { // this might be useful if the run container has just one very large
       * run int lastval = (getValue(nbrruns + offset - 1)) +
       * (getLength(nbrruns + offset - 1)) + 1; i.advanceIfNeeded((char)
       * lastval); }
       */
      while (i.hasNext()) {
        smartAppend(i.next());
      }
    } else {
      while (rlepos < nbrruns) {
        smartAppend(getValue(rlepos + offset), getLength(rlepos + offset));
        rlepos++;
      }
    }
    return toEfficientContainer();
  }

  @Override
  public Container ior(BitmapContainer x) {
    if (isFull()) {
      return this;
    }
    return or(x);
  }

  @Override
  public Container ior(RunContainer x) {
    if (isFull()) {
      return this;
    }

    final int nbrruns = this.nbrruns;
    final int xnbrruns = x.nbrruns;
    final int offset = Math.max(nbrruns, xnbrruns);

    // Push all values length to the end of the array (resize array if needed)
    copyToOffset(offset);
    // Aggregate and store the result at the beginning of the array
    this.nbrruns = 0;
    int rlepos = 0;
    int xrlepos = 0;

    // Add values length (smaller first)
    while ((rlepos < nbrruns) && (xrlepos < xnbrruns)) {
      final char value = this.getValue(offset + rlepos);
      final char xvalue = x.getValue(xrlepos);
      final char length = this.getLength(offset + rlepos);
      final char xlength = x.getLength(xrlepos);

      if (value - xvalue <= 0) {
        this.smartAppend(value, length);
        ++rlepos;
      } else {
        this.smartAppend(xvalue, xlength);
        ++xrlepos;
      }
    }

    while (rlepos < nbrruns) {
      this.smartAppend(this.getValue(offset + rlepos), this.getLength(offset + rlepos));
      ++rlepos;
    }

    while (xrlepos < xnbrruns) {
      this.smartAppend(x.getValue(xrlepos), x.getLength(xrlepos));
      ++xrlepos;
    }
    return this.toBitmapIfNeeded();
  }

  @Override
  public Container iremove(int begin, int end) {
    // TODO: it might be better and simpler to do return
    // toBitmapOrArrayContainer(getCardinality()).iremove(begin,end)
    if(end == begin) {
      return this;
    }
    if ((begin > end) || (end > (1 << 16))) {
      throw new IllegalArgumentException("Invalid range [" + begin + "," + end + ")");
    }
    if (begin == end - 1) {
      remove((char) begin);
      return this;
    }

    int bIndex = unsignedInterleavedBinarySearch(this.valueslength, 0, this.nbrruns, (char) begin);
    int eIndex =
        unsignedInterleavedBinarySearch(this.valueslength, 0, this.nbrruns, (char) (end - 1));

    // note, eIndex is looking for (end-1)

    if (bIndex >= 0) { // beginning marks beginning of a run
      if (eIndex < 0) {
        eIndex = -eIndex - 2;
      }
      // eIndex could be a run that begins exactly at "end"
      // or it might be an earlier run

      // if the end is before the first run, we'd have eIndex==-1. But bIndex makes this impossible.

      if (valueLengthContains(end, eIndex)) {
        initValueLength(end, eIndex); // there is something left in the run
        recoverRoomsInRange(bIndex - 1, eIndex - 1);
      } else {
        recoverRoomsInRange(bIndex - 1, eIndex); // nothing left in the run
      }

    } else if (eIndex >= 0) {
      // start does not coincide to a run start, but end does.
      bIndex = -bIndex - 2;

      if (bIndex >= 0) {
        if (valueLengthContains(begin, bIndex)) {
          closeValueLength(begin - 1, bIndex);
        }
      }

      // last run is one shorter
      if (getLength(eIndex) == 0) {// special case where we remove last run
        recoverRoomsInRange(eIndex - 1, eIndex);
      } else {
        incrementValue(eIndex);
        decrementLength(eIndex);
      }
      recoverRoomsInRange(bIndex, eIndex - 1);

    } else {
      bIndex = -bIndex - 2;
      eIndex = -eIndex - 2;

      if (eIndex >= 0) { // end-1 is not before first run.
        if (bIndex >= 0) { // nor is begin
          if (bIndex == eIndex) { // all removal nested properly between
                                  // one run start and the next
            if (valueLengthContains(begin, bIndex)) {
              if (valueLengthContains(end, eIndex)) {
                // proper nesting within a run, generates 2 sub-runs
                makeRoomAtIndex(bIndex);
                closeValueLength(begin - 1, bIndex);
                initValueLength(end, bIndex + 1);
                return this;
              }
              // removed area extends beyond run.
              closeValueLength(begin - 1, bIndex);
            }
          } else { // begin in one run area, end in a later one.
            if (valueLengthContains(begin, bIndex)) {
              closeValueLength(begin - 1, bIndex);
              // this cannot leave the bIndex run empty.
            }
            if (valueLengthContains(end, eIndex)) {
              // there is additional stuff in the eIndex run
              initValueLength(end, eIndex);
              eIndex--;
            }  // run ends at or before the range being removed, can delete it

            recoverRoomsInRange(bIndex, eIndex);
          }

        } else {
          // removed range begins before the first run
          if (valueLengthContains(end, eIndex)) { // had been end-1
            initValueLength(end, eIndex);
            recoverRoomsInRange(bIndex, eIndex - 1);
          } else { // removed range includes all the last run
            recoverRoomsInRange(bIndex, eIndex);
          }
        }

      } // eIndex == -1: whole range is before first run, nothing to delete...


    }
    return this;
  }

  @Override
  public boolean isFull() {
    return (this.nbrruns == 1) && (this.getValue(0) == 0) && (this.getLength(0) == 0xFFFF);
  }

  public static RunContainer full() {
    return new RunContainer(0, 1 << 16);
  }

  @Override
  public Iterator<Character> iterator() {
    final CharIterator i = getCharIterator();
    return new Iterator<Character>() {

      @Override
      public boolean hasNext() {
        return i.hasNext();
      }

      @Override
      public Character next() {
        return i.next();
      }

      @Override
      public void remove() {
        i.remove();
      }
    };

  }

  @Override
  public Container ixor(ArrayContainer x) {
    return xor(x);
  }

  @Override
  public Container ixor(BitmapContainer x) {
    return xor(x);
  }



  @Override
  public Container ixor(RunContainer x) {
    return xor(x);
  }

  private RunContainer lazyandNot(ArrayContainer x) {
    if (x.isEmpty()) {
      return this;
    }
    RunContainer answer = new RunContainer(new char[2 * (this.nbrruns + x.cardinality)], 0);
    int rlepos = 0;
    int xrlepos = 0;
    int start = (this.getValue(rlepos));
    int end = start + (this.getLength(rlepos)) + 1;
    int xstart = (x.content[xrlepos]);
    while ((rlepos < this.nbrruns) && (xrlepos < x.cardinality)) {
      if (end <= xstart) {
        // output the first run
        answer.valueslength[2 * answer.nbrruns] = (char) start;
        answer.valueslength[2 * answer.nbrruns + 1] = (char) (end - start - 1);
        answer.nbrruns++;
        rlepos++;
        if (rlepos < this.nbrruns) {
          start = (this.getValue(rlepos));
          end = start + (this.getLength(rlepos)) + 1;
        }
      } else if (xstart + 1 <= start) {
        // exit the second run
        xrlepos++;
        if (xrlepos < x.cardinality) {
          xstart = (x.content[xrlepos]);
        }
      } else {
        if (start < xstart) {
          answer.valueslength[2 * answer.nbrruns] = (char) start;
          answer.valueslength[2 * answer.nbrruns + 1] = (char) (xstart - start - 1);
          answer.nbrruns++;
        }
        if (xstart + 1 < end) {
          start = xstart + 1;
        } else {
          rlepos++;
          if (rlepos < this.nbrruns) {
            start = (this.getValue(rlepos));
            end = start + (this.getLength(rlepos)) + 1;
          }
        }
      }
    }
    if (rlepos < this.nbrruns) {
      answer.valueslength[2 * answer.nbrruns] = (char) start;
      answer.valueslength[2 * answer.nbrruns + 1] = (char) (end - start - 1);
      answer.nbrruns++;
      rlepos++;
      if (rlepos < this.nbrruns) {
        System.arraycopy(this.valueslength, 2 * rlepos, answer.valueslength, 2 * answer.nbrruns,
            2 * (this.nbrruns - rlepos));
        answer.nbrruns = answer.nbrruns + this.nbrruns - rlepos;
      }
    }
    return answer;
  }

  protected Container lazyor(ArrayContainer x) {
    return lazyorToRun(x);
  }

  private Container lazyorToRun(ArrayContainer x) {
    if (isFull()) {
      return full();
    }
    // TODO: should optimize for the frequent case where we have a single run
    RunContainer answer = new RunContainer(new char[2 * (this.nbrruns + x.getCardinality())], 0);
    int rlepos = 0;
    PeekableCharIterator i = x.getCharIterator();

    while (i.hasNext() && (rlepos < this.nbrruns)) {
      if (getValue(rlepos) - i.peekNext() <= 0) {
        answer.smartAppend(getValue(rlepos), getLength(rlepos));
        // in theory, this next code could help, in practice it doesn't.
        /*
         * int lastval = (answer.getValue(answer.nbrruns - 1)) +
         * (answer.getLength(answer.nbrruns - 1)) + 1; i.advanceIfNeeded((char)
         * lastval);
         */

        rlepos++;
      } else {
        answer.smartAppend(i.next());
      }
    }
    if (i.hasNext()) {
      /*
       * if(answer.nbrruns>0) { this might be useful if the run container has just one very large
       * run int lastval = (answer.getValue(answer.nbrruns - 1)) +
       * (answer.getLength(answer.nbrruns - 1)) + 1; i.advanceIfNeeded((char)
       * lastval); }
       */
      while (i.hasNext()) {
        answer.smartAppend(i.next());
      }
    } else {
      while (rlepos < this.nbrruns) {
        answer.smartAppend(getValue(rlepos), getLength(rlepos));
        rlepos++;
      }
    }
    if (answer.isFull()) {
      return full();
    }
    return answer.convertToLazyBitmapIfNeeded();
  }

  private Container lazyxor(ArrayContainer x) {
    if (x.isEmpty()) {
      return this;
    }
    if (this.nbrruns == 0) {
      return x;
    }
    RunContainer answer = new RunContainer(new char[2 * (this.nbrruns + x.getCardinality())], 0);
    int rlepos = 0;
    CharIterator i = x.getCharIterator();
    char cv = i.next();

    while (true) {
      if (getValue(rlepos) < cv) {
        answer.smartAppendExclusive(getValue(rlepos), getLength(rlepos));
        rlepos++;
        if (rlepos == this.nbrruns) {
          answer.smartAppendExclusive(cv);
          while (i.hasNext()) {
            answer.smartAppendExclusive(i.next());
          }
          break;
        }
      } else {
        answer.smartAppendExclusive(cv);
        if (!i.hasNext()) {
          while (rlepos < this.nbrruns) {
            answer.smartAppendExclusive(getValue(rlepos), getLength(rlepos));
            rlepos++;
          }
          break;
        } else {
          cv = i.next();
        }
      }
    }
    return answer;
  }


  @Override
  public Container limit(int maxcardinality) {
    if (maxcardinality >= getCardinality()) {
      return clone();
    }

    int r;
    int cardinality = 0;
    for (r = 0; r < this.nbrruns; ++r) {
      cardinality += (getLength(r)) + 1;
      if (maxcardinality <= cardinality) {
        break;
      }
    }

    RunContainer rc = new RunContainer(Arrays.copyOf(valueslength, 2 * (r+1)), r+1);
    rc.setLength(r ,
        (char) ((rc.getLength(r)) - cardinality + maxcardinality));
    return rc;
  }

  private void makeRoomAtIndex(int index) {
    if (2 * (nbrruns + 1) > valueslength.length) {
      increaseCapacity();
    }
    copyValuesLength(valueslength, index, valueslength, index + 1, nbrruns - index);
    nbrruns++;
  }

  // To merge values length from begin(inclusive) to end(inclusive)
  private void mergeValuesLength(int begin, int end) {
    if (begin < end) {
      int bValue = (getValue(begin));
      int eValue = (getValue(end));
      int eLength = (getLength(end));
      int newLength = eValue - bValue + eLength;
      setLength(begin, (char) newLength);
      recoverRoomsInRange(begin, end);
    }
  }

  @Override
  public Container not(int rangeStart, int rangeEnd) {
    if (rangeEnd <= rangeStart) {
      return this.clone();
    }
    RunContainer ans = new RunContainer(nbrruns + 1);
    int k = 0;
    for (; (k < this.nbrruns) && ((this.getValue(k)) < rangeStart); ++k) {
      ans.valueslength[2 * k] = this.valueslength[2 * k];
      ans.valueslength[2 * k + 1] = this.valueslength[2 * k + 1];
      ans.nbrruns++;
    }
    ans.smartAppendExclusive((char) rangeStart, (char) (rangeEnd - rangeStart - 1));
    for (; k < this.nbrruns; ++k) {
      ans.smartAppendExclusive(getValue(k), getLength(k));
    }
    // the number of runs can increase by one, meaning (rarely) a bitmap will become better
    // or the cardinality can decrease by a lot, making an array better
    return ans.toEfficientContainer();
  }

  @Override
  public int numberOfRuns() {
    return nbrruns;
  }

  @Override
  public Container or(ArrayContainer x) {
    // we guess that, often, the result will still be efficiently expressed as a run container
    return lazyor(x).repairAfterLazy();
  }

  @Override
  public Container or(BitmapContainer x) {
    if (isFull()) {
      return full();
    }
    // could be implemented as return toTemporaryBitmap().ior(x);
    BitmapContainer answer = x.clone();
    for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
      int start = (this.getValue(rlepos));
      int end = start + (this.getLength(rlepos)) + 1;
      int prevOnesInRange = answer.cardinalityInRange(start, end);
      Util.setBitmapRange(answer.bitmap, start, end);
      answer.updateCardinality(prevOnesInRange, end - start);
    }
    if (answer.isFull()) {
      return full();
    }
    return answer;
  }

  @Override
  public Container or(RunContainer x) {
    if (isFull()) {
      return full();
    }
    if (x.isFull()) {
      return full(); // cheap case that can save a lot of computation
    }
    // we really ought to optimize the rest of the code for the frequent case where there is a
    // single run
    RunContainer answer = new RunContainer(new char[2 * (this.nbrruns + x.nbrruns)], 0);
    int rlepos = 0;
    int xrlepos = 0;

    while ((xrlepos < x.nbrruns) && (rlepos < this.nbrruns)) {
      if (getValue(rlepos) - x.getValue(xrlepos) <= 0) {
        answer.smartAppend(getValue(rlepos), getLength(rlepos));
        rlepos++;
      } else {
        answer.smartAppend(x.getValue(xrlepos), x.getLength(xrlepos));
        xrlepos++;
      }
    }
    while (xrlepos < x.nbrruns) {
      answer.smartAppend(x.getValue(xrlepos), x.getLength(xrlepos));
      xrlepos++;
    }
    while (rlepos < this.nbrruns) {
      answer.smartAppend(getValue(rlepos), getLength(rlepos));
      rlepos++;
    }
    if (answer.isFull()) {
      return full();
    }
    return answer.toBitmapIfNeeded();
  }

  // Prepend a value length with all values starting from a given value
  private void prependValueLength(int value, int index) {
    int initialValue = (getValue(index));
    int length = (getLength(index));
    setValue(index, (char) value);
    setLength(index, (char) (initialValue - value + length));
  }

  @Override
  public int rank(char lowbits) {
    int answer = 0;
    for (int k = 0; k < this.nbrruns; ++k) {
      int value = (getValue(k));
      int length = (getLength(k));
      if ((int) (lowbits) < value) {
        return answer;
      } else if (value + length + 1 > (int) (lowbits)) {
        return answer + (int) (lowbits) - value + 1;
      }
      answer += length + 1;
    }
    return answer;
  }

  @Override
  public void readExternal(ObjectInput in) throws IOException {
    deserialize(in);
  }

  private void recoverRoomAtIndex(int index) {
    copyValuesLength(valueslength, index + 1, valueslength, index, nbrruns - index - 1);
    nbrruns--;
  }

  // To recover rooms between begin(exclusive) and end(inclusive)
  private void recoverRoomsInRange(int begin, int end) {
    if (end + 1 < this.nbrruns) {
      copyValuesLength(this.valueslength, end + 1, this.valueslength, begin + 1,
          this.nbrruns - 1 - end);
    }
    this.nbrruns -= end - begin;
  }

  @Override
  public Container remove(int begin, int end) {
    RunContainer rc = (RunContainer) clone();
    return rc.iremove(begin, end);
  }

  @Override
  public Container remove(char x) {
    int index = unsignedInterleavedBinarySearch(valueslength, 0, nbrruns, x);
    if (index >= 0) {
      if (getLength(index) == 0) {
        recoverRoomAtIndex(index);
      } else {
        incrementValue(index);
        decrementLength(index);
      }
      return this;// already there
    }
    index = -index - 2;// points to preceding value, possibly -1
    if (index >= 0) {// possible match
      int offset = (x) - (getValue(index));
      int le = (getLength(index));
      if (offset < le) {
        // need to break in two
        this.setLength(index, (char) (offset - 1));
        // need to insert
        int newvalue = (x) + 1;
        int newlength = le - offset - 1;
        makeRoomAtIndex(index + 1);
        this.setValue(index + 1, (char) newvalue);
        this.setLength(index + 1, (char) newlength);
        return this;

      } else if (offset == le) {
        decrementLength(index);
      }
    }
    // no match
    return this;
  }

  @Override
  public Container repairAfterLazy() {
    return toEfficientContainer();
  }

  /**
   * Convert to Array or Bitmap container if the serialized form would be shorter. Exactly the same
   * functionality as toEfficientContainer.
   */

  @Override
  public Container runOptimize() {
    return toEfficientContainer();
  }

  @Override
  public char select(int j) {
    int offset = 0;
    for (int k = 0; k < this.nbrruns; ++k) {
      int nextOffset = offset + (getLength(k)) + 1;
      if (nextOffset > j) {
        return (char) (getValue(k) + (j - offset));
      }
      offset = nextOffset;
    }
    throw new IllegalArgumentException(
        "Cannot select " + j + " since cardinality is " + getCardinality());
  }

  @Override
  public void serialize(DataOutput out) throws IOException {
    writeArray(out);
  }


  @Override
  public int serializedSizeInBytes() {
    return serializedSizeInBytes(nbrruns);
  }

  private void setLength(int index, char v) {
    setLength(valueslength, index, v);
  }



  private void setLength(char[] valueslength, int index, char v) {
    valueslength[2 * index + 1] = v;
  }

  private void setValue(int index, char v) {
    setValue(valueslength, index, v);
  }

  private void setValue(char[] valueslength, int index, char v) {
    valueslength[2 * index] = v;
  }



  // bootstrapping (aka "galloping") binary search. Always skips at least one.
  // On our "real data" benchmarks, enabling galloping is a minor loss
  // .."ifdef ENABLE_GALLOPING_AND" :)
  private int skipAhead(RunContainer skippingOn, int pos, int targetToExceed) {
    int left = pos;
    int span = 1;
    int probePos;
    int end;
    // jump ahead to find a spot where end > targetToExceed (if it exists)
    do {
      probePos = left + span;
      if (probePos >= skippingOn.nbrruns - 1) {
        // expect it might be quite common to find the container cannot be advanced as far as
        // requested. Optimize for it.
        probePos = skippingOn.nbrruns - 1;
        end = (skippingOn.getValue(probePos))
            + (skippingOn.getLength(probePos)) + 1;
        if (end <= targetToExceed) {
          return skippingOn.nbrruns;
        }
      }
      end = (skippingOn.getValue(probePos))
          + (skippingOn.getLength(probePos)) + 1;
      span *= 2;
    } while (end <= targetToExceed);
    int right = probePos;
    // left and right are both valid positions. Invariant: left <= targetToExceed && right >
    // targetToExceed
    // do a binary search to discover the spot where left and right are separated by 1, and
    // invariant is maintained.
    while (right - left > 1) {
      int mid = (right + left) / 2;
      int midVal = (skippingOn.getValue(mid))
          + (skippingOn.getLength(mid)) + 1;
      if (midVal > targetToExceed) {
        right = mid;
      } else {
        left = mid;
      }
    }
    return right;
  }

  private void smartAppend(char val) {
    int oldend;
    if ((nbrruns == 0)
        || (val > (oldend = (valueslength[2 * (nbrruns - 1)])
            + (valueslength[2 * (nbrruns - 1) + 1])) + 1)) { // we add a new one
      valueslength[2 * nbrruns] = val;
      valueslength[2 * nbrruns + 1] = 0;
      nbrruns++;
      return;
    }
    if (val == (char) (oldend + 1)) { // we merge
      valueslength[2 * (nbrruns - 1) + 1]++;
    }
  }

  void smartAppend(char start, char length) {
    int oldend;
    if ((nbrruns == 0) || ((start) > (oldend =
        (getValue(nbrruns - 1)) + (getLength(nbrruns - 1)))
        + 1)) { // we add a new one
      ensureCapacity(nbrruns + 1);
      valueslength[2 * nbrruns] = start;
      valueslength[2 * nbrruns + 1] = length;
      nbrruns++;
      return;
    }
    int newend = (start) + length + 1;
    if (newend > oldend) { // we merge
      setLength(nbrruns - 1, (char) (newend - 1 - (getValue(nbrruns - 1))));
    }
  }

  private void smartAppendExclusive(char val) {
    int oldend;
    if ((nbrruns == 0)
        || (val > (oldend = getValue(nbrruns - 1)
            + getLength(nbrruns - 1) + 1))) { // we add a new one
      valueslength[2 * nbrruns] = val;
      valueslength[2 * nbrruns + 1] = 0;
      nbrruns++;
      return;
    }
    // We have that val <= oldend.
    if (oldend == val) {
      // we merge
      valueslength[2 * (nbrruns - 1) + 1]++;
      return;
    }
    // We have that val < oldend.

    int newend = val + 1;
    // We have that newend = val + 1 and val < oldend.
    // so newend <= oldend.

    if (val == getValue(nbrruns - 1)) {
      // we wipe out previous
      if (newend != oldend) {
        setValue(nbrruns - 1, (char) newend);
        setLength(nbrruns - 1, (char) (oldend - newend - 1));
        return;
      } else { // they cancel out
        nbrruns--;
        return;
      }
    }
    setLength(nbrruns - 1, (char) (val - getValue(nbrruns - 1) - 1));
    if (newend < oldend) {
      setValue(nbrruns, (char) newend);
      setLength(nbrruns, (char) (oldend - newend - 1));
      nbrruns++;
    } // otherwise newend == oldend

  }

  private void smartAppendExclusive(char start, char length) {
    int oldend;
    if ((nbrruns == 0)
        || (start > (oldend = (getValue(nbrruns - 1))
            + (getLength(nbrruns - 1)) + 1))) { // we add a new one
      valueslength[2 * nbrruns] = start;
      valueslength[2 * nbrruns + 1] = length;
      nbrruns++;
      return;
    }
    if (oldend == start) {
      // we merge
      valueslength[2 * (nbrruns - 1) + 1] += length + 1;
      return;
    }

    int newend = start + length + 1;

    if (start == (getValue(nbrruns - 1))) {
      // we wipe out previous
      if (newend < oldend) {
        setValue(nbrruns - 1, (char) newend);
        setLength(nbrruns - 1, (char) (oldend - newend - 1));
        return;
      } else if (newend > oldend) {
        setValue(nbrruns - 1, (char) oldend);
        setLength(nbrruns - 1, (char) (newend - oldend - 1));
        return;
      } else { // they cancel out
        nbrruns--;
        return;
      }
    }
    setLength(nbrruns - 1, (char) (start - (getValue(nbrruns - 1)) - 1));
    if (newend < oldend) {
      setValue(nbrruns, (char) newend);
      setLength(nbrruns, (char) (oldend - newend - 1));
      nbrruns++;
    } else if (newend > oldend) {
      setValue(nbrruns, (char) oldend);
      setLength(nbrruns, (char) (newend - oldend - 1));
      nbrruns++;
    }
  }

  // convert to bitmap *if needed* (useful if you know it can't be an array)
  private Container toBitmapIfNeeded() {
    int sizeAsRunContainer = RunContainer.serializedSizeInBytes(this.nbrruns);
    int sizeAsBitmapContainer = BitmapContainer.serializedSizeInBytes(0);
    if (sizeAsBitmapContainer > sizeAsRunContainer) {
      return this;
    }
    return toBitmapContainer();
  }

  /**
   * Convert the container to either a Bitmap or an Array Container, depending on the cardinality.
   *
   * @param card the current cardinality
   * @return new container
   */
  Container toBitmapOrArrayContainer(int card) {
    // int card = this.getCardinality();
    if (card <= ArrayContainer.DEFAULT_MAX_SIZE) {
      ArrayContainer answer = new ArrayContainer(card);
      answer.cardinality = 0;
      for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
        int runStart = (this.getValue(rlepos));
        int runEnd = runStart + (this.getLength(rlepos));

        for (int runValue = runStart; runValue <= runEnd; ++runValue) {
          answer.content[answer.cardinality++] = (char) runValue;
        }
      }
      return answer;
    }
    BitmapContainer answer = new BitmapContainer();
    for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
      int start = (this.getValue(rlepos));
      int end = start + (this.getLength(rlepos)) + 1;
      Util.setBitmapRange(answer.bitmap, start, end);
    }
    answer.cardinality = card;
    return answer;
  }

  // convert to bitmap or array *if needed*
  private Container toEfficientContainer() {
    int sizeAsRunContainer = RunContainer.serializedSizeInBytes(this.nbrruns);
    int sizeAsBitmapContainer = BitmapContainer.serializedSizeInBytes(0);
    int card = this.getCardinality();
    int sizeAsArrayContainer = ArrayContainer.serializedSizeInBytes(card);
    if (sizeAsRunContainer <= Math.min(sizeAsBitmapContainer, sizeAsArrayContainer)) {
      return this;
    }
    return toBitmapOrArrayContainer(card);
  }

  @Override
  public MappeableContainer toMappeableContainer() {
    return new MappeableRunContainer(this);
  }

  /**
   * Return the content of this container as a ShortBuffer. This creates a copy and might be
   * relatively slow.
   *
   * @return the ShortBuffer
   */
  public CharBuffer toCharBuffer() {
    CharBuffer sb = CharBuffer.allocate(this.nbrruns * 2);
    sb.put(this.valueslength, 0, this.nbrruns * 2);
    return sb;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    for (int k = 0; k < this.nbrruns; ++k) {
      sb.append("[");
      sb.append((int)(this.getValue(k)));
      sb.append(",");
      sb.append((this.getValue(k)) + (this.getLength(k)));
      sb.append("]");
    }
    return sb.toString();
  }


  @Override
  public void trim() {
    if (valueslength.length == 2 * nbrruns) {
      return;
    }
    valueslength = Arrays.copyOf(valueslength, 2 * nbrruns);
  }


  // To check if a value length contains a given value
  private boolean valueLengthContains(int value, int index) {
    int initialValue = (getValue(index));
    int length = (getLength(index));

    return value <= initialValue + length;
  }

  @Override
  public void writeArray(DataOutput out) throws IOException {
    out.writeShort(Character.reverseBytes((char) this.nbrruns));
    for (int k = 0; k < 2 * this.nbrruns; ++k) {
      out.writeShort(Character.reverseBytes(this.valueslength[k]));
    }
  }

  @Override
  public void writeArray(ByteBuffer buffer) {
    assert buffer.order() == ByteOrder.LITTLE_ENDIAN;
    CharBuffer buf = buffer.asCharBuffer();
    buf.put((char)nbrruns);
    buf.put(valueslength, 0, nbrruns * 2);
    int bytesWritten = (nbrruns * 2 + 1) * 2;
    buffer.position(buffer.position() + bytesWritten);
  }

  @Override
  public void writeExternal(ObjectOutput out) throws IOException {
    serialize(out);

  }

  @Override
  public Container xor(ArrayContainer x) {
    // if the cardinality of the array is small, guess that the output will still be a run container
    final int arbitrary_threshold = 32; // 32 is arbitrary here
    if (x.getCardinality() < arbitrary_threshold) {
      return lazyxor(x).repairAfterLazy();
    }
    // otherwise, we expect the output to be either an array or bitmap
    final int card = getCardinality();
    if (card <= ArrayContainer.DEFAULT_MAX_SIZE) {
      // if the cardinality is small, we construct the solution in place
      return x.xor(this.getCharIterator());
    }
    // otherwise, we generate a bitmap (even if runcontainer would be better)
    return toBitmapOrArrayContainer(card).ixor(x);
  }

  @Override
  public Container xor(BitmapContainer x) {
    // could be implemented as return toTemporaryBitmap().ixor(x);
    BitmapContainer answer = x.clone();
    for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
      int start = (this.getValue(rlepos));
      int end = start + (this.getLength(rlepos)) + 1;
      int prevOnes = answer.cardinalityInRange(start, end);
      Util.flipBitmapRange(answer.bitmap, start, end);
      answer.updateCardinality(prevOnes, end - start - prevOnes);
    }
    if (answer.getCardinality() > ArrayContainer.DEFAULT_MAX_SIZE) {
      return answer;
    } else {
      return answer.toArrayContainer();
    }
  }

  @Override
  public Container xor(RunContainer x) {
    if (x.nbrruns == 0) {
      return this.clone();
    }
    if (this.nbrruns == 0) {
      return x.clone();
    }
    RunContainer answer = new RunContainer(new char[2 * (this.nbrruns + x.nbrruns)], 0);
    int rlepos = 0;
    int xrlepos = 0;

    while (true) {
      if (getValue(rlepos) < x.getValue(xrlepos)) {
        answer.smartAppendExclusive(getValue(rlepos), getLength(rlepos));
        rlepos++;

        if (rlepos == this.nbrruns) {
          while (xrlepos < x.nbrruns) {
            answer.smartAppendExclusive(x.getValue(xrlepos), x.getLength(xrlepos));
            xrlepos++;
          }
          break;
        }
      } else {
        answer.smartAppendExclusive(x.getValue(xrlepos), x.getLength(xrlepos));

        xrlepos++;
        if (xrlepos == x.nbrruns) {
          while (rlepos < this.nbrruns) {
            answer.smartAppendExclusive(getValue(rlepos), getLength(rlepos));
            rlepos++;
          }
          break;
        }
      }
    }
    return answer.toEfficientContainer();
  }

  @Override
  public void forEach(char msb, IntConsumer ic) {
    int high = msb << 16;
    for(int k = 0; k < this.nbrruns; ++k) {
      int base = this.getValue(k) | high;
      int le = this.getLength(k);
      for(int l = base; l - le <= base; ++l) {
        ic.accept(l);
      }
    }
  }

  @Override
  public void forAll(int offset, final RelativeRangeConsumer rrc) {
    int next = 0;
    for (int run = 0; run < nbrruns; run++) {
      int runPos = run << 1;
      char runStart = valueslength[runPos];
      char runLength = valueslength[runPos + 1];
      if (next < runStart) {
        // fill in missing values until runStart
        rrc.acceptAllAbsent(offset + next, offset + runStart);
      }
      rrc.acceptAllPresent(offset + runStart, offset + runStart + runLength + 1);
      next = runStart + runLength + 1;
    }
    if (next <= Character.MAX_VALUE) {
      // fill in the remaining values until end
      rrc.acceptAllAbsent(offset + next, offset + Character.MAX_VALUE + 1);
    }
  }

  @Override
  public void forAllFrom(char startValue, final RelativeRangeConsumer rrc) {
    int startOffset = startValue;
    int next = startValue;
    for (int run = 0; run < nbrruns; run++) {
      int runPos = run << 1;
      char runStart = valueslength[runPos];
      char runLength = valueslength[runPos + 1];
      int runEnd = runStart + runLength;
      if (runEnd < startValue) {
        // skip forward
        continue;
      }

      if (runStart < next) { // next == startValue
        assert next == startValue; // TODO: remove
        // start is somewhere within the run
        rrc.acceptAllPresent(0, runStart + runLength + 1 - startOffset);
      } else {
        // start is before the run
        if (next < runStart) {
          // fill in missing values until runStart
          rrc.acceptAllAbsent(next - startOffset, runStart - startOffset);
        }
        // take whole run
        rrc.acceptAllPresent(runStart - startOffset, runStart + runLength + 1 - startOffset);
      }
      next = runStart + runLength + 1;
    }
    if (next <= Character.MAX_VALUE) {
      // fill in the remaining values until end
      rrc.acceptAllAbsent(next - startOffset, Character.MAX_VALUE + 1 - startOffset);
    }
  }

  @Override
  public void forAllUntil(int offset, char endValue, final RelativeRangeConsumer rrc) {
    int next = 0;
    for (int run = 0; run < nbrruns; run++) {
      int runPos = run << 1;
      char runStart = valueslength[runPos];
      char runLength = valueslength[runPos + 1];
      if (endValue <= runStart) {
        // no more relevant values in this run or the following
        break;
      }
      if (next < runStart) {
        // fill in missing values until runStart
        rrc.acceptAllAbsent(offset + next, offset + runStart);
      }
      char runEnd = (char) (runStart + runLength);
      // endValue is exclusive, but runEnd is inclusive.
      if (endValue <= runEnd) {
        // we end within this run
        rrc.acceptAllPresent(offset + runStart, offset + endValue);
        return;
      }
      rrc.acceptAllPresent(offset + runStart, offset + runEnd + 1); // runEnd is inclusive
      next = runEnd + 1;
    }
    if (next < endValue) {
      // fill in the remaining values until end
      rrc.acceptAllAbsent(offset + next, offset + endValue);
    }
  }

  @Override
  public void forAllInRange(char startValue, char endValue, final RelativeRangeConsumer rrc) {
    if (endValue <= startValue) {
      throw new IllegalArgumentException(
              "startValue (" + startValue + ") must be less than endValue (" + endValue + ")");
    }
    int startOffset = startValue;
    int next = startValue;
    for (int run = 0; run < nbrruns; run++) {
      int runPos = run << 1;
      char runStart = valueslength[runPos];
      char runLength = valueslength[runPos + 1];
      int runEnd = runStart + runLength;
      if (runEnd < startValue) {
        // skip forward
        continue;
      }
      if (endValue <= runStart) {
        // no more relevant values in this run or the following
        break;
      }
      if (runStart < next) { // next == startValue
        // start is somewhere within the run
        if (endValue <= runEnd) {
          // we also end within this run
          rrc.acceptAllPresent(0, endValue - startOffset);
          return;
        }
        rrc.acceptAllPresent(0, runEnd + 1 - startOffset);
      } else {
        // start is before the run
        if (next < runStart) {
          // fill in missing values until runStart
          rrc.acceptAllAbsent(next - startOffset, runStart - startOffset);
        }
        if (endValue <= runEnd) {
          // we end within this run
          rrc.acceptAllPresent(runStart - startOffset, endValue - startOffset);
          return;
        }
        // take whole run
        rrc.acceptAllPresent(runStart - startOffset, runStart + runLength + 1 - startOffset);
      }
      next = runStart + runLength + 1;
    }
    if (next < endValue) {
      // fill in the remaining values until end
      rrc.acceptAllAbsent(next - startOffset, endValue - startOffset);
    }
  }

  @Override
  public BitmapContainer toBitmapContainer() {
    int card = this.getCardinality();
    BitmapContainer answer = new BitmapContainer();
    for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
      int start = (this.getValue(rlepos));
      int end = start + (this.getLength(rlepos)) + 1;
      Util.setBitmapRange(answer.bitmap, start, end);
    }
    answer.cardinality = card;
    return answer;
  }

  @Override
  public int nextValue(char fromValue) {
    int index = unsignedInterleavedBinarySearch(valueslength, 0, nbrruns, fromValue);
    int effectiveIndex = index >= 0 ? index : -index - 2;
    if (effectiveIndex == -1) {
      return first();
    }
    int startValue = (getValue(effectiveIndex));
    int offset = (int) (fromValue) - startValue;
    int le = (getLength(effectiveIndex));
    if (offset <= le) {
      return fromValue;
    }
    if (effectiveIndex + 1 < numberOfRuns()) {
      return (getValue(effectiveIndex + 1));
    }
    return -1;
  }

  @Override
  public int previousValue(char fromValue) {
    int index = unsignedInterleavedBinarySearch(valueslength, 0, nbrruns, fromValue);
    int effectiveIndex = index >= 0 ? index : -index - 2;
    if (effectiveIndex == -1) {
      return -1;
    }
    int startValue = (getValue(effectiveIndex));
    int offset = (int) (fromValue) - startValue;
    int le = (getLength(effectiveIndex));
    if (offset >= 0 && offset <= le) {
      return fromValue;
    }
    return startValue + le;
  }

  @Override
  public int nextAbsentValue(char fromValue) {
    int index = unsignedInterleavedBinarySearch(valueslength, 0, nbrruns, fromValue);
    int effectiveIndex = index >= 0 ? index : -index - 2;
    if (effectiveIndex == -1) {
      return (fromValue);
    }
    int startValue = (getValue(effectiveIndex));
    int offset = (int) (fromValue) - startValue;
    int le = (getLength(effectiveIndex));
    return offset <= le ? startValue + le + 1 : (int) (fromValue);
  }

  @Override
  public int previousAbsentValue(char fromValue) {
    int index = unsignedInterleavedBinarySearch(valueslength, 0, nbrruns, fromValue);
    int effectiveIndex = index >= 0 ? index : -index - 2;
    if (effectiveIndex == -1) {
      return (fromValue);
    }
    int startValue = (getValue(effectiveIndex));
    int offset = (int) (fromValue) - startValue;
    int le = (getLength(effectiveIndex));
    return offset <= le ? startValue - 1 : (int) (fromValue);
  }

  @Override
  public int first() {
    assertNonEmpty(numberOfRuns() == 0);
    return (valueslength[0]);
  }

  @Override
  public int last() {
    assertNonEmpty(numberOfRuns() == 0);
    int index = numberOfRuns() - 1;
    int start = (getValue(index));
    int length = (getLength(index));
    return start + length;
  }

}


class RunContainerCharIterator implements PeekableCharIterator {
  int pos;
  int le = 0;
  int maxlength;
  int base;

  RunContainer parent;

  RunContainerCharIterator() {

  }

  RunContainerCharIterator(RunContainer p) {
    wrap(p);
  }

  @Override
  public PeekableCharIterator clone() {
    try {
      return (PeekableCharIterator) super.clone();
    } catch (CloneNotSupportedException e) {
      return null;// will not happen
    }
  }

  @Override
  public boolean hasNext() {
    return pos < parent.nbrruns;
  }

  @Override
  public char next() {
    char ans = (char) (base + le);
    le++;
    if (le > maxlength) {
      pos++;
      le = 0;
      if (pos < parent.nbrruns) {
        maxlength = (parent.getLength(pos));
        base = (parent.getValue(pos));
      }
    }
    return ans;
  }

  @Override
  public int nextAsInt() {
    int ans = base + le;
    le++;
    if (le > maxlength) {
      pos++;
      le = 0;
      if (pos < parent.nbrruns) {
        maxlength = (parent.getLength(pos));
        base = (parent.getValue(pos));
      }
    }
    return ans;
  }

  @Override
  public void remove() {
    throw new RuntimeException("Not implemented");// TODO
  }

  void wrap(RunContainer p) {
    parent = p;
    pos = 0;
    le = 0;
    if (pos < parent.nbrruns) {
      maxlength = (parent.getLength(pos));
      base = (parent.getValue(pos));
    }
  }

  @Override
  public void advanceIfNeeded(char minval) {
    while (base + maxlength < (minval)) {
      pos++;
      le = 0;
      if (pos < parent.nbrruns) {
        maxlength = (parent.getLength(pos));
        base = (parent.getValue(pos));
      } else {
        return;
      }
    }
    if (base > (minval)) {
      return;
    }
    le = (minval) - base;
  }



  @Override
  public char peekNext() {
    return (char) (base + le);
  }

}

class RunContainerCharRankIterator extends RunContainerCharIterator
    implements PeekableCharRankIterator {

  private int nextRank = 1;

  RunContainerCharRankIterator(RunContainer p) {
    super(p);
  }

  @Override
  public char next() {
    ++nextRank;
    return super.next();
  }

  @Override
  public int nextAsInt() {
    ++nextRank;
    return super.nextAsInt();
  }

  @Override
  public void advanceIfNeeded(char minval) {
    while (base + maxlength < (minval)) {
      nextRank += maxlength - le + 1;

      pos++;
      le = 0;
      if (pos < parent.nbrruns) {
        maxlength = (parent.getLength(pos));
        base = (parent.getValue(pos));
      } else {
        return;
      }
    }

    if (base > (minval)) {
      return;
    }
    int nextLe = (minval) - base;

    nextRank += nextLe - le;
    le = nextLe;
  }

  @Override
  public int peekNextRank() {
    return nextRank;
  }

  @Override
  public RunContainerCharRankIterator clone() {
    return (RunContainerCharRankIterator) super.clone();
  }
}


final class ReverseRunContainerCharIterator implements PeekableCharIterator {
  int pos;
  private int le;
  private RunContainer parent;
  private int maxlength;
  private int base;


  ReverseRunContainerCharIterator() {

  }

  ReverseRunContainerCharIterator(RunContainer p) {
    wrap(p);
  }

  @Override
  public PeekableCharIterator clone() {
    try {
      return (PeekableCharIterator) super.clone();
    } catch (CloneNotSupportedException e) {
      return null;// will not happen
    }
  }

  @Override
  public boolean hasNext() {
    return pos >= 0;
  }

  @Override
  public char next() {
    char ans = (char) (base + maxlength - le);
    le++;
    if (le > maxlength) {
      pos--;
      le = 0;
      if (pos >= 0) {
        maxlength = (parent.getLength(pos));
        base = (parent.getValue(pos));
      }
    }
    return ans;
  }

  @Override
  public int nextAsInt() {
    int ans = base + maxlength - le;
    le++;
    if (le > maxlength) {
      pos--;
      le = 0;
      if (pos >= 0) {
        maxlength = (parent.getLength(pos));
        base = (parent.getValue(pos));
      }
    }
    return ans;
  }

  @Override
  public void advanceIfNeeded(char maxval) {
    while (base > (maxval)) {
      pos--;
      le = 0;
      if (pos >= 0) {
        maxlength = (parent.getLength(pos));
        base = (parent.getValue(pos));
      } else {
        return;
      }
    }
    if (base + maxlength < (maxval)) {
      return;
    }
    le = maxlength + base - (maxval);
  }

  
  @Override
  public char peekNext() {
    return (char) (base + maxlength - le);
  }
  
  @Override
  public void remove() {
    throw new RuntimeException("Not implemented");// TODO
  }

  void wrap(RunContainer p) {
    parent = p;
    pos = parent.nbrruns - 1;
    le = 0;
    if (pos >= 0) {
      maxlength = (parent.getLength(pos));
      base = (parent.getValue(pos));
    }
  }

}

>>> file_path: ../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MappeableRunContainer.java
/*
 * (c) the authors Licensed under the Apache License, Version 2.0.
 */
package org.roaringbitmap.buffer;


import org.roaringbitmap.*;

import java.io.DataOutput;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.util.Arrays;
import java.util.Iterator;

import static java.nio.ByteOrder.LITTLE_ENDIAN;
import static org.roaringbitmap.Util.*;
import static org.roaringbitmap.buffer.MappeableBitmapContainer.MAX_CAPACITY;

/**
 * This container takes the form of runs of consecutive values (effectively, run-length encoding).
 * Uses a CharBuffer to store data, unlike org.roaringbitmap.RunContainer. Otherwise similar.
 *
 *
 * Adding and removing content from this container might make it wasteful so regular calls to
 * "runOptimize" might be warranted.
 */
public final class MappeableRunContainer extends MappeableContainer implements Cloneable {
  private static final int DEFAULT_INIT_SIZE = 4;
  private static final long serialVersionUID = 1L;

  private static int branchyBufferedUnsignedInterleavedBinarySearch(final CharBuffer sb,
      final int begin, final int end, final char k) {
    int low = begin;
    int high = end - 1;
    while (low <= high) {
      final int middleIndex = (low + high) >>> 1;
      final int middleValue = (sb.get(2 * middleIndex));
      if (middleValue < (int) (k)) {
        low = middleIndex + 1;
      } else if (middleValue > (int) (k)) {
        high = middleIndex - 1;
      } else {
        return middleIndex;
      }
    }
    return -(low + 1);
  }

  private static int branchyBufferedUnsignedInterleavedBinarySearch(final ByteBuffer sb,
      int position, final int begin, final int end, final char k) {
    int low = begin;
    int high = end - 1;
    while (low <= high) {
      final int middleIndex = (low + high) >>> 1;
      final int middleValue = (sb.getChar(position + 2 * middleIndex * 2));
      if (middleValue < (int) (k)) {
        low = middleIndex + 1;
      } else if (middleValue > (int) (k)) {
        high = middleIndex - 1;
      } else {
        return middleIndex;
      }
    }
    return -(low + 1);
  }

  private static int bufferedUnsignedInterleavedBinarySearch(final CharBuffer sb, final int begin,
      final int end, final char k) {
    return branchyBufferedUnsignedInterleavedBinarySearch(sb, begin, end, k);
  }


  private static int bufferedUnsignedInterleavedBinarySearch(final ByteBuffer sb, int position,
      final int begin, final int end, final char k) {
    return branchyBufferedUnsignedInterleavedBinarySearch(sb, position, begin, end, k);
  }

  protected static int getArraySizeInBytes(int nbrruns) {
    return 2 + 4 * nbrruns;
  }

  private static char getLength(char[] vl, int index) {
    return vl[2 * index + 1];
  }


  private static char getValue(char[] vl, int index) {
    return vl[2 * index];
  }

  protected static int serializedSizeInBytes(int numberOfRuns) {
    return 2 + 2 * 2 * numberOfRuns; // each run requires 2 2-byte entries.
  }

  protected CharBuffer valueslength;

  protected int nbrruns = 0;// how many runs, this number should fit in 16 bits.


  /**
   * Create a container with default capacity
   */
  public MappeableRunContainer() {
    this(DEFAULT_INIT_SIZE);
  }

  /**
   * Create an array container with specified capacity
   *
   * @param capacity The capacity of the container
   */
  public MappeableRunContainer(final int capacity) {
    valueslength = CharBuffer.allocate(2 * capacity);
  }


  private MappeableRunContainer(int nbrruns, final CharBuffer valueslength) {
    this.nbrruns = nbrruns;
    CharBuffer tmp = valueslength.duplicate();// for thread safety
    this.valueslength = CharBuffer.allocate(Math.max(2 * nbrruns, tmp.limit()));
    tmp.rewind();
    this.valueslength.put(tmp); // may copy more than it needs to??
  }


  protected MappeableRunContainer(MappeableArrayContainer arr, int nbrRuns) {
    this.nbrruns = nbrRuns;
    valueslength = CharBuffer.allocate(2 * nbrRuns);
    char[] vl = valueslength.array();
    if (nbrRuns == 0) {
      return;
    }

    int prevVal = -2;
    int runLen = 0;
    int runCount = 0;
    if (BufferUtil.isBackedBySimpleArray(arr.content)) {
      char[] a = arr.content.array();
      for (int i = 0; i < arr.cardinality; i++) {
        int curVal = (a[i]);
        if (curVal == prevVal + 1) {
          ++runLen;
        } else {
          if (runCount > 0) {
            vl[2 * (runCount - 1) + 1] = (char) runLen;
          }
          // setLength(runCount - 1, (char) runLen);
          vl[2 * runCount] = (char) curVal;
          // setValue(runCount, (char) curVal);
          runLen = 0;
          ++runCount;
        }
        prevVal = curVal;
      }

    } else {
      for (int i = 0; i < arr.cardinality; i++) {
        int curVal = (arr.content.get(i));
        if (curVal == prevVal + 1) {
          ++runLen;
        } else {
          if (runCount > 0) {
            vl[2 * (runCount - 1) + 1] = (char) runLen;
          }
          // setLength(runCount - 1, (char) runLen);
          vl[2 * runCount] = (char) curVal;
          // setValue(runCount, (char) curVal);
          runLen = 0;
          ++runCount;
        }
        prevVal = curVal;
      }
    }
    // setLength(runCount-1, (char) runLen);
    vl[2 * (runCount - 1) + 1] = (char) runLen;
  }

  /**
   * Create an run container with a run of ones from firstOfRun to lastOfRun.
   *
   * @param firstOfRun first index
   * @param lastOfRun last index (range is exclusive)
   */
  public MappeableRunContainer(final int firstOfRun, final int lastOfRun) {
    this.nbrruns = 1;
    char[] vl = {(char) firstOfRun, (char) (lastOfRun - 1 - firstOfRun)};
    this.valueslength = CharBuffer.wrap(vl);
  }

  // convert a bitmap container to a run container somewhat efficiently.
  protected MappeableRunContainer(MappeableBitmapContainer bc, int nbrRuns) {
    this.nbrruns = nbrRuns;
    valueslength = CharBuffer.allocate(2 * nbrRuns);
    if (!BufferUtil.isBackedBySimpleArray(valueslength)) {
      throw new RuntimeException("Unexpected internal error.");
    }
    char[] vl = valueslength.array();
    if (nbrRuns == 0) {
      return;
    }
    if (bc.isArrayBacked()) {
      long[] b = bc.bitmap.array();
      int longCtr = 0; // index of current long in bitmap
      long curWord = b[0]; // its value
      int runCount = 0;
      final int len = bc.bitmap.limit();
      while (true) {
        // potentially multiword advance to first 1 bit
        while (curWord == 0L && longCtr < len - 1) {
          curWord = b[++longCtr];
        }

        if (curWord == 0L) {
          // wrap up, no more runs
          return;
        }
        int localRunStart = Long.numberOfTrailingZeros(curWord);
        int runStart = localRunStart + 64 * longCtr;
        // stuff 1s into number's LSBs
        long curWordWith1s = curWord | (curWord - 1);

        // find the next 0, potentially in a later word
        int runEnd = 0;
        while (curWordWith1s == -1L && longCtr < len - 1) {
          curWordWith1s = b[++longCtr];
        }

        if (curWordWith1s == -1L) {
          // a final unterminated run of 1s (32 of them)
          runEnd = 64 + longCtr * 64;
          // setValue(runCount, (char) runStart);
          vl[2 * runCount] = (char) runStart;
          // setLength(runCount, (char) (runEnd-runStart-1));
          vl[2 * runCount + 1] = (char) (runEnd - runStart - 1);
          return;
        }
        int localRunEnd = Long.numberOfTrailingZeros(~curWordWith1s);
        runEnd = localRunEnd + longCtr * 64;
        // setValue(runCount, (char) runStart);
        vl[2 * runCount] = (char) runStart;
        // setLength(runCount, (char) (runEnd-runStart-1));
        vl[2 * runCount + 1] = (char) (runEnd - runStart - 1);
        runCount++;
        // now, zero out everything right of runEnd.
        curWord = curWordWith1s & (curWordWith1s + 1);
        // We've lathered and rinsed, so repeat...
      }
    } else {
      int longCtr = 0; // index of current long in bitmap
      long curWord = bc.bitmap.get(0); // its value
      int runCount = 0;
      final int len = bc.bitmap.limit();
      while (true) {
        // potentially multiword advance to first 1 bit
        while (curWord == 0L && longCtr < len - 1) {
          curWord = bc.bitmap.get(++longCtr);
        }

        if (curWord == 0L) {
          // wrap up, no more runs
          return;
        }
        int localRunStart = Long.numberOfTrailingZeros(curWord);
        int runStart = localRunStart + 64 * longCtr;
        // stuff 1s into number's LSBs
        long curWordWith1s = curWord | (curWord - 1);

        // find the next 0, potentially in a later word
        int runEnd = 0;
        while (curWordWith1s == -1L && longCtr < len - 1) {
          curWordWith1s = bc.bitmap.get(++longCtr);
        }

        if (curWordWith1s == -1L) {
          // a final unterminated run of 1s (32 of them)
          runEnd = 64 + longCtr * 64;
          // setValue(runCount, (char) runStart);
          vl[2 * runCount] = (char) runStart;
          // setLength(runCount, (char) (runEnd-runStart-1));
          vl[2 * runCount + 1] = (char) (runEnd - runStart - 1);
          return;
        }
        int localRunEnd = Long.numberOfTrailingZeros(~curWordWith1s);
        runEnd = localRunEnd + longCtr * 64;
        // setValue(runCount, (char) runStart);
        vl[2 * runCount] = (char) runStart;
        // setLength(runCount, (char) (runEnd-runStart-1));
        vl[2 * runCount + 1] = (char) (runEnd - runStart - 1);
        runCount++;
        // now, zero out everything right of runEnd.

        curWord = curWordWith1s & (curWordWith1s + 1);
        // We've lathered and rinsed, so repeat...
      }

    }
  }

  /**
   * Creates a new container from a non-mappeable one. This copies the data.
   *
   * @param bc the original container
   */
  public MappeableRunContainer(RunContainer bc) {
    this.nbrruns = bc.numberOfRuns();
    this.valueslength = bc.toCharBuffer();
  }

  /**
   * Construct a new RunContainer backed by the provided CharBuffer. Note that if you modify the
   * RunContainer a new CharBuffer may be produced.
   *
   * @param array CharBuffer where the data is stored
   * @param numRuns number of runs (each using 2 chars in the buffer)
   *
   */
  public MappeableRunContainer(final CharBuffer array, final int numRuns) {
    if (array.limit() < 2 * numRuns) {
      throw new RuntimeException("Mismatch between buffer and numRuns");
    }
    this.nbrruns = numRuns;
    this.valueslength = array;
  }

  @Override
  public MappeableContainer add(int begin, int end) {
    MappeableRunContainer rc = (MappeableRunContainer) clone();
    return rc.iadd(begin, end);
  }

  @Override
  // not thread-safe
  public MappeableContainer add(char k) {
    // TODO: it might be better and simpler to do return
    // toBitmapOrArrayContainer(getCardinality()).add(k)
    int index = bufferedUnsignedInterleavedBinarySearch(valueslength, 0, nbrruns, k);
    if (index >= 0) {
      return this;// already there
    }
    index = -index - 2;// points to preceding value, possibly -1
    if (index >= 0) {// possible match
      int offset = (k) - (getValue(index));
      int le = (getLength(index));
      if (offset <= le) {
        return this;
      }
      if (offset == le + 1) {
        // we may need to fuse
        if (index + 1 < nbrruns) {
          if ((getValue(index + 1)) == (k) + 1) {
            // indeed fusion is needed
            setLength(index,
                (char) (getValue(index + 1) + getLength(index + 1) - getValue(index)));
            recoverRoomAtIndex(index + 1);
            return this;
          }
        }
        incrementLength(index);
        return this;
      }
      if (index + 1 < nbrruns) {
        // we may need to fuse
        if ((getValue(index + 1)) == (k) + 1) {
          // indeed fusion is needed
          setValue(index + 1, k);
          setLength(index + 1, (char) (getLength(index + 1) + 1));
          return this;
        }
      }
    }
    if (index == -1) {
      // we may need to extend the first run
      if (0 < nbrruns) {
        if (getValue(0) == k + 1) {
          incrementLength(0);
          decrementValue(0);
          return this;
        }
      }
    }
    makeRoomAtIndex(index + 1);
    setValue(index + 1, k);
    setLength(index + 1, (char) 0);
    return this;
  }

  @Override
  public boolean isEmpty() {
    return nbrruns == 0;
  }


  @Override
  public MappeableContainer and(MappeableArrayContainer x) {
    MappeableArrayContainer ac = new MappeableArrayContainer(x.cardinality);
    if (this.nbrruns == 0) {
      return ac;
    }
    int rlepos = 0;
    int arraypos = 0;

    int rleval = (this.getValue(rlepos));
    int rlelength = (this.getLength(rlepos));
    while (arraypos < x.cardinality) {
      int arrayval = (x.content.get(arraypos));
      while (rleval + rlelength < arrayval) {// this will frequently be false
        ++rlepos;
        if (rlepos == this.nbrruns) {
          return ac;// we are done
        }
        rleval = (this.getValue(rlepos));
        rlelength = (this.getLength(rlepos));
      }
      if (rleval > arrayval) {
        arraypos =
            BufferUtil.advanceUntil(x.content, arraypos, x.cardinality, (char)rleval);
      } else {
        ac.content.put(ac.cardinality, (char) arrayval);
        ac.cardinality++;
        arraypos++;
      }
    }
    return ac;
  }

  @Override
  public MappeableContainer and(MappeableBitmapContainer x) {
    int card = this.getCardinality();
    if (card <= MappeableArrayContainer.DEFAULT_MAX_SIZE) {
      // result can only be an array (assuming that we never make a RunContainer)
      if (card > x.cardinality) {
        card = x.cardinality;
      }
      MappeableArrayContainer answer = new MappeableArrayContainer(card);
      answer.cardinality = 0;
      for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
        int runStart = (this.getValue(rlepos));
        int runEnd = runStart + (this.getLength(rlepos));
        for (int runValue = runStart; runValue <= runEnd; ++runValue) {
          if (x.contains((char) runValue)) {
            answer.content.put(answer.cardinality++, (char) runValue);
          }
        }
      }
      return answer;
    }
    // we expect the answer to be a bitmap (if we are lucky)

    MappeableBitmapContainer answer = x.clone();
    int start = 0;
    for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
      int end = (this.getValue(rlepos));
      int prevOnes = answer.cardinalityInRange(start, end);
      BufferUtil.resetBitmapRange(answer.bitmap, start, end);
      answer.updateCardinality(prevOnes, 0);
      start = end + (this.getLength(rlepos)) + 1;
    }
    int ones = answer.cardinalityInRange(start, MAX_CAPACITY);
    BufferUtil.resetBitmapRange(answer.bitmap, start, MAX_CAPACITY);
    answer.updateCardinality(ones, 0);
    if (answer.getCardinality() > MappeableArrayContainer.DEFAULT_MAX_SIZE) {
      return answer;
    } else {
      return answer.toArrayContainer();
    }

  }

  @Override
  public MappeableContainer and(MappeableRunContainer x) {
    MappeableRunContainer answer =
        new MappeableRunContainer(CharBuffer.allocate(2 * (this.nbrruns + x.nbrruns)), 0);
    char[] vl = answer.valueslength.array();
    int rlepos = 0;
    int xrlepos = 0;
    int start = (this.getValue(rlepos));
    int end = start + (this.getLength(rlepos)) + 1;
    int xstart = (x.getValue(xrlepos));
    int xend = xstart + (x.getLength(xrlepos)) + 1;
    while ((rlepos < this.nbrruns) && (xrlepos < x.nbrruns)) {
      if (end <= xstart) {
        // exit the first run
        rlepos++;
        if (rlepos < this.nbrruns) {
          start = (this.getValue(rlepos));
          end = start + (this.getLength(rlepos)) + 1;
        }
      } else if (xend <= start) {
        // exit the second run
        xrlepos++;
        if (xrlepos < x.nbrruns) {
          xstart = (x.getValue(xrlepos));
          xend = xstart + (x.getLength(xrlepos)) + 1;
        }
      } else {// they overlap
        final int lateststart = Math.max(start, xstart);
        int earliestend;
        if (end == xend) {// improbable
          earliestend = end;
          rlepos++;
          xrlepos++;
          if (rlepos < this.nbrruns) {
            start = (this.getValue(rlepos));
            end = start + (this.getLength(rlepos)) + 1;
          }
          if (xrlepos < x.nbrruns) {
            xstart = (x.getValue(xrlepos));
            xend = xstart + (x.getLength(xrlepos)) + 1;
          }
        } else if (end < xend) {
          earliestend = end;
          rlepos++;
          if (rlepos < this.nbrruns) {
            start = (this.getValue(rlepos));
            end = start + (this.getLength(rlepos)) + 1;
          }

        } else {// end > xend
          earliestend = xend;
          xrlepos++;
          if (xrlepos < x.nbrruns) {
            xstart = (x.getValue(xrlepos));
            xend = xstart + (x.getLength(xrlepos)) + 1;
          }
        }
        vl[2 * answer.nbrruns] = (char) lateststart;
        vl[2 * answer.nbrruns + 1] = (char) (earliestend - lateststart - 1);
        answer.nbrruns++;
      }
    }
    return answer;
  }

  @Override
  public MappeableContainer andNot(MappeableArrayContainer x) {
    // when x is small, we guess that the result will still be a run container
    final int arbitrary_threshold = 32; // this is arbitrary
    if (x.getCardinality() < arbitrary_threshold) {
      return lazyandNot(x).toEfficientContainer();
    }
    // otherwise we generate either an array or bitmap container
    final int card = getCardinality();
    if (card <= MappeableArrayContainer.DEFAULT_MAX_SIZE) {
      // if the cardinality is small, we construct the solution in place
      MappeableArrayContainer ac = new MappeableArrayContainer(card);
      ac.cardinality = org.roaringbitmap.Util.unsignedDifference(this.getCharIterator(),
          x.getCharIterator(), ac.content.array());
      return ac;
    }
    // otherwise, we generate a bitmap
    return toBitmapOrArrayContainer(card).iandNot(x);
  }

  @Override
  public MappeableContainer andNot(MappeableBitmapContainer x) {
    int card = this.getCardinality();
    if (card <= MappeableArrayContainer.DEFAULT_MAX_SIZE) {
      // result can only be an array (assuming that we never make a RunContainer)
      MappeableArrayContainer answer = new MappeableArrayContainer(card);
      answer.cardinality = 0;
      for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
        int runStart = (this.getValue(rlepos));
        int runEnd = runStart + (this.getLength(rlepos));
        for (int runValue = runStart; runValue <= runEnd; ++runValue) {
          if (!x.contains((char) runValue)) {
            answer.content.put(answer.cardinality++, (char) runValue);
          }
        }
      }
      return answer;
    }
    // we expect the answer to be a bitmap (if we are lucky)
    MappeableBitmapContainer answer = x.clone();
    int lastPos = 0;
    for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
      int start = (this.getValue(rlepos));
      int end = start + (this.getLength(rlepos)) + 1;
      int prevOnes = answer.cardinalityInRange(lastPos, start);
      int flippedOnes = answer.cardinalityInRange(start, end);
      BufferUtil.resetBitmapRange(answer.bitmap, lastPos, start);
      BufferUtil.flipBitmapRange(answer.bitmap, start, end);
      answer.updateCardinality(prevOnes + flippedOnes, end - start - flippedOnes);
      lastPos = end;
    }
    int ones = answer.cardinalityInRange(lastPos, MAX_CAPACITY);
    BufferUtil.resetBitmapRange(answer.bitmap, lastPos, answer.bitmap.capacity() * 64);
    answer.updateCardinality(ones, 0);
    if (answer.getCardinality() > MappeableArrayContainer.DEFAULT_MAX_SIZE) {
      return answer;
    } else {
      return answer.toArrayContainer();
    }
  }

  @Override
  public MappeableContainer andNot(MappeableRunContainer x) {
    MappeableRunContainer answer =
        new MappeableRunContainer(CharBuffer.allocate(2 * (this.nbrruns + x.nbrruns)), 0);
    char[] vl = answer.valueslength.array();
    int rlepos = 0;
    int xrlepos = 0;
    int start = (this.getValue(rlepos));
    int end = start + (this.getLength(rlepos)) + 1;
    int xstart = (x.getValue(xrlepos));
    int xend = xstart + (x.getLength(xrlepos)) + 1;
    while ((rlepos < this.nbrruns) && (xrlepos < x.nbrruns)) {
      if (end <= xstart) {
        // output the first run
        vl[2 * answer.nbrruns] = (char) start;
        vl[2 * answer.nbrruns + 1] = (char) (end - start - 1);
        answer.nbrruns++;
        rlepos++;
        if (rlepos < this.nbrruns) {
          start = (this.getValue(rlepos));
          end = start + (this.getLength(rlepos)) + 1;
        }
      } else if (xend <= start) {
        // exit the second run
        xrlepos++;
        if (xrlepos < x.nbrruns) {
          xstart = (x.getValue(xrlepos));
          xend = xstart + (x.getLength(xrlepos)) + 1;
        }
      } else {
        if (start < xstart) {
          vl[2 * answer.nbrruns] = (char) start;
          vl[2 * answer.nbrruns + 1] = (char) (xstart - start - 1);
          answer.nbrruns++;
        }
        if (xend < end) {
          start = xend;
        } else {
          rlepos++;
          if (rlepos < this.nbrruns) {
            start = (this.getValue(rlepos));
            end = start + (this.getLength(rlepos)) + 1;
          }
        }
      }
    }
    if (rlepos < this.nbrruns) {
      vl[2 * answer.nbrruns] = (char) start;
      vl[2 * answer.nbrruns + 1] = (char) (end - start - 1);
      answer.nbrruns++;
      rlepos++;
      for (; rlepos < this.nbrruns; ++rlepos) {
        vl[2 * answer.nbrruns] = this.valueslength.get(2 * rlepos);
        vl[2 * answer.nbrruns + 1] = this.valueslength.get(2 * rlepos + 1);
        answer.nbrruns++;
      }
      // next bit would be faster but not thread-safe because of the "position"
      // if(rlepos < this.nbrruns) {
      // this.valueslength.position(2 * rlepos);
      // this.valueslength.get(vl, 2 * answer.nbrruns, 2*(this.nbrruns-rlepos ));
      // answer.nbrruns = answer.nbrruns + this.nbrruns - rlepos;
      // }
    }
    return answer;
  }

  // Append a value length with all values until a given value
  private void appendValueLength(int value, int index) {
    int previousValue = (getValue(index));
    int length = (getLength(index));
    int offset = value - previousValue;
    if (offset > length) {
      setLength(index, (char) offset);
    }
  }


  // To check if a value length can be prepended with a given value
  private boolean canPrependValueLength(int value, int index) {
    if (index < this.nbrruns) {
      int nextValue = (getValue(index));
      return nextValue == value + 1;
    }
    return false;
  }



  @Override
  public void clear() {
    nbrruns = 0;
  }


  @Override
  public MappeableContainer clone() {
    return new MappeableRunContainer(nbrruns, valueslength);
  }



  // To set the last value of a value length
  private void closeValueLength(int value, int index) {
    int initialValue = (getValue(index));
    setLength(index, (char) (value - initialValue));
  }

  @Override
  public boolean contains(char x) {
    int index = bufferedUnsignedInterleavedBinarySearch(valueslength, 0, nbrruns, x);
    if (index >= 0) {
      return true;
    }
    index = -index - 2; // points to preceding value, possibly -1
    if (index != -1) {// possible match
      int offset = (x) - (getValue(index));
      int le = (getLength(index));
      return offset <= le;
    }
    return false;
  }

  /**
   * Checks whether the run container contains x.
   *
   * @param buf underlying ByteBuffer
   * @param position starting position of the container in the ByteBuffer
   * @param x target 16-bit value
   * @param numRuns number of runs
   * @return whether the run container contains x
   */
  public static boolean contains(ByteBuffer buf, int position, char x, final int numRuns) {
    int index = bufferedUnsignedInterleavedBinarySearch(buf, position, 0, numRuns, x);
    if (index >= 0) {
      return true;
    }
    index = -index - 2; // points to preceding value, possibly -1
    if (index != -1) {// possible match
      int offset = (x)
          - (buf.getChar(position + index * 2 * 2));
      int le = (buf.getChar(position + index * 2 * 2 + 2));
      return offset <= le;
    }
    return false;

  }

  // a very cheap check... if you have more than 4096, then you should use a bitmap container.
  // this function avoids computing the cardinality
  private MappeableContainer convertToLazyBitmapIfNeeded() {
    // when nbrruns exceed MappeableArrayContainer.DEFAULT_MAX_SIZE, then we know it should be
    // stored as a bitmap, always
    if (this.nbrruns > MappeableArrayContainer.DEFAULT_MAX_SIZE) {
      MappeableBitmapContainer answer = new MappeableBitmapContainer();
      for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
        int start = (this.getValue(rlepos));
        int end = start + (this.getLength(rlepos)) + 1;
        BufferUtil.setBitmapRange(answer.bitmap, start, end);
      }
      answer.cardinality = -1;
      return answer;
    }
    return this;
  }

  // Push all values length to the end of the array (resize array if needed)
  private void copyToOffset(int offset) {
    final int minCapacity = 2 * (offset + nbrruns);
    if (valueslength.capacity() < minCapacity) {
      // expensive case where we need to reallocate
      int newCapacity = valueslength.capacity();
      while (newCapacity < minCapacity) {
        newCapacity = (newCapacity == 0) ? DEFAULT_INIT_SIZE
            : newCapacity < 64 ? newCapacity * 2
                : newCapacity < 1024 ? newCapacity * 3 / 2 : newCapacity * 5 / 4;
      }
      CharBuffer newvalueslength = CharBuffer.allocate(newCapacity);
      copyValuesLength(this.valueslength, 0, newvalueslength, offset, nbrruns);
      this.valueslength = newvalueslength;
    } else {
      // efficient case where we just copy
      copyValuesLength(this.valueslength, 0, this.valueslength, offset, nbrruns);
    }
  }

  private void copyValuesLength(CharBuffer src, int srcIndex, CharBuffer dst, int dstIndex,
      int length) {
    if (BufferUtil.isBackedBySimpleArray(src) && BufferUtil.isBackedBySimpleArray(dst)) {
      // common case.
      System.arraycopy(src.array(), 2 * srcIndex, dst.array(), 2 * dstIndex, 2 * length);
      return;
    }
    // source and destination may overlap
    // consider specialized code for various cases, rather than using a second buffer
    CharBuffer temp = CharBuffer.allocate(2 * length);
    for (int i = 0; i < 2 * length; ++i) {
      temp.put(src.get(2 * srcIndex + i));
    }
    temp.flip();
    for (int i = 0; i < 2 * length; ++i) {
      dst.put(2 * dstIndex + i, temp.get());
    }
  }

  private void decrementLength(int index) {
    // caller is responsible to ensure that value is non-zero
    valueslength.put(2 * index + 1, (char) (valueslength.get(2 * index + 1) - 1));
  }


  private void decrementValue(int index) {
    valueslength.put(2 * index, (char) (valueslength.get(2 * index) - 1));
  }

  // not thread safe!
  // not actually used anywhere, but potentially useful
  private void ensureCapacity(int minNbRuns) {
    final int minCapacity = 2 * minNbRuns;
    if (valueslength.capacity() < minCapacity) {
      int newCapacity = valueslength.capacity();
      while (newCapacity < minCapacity) {
        newCapacity = (newCapacity == 0) ? DEFAULT_INIT_SIZE
            : newCapacity < 64 ? newCapacity * 2
                : newCapacity < 1024 ? newCapacity * 3 / 2 : newCapacity * 5 / 4;
      }
      final CharBuffer nv = CharBuffer.allocate(newCapacity);
      valueslength.rewind();
      nv.put(valueslength);
      valueslength = nv;
    }
  }

  @Override
  public boolean equals(Object o) {
    if (o instanceof MappeableRunContainer) {
      return equals((MappeableRunContainer) o);
    } else if (o instanceof MappeableArrayContainer) {
      return equals((MappeableArrayContainer) o);
    } else if (o instanceof MappeableContainer) {
      if (((MappeableContainer) o).getCardinality() != this.getCardinality()) {
        return false; // should be a frequent branch if they differ
      }
      // next bit could be optimized if needed:
      CharIterator me = this.getCharIterator();
      CharIterator you = ((MappeableContainer) o).getCharIterator();
      while (me.hasNext()) {
        if (me.next() != you.next()) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  private boolean equals(MappeableRunContainer runContainer) {
    if (runContainer.nbrruns != this.nbrruns) {
      return false;
    }
    for (int i = 0; i < nbrruns; ++i) {
      if (this.getValue(i) != runContainer.getValue(i)) {
        return false;
      }
      if (this.getLength(i) != runContainer.getLength(i)) {
        return false;
      }
    }
    return true;
  }

  private boolean equals(MappeableArrayContainer arrayContainer) {
    int pos = 0;
    for (char i = 0; i < nbrruns; ++i) {
      char runStart = getValue(i);
      int length = (getLength(i));
      if (pos + length >= arrayContainer.getCardinality()) {
        return false;
      }
      if (arrayContainer.select(pos) != runStart) {
        return false;
      }
      if (arrayContainer.select(pos + length) != (char)((runStart) + length)) {
        return false;
      }
      pos += length + 1;
    }
    return pos == arrayContainer.getCardinality();
  }

  @Override
  public void fillLeastSignificant16bits(int[] x, int i, int mask) {
    int pos = i;
    for (int k = 0; k < this.nbrruns; ++k) {
      final int limit = (this.getLength(k));
      final int base = (this.getValue(k));
      for (int le = 0; le <= limit; ++le) {
        x[pos++] = (base + le) | mask;
      }
    }
  }


  @Override
  public MappeableContainer flip(char x) {
    if (this.contains(x)) {
      return this.remove(x);
    } else {
      return this.add(x);
    }
  }

  @Override
  protected int getArraySizeInBytes() {
    return 2 + 4 * this.nbrruns; // "array" includes its size
  }

  @Override
  public int getCardinality() {
    int sum = nbrruns; // lengths are stored -1
    if (isArrayBacked()) {
      char[] vl = valueslength.array();
      for (int k = 0; k < nbrruns; ++k) {
        sum = sum + (vl[2 * k + 1])/* + 1 */;
      }
    } else {
      for (int k = 0; k < nbrruns; ++k) {
        sum = sum + (getLength(k))/* + 1 */;
      }
    }
    return sum;
  }

  /**
   * Gets the length of the run at the index.
   * @param index the index of the run.
   * @return the length of the run at the index.
   * @throws ArrayIndexOutOfBoundsException if index is negative or larger than the index of the
   *     last run.
   */
  public char getLength(int index) {
    return valueslength.get(2 * index + 1);
  }

  @Override
  public CharIterator getReverseCharIterator() {
    if (isArrayBacked()) {
      return new RawReverseMappeableRunContainerCharIterator(this);
    }
    return new ReverseMappeableRunContainerCharIterator(this);
  }

  @Override
  public PeekableCharIterator getCharIterator() {
    if (isArrayBacked()) {
      return new RawMappeableRunContainerCharIterator(this);
    }
    return new MappeableRunContainerCharIterator(this);
  }

  @Override
  public ContainerBatchIterator getBatchIterator() {
    return new RunBatchIterator(this);
  }

  @Override
  public int getSizeInBytes() {
    return this.nbrruns * 4 + 4; // not sure about how exact it will be
  }

  /**
   * Gets the value of the first element of the run at the index.
   * @param index the index of the run.
   * @return the value of the first element of the run at the index.
   * @throws ArrayIndexOutOfBoundsException if index is negative or larger than the index of the
   *     last run.
   */
  public char getValue(int index) {
    return valueslength.get(2 * index);
  }

  @Override
  public int hashCode() {
    int hash = 0;
    for (int k = 0; k < nbrruns * 2; ++k) {
      hash += 31 * hash + valueslength.get(k);
    }
    return hash;
  }

  @Override
  // not thread-safe
  public MappeableContainer iadd(int begin, int end) {
    // TODO: it might be better and simpler to do return
    // toBitmapOrArrayContainer(getCardinality()).iadd(begin,end)
    if(end == begin) {
      return this;
    }
    if ((begin > end) || (end > (1 << 16))) {
      throw new IllegalArgumentException("Invalid range [" + begin + "," + end + ")");
    }
    if (begin == end - 1) {
      add((char) begin);
      return this;
    }

    int bIndex =
        bufferedUnsignedInterleavedBinarySearch(this.valueslength, 0, this.nbrruns, (char) begin);
    int eIndex = bufferedUnsignedInterleavedBinarySearch(this.valueslength, 0, this.nbrruns,
        (char) (end - 1));

    if (bIndex >= 0 && eIndex >= 0) {
      mergeValuesLength(bIndex, eIndex);
      return this;

    } else if (bIndex >= 0) {
      eIndex = -eIndex - 2;

      if (canPrependValueLength(end - 1, eIndex + 1)) {
        mergeValuesLength(bIndex, eIndex + 1);
        return this;
      }

      appendValueLength(end - 1, eIndex);
      mergeValuesLength(bIndex, eIndex);
      return this;

    } else if (eIndex >= 0) {
      bIndex = -bIndex - 2;

      if (bIndex >= 0) {
        if (valueLengthContains(begin - 1, bIndex)) {
          mergeValuesLength(bIndex, eIndex);
          return this;
        }
      }
      prependValueLength(begin, bIndex + 1);
      mergeValuesLength(bIndex + 1, eIndex);
      return this;

    } else {
      bIndex = -bIndex - 2;
      eIndex = -eIndex - 2;

      if (eIndex >= 0) {
        if (bIndex >= 0) {
          if (!valueLengthContains(begin - 1, bIndex)) {
            if (bIndex == eIndex) {
              if (canPrependValueLength(end - 1, eIndex + 1)) {
                prependValueLength(begin, eIndex + 1);
                return this;
              }
              makeRoomAtIndex(eIndex + 1);
              setValue(eIndex + 1, (char) begin);
              setLength(eIndex + 1, (char) (end - 1 - begin));
              return this;

            } else {
              bIndex++;
              prependValueLength(begin, bIndex);
            }
          }
        } else {
          bIndex = 0;
          prependValueLength(begin, bIndex);
        }

        if (canPrependValueLength(end - 1, eIndex + 1)) {
          mergeValuesLength(bIndex, eIndex + 1);
          return this;
        }

        appendValueLength(end - 1, eIndex);
        mergeValuesLength(bIndex, eIndex);
        return this;

      } else {
        if (canPrependValueLength(end - 1, 0)) {
          prependValueLength(begin, 0);
        } else {
          makeRoomAtIndex(0);
          setValue(0, (char) begin);
          setLength(0, (char) (end - 1 - begin));
        }
        return this;
      }
    }
  }



  @Override
  public MappeableContainer iand(MappeableArrayContainer x) {
    return and(x);
  }

  @Override
  public MappeableContainer iand(MappeableBitmapContainer x) {
    return and(x);
  }


  @Override
  public MappeableContainer iand(MappeableRunContainer x) {
    return and(x);
  }

  @Override
  public MappeableContainer iandNot(MappeableArrayContainer x) {
    return andNot(x);
  }

  @Override
  public MappeableContainer iandNot(MappeableBitmapContainer x) {
    return andNot(x);
  }

  @Override
  public MappeableContainer iandNot(MappeableRunContainer x) {
    return andNot(x);
  }

  MappeableContainer ilazyor(MappeableArrayContainer x) {
    if (isFull()) {
      return this; // this can sometimes solve a lot of computation!
    }
    return ilazyorToRun(x);
  }


  private MappeableContainer ilazyorToRun(MappeableArrayContainer x) {
    if (isFull()) {
      return full();
    }
    final int nbrruns = this.nbrruns;
    final int offset = Math.max(nbrruns, x.getCardinality());
    copyToOffset(offset);
    char[] vl = valueslength.array();
    int rlepos = 0;
    this.nbrruns = 0;
    PeekableCharIterator i = x.getCharIterator();
    while (i.hasNext() && (rlepos < nbrruns)) {
      if ((getValue(vl, rlepos + offset)) - (i.peekNext()) <= 0) {
        smartAppend(vl, getValue(vl, rlepos + offset), getLength(vl, rlepos + offset));
        rlepos++;
      } else {
        smartAppend(vl, i.next());
      }
    }
    if (i.hasNext()) {
      /*
       * if(this.nbrruns>0) { // this might be useful if the run container has just one very large
       * run int lastval = (getValue(vl,nbrruns + offset - 1)) +
       * (getLength(vl,nbrruns + offset - 1)) + 1; i.advanceIfNeeded((char)
       * lastval); }
       */
      while (i.hasNext()) {
        smartAppend(vl, i.next());
      }
    } else {
      while (rlepos < nbrruns) {
        smartAppend(vl, getValue(vl, rlepos + offset), getLength(vl, rlepos + offset));
        rlepos++;
      }
    }
    return convertToLazyBitmapIfNeeded();
  }

  // not thread safe!
  private void increaseCapacity() {
    int newCapacity = (valueslength.capacity() == 0) ? DEFAULT_INIT_SIZE
        : valueslength.capacity() < 64 ? valueslength.capacity() * 2
            : valueslength.capacity() < 1024 ? valueslength.capacity() * 3 / 2
                : valueslength.capacity() * 5 / 4;

    final CharBuffer nv = CharBuffer.allocate(newCapacity);
    valueslength.rewind();
    nv.put(valueslength);
    valueslength = nv;
  }

  private void incrementLength(int index) {
    valueslength.put(2 * index + 1, (char) (1 + valueslength.get(2 * index + 1)));
  }

  private void incrementValue(int index) {
    valueslength.put(2 * index, (char) (1 + valueslength.get(2 * index)));
  }

  // To set the first value of a value length
  private void initValueLength(int value, int index) {
    int initialValue = (getValue(index));
    int length = (getLength(index));
    setValue(index, (char) (value));
    setLength(index, (char) (length - (value - initialValue)));
  }


  @Override
  public MappeableContainer inot(int rangeStart, int rangeEnd) {
    if (rangeEnd <= rangeStart) {
      return this;
    }
    char[] vl = this.valueslength.array();

    // TODO: write special case code for rangeStart=0; rangeEnd=65535
    // a "sliding" effect where each range records the gap adjacent it
    // can probably be quite fast. Probably have 2 cases: start with a
    // 0 run vs start with a 1 run. If you both start and end with 0s,
    // you will require room for expansion.

    // the +1 below is needed in case the valueslength.length is odd
    if (vl.length <= 2 * nbrruns + 1) {
      // no room for expansion
      // analyze whether this is a case that will require expansion (that we cannot do)
      // this is a bit costly now (4 "contains" checks)

      boolean lastValueBeforeRange = false;
      boolean firstValueInRange;
      boolean lastValueInRange;
      boolean firstValuePastRange = false;

      // contains is based on a binary search and is hopefully fairly fast.
      // however, one binary search could *usually* suffice to find both
      // lastValueBeforeRange AND firstValueInRange. ditto for
      // lastVaueInRange and firstValuePastRange

      // find the start of the range
      if (rangeStart > 0) {
        lastValueBeforeRange = contains((char) (rangeStart - 1));
      }
      firstValueInRange = contains((char) rangeStart);

      if (lastValueBeforeRange == firstValueInRange) {
        // expansion is required if also lastValueInRange==firstValuePastRange

        // tougher to optimize out, but possible.
        lastValueInRange = contains((char) (rangeEnd - 1));
        if (rangeEnd != 65536) {
          firstValuePastRange = contains((char) rangeEnd);
        }

        // there is definitely one more run after the operation.
        if (lastValueInRange == firstValuePastRange) {
          return not(rangeStart, rangeEnd); // can't do in-place: true space limit
        }
      }
    }
    // either no expansion required, or we have room to handle any required expansion for it.

    // remaining code is just a minor variation on not()
    int myNbrRuns = nbrruns;

    MappeableRunContainer ans = this; // copy on top of self.
    int k = 0;
    ans.nbrruns = 0; // losing this.nbrruns, which is stashed in myNbrRuns.

    // could try using unsignedInterleavedBinarySearch(valueslength, 0, nbrruns, rangeStart) instead
    // of sequential scan
    // to find the starting location

    for (; k < myNbrRuns && (this.getValue(k)) < rangeStart; ++k) {
      // since it is atop self, there is no copying needed
      // ans.valueslength[2 * k] = this.valueslength[2 * k];
      // ans.valueslength[2 * k + 1] = this.valueslength[2 * k + 1];
      ans.nbrruns++;
    }
    // We will work left to right, with a read pointer that always stays
    // left of the write pointer. However, we need to give the read pointer a head start.
    // use local variables so we are always reading 1 location ahead.

    char bufferedValue = 0, bufferedLength = 0; // 65535 start and 65535 length would be illegal,
                                                 // could use as sentinel
    char nextValue = 0, nextLength = 0;
    if (k < myNbrRuns) { // prime the readahead variables
      bufferedValue = vl[2 * k];// getValue(k);
      bufferedLength = vl[2 * k + 1];// getLength(k);
    }

    ans.smartAppendExclusive(vl, (char) rangeStart, (char) (rangeEnd - rangeStart - 1));

    for (; k < myNbrRuns; ++k) {
      if (ans.nbrruns > k + 1) {
        throw new RuntimeException(
            "internal error in inot, writer has overtaken reader!! " + k + " " + ans.nbrruns);
      }
      if (k + 1 < myNbrRuns) {
        nextValue = vl[2 * (k + 1)];// getValue(k+1); // readahead for next iteration
        nextLength = vl[2 * (k + 1) + 1];// getLength(k+1);
      }
      ans.smartAppendExclusive(vl, bufferedValue, bufferedLength);
      bufferedValue = nextValue;
      bufferedLength = nextLength;
    }
    // the number of runs can increase by one, meaning (rarely) a bitmap will become better
    // or the cardinality can decrease by a lot, making an array better
    return ans.toEfficientContainer();
  }

  @Override
  public boolean intersects(MappeableArrayContainer x) {
    if (this.nbrruns == 0) {
      return false;
    }
    int rlepos = 0;
    int arraypos = 0;

    int rleval = (this.getValue(rlepos));
    int rlelength = (this.getLength(rlepos));
    while (arraypos < x.cardinality) {
      int arrayval = (x.content.get(arraypos));
      while (rleval + rlelength < arrayval) {// this will frequently be false
        ++rlepos;
        if (rlepos == this.nbrruns) {
          return false;
        }
        rleval = (this.getValue(rlepos));
        rlelength = (this.getLength(rlepos));
      }
      if (rleval > arrayval) {
        arraypos =
            BufferUtil.advanceUntil(x.content, arraypos, x.cardinality, this.getValue(rlepos));
      } else {
        return true;
      }
    }
    return false;
  }

  @Override
  public boolean intersects(MappeableBitmapContainer x) {
    for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
      int runStart = this.getValue(rlepos);
      int runEnd = runStart + this.getLength(rlepos);
      if (x.intersects(runStart, runEnd + 1)) {
        return true;
      }
    }
    return false;
  }

  @Override
  public boolean intersects(MappeableRunContainer x) {
    int rlepos = 0;
    int xrlepos = 0;
    int start = (this.getValue(rlepos));
    int end = start + (this.getLength(rlepos)) + 1;
    int xstart = (x.getValue(xrlepos));
    int xend = xstart + (x.getLength(xrlepos)) + 1;
    while ((rlepos < this.nbrruns) && (xrlepos < x.nbrruns)) {
      if (end <= xstart) {
        // exit the first run
        rlepos++;
        if (rlepos < this.nbrruns) {
          start = (this.getValue(rlepos));
          end = start + (this.getLength(rlepos)) + 1;
        }
      } else if (xend <= start) {
        // exit the second run
        xrlepos++;
        if (xrlepos < x.nbrruns) {
          xstart = (x.getValue(xrlepos));
          xend = xstart + (x.getLength(xrlepos)) + 1;
        }
      } else {// they overlap
        return true;
      }
    }
    return false;
  }

  @Override
  public MappeableContainer ior(MappeableArrayContainer x) {
    if (isFull()) {
      return this;
    }
    final int nbrruns = this.nbrruns;
    final int offset = Math.max(nbrruns, x.getCardinality());
    copyToOffset(offset);
    char[] vl = this.valueslength.array();
    int rlepos = 0;
    this.nbrruns = 0;
    PeekableCharIterator i = x.getCharIterator();
    while (i.hasNext() && (rlepos < nbrruns)) {
      if ((getValue(vl, rlepos + offset)) - (i.peekNext()) <= 0) {
        smartAppend(vl, getValue(vl, rlepos + offset), getLength(vl, rlepos + offset));
        rlepos++;
      } else {
        smartAppend(vl, i.next());
      }
    }
    if (i.hasNext()) {
      /*
       * if(this.nbrruns>0) { // this might be useful if the run container has just one very large
       * run int lastval = (getValue(nbrruns + offset - 1)) +
       * (getLength(nbrruns + offset - 1)) + 1; i.advanceIfNeeded((char)
       * lastval); }
       */
      while (i.hasNext()) {
        smartAppend(vl, i.next());
      }
    } else {
      while (rlepos < nbrruns) {
        smartAppend(vl, getValue(vl, rlepos + offset), getLength(vl, rlepos + offset));
        rlepos++;
      }
    }
    return toEfficientContainer();
  }

  @Override
  public MappeableContainer ior(MappeableBitmapContainer x) {
    if (isFull()) {
      return this;
    }
    return or(x);
  }

  @Override
  public MappeableContainer ior(MappeableRunContainer x) {
    if (isFull()) {
      return this;
    }

    final int nbrruns = this.nbrruns;
    final int xnbrruns = x.nbrruns;
    final int offset = Math.max(nbrruns, xnbrruns);

    // Push all values length to the end of the array (resize array if needed)
    copyToOffset(offset);

    // Aggregate and store the result at the beginning of the array
    this.nbrruns = 0;
    int rlepos = 0;
    int xrlepos = 0;
    char[] vl = this.valueslength.array();

    // Add values length (smaller first)
    while ((rlepos < nbrruns) && (xrlepos < xnbrruns)) {
      final char value = getValue(vl, offset + rlepos);
      final char xvalue = x.getValue(xrlepos);
      final char length = getLength(vl, offset + rlepos);
      final char xlength = x.getLength(xrlepos);

      if ((value) - (xvalue) <= 0) {
        this.smartAppend(vl, value, length);
        ++rlepos;
      } else {
        this.smartAppend(vl, xvalue, xlength);
        ++xrlepos;
      }
    }
    while (rlepos < nbrruns) {
      this.smartAppend(vl, getValue(vl, offset + rlepos), getLength(vl, offset + rlepos));
      ++rlepos;
    }
    while (xrlepos < xnbrruns) {
      this.smartAppend(vl, x.getValue(xrlepos), x.getLength(xrlepos));
      ++xrlepos;
    }
    return this.toBitmapIfNeeded();
  }

  @Override
  // not thread-safe
  public MappeableContainer iremove(int begin, int end) {
    // TODO: it might be better and simpler to do return
    // toBitmapOrArrayContainer(getCardinality()).iremove(begin,end)
    if(end == begin) {
      return this;
    }
    if ((begin > end) || (end > (1 << 16))) {
      throw new IllegalArgumentException("Invalid range [" + begin + "," + end + ")");
    }
    if (begin == end - 1) {
      remove((char) begin);
      return this;
    }

    int bIndex =
        bufferedUnsignedInterleavedBinarySearch(this.valueslength, 0, this.nbrruns, (char) begin);
    int eIndex = bufferedUnsignedInterleavedBinarySearch(this.valueslength, 0, this.nbrruns,
        (char) (end - 1));

    if (bIndex >= 0) {
      if (eIndex < 0) {
        eIndex = -eIndex - 2;
      }

      if (valueLengthContains(end, eIndex)) {
        initValueLength(end, eIndex);
        recoverRoomsInRange(bIndex - 1, eIndex - 1);
      } else {
        recoverRoomsInRange(bIndex - 1, eIndex);
      }

    } else if (eIndex >= 0) {
      bIndex = -bIndex - 2;

      if (bIndex >= 0) {
        if (valueLengthContains(begin, bIndex)) {
          closeValueLength(begin - 1, bIndex);
        }
      }
      // last run is one charer
      if (getLength(eIndex) == 0) {// special case where we remove last run
        recoverRoomsInRange(eIndex - 1, eIndex);
      } else {
        incrementValue(eIndex);
        decrementLength(eIndex);
      }
      recoverRoomsInRange(bIndex, eIndex - 1);

    } else {
      bIndex = -bIndex - 2;
      eIndex = -eIndex - 2;

      if (eIndex >= 0) {
        if (bIndex >= 0) {
          if (bIndex == eIndex) {
            if (valueLengthContains(begin, bIndex)) {
              if (valueLengthContains(end, eIndex)) {
                makeRoomAtIndex(bIndex);
                closeValueLength(begin - 1, bIndex);
                initValueLength(end, bIndex + 1);
                return this;
              }
              closeValueLength(begin - 1, bIndex);
            }
          } else {
            if (valueLengthContains(begin, bIndex)) {
              closeValueLength(begin - 1, bIndex);
            }
            if (valueLengthContains(end, eIndex)) {
              initValueLength(end, eIndex);
              eIndex--;
            }
            recoverRoomsInRange(bIndex, eIndex);
          }

        } else {
          if (valueLengthContains(end, eIndex)) { // was end-1
            initValueLength(end, eIndex);
            recoverRoomsInRange(bIndex, eIndex - 1);
          } else {
            recoverRoomsInRange(bIndex, eIndex);
          }
        }

      }

    }
    return this;
  }

  @Override
  protected boolean isArrayBacked() {
    return BufferUtil.isBackedBySimpleArray(this.valueslength);
  }

  @Override
  public boolean isFull() {
    return (this.nbrruns == 1) && (this.getValue(0) == 0) && (this.getLength(0) == 0xFFFF);
  }

  @Override
  public void orInto(long[] bits) {
    for (int r = 0; r < numberOfRuns(); ++r) {
      int start = this.valueslength.get(r << 1);
      int length = this.valueslength.get((r << 1) + 1);
      setBitmapRange(bits, start, start + length + 1);
    }
  }

  @Override
  public void andInto(long[] bits) {
    int prev = 0;
    for (int r = 0; r < numberOfRuns(); ++r) {
      int start = this.valueslength.get(r << 1);
      int length = this.valueslength.get((r << 1) + 1);
      resetBitmapRange(bits, prev, start);
      prev = start + length + 1;
    }
    resetBitmapRange(bits, prev, MAX_CAPACITY);
  }

  @Override
  public void removeFrom(long[] bits) {
    for (int r = 0; r < numberOfRuns(); ++r) {
      int start = this.valueslength.get(r << 1);
      int length = this.valueslength.get((r << 1) + 1);
      resetBitmapRange(bits, start, start + length + 1);
    }
  }

  public static MappeableRunContainer full() {
    return new MappeableRunContainer(0, 1 << 16);
  }

  @Override
  public Iterator<Character> iterator() {
    final CharIterator i = getCharIterator();
    return new Iterator<Character>() {

      @Override
      public boolean hasNext() {
        return i.hasNext();
      }

      @Override
      public Character next() {
        return i.next();
      }

      @Override
      public void remove() {
        i.remove();
      }
    };

  }

  @Override
  public MappeableContainer ixor(MappeableArrayContainer x) {
    return xor(x);
  }


  @Override
  public MappeableContainer ixor(MappeableBitmapContainer x) {
    return xor(x);
  }

  @Override
  public MappeableContainer ixor(MappeableRunContainer x) {
    return xor(x);
  }

  private MappeableRunContainer lazyandNot(MappeableArrayContainer x) {
    if (x.isEmpty()) {
      return this;
    }
    MappeableRunContainer answer =
        new MappeableRunContainer(CharBuffer.allocate(2 * (this.nbrruns + x.cardinality)), 0);
    char[] vl = answer.valueslength.array();
    int rlepos = 0;
    int xrlepos = 0;
    int start = (this.getValue(rlepos));
    int end = start + (this.getLength(rlepos)) + 1;
    int xstart = (x.content.get(xrlepos));
    while ((rlepos < this.nbrruns) && (xrlepos < x.cardinality)) {
      if (end <= xstart) {
        // output the first run
        vl[2 * answer.nbrruns] = (char) start;
        vl[2 * answer.nbrruns + 1] = (char) (end - start - 1);
        answer.nbrruns++;
        rlepos++;
        if (rlepos < this.nbrruns) {
          start = (this.getValue(rlepos));
          end = start + (this.getLength(rlepos)) + 1;
        }
      } else if (xstart + 1 <= start) {
        // exit the second run
        xrlepos++;
        if (xrlepos < x.cardinality) {
          xstart = (x.content.get(xrlepos));
        }
      } else {
        if (start < xstart) {
          vl[2 * answer.nbrruns] = (char) start;
          vl[2 * answer.nbrruns + 1] = (char) (xstart - start - 1);
          answer.nbrruns++;
        }
        if (xstart + 1 < end) {
          start = xstart + 1;
        } else {
          rlepos++;
          if (rlepos < this.nbrruns) {
            start = (this.getValue(rlepos));
            end = start + (this.getLength(rlepos)) + 1;
          }
        }
      }
    }
    if (rlepos < this.nbrruns) {
      vl[2 * answer.nbrruns] = (char) start;
      vl[2 * answer.nbrruns + 1] = (char) (end - start - 1);
      answer.nbrruns++;
      rlepos++;
      for (; rlepos < this.nbrruns; ++rlepos) {
        vl[2 * answer.nbrruns] = this.valueslength.get(2 * rlepos);
        vl[2 * answer.nbrruns + 1] = this.valueslength.get(2 * rlepos + 1);
        answer.nbrruns++;
      }
      // next bit would be faster, but not thread-safe because of the "position"
      // if(rlepos < this.nbrruns) {
      // this.valueslength.position(2 * rlepos);
      // this.valueslength.get(vl, 2 * answer.nbrruns, 2*(this.nbrruns-rlepos ));
      // answer.nbrruns = answer.nbrruns + this.nbrruns - rlepos;
      // }
    }
    return answer;
  }



  protected MappeableContainer lazyor(MappeableArrayContainer x) {
    return lazyorToRun(x);
  }

  private MappeableContainer lazyorToRun(MappeableArrayContainer x) {
    if (isFull()) {
      return full();
    }
    // TODO: should optimize for the frequent case where we have a single run
    MappeableRunContainer answer =
        new MappeableRunContainer(CharBuffer.allocate(2 * (this.nbrruns + x.getCardinality())), 0);
    char[] vl = answer.valueslength.array();
    int rlepos = 0;
    PeekableCharIterator i = x.getCharIterator();

    while ((rlepos < this.nbrruns) && i.hasNext()) {
      if ((getValue(rlepos)) - (i.peekNext()) <= 0) {
        answer.smartAppend(vl, getValue(rlepos), getLength(rlepos));
        // could call i.advanceIfNeeded(minval);
        rlepos++;
      } else {
        answer.smartAppend(vl, i.next());
      }
    }
    if (i.hasNext()) {
      /*
       * if(answer.nbrruns>0) { // this might be useful if the run container has just one very large
       * run int lastval = (answer.getValue(answer.nbrruns - 1)) +
       * (answer.getLength(answer.nbrruns - 1)) + 1;
       * i.advanceIfNeeded((char) lastval); }
       */
      while (i.hasNext()) {
        answer.smartAppend(vl, i.next());
      }
    } else {

      while (rlepos < this.nbrruns) {
        answer.smartAppend(vl, getValue(rlepos), getLength(rlepos));
        rlepos++;
      }
    }
    if (answer.isFull()) {
      return full();
    }
    return answer.convertToLazyBitmapIfNeeded();
  }

  private MappeableContainer lazyxor(MappeableArrayContainer x) {
    if (x.isEmpty()) {
      return this;
    }
    if (this.nbrruns == 0) {
      return x;
    }
    MappeableRunContainer answer =
        new MappeableRunContainer(CharBuffer.allocate(2 * (this.nbrruns + x.getCardinality())), 0);
    char[] vl = answer.valueslength.array();
    int rlepos = 0;
    CharIterator i = x.getCharIterator();
    char cv = i.next();
    while (true) {
      if ((getValue(rlepos)) - (cv) < 0) {
        answer.smartAppendExclusive(vl, getValue(rlepos), getLength(rlepos));
        rlepos++;
        if (rlepos == this.nbrruns) {
          answer.smartAppendExclusive(vl, cv);
          while (i.hasNext()) {
            answer.smartAppendExclusive(vl, i.next());
          }
          break;
        }
      } else {
        answer.smartAppendExclusive(vl, cv);
        if (!i.hasNext()) {
          while (rlepos < this.nbrruns) {
            answer.smartAppendExclusive(vl, getValue(rlepos), getLength(rlepos));
            rlepos++;
          }
          break;
        } else {
          cv = i.next();
        }
      }
    }
    return answer;
  }

  @Override
  public MappeableContainer limit(int maxcardinality) {
    if (maxcardinality >= getCardinality()) {
      return clone();
    }

    int r;
    int cardinality = 0;
    for (r = 0; r < this.nbrruns; ++r) {
      cardinality += (getLength(r)) + 1;
      if (maxcardinality <= cardinality) {
        break;
      }
    }

    CharBuffer newBuf = CharBuffer.allocate(2 * (r + 1));
    for (int i = 0; i < 2 * (r + 1); ++i) {
      newBuf.put(valueslength.get(i)); // could be optimized
    }
    MappeableRunContainer rc = new MappeableRunContainer(newBuf, r + 1);

    rc.setLength(r,
        (char) ((rc.getLength(r)) - cardinality + maxcardinality));
    return rc;
  }

  // not thread-safe
  private void makeRoomAtIndex(int index) {
    if (2 * (nbrruns + 1) > valueslength.capacity()) {
      increaseCapacity();
    }
    copyValuesLength(valueslength, index, valueslength, index + 1, nbrruns - index);
    nbrruns++;
  }

  // To merge values length from begin(inclusive) to end(inclusive)
  private void mergeValuesLength(int begin, int end) {
    if (begin < end) {
      int bValue = (getValue(begin));
      int eValue = (getValue(end));
      int eLength = (getLength(end));
      int newLength = eValue - bValue + eLength;
      setLength(begin, (char) newLength);
      recoverRoomsInRange(begin, end);
    }
  }

  @Override
  public MappeableContainer not(int rangeStart, int rangeEnd) {
    if (rangeEnd <= rangeStart) {
      return this.clone();
    }
    MappeableRunContainer ans = new MappeableRunContainer(nbrruns + 1);
    if (!ans.isArrayBacked()) {
      throw new RuntimeException("internal bug");
    }
    char[] vl = ans.valueslength.array();
    int k = 0;

    if (isArrayBacked()) {
      char[] myVl = valueslength.array();
      for (; k < this.nbrruns && (getValue(myVl, k)) < rangeStart; ++k) {
        vl[2 * k] = myVl[2 * k];
        vl[2 * k + 1] = myVl[2 * k + 1];
        ans.nbrruns++;
      }
      ans.smartAppendExclusive(vl, (char) rangeStart, (char) (rangeEnd - rangeStart - 1));
      for (; k < this.nbrruns; ++k) {
        ans.smartAppendExclusive(vl, getValue(myVl, k), getLength(myVl, k));
      }
    } else { // not array backed

      for (; k < this.nbrruns && (this.getValue(k)) < rangeStart; ++k) {
        vl[2 * k] = getValue(k);
        vl[2 * k + 1] = getLength(k);
        ans.nbrruns++;
      }
      ans.smartAppendExclusive(vl, (char) rangeStart, (char) (rangeEnd - rangeStart - 1));
      for (; k < this.nbrruns; ++k) {
        ans.smartAppendExclusive(vl, getValue(k), getLength(k));
      }
    }
    return ans.toEfficientContainer();
  }

  @Override
  public int numberOfRuns() {
    return this.nbrruns;
  }

  @Override
  public MappeableContainer or(MappeableArrayContainer x) {
    // we guess that, often, the result will still be efficiently expressed as a run container
    return lazyorToRun(x).repairAfterLazy();
  }

  @Override
  public MappeableContainer or(MappeableBitmapContainer x) {
    if (isFull()) {
      return full();
    }
    MappeableBitmapContainer answer = x.clone();
    for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
      int start = (this.getValue(rlepos));
      int end = start + (this.getLength(rlepos)) + 1;
      int prevOnesInRange = answer.cardinalityInRange(start, end);
      BufferUtil.setBitmapRange(answer.bitmap, start, end);
      answer.updateCardinality(prevOnesInRange, end - start);
    }
    if (answer.isFull()) {
      return full();
    }
    return answer;
  }

  @Override
  public MappeableContainer or(MappeableRunContainer x) {
    if (isFull() || x.isFull()) {
      return full(); // cheap case that can save a lot of computation
    }
    // we really ought to optimize the rest of the code for the frequent case where there is a
    // single run
    MappeableRunContainer answer =
        new MappeableRunContainer(CharBuffer.allocate(2 * (this.nbrruns + x.nbrruns)), 0);
    char[] vl = answer.valueslength.array();
    int rlepos = 0;
    int xrlepos = 0;

    while ((rlepos < this.nbrruns) && (xrlepos < x.nbrruns)) {
      if ((getValue(rlepos)) - (x.getValue(xrlepos)) <= 0) {
        answer.smartAppend(vl, getValue(rlepos), getLength(rlepos));
        rlepos++;
      } else {
        answer.smartAppend(vl, x.getValue(xrlepos), x.getLength(xrlepos));
        xrlepos++;
      }
    }
    while (xrlepos < x.nbrruns) {
      answer.smartAppend(vl, x.getValue(xrlepos), x.getLength(xrlepos));
      xrlepos++;
    }
    while (rlepos < this.nbrruns) {
      answer.smartAppend(vl, getValue(rlepos), getLength(rlepos));
      rlepos++;
    }
    if (answer.isFull()) {
      return full();
    }
    return answer.toBitmapIfNeeded();
  }

  // Prepend a value length with all values starting from a given value
  private void prependValueLength(int value, int index) {
    int initialValue = (getValue(index));
    int length = (getLength(index));
    setValue(index, (char) value);
    setLength(index, (char) (initialValue - value + length));
  }

  @Override
  public int rank(char lowbits) {
    int answer = 0;
    for (int k = 0; k < this.nbrruns; ++k) {
      int value = (getValue(k));
      int length = (getLength(k));
      if ((int) (lowbits) < value) {
        return answer;
      } else if (value + length + 1 > (int) (lowbits)) {
        return answer + (int) (lowbits) - value + 1;
      }
      answer += length + 1;
    }
    return answer;
  }

  @Override
  public void readExternal(ObjectInput in) throws IOException {
    // little endian
    this.nbrruns = Character.reverseBytes(in.readChar());
    if (this.valueslength.capacity() < 2 * this.nbrruns) {
      this.valueslength = CharBuffer.allocate(2 * this.nbrruns);
    }
    for (int k = 0; k < 2 * this.nbrruns; ++k) {
      this.valueslength.put(k, Character.reverseBytes(in.readChar()));
    }
  }

  private void recoverRoomAtIndex(int index) {
    copyValuesLength(valueslength, index + 1, valueslength, index, nbrruns - index - 1);
    nbrruns--;
  }

  // To recover rooms between begin(exclusive) and end(inclusive)
  private void recoverRoomsInRange(int begin, int end) {
    if (end + 1 < nbrruns) {
      copyValuesLength(valueslength, end + 1, valueslength, begin + 1, nbrruns - 1 - end);
    }
    nbrruns -= end - begin;
  }

  @Override
  public MappeableContainer remove(int begin, int end) {
    MappeableRunContainer rc = (MappeableRunContainer) clone();
    return rc.iremove(begin, end);
  }

  @Override
  // not thread-safe
  public MappeableContainer remove(char x) {
    int index = bufferedUnsignedInterleavedBinarySearch(valueslength, 0, nbrruns, x);
    if (index >= 0) {
      if (getLength(index) == 0) {
        recoverRoomAtIndex(index);
      } else {
        incrementValue(index);
        decrementLength(index);
      }
      return this;// already there
    }
    index = -index - 2;// points to preceding value, possibly -1
    if (index >= 0) {// possible match
      int offset = (x) - (getValue(index));
      int le = (getLength(index));
      if (offset < le) {
        // need to break in two
        this.setLength(index, (char) (offset - 1));
        // need to insert
        int newvalue = (x) + 1;
        int newlength = le - offset - 1;
        makeRoomAtIndex(index + 1);
        this.setValue(index + 1, (char) newvalue);
        this.setLength(index + 1, (char) newlength);
        return this;
      } else if (offset == le) {
        decrementLength(index);
      }
    }
    // no match
    return this;
  }

  @Override
  public MappeableContainer repairAfterLazy() {
    return toEfficientContainer();
  }

  /**
   * Convert to Array or Bitmap container if the serialized form would be shorter
   */

  @Override
  public MappeableContainer runOptimize() {
    return toEfficientContainer(); // which had the same functionality.
  }

  @Override
  public char select(int j) {
    int offset = 0;
    for (int k = 0; k < this.nbrruns; ++k) {
      int nextOffset = offset + (getLength(k)) + 1;
      if (nextOffset > j) {
        return (char) (getValue(k) + (j - offset));
      }
      offset = nextOffset;
    }
    throw new IllegalArgumentException(
        "Cannot select " + j + " since cardinality is " + getCardinality());
  }

  @Override
  public int serializedSizeInBytes() {
    return serializedSizeInBytes(nbrruns);
  }



  private void setLength(int index, char v) {
    setLength(valueslength, index, v);
  }



  private void setLength(CharBuffer valueslength, int index, char v) {
    valueslength.put(2 * index + 1, v);
  }


  private void setValue(int index, char v) {
    setValue(valueslength, index, v);
  }

  private void setValue(CharBuffer valueslength, int index, char v) {
    valueslength.put(2 * index, v);
  }



  // assume that the (maybe) inplace operations
  // will never actually *be* in place if they are
  // to return ArrayContainer or BitmapContainer

  private void smartAppend(char[] vl, char val) {
    int oldend;
    if ((nbrruns == 0) || (
            (val) > (oldend = (vl[2 * (nbrruns - 1)])
            + (vl[2 * (nbrruns - 1) + 1])) + 1)) { // we add a new one
      vl[2 * nbrruns] = val;
      vl[2 * nbrruns + 1] = 0;
      nbrruns++;
      return;
    }
    if (val == (char) (oldend + 1)) { // we merge
      vl[2 * (nbrruns - 1) + 1]++;
    }
  }

  void smartAppend(char start, char length) {
    int oldend;
    if ((nbrruns == 0) || ((start) > (oldend =
          (getValue(nbrruns - 1)) + (getLength(nbrruns - 1)))
          + 1)) { // we add a new one
      ensureCapacity(nbrruns + 1);
      valueslength.put(2 * nbrruns, start);
      valueslength.put(2 * nbrruns + 1, length);
      nbrruns++;
      return;
    }
    int newend = (start) + (length) + 1;
    if (newend > oldend) { // we merge
      setLength(nbrruns - 1, (char) (newend - 1 - (getValue(nbrruns - 1))));
    }
  }

  private void smartAppend(char[] vl, char start, char length) {
    int oldend;
    if ((nbrruns == 0) || (
            (start) > (oldend = (vl[2 * (nbrruns - 1)])
            + (vl[2 * (nbrruns - 1) + 1])) + 1)) { // we add a new one
      vl[2 * nbrruns] = start;
      vl[2 * nbrruns + 1] = length;
      nbrruns++;
      return;
    }
    int newend = (start) + (length) + 1;
    if (newend > oldend) { // we merge
      vl[2 * (nbrruns - 1) + 1] =
          (char) (newend - 1 - (vl[2 * (nbrruns - 1)]));
    }
  }

  private void smartAppendExclusive(char[] vl, char val) {
    int oldend;
    if ((nbrruns == 0) || (
            (val) > (oldend = (getValue(nbrruns - 1))
            + (getLength(nbrruns - 1)) + 1))) { // we add a new one
      vl[2 * nbrruns] = val;
      vl[2 * nbrruns + 1] = 0;
      nbrruns++;
      return;
    }
    // We have that val <= oldend.
    if (oldend == val) {
      // we merge
      vl[2 * (nbrruns - 1) + 1]++;
      return;
    }
    // We have that val < oldend.

    int newend = val + 1;
    // We have that newend = val + 1 and val < oldend.
    // so newend <= oldend.

    if ((val) == (getValue(nbrruns - 1))) {
      // we wipe out previous
      if (newend != oldend) {
        setValue(nbrruns - 1, (char) newend);
        setLength(nbrruns - 1, (char) (oldend - newend - 1));
        return;
      } else { // they cancel out
        nbrruns--;
        return;
      }
    }
    setLength(nbrruns - 1, (char) (val - (getValue(nbrruns - 1)) - 1));

    if (newend < oldend) {
      setValue(nbrruns, (char) newend);
      setLength(nbrruns, (char) (oldend - newend - 1));
      nbrruns++;
    } // otherwise newend == oldend
  }

  private void smartAppendExclusive(char[] vl, char start, char length) {
    int oldend;
    if ((nbrruns == 0) || (
            start > (oldend = getValue(nbrruns - 1)
            + getLength(nbrruns - 1) + 1))) { // we add a new one
      vl[2 * nbrruns] = start;
      vl[2 * nbrruns + 1] = length;
      nbrruns++;
      return;
    }
    if (oldend == start) {
      // we merge
      vl[2 * (nbrruns - 1) + 1] += length + 1;
      return;
    }

    int newend = start + (length) + 1;

    if (start == getValue(nbrruns - 1)) {
      // we wipe out previous
      if (newend < oldend) {
        setValue(nbrruns - 1, (char) newend);
        setLength(nbrruns - 1, (char) (oldend - newend - 1));
        return;
      } else if (newend > oldend) {
        setValue(nbrruns - 1, (char) oldend);
        setLength(nbrruns - 1, (char) (newend - oldend - 1));
        return;
      } else { // they cancel out
        nbrruns--;
        return;
      }
    }
    setLength(nbrruns - 1, (char) (start - getValue(nbrruns - 1) - 1));

    if (newend < oldend) {
      setValue(nbrruns, (char) newend);
      setLength(nbrruns, (char) (oldend - newend - 1));
      nbrruns++;
    } else if (newend > oldend) {
      setValue(nbrruns, (char) oldend);
      setLength(nbrruns, (char) (newend - oldend - 1));
      nbrruns++;
    }
  }


  // convert to bitmap *if needed* (useful if you know it can't be an array)
  private MappeableContainer toBitmapIfNeeded() {
    int sizeAsRunContainer = MappeableRunContainer.serializedSizeInBytes(this.nbrruns);
    int sizeAsBitmapContainer = MappeableBitmapContainer.serializedSizeInBytes(0);
    if (sizeAsBitmapContainer > sizeAsRunContainer) {
      return this;
    }
    return toBitmapContainer();
  }

  /**
   * Convert the container to either a Bitmap or an Array Container, depending on the cardinality.
   *
   * @param card the current cardinality
   * @return new container
   */
  MappeableContainer toBitmapOrArrayContainer(int card) {
    // int card = this.getCardinality();
    if (card <= MappeableArrayContainer.DEFAULT_MAX_SIZE) {
      MappeableArrayContainer answer = new MappeableArrayContainer(card);
      answer.cardinality = 0;
      for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
        int runStart = (this.getValue(rlepos));
        int runEnd = runStart + (this.getLength(rlepos));

        for (int runValue = runStart; runValue <= runEnd; ++runValue) {
          answer.content.put(answer.cardinality++, (char) runValue);
        }
      }
      return answer;
    }
    MappeableBitmapContainer answer = new MappeableBitmapContainer();
    for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
      int start = (this.getValue(rlepos));
      int end = start + (this.getLength(rlepos)) + 1;
      BufferUtil.setBitmapRange(answer.bitmap, start, end);
    }
    answer.cardinality = card;
    return answer;
  }

  @Override
  public Container toContainer() {
    return new RunContainer(this);
  }


  // convert to bitmap or array *if needed*
  private MappeableContainer toEfficientContainer() {
    int sizeAsRunContainer = MappeableRunContainer.serializedSizeInBytes(this.nbrruns);
    int sizeAsBitmapContainer = MappeableBitmapContainer.serializedSizeInBytes(0);
    int card = this.getCardinality();
    int sizeAsArrayContainer = MappeableArrayContainer.serializedSizeInBytes(card);
    if (sizeAsRunContainer <= Math.min(sizeAsBitmapContainer, sizeAsArrayContainer)) {
      return this;
    }
    if (card <= MappeableArrayContainer.DEFAULT_MAX_SIZE) {
      MappeableArrayContainer answer = new MappeableArrayContainer(card);
      answer.cardinality = 0;
      for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
        int runStart = (this.getValue(rlepos));
        int runEnd = runStart + (this.getLength(rlepos));
        // next bit could potentially be faster, test
        if (BufferUtil.isBackedBySimpleArray(answer.content)) {
          char[] ba = answer.content.array();
          for (int runValue = runStart; runValue <= runEnd; ++runValue) {
            ba[answer.cardinality++] = (char) runValue;
          }
        } else {
          for (int runValue = runStart; runValue <= runEnd; ++runValue) {
            answer.content.put(answer.cardinality++, (char) runValue);
          }
        }
      }
      return answer;
    }
    MappeableBitmapContainer answer = new MappeableBitmapContainer();
    for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
      int start = (this.getValue(rlepos));
      int end = start + (this.getLength(rlepos)) + 1;
      BufferUtil.setBitmapRange(answer.bitmap, start, end);
    }
    answer.cardinality = card;
    return answer;
  }

  /**
   * Create a copy of the content of this container as a char array. This creates a copy.
   *
   * @return copy of the content as a char array
   */
  public char[] toCharArray() {
    char[] answer = new char[2 * nbrruns];
    valueslength.rewind();
    valueslength.get(answer);
    return answer;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    for (int k = 0; k < this.nbrruns; ++k) {
      sb.append("[");
      sb.append((int)(this.getValue(k)));
      sb.append(",");
      sb.append((this.getValue(k))
          + (this.getLength(k)));
      sb.append("]");
    }
    return sb.toString();
  }

  @Override
  public void trim() {
    if (valueslength.limit() == 2 * nbrruns) {
      return;
    }
    if (BufferUtil.isBackedBySimpleArray(valueslength)) {
      this.valueslength = CharBuffer.wrap(Arrays.copyOf(valueslength.array(), 2 * nbrruns));
    } else {

      final CharBuffer co = CharBuffer.allocate(2 * nbrruns);
      char[] a = co.array();
      for (int k = 0; k < 2 * nbrruns; ++k) {
        a[k] = this.valueslength.get(k);
      }
      this.valueslength = co;
    }
  }

  // To check if a value length contains a given value
  private boolean valueLengthContains(int value, int index) {
    int initialValue = (getValue(index));
    int length = (getLength(index));

    return value <= initialValue + length;
  }

  @Override
  protected void writeArray(DataOutput out) throws IOException {
    out.writeShort(Character.reverseBytes((char) this.nbrruns));
    for (int k = 0; k < 2 * this.nbrruns; ++k) {
      out.writeShort(Character.reverseBytes(this.valueslength.get(k)));
    }
  }

  @Override
  protected void writeArray(ByteBuffer buffer) {
    assert buffer.order() == LITTLE_ENDIAN;
    CharBuffer source = valueslength.duplicate();
    source.position(0);
    source.limit(nbrruns * 2);
    CharBuffer target = buffer.asCharBuffer();
    target.put((char)nbrruns);
    target.put(source);
    int bytesWritten = (nbrruns * 2 + 1) * 2;
    buffer.position(buffer.position() + bytesWritten);
  }

  @Override
  public void writeExternal(ObjectOutput out) throws IOException {
    out.writeShort(Character.reverseBytes((char) this.nbrruns));
    for (int k = 0; k < 2 * this.nbrruns; ++k) {
      out.writeShort(Character.reverseBytes(this.valueslength.get(k)));
    }
  }

  @Override
  public MappeableContainer xor(MappeableArrayContainer x) {
    // if the cardinality of the array is small, guess that the output will still be a run container
    final int arbitrary_threshold = 32; // 32 is arbitrary here
    if (x.getCardinality() < arbitrary_threshold) {
      return lazyxor(x).repairAfterLazy();
    }
    // otherwise, we expect the output to be either an array or bitmap
    final int card = getCardinality();
    if (card <= MappeableArrayContainer.DEFAULT_MAX_SIZE) {
      // if the cardinality is small, we construct the solution in place
      return x.xor(this.getCharIterator());
    }
    // otherwise, we generate a bitmap
    return toBitmapOrArrayContainer(card).ixor(x);
  }

  @Override
  public MappeableContainer xor(MappeableBitmapContainer x) {
    MappeableBitmapContainer answer = x.clone();
    for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
      int start = (this.getValue(rlepos));
      int end = start + (this.getLength(rlepos)) + 1;
      int prevOnes = answer.cardinalityInRange(start, end);
      BufferUtil.flipBitmapRange(answer.bitmap, start, end);
      answer.updateCardinality(prevOnes, end - start - prevOnes);
    }
    if (answer.getCardinality() > MappeableArrayContainer.DEFAULT_MAX_SIZE) {
      return answer;
    } else {
      return answer.toArrayContainer();
    }
  }

  @Override
  public MappeableContainer xor(MappeableRunContainer x) {
    if (x.nbrruns == 0) {
      return this.clone();
    }
    if (this.nbrruns == 0) {
      return x.clone();
    }
    MappeableRunContainer answer =
        new MappeableRunContainer(CharBuffer.allocate(2 * (this.nbrruns + x.nbrruns)), 0);
    char[] vl = answer.valueslength.array();
    int rlepos = 0;
    int xrlepos = 0;

    while (true) {
      if ((getValue(rlepos)) - (x.getValue(xrlepos)) < 0) {
        answer.smartAppendExclusive(vl, getValue(rlepos), getLength(rlepos));
        rlepos++;
        if (rlepos == this.nbrruns) {
          while (xrlepos < x.nbrruns) {
            answer.smartAppendExclusive(vl, x.getValue(xrlepos), x.getLength(xrlepos));
            xrlepos++;
          }
          break;
        }
      } else {
        answer.smartAppendExclusive(vl, x.getValue(xrlepos), x.getLength(xrlepos));
        xrlepos++;
        if (xrlepos == x.nbrruns) {
          while (rlepos < this.nbrruns) {
            answer.smartAppendExclusive(vl, getValue(rlepos), getLength(rlepos));
            rlepos++;
          }
          break;
        }
      }
    }
    return answer.toEfficientContainer();
  }


  @Override
  public void forEach(char msb, IntConsumer ic) {
    int high = ((int)msb) << 16;
    for(int k = 0; k < this.nbrruns; ++k) {
      int base = (this.getValue(k) & 0xFFFF) | high;
      int le = this.getLength(k) & 0xFFFF;
      for(int l = base; l - le <= base; ++l) {
        ic.accept(l);
      }
    }
  }



  @Override
  public int andCardinality(MappeableArrayContainer x) {
    if (this.nbrruns == 0) {
      return 0;
    }
    int rlepos = 0;
    int arraypos = 0;
    int andCardinality = 0;
    int rleval = (this.getValue(rlepos));
    int rlelength = (this.getLength(rlepos));
    while (arraypos < x.cardinality) {
      int arrayval = (x.content.get(arraypos));
      while (rleval + rlelength < arrayval) {// this will frequently be false
        ++rlepos;
        if (rlepos == this.nbrruns) {
          return andCardinality;// we are done
        }
        rleval = (this.getValue(rlepos));
        rlelength = (this.getLength(rlepos));
      }
      if (rleval > arrayval) {
        arraypos = BufferUtil.advanceUntil(x.content, arraypos,
            x.cardinality, this.getValue(rlepos));
      } else {
        andCardinality++;
        arraypos++;
      }
    }
    return andCardinality;
  }


  @Override
  public int andCardinality(MappeableBitmapContainer x) {
    // could be implemented as return toBitmapOrArrayContainer().iand(x);
    int cardinality = 0;
    for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
      int runStart = this.getValue(rlepos);
      int runEnd = runStart + this.getLength(rlepos);
      cardinality += x.cardinalityInRange(runStart, runEnd + 1);
    }
    return cardinality;
  }

  @Override
  public int andCardinality(MappeableRunContainer x) {
    int cardinality = 0;
    int rlepos = 0;
    int xrlepos = 0;
    int start = (this.getValue(rlepos));
    int end = start + (this.getLength(rlepos)) + 1;
    int xstart = (x.getValue(xrlepos));
    int xend = xstart + (x.getLength(xrlepos)) + 1;
    while ((rlepos < this.nbrruns) && (xrlepos < x.nbrruns)) {
      if (end <= xstart) {
        ++rlepos;
        if (rlepos < this.nbrruns) {
          start = (this.getValue(rlepos));
          end = start + (this.getLength(rlepos)) + 1;
        }
      } else if (xend <= start) {
        ++xrlepos;

        if (xrlepos < x.nbrruns) {
          xstart = (x.getValue(xrlepos));
          xend = xstart + (x.getLength(xrlepos)) + 1;
        }
      } else {// they overlap
        final int lateststart = Math.max(start, xstart);
        int earliestend;
        if (end == xend) {// improbable
          earliestend = end;
          rlepos++;
          xrlepos++;
          if (rlepos < this.nbrruns) {
            start = (this.getValue(rlepos));
            end = start + (this.getLength(rlepos)) + 1;
          }
          if (xrlepos < x.nbrruns) {
            xstart = (x.getValue(xrlepos));
            xend = xstart + (x.getLength(xrlepos)) + 1;
          }
        } else if (end < xend) {
          earliestend = end;
          rlepos++;
          if (rlepos < this.nbrruns) {
            start = (this.getValue(rlepos));
            end = start + (this.getLength(rlepos)) + 1;
          }

        } else {// end > xend
          earliestend = xend;
          xrlepos++;
          if (xrlepos < x.nbrruns) {
            xstart = (x.getValue(xrlepos));
            xend = xstart + (x.getLength(xrlepos)) + 1;
          }
        }
        // earliestend - lateststart are all values that are true.
        cardinality += earliestend - lateststart;
      }
    }
    return cardinality;
  }


  @Override
  public MappeableBitmapContainer toBitmapContainer() {
    int card = this.getCardinality();
    MappeableBitmapContainer answer = new MappeableBitmapContainer();
    for (int rlepos = 0; rlepos < this.nbrruns; ++rlepos) {
      int start = (this.getValue(rlepos));
      int end = start + (this.getLength(rlepos)) + 1;
      BufferUtil.setBitmapRange(answer.bitmap, start, end);
    }
    answer.cardinality = card;
    return answer;
  }

  @Override
  public int first() {
    assertNonEmpty(numberOfRuns() == 0);
    return (getValue(0));
  }

  @Override
  public int last() {
    assertNonEmpty(numberOfRuns() == 0);
    int index = numberOfRuns() - 1;
    int start = (getValue(index));
    int length = (getLength(index));
    return start + length;
  }

  @Override
  public int nextValue(char fromValue) {
    int index = bufferedUnsignedInterleavedBinarySearch(valueslength, 0, nbrruns, fromValue);
    int effectiveIndex = index >= 0 ? index : -index - 2;
    if (effectiveIndex == -1) {
      return first();
    }
    int startValue = (getValue(effectiveIndex));
    int offset = (int) (fromValue) - startValue;
    int le = (getLength(effectiveIndex));
    if (offset <= le) {
      return fromValue;
    }
    if (effectiveIndex + 1 < numberOfRuns()) {
      return (getValue(effectiveIndex + 1));
    }
    return -1;
  }

  @Override
  public int previousValue(char fromValue) {
    int index = bufferedUnsignedInterleavedBinarySearch(valueslength, 0, nbrruns, fromValue);
    int effectiveIndex = index >= 0 ? index : -index - 2;
    if (effectiveIndex == -1) {
      return -1;
    }
    int startValue = (getValue(effectiveIndex));
    int offset = (int) (fromValue) - startValue;
    int le = (getLength(effectiveIndex));
    if (offset >= 0 && offset <= le) {
      return fromValue;
    }
    return startValue + le;
  }

  @Override
  public int nextAbsentValue(char fromValue) {
    int index = bufferedUnsignedInterleavedBinarySearch(valueslength, 0, nbrruns, fromValue);
    int effectiveIndex = index >= 0 ? index : -index - 2;
    if (effectiveIndex == -1) {
      return (fromValue);
    }
    int startValue = (getValue(effectiveIndex));
    int offset = (int) (fromValue) - startValue;
    int le = (getLength(effectiveIndex));
    return offset <= le ? startValue + le + 1 : (int) (fromValue);
  }

  @Override
  public int previousAbsentValue(char fromValue) {
    int index = bufferedUnsignedInterleavedBinarySearch(valueslength, 0, nbrruns, fromValue);
    int effectiveIndex = index >= 0 ? index : -index - 2;
    if (effectiveIndex == -1) {
      return (fromValue);
    }
    int startValue = (getValue(effectiveIndex));
    int offset = (int) (fromValue) - startValue;
    int le = (getLength(effectiveIndex));
    return offset <= le ? startValue - 1 : (int) (fromValue);
  }

  @Override
  protected boolean contains(MappeableRunContainer runContainer) {
    int i1 = 0, i2 = 0;
    while(i1 < numberOfRuns() && i2 < runContainer.numberOfRuns()) {
      int start1 = (getValue(i1));
      int stop1 = start1 + (getLength(i1));
      int start2 = (runContainer.getValue(i2));
      int stop2 = start2 + (runContainer.getLength(i2));
      if(start1 > start2) {
        return false;
      } else {
        if(stop1 > stop2) {
          i2++;
        } else if(stop1 == stop2) {
          i1++;
          i2++;
        } else {
          i1++;
        }
      }
    }
    return i2 == runContainer.numberOfRuns();
  }

  @Override
  protected boolean contains(MappeableArrayContainer arrayContainer) {
    final int cardinality = getCardinality();
    final int runCount = numberOfRuns();
    if (arrayContainer.getCardinality() > cardinality) {
      return false;
    }
    int ia = 0, ir = 0;
    while(ia < arrayContainer.getCardinality() && ir < runCount) {
      int start = (getValue(ir));
      int stop = start + (getLength(ir));
      int value = (arrayContainer.content.get(ia));
      if(value < start) {
        return false;
      } else if (value > stop) {
        ++ir;
      } else {
        ++ia;
      }
    }
    return ia == arrayContainer.getCardinality();
  }

  @Override
  protected boolean contains(MappeableBitmapContainer bitmapContainer) {
    final int cardinality = getCardinality();
    if (bitmapContainer.getCardinality() != -1 && bitmapContainer.getCardinality() > cardinality) {
      return false;
    }
    final int runCount = numberOfRuns();
    char ib = 0, ir = 0;
    while(ib < MappeableBitmapContainer.MAX_CAPACITY / 64 && ir < runCount) {
      long w = bitmapContainer.bitmap.get(ib);
      while (w != 0 && ir < runCount) {
        int start = (getValue(ir));
        int stop = start+ (getLength(ir));
        long t = w & -w;
        long r = ib * 64 + Long.numberOfTrailingZeros(w);
        if (r < start) {
          return false;
        } else if(r > stop) {
          ++ir;
        } else {
          w ^= t;
        }
      }
      if(w == 0) {
        ++ib;
      } else {
        return false;
      }
    }
    if(ib < MappeableBitmapContainer.MAX_CAPACITY / 64) {
      for(; ib < MappeableBitmapContainer.MAX_CAPACITY / 64 ; ib++) {
        if(bitmapContainer.bitmap.get(ib) != 0) {
          return false;
        }
      }
    }
    return true;
  }

  @Override
  public boolean intersects(int minimum, int supremum) {
    if((minimum < 0) || (supremum < minimum) || (supremum > (1<<16))) {
      throw new RuntimeException("This should never happen (bug).");
    }
    for (int i = 0; i < numberOfRuns(); ++i) {
      char runFirstValue = getValue(i);
      char runLastValue = (char) (runFirstValue + getLength(i));

      if ((runFirstValue) < supremum
          && (runLastValue) - ((char) minimum) >= 0){
        return true;
      }
    }
    return false;
  }

  @Override
  public boolean contains(int minimum, int supremum) {
    for (int i = 0; i < numberOfRuns(); ++i) {
      int start = getValue(i);
      int length = getLength(i);
      int stop = start + length + 1;
      if (start >= supremum) {
        break;
      }
      if (minimum >= start && supremum <= stop) {
        return true;
      }
    }
    return false;
  }


}


final class MappeableRunContainerCharIterator implements PeekableCharIterator {
  private int pos;
  private int le = 0;
  private int maxlength;
  private int base;

  private MappeableRunContainer parent;

  MappeableRunContainerCharIterator() {

  }

  MappeableRunContainerCharIterator(MappeableRunContainer p) {
    wrap(p);
  }

  @Override
  public PeekableCharIterator clone() {
    try {
      return (PeekableCharIterator) super.clone();
    } catch (CloneNotSupportedException e) {
      return null;// will not happen
    }
  }

  @Override
  public boolean hasNext() {
    return pos < parent.nbrruns;
  }

  @Override
  public char next() {
    char ans = (char) (base + le);
    le++;
    if (le > maxlength) {
      pos++;
      le = 0;
      if (pos < parent.nbrruns) {
        maxlength = parent.getLength(pos);
        base = parent.getValue(pos);
      }
    }
    return ans;
  }

  @Override
  public int nextAsInt() {
    int ans = base + le;
    le++;
    if (le > maxlength) {
      pos++;
      le = 0;
      if (pos < parent.nbrruns) {
        maxlength = parent.getLength(pos);
        base = parent.getValue(pos);
      }
    }
    return ans;
  }

  @Override
  public void remove() {
    throw new RuntimeException("Not implemented");// TODO
  }

  void wrap(MappeableRunContainer p) {
    parent = p;
    pos = 0;
    le = 0;
    if (pos < parent.nbrruns) {
      maxlength = parent.getLength(pos);
      base = parent.getValue(pos);
    }
  }

  @Override
  public void advanceIfNeeded(char minval) {
    while (base + maxlength < (minval)) {
      pos++;
      le = 0;
      if (pos < parent.nbrruns) {
        maxlength = parent.getLength(pos);
        base = parent.getValue(pos);
      } else {
        return;
      }
    }
    if (base > (minval)) {
      return;
    }
    le = minval - base;
  }

  @Override
  public char peekNext() {
    return (char) (base + le);
  }

}


final class RawMappeableRunContainerCharIterator implements PeekableCharIterator {
  private int pos;
  private int le = 0;
  private int maxlength;
  private int base;

  private MappeableRunContainer parent;
  private char[] vl;


  RawMappeableRunContainerCharIterator(MappeableRunContainer p) {
    wrap(p);
  }

  @Override
  public PeekableCharIterator clone() {
    try {
      return (PeekableCharIterator) super.clone();
    } catch (CloneNotSupportedException e) {
      return null;// will not happen
    }
  }

  private char getLength(int index) {
    return vl[2 * index + 1];
  }

  private char getValue(int index) {
    return vl[2 * index];
  }

  @Override
  public boolean hasNext() {
    return pos < parent.nbrruns;
  }

  @Override
  public char next() {
    char ans = (char) (base + le);
    le++;
    if (le > maxlength) {
      pos++;
      le = 0;
      if (pos < parent.nbrruns) {
        maxlength = getLength(pos);
        base = getValue(pos);
      }
    }
    return ans;
  }


  @Override
  public int nextAsInt() {
    int ans = base + le;
    le++;
    if (le > maxlength) {
      pos++;
      le = 0;
      if (pos < parent.nbrruns) {
        maxlength = getLength(pos);
        base = getValue(pos);
      }
    }
    return ans;
  }

  @Override
  public void remove() {
    throw new RuntimeException("Not implemented");// TODO
  }

  private void wrap(MappeableRunContainer p) {
    parent = p;
    if (!parent.isArrayBacked()) {
      throw new RuntimeException("internal error");
    }
    vl = parent.valueslength.array();
    pos = 0;
    le = 0;
    if (pos < parent.nbrruns) {
      maxlength = getLength(pos);
      base = getValue(pos);
    }
  }

  @Override
  public void advanceIfNeeded(char minval) {
    while (base + maxlength < minval) {
      pos++;
      le = 0;
      if (pos < parent.nbrruns) {
        maxlength = parent.getLength(pos);
        base = parent.getValue(pos);
      } else {
        return;
      }
    }
    if (base > (minval)) {
      return;
    }
    le = (minval) - base;
  }

  @Override
  public char peekNext() {
    return (char) (base + le);
  }

}


final class RawReverseMappeableRunContainerCharIterator implements CharIterator {
  private int pos;
  private int le;
  private int maxlength;
  private int base;
  private char[] vl;



  RawReverseMappeableRunContainerCharIterator(MappeableRunContainer p) {
    wrap(p);
  }

  @Override
  public CharIterator clone() {
    try {
      return (CharIterator) super.clone();
    } catch (CloneNotSupportedException e) {
      return null;// will not happen
    }
  }

  private char getLength(int index) {
    return vl[2 * index + 1];
  }

  private char getValue(int index) {
    return vl[2 * index];
  }

  @Override
  public boolean hasNext() {
    return pos >= 0;
  }

  @Override
  public char next() {
    char ans = (char) (base + maxlength - le);
    le++;
    if (le > maxlength) {
      pos--;
      le = 0;
      if (pos >= 0) {
        maxlength = getLength(pos);
        base = getValue(pos);
      }
    }
    return ans;
  }

  @Override
  public int nextAsInt() {
    int ans = base + maxlength - le;
    le++;
    if (le > maxlength) {
      pos--;
      le = 0;
      if (pos >= 0) {
        maxlength = getLength(pos);
        base = getValue(pos);
      }
    }
    return ans;
  }

  @Override
  public void remove() {
    throw new RuntimeException("Not implemented");// TODO
  }

  private void wrap(MappeableRunContainer p) {
    MappeableRunContainer parent = p;
    if (!parent.isArrayBacked()) {
      throw new RuntimeException("internal error");
    }
    vl = parent.valueslength.array();
    pos = parent.nbrruns - 1;
    le = 0;
    if (pos >= 0) {
      maxlength = getLength(pos);
      base = getValue(pos);
    }
  }

}


final class ReverseMappeableRunContainerCharIterator implements CharIterator {
  private int pos;
  private int le;
  private int maxlength;
  private int base;
  private MappeableRunContainer parent;


  ReverseMappeableRunContainerCharIterator() {

  }

  ReverseMappeableRunContainerCharIterator(MappeableRunContainer p) {
    wrap(p);
  }

  @Override
  public CharIterator clone() {
    try {
      return (CharIterator) super.clone();
    } catch (CloneNotSupportedException e) {
      return null;// will not happen
    }
  }

  @Override
  public boolean hasNext() {
    return pos >= 0;
  }

  @Override
  public char next() {
    char ans = (char) (base + maxlength - le);
    le++;
    if (le > maxlength) {
      pos--;
      le = 0;
      if (pos >= 0) {
        maxlength = parent.getLength(pos);
        base = parent.getValue(pos);
      }
    }
    return ans;
  }

  @Override
  public int nextAsInt() {
    int ans = base + maxlength - le;
    le++;
    if (le > maxlength) {
      pos--;
      le = 0;
      if (pos >= 0) {
        maxlength = parent.getLength(pos);
        base = parent.getValue(pos);
      }
    }
    return ans;
  }

  @Override
  public void remove() {
    throw new RuntimeException("Not implemented");// TODO
  }

  void wrap(MappeableRunContainer p) {
    parent = p;
    pos = parent.nbrruns - 1;
    le = 0;
    if (pos >= 0) {
      maxlength = parent.getLength(pos);
      base = parent.getValue(pos);
    }
  }

}

---------
>> The unit tests are:
>>> file_path: ../RoaringBitmap/RoaringBitmap/src/test/java/org/roaringbitmap/TestRunContainer.java
package org.roaringbitmap;

import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.parallel.Execution;
import org.junit.jupiter.api.parallel.ExecutionMode;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.roaringbitmap.ArrayContainer.DEFAULT_MAX_SIZE;
import static org.roaringbitmap.ValidationRangeConsumer.Value.ABSENT;
import static org.roaringbitmap.ValidationRangeConsumer.Value.PRESENT;

@Execution(ExecutionMode.CONCURRENT)
public class TestRunContainer {
  @Test
  public void testRunOpti() {
    RoaringBitmap mrb = new RoaringBitmap();
    for(int r = 0; r< 100000; r+=3 ) {
      mrb.add(r);
    }
    mrb.add(1000000);
    for(int r = 2000000; r < 3000000; ++r) {
      mrb.add(r);
    }
    RoaringBitmap m2 = mrb.clone();
    m2.runOptimize();
    IntIterator x = m2.getReverseIntIterator();
    int count = 0;
    while(x.hasNext()) {
      x.next();
      count++;
    }
    assertEquals(m2.getCardinality(), count);
    assertEquals(mrb.getCardinality(), count);
    assertTrue(m2.serializedSizeInBytes() < mrb.serializedSizeInBytes());
    assertEquals(m2, mrb);
  }

  public static Container fillMeUp(Container c, int[] values) {
    if (values.length == 0) {
      throw new RuntimeException("You are trying to create an empty bitmap! ");
    }
    for (int k = 0; k < values.length; ++k) {
      c = c.add((char) values[k]);
    }
    if (c.getCardinality() != values.length) {
      throw new RuntimeException("add failure");
    }
    return c;
  }

  /**
   * generates randomly N distinct integers from 0 to Max.
   */
  static int[] generateUniformHash(Random rand, int N, int Max) {

    if (N > Max) {
      throw new RuntimeException("not possible");
    }
    if (N > Max / 2) {
      return negate(generateUniformHash(rand, Max - N, Max), Max);
    }
    int[] ans = new int[N];
    HashSet<Integer> s = new HashSet<Integer>();
    while (s.size() < N) {
      s.add(new Integer(rand.nextInt(Max)));
    }
    Iterator<Integer> i = s.iterator();
    for (int k = 0; k < N; ++k) {
      ans[k] = i.next().intValue();
    }
    Arrays.sort(ans);
    return ans;
  }

  private static void getSetOfRunContainers(ArrayList<RunContainer> set,
      ArrayList<Container> setb) {
    RunContainer r1 = new RunContainer();
    r1 = (RunContainer) r1.iadd(0, (1 << 16));
    Container b1 = new ArrayContainer();
    b1 = b1.iadd(0, 1 << 16);
    assertEquals(r1, b1);

    set.add(r1);
    setb.add(b1);

    RunContainer r2 = new RunContainer();
    r2 = (RunContainer) r2.iadd(0, 4096);
    Container b2 = new ArrayContainer();
    b2 = b2.iadd(0, 4096);
    set.add(r2);
    setb.add(b2);
    assertEquals(r2, b2);

    RunContainer r3 = new RunContainer();
    Container b3 = new ArrayContainer();

    // mayhaps some of the 655536s were intended to be 65536s?? And later...
    for (int k = 0; k < 655536; k += 2) {
      r3 = (RunContainer) r3.add((char) k);
      b3 = b3.add((char) k);
    }
    assertEquals(r3, b3);
    set.add(r3);
    setb.add(b3);

    RunContainer r4 = new RunContainer();
    Container b4 = new ArrayContainer();
    for (int k = 0; k < 655536; k += 256) {
      r4 = (RunContainer) r4.add((char) k);
      b4 = b4.add((char) k);
    }
    assertEquals(r4, b4);
    set.add(r4);
    setb.add(b4);

    RunContainer r5 = new RunContainer();
    Container b5 = new ArrayContainer();
    for (int k = 0; k + 4096 < 65536; k += 4096) {
      r5 = (RunContainer) r5.iadd(k, k + 256);
      b5 = b5.iadd(k, k + 256);
    }
    assertEquals(r5, b5);
    set.add(r5);
    setb.add(b5);

    RunContainer r6 = new RunContainer();
    Container b6 = new ArrayContainer();
    for (int k = 0; k + 1 < 65536; k += 7) {
      r6 = (RunContainer) r6.iadd(k, k + 1);
      b6 = b6.iadd(k, k + 1);
    }
    assertEquals(r6, b6);
    set.add(r6);
    setb.add(b6);


    RunContainer r7 = new RunContainer();
    Container b7 = new ArrayContainer();
    for (int k = 0; k + 1 < 65536; k += 11) {
      r7 = (RunContainer) r7.iadd(k, k + 1);
      b7 = b7.iadd(k, k + 1);
    }
    assertEquals(r7, b7);
    set.add(r7);
    setb.add(b7);

  }

  /**
   * output all integers from the range [0,Max) that are not in the array
   */
  static int[] negate(int[] x, int Max) {
    int[] ans = new int[Max - x.length];
    int i = 0;
    int c = 0;
    for (int j = 0; j < x.length; ++j) {
      int v = x[j];
      for (; i < v; ++i) {
        ans[c++] = i;
      }
      ++i;
    }
    while (c < ans.length) {
      ans[c++] = i++;
    }
    return ans;
  }

  @Test
  public void addAndCompress() {
    RunContainer container = new RunContainer();
    container.add((char) 0);
    container.add((char) 99);
    container.add((char) 98);
    assertEquals(12, container.getSizeInBytes());
  }

  @Test
  public void addOutOfOrder() {
    RunContainer container = new RunContainer();
    container.add((char) 0);
    container.add((char) 2);
    container.add((char) 55);
    container.add((char) 1);
    assertEquals(4, container.getCardinality());
    assertTrue(container.contains((char) 0));
    assertTrue(container.contains((char) 1));
    assertTrue(container.contains((char) 2));
    assertTrue(container.contains((char) 55));
  }

  @Test
  public void addRange() {
    for (int i = 0; i < 100; ++i) {
      for (int j = 0; j < 100; ++j) {
        for (int k = 0; k < 50; ++k) {
          BitSet bs = new BitSet();
          RunContainer container = new RunContainer();
          for (int p = 0; p < i; ++p) {
            container.add((char) p);
            bs.set(p);
          }
          for (int p = 0; p < j; ++p) {
            container.add((char) (99 - p));
            bs.set(99 - p);
          }
          Container newContainer = container.add(49 - k, 50 + k);
          bs.set(49 - k, 50 + k);
          assertNotSame(container, newContainer);
          assertEquals(bs.cardinality(), newContainer.getCardinality());

          int nb_runs = 1;
          int lastIndex = bs.nextSetBit(0);
          for (int p = bs.nextSetBit(0); p >= 0; p = bs.nextSetBit(p + 1)) {
            if (p - lastIndex > 1) {
              nb_runs++;
            }
            lastIndex = p;
            assertTrue(newContainer.contains((char) p));
          }
          assertEquals(nb_runs * 4 + 4, newContainer.getSizeInBytes());
        }
      }
    }
  }

  @Test
  public void addRangeAndFuseWithNextValueLength() {
    RunContainer container = new RunContainer();
    for (char i = 10; i < 20; ++i) {
      container.add(i);
    }
    for (char i = 21; i < 30; ++i) {
      container.add(i);
    }
    Container newContainer = container.add(15, 21);
    assertNotSame(container, newContainer);
    assertEquals(20, newContainer.getCardinality());
    for (char i = 10; i < 30; ++i) {
      assertTrue(newContainer.contains(i));
    }
    assertEquals(8, newContainer.getSizeInBytes());
  }

  @Test
  public void addRangeAndFuseWithPreviousValueLength() {
    RunContainer container = new RunContainer();
    for (char i = 10; i < 20; ++i) {
      container.add(i);
    }
    Container newContainer = container.add(20, 30);
    assertNotSame(container, newContainer);
    assertEquals(20, newContainer.getCardinality());
    for (char i = 10; i < 30; ++i) {
      assertTrue(newContainer.contains(i));
    }
    assertEquals(8, newContainer.getSizeInBytes());
  }

  @Test
  public void addRangeOnEmptyContainer() {
    RunContainer container = new RunContainer();
    Container newContainer = container.add(10, 100);
    assertNotSame(container, newContainer);
    assertEquals(90, newContainer.getCardinality());
    for (char i = 10; i < 100; ++i) {
      assertTrue(newContainer.contains(i));
    }
  }

  @Test
  public void addRangeOnNonEmptyContainer() {
    RunContainer container = new RunContainer();
    container.add((char) 1);
    container.add((char) 256);
    Container newContainer = container.add(10, 100);
    assertNotSame(container, newContainer);
    assertEquals(92, newContainer.getCardinality());
    assertTrue(newContainer.contains((char) 1));
    assertTrue(newContainer.contains((char) 256));
    for (char i = 10; i < 100; ++i) {
      assertTrue(newContainer.contains(i));
    }
  }

  @Test
  public void addRangeOnNonEmptyContainerAndFuse() {
    RunContainer container = new RunContainer();
    for (char i = 1; i < 20; ++i) {
      container.add(i);
    }
    for (char i = 90; i < 120; ++i) {
      container.add(i);
    }
    Container newContainer = container.add(10, 100);
    assertNotSame(container, newContainer);
    assertEquals(119, newContainer.getCardinality());
    for (char i = 1; i < 120; ++i) {
      assertTrue(newContainer.contains(i));
    }
  }

  @Test
  public void addRangeWithinSetBounds() {
    RunContainer container = new RunContainer();
    container.add((char) 10);
    container.add((char) 99);
    Container newContainer = container.add(10, 100);
    assertNotSame(container, newContainer);
    assertEquals(90, newContainer.getCardinality());
    for (char i = 10; i < 100; ++i) {
      assertTrue(newContainer.contains(i));
    }
  }

  @Test
  public void addRangeWithinSetBoundsAndFuse() {
    RunContainer container = new RunContainer();
    container.add((char) 1);
    container.add((char) 10);
    container.add((char) 55);
    container.add((char) 99);
    container.add((char) 150);
    Container newContainer = container.add(10, 100);
    assertNotSame(container, newContainer);
    assertEquals(92, newContainer.getCardinality());
    for (char i = 10; i < 100; ++i) {
      assertTrue(newContainer.contains(i));
    }
  }

  @Test
  public void andNot() {
    Container bc = new BitmapContainer();
    Container rc = new RunContainer();
    for (int k = 0; k < 2 * DEFAULT_MAX_SIZE; ++k) {
      bc = bc.add((char) (k * 10));
      rc = rc.add((char) (k * 10 + 3));
    }
    Container result = rc.andNot(bc);
    assertEquals(rc, result);
  }

  @Test
  public void andNot1() {
    Container bc = new BitmapContainer();
    Container rc = new RunContainer();
    rc.add((char) 1);
    Container result = rc.andNot(bc);
    assertEquals(1, result.getCardinality());
    assertTrue(result.contains((char) 1));
  }

  @Test
  public void andNot2() {
    Container bc = new BitmapContainer();
    Container rc = new RunContainer();
    bc.add((char) 1);
    Container result = rc.andNot(bc);
    assertEquals(0, result.getCardinality());
  }

  @Test
  public void andNotTest1() {
    // this test uses a bitmap container that will be too sparse- okay?
    Container bc = new BitmapContainer();
    Container rc = new RunContainer();
    for (int k = 0; k < 100; ++k) {
      bc = bc.add((char) (k * 10));
      bc = bc.add((char) (k * 10 + 3));

      rc = rc.add((char) (k * 10 + 5));
      rc = rc.add((char) (k * 10 + 3));
    }
    Container intersectionNOT = rc.andNot(bc);
    assertEquals(100, intersectionNOT.getCardinality());
    for (int k = 0; k < 100; ++k) {
      assertTrue(intersectionNOT.contains((char) (k * 10 + 5)), " missing k=" + k);
    }
    assertEquals(200, bc.getCardinality());
    assertEquals(200, rc.getCardinality());
  }

  @Test
  public void andNotTest2() {
    System.out.println("andNotTest2");
    Container ac = new ArrayContainer();
    Container rc = new RunContainer();
    for (int k = 0; k < 100; ++k) {
      ac = ac.add((char) (k * 10));
      ac = ac.add((char) (k * 10 + 3));

      rc = rc.add((char) (k * 10 + 5));
      rc = rc.add((char) (k * 10 + 3));
    }
    Container intersectionNOT = rc.andNot(ac);
    assertEquals(100, intersectionNOT.getCardinality());
    for (int k = 0; k < 100; ++k) {
      assertTrue(intersectionNOT.contains((char) (k * 10 + 5)), " missing k=" + k);
    }
    assertEquals(200, ac.getCardinality());
    assertEquals(200, rc.getCardinality());
  }

  @Test
  public void basic() {
    RunContainer x = new RunContainer();
    for (int k = 0; k < (1 << 16); ++k) {
      assertFalse(x.contains((char) k));
    }
    for (int k = 0; k < (1 << 16); ++k) {
      assertFalse(x.contains((char) k));
      x = (RunContainer) x.add((char) k);
      assertEquals(k + 1, x.getCardinality());
      assertTrue(x.contains((char) k));
    }
    for (int k = 0; k < (1 << 16); ++k) {
      assertTrue(x.contains((char) k));
    }
    for (int k = 0; k < (1 << 16); ++k) {
      assertTrue(x.contains((char) k));
      x = (RunContainer) x.remove((char) k);
      assertFalse(x.contains((char) k));
      assertEquals(k + 1, (1 << 16) - x.getCardinality());
    }
    for (int k = 0; k < (1 << 16); ++k) {
      assertFalse(x.contains((char) k));
      x = (RunContainer) x.add((char) k);
      assertEquals(k + 1, x.getCardinality());
      assertTrue(x.contains((char) k));
    }
    for (int k = (1 << 16) - 1; k >= 0; --k) {
      assertTrue(x.contains((char) k));
      x = (RunContainer) x.remove((char) k);
      assertFalse(x.contains((char) k));
      assertEquals(k, x.getCardinality());
    }
    for (int k = 0; k < (1 << 16); ++k) {
      assertFalse(x.contains((char) k));
      x = (RunContainer) x.add((char) k);
      assertEquals(k + 1, x.getCardinality());
      assertTrue(x.contains((char) k));
    }
    for (int k = 0; k < (1 << 16); ++k) {
      RunContainer copy = (RunContainer) x.clone();
      copy = (RunContainer) copy.remove((char) k);
      assertEquals(copy.getCardinality() + 1, x.getCardinality());
      copy = (RunContainer) copy.add((char) k);
      assertEquals(copy.getCardinality(), x.getCardinality());
      assertEquals(copy, x);
      assertEquals(x, copy);
      copy.trim();
      assertEquals(copy, x);
      assertEquals(x, copy);
    }
  }

  @Test
  public void basic2() {
    RunContainer x = new RunContainer();
    int a = 33;
    int b = 50000;
    for (int k = a; k < b; ++k) {
      x = (RunContainer) x.add((char) k);
    }
    for (int k = 0; k < (1 << 16); ++k) {
      if (x.contains((char) k)) {
        RunContainer copy = (RunContainer) x.clone();
        copy = (RunContainer) copy.remove((char) k);
        copy = (RunContainer) copy.add((char) k);
        assertEquals(copy.getCardinality(), x.getCardinality());
        assertEquals(copy, x);
        assertEquals(x, copy);
        x.trim();
        assertEquals(copy, x);
        assertEquals(x, copy);

      } else {
        RunContainer copy = (RunContainer) x.clone();
        copy = (RunContainer) copy.add((char) k);
        assertEquals(copy.getCardinality(), x.getCardinality() + 1);
      }
    }
  }

  @Test
  public void basictri() {
    RunContainer x = new RunContainer();
    for (int k = 0; k < (1 << 16); ++k) {
      assertFalse(x.contains((char) k));
    }
    for (int k = 0; k < (1 << 16); ++k) {
      assertFalse(x.contains((char) k));
      x = (RunContainer) x.add((char) k);
      x.trim();
      assertEquals(k + 1, x.getCardinality());
      assertTrue(x.contains((char) k));
    }
    for (int k = 0; k < (1 << 16); ++k) {
      assertTrue(x.contains((char) k));
    }
    for (int k = 0; k < (1 << 16); ++k) {
      assertTrue(x.contains((char) k));
      x = (RunContainer) x.remove((char) k);
      x.trim();
      assertFalse(x.contains((char) k));
      assertEquals(k + 1, (1 << 16) - x.getCardinality());
    }
    for (int k = 0; k < (1 << 16); ++k) {
      assertFalse(x.contains((char) k));
      x = (RunContainer) x.add((char) k);
      x.trim();
      assertEquals(k + 1, x.getCardinality());
      assertTrue(x.contains((char) k));
    }
    for (int k = (1 << 16) - 1; k >= 0; --k) {
      assertTrue(x.contains((char) k));
      x = (RunContainer) x.remove((char) k);
      x.trim();
      assertFalse(x.contains((char) k));
      assertEquals(k, x.getCardinality());
    }
    for (int k = 0; k < (1 << 16); ++k) {
      assertFalse(x.contains((char) k));
      x = (RunContainer) x.add((char) k);
      x.trim();
      assertEquals(k + 1, x.getCardinality());
      assertTrue(x.contains((char) k));
    }
    for (int k = 0; k < (1 << 16); ++k) {
      RunContainer copy = (RunContainer) x.clone();
      copy.trim();
      copy = (RunContainer) copy.remove((char) k);
      copy = (RunContainer) copy.add((char) k);
      assertEquals(copy.getCardinality(), x.getCardinality());
      assertEquals(copy, x);
      assertEquals(x, copy);
      copy.trim();
      assertEquals(copy, x);
      assertEquals(x, copy);
    }
  }

  @Test
  public void clear() {
    Container rc = new RunContainer();
    rc.add((char) 1);
    assertEquals(1, rc.getCardinality());
    rc.clear();
    assertEquals(0, rc.getCardinality());
  }

  @Test
  public void equalTest1() {
    Container ac = new ArrayContainer();
    Container ar = new RunContainer();
    for (int k = 0; k < 100; ++k) {
      ac = ac.add((char) (k * 10));
      ar = ar.add((char) (k * 10));
    }
    assertEquals(ac, ar);
  }

  @Test
  public void equalTest2() {
    Container ac = new ArrayContainer();
    Container ar = new RunContainer();
    for (int k = 0; k < 10000; ++k) {
      ac = ac.add((char) k);
      ar = ar.add((char) k);
    }
    assertEquals(ac, ar);
  }


  @Test
  public void fillLeastSignificantBits() {
    Container rc = new RunContainer();
    rc.add((char) 1);
    rc.add((char) 3);
    rc.add((char) 12);
    int[] array = new int[4];
    rc.fillLeastSignificant16bits(array, 1, 0);
    assertEquals(0, array[0]);
    assertEquals(1, array[1]);
    assertEquals(3, array[2]);
    assertEquals(12, array[3]);
  }



  @Test
  public void flip() {
    RunContainer rc = new RunContainer();
    rc.flip((char) 1);
    assertTrue(rc.contains((char) 1));
    rc.flip((char) 1);
    assertFalse(rc.contains((char) 1));
  }


  @Test
  public void iaddInvalidRange1() {
    assertThrows(IllegalArgumentException.class, () -> {
      Container rc = new RunContainer();
      rc.iadd(10, 9);
    });
  }



  @Test
  public void iaddInvalidRange2() {
    assertThrows(IllegalArgumentException.class, () -> {
      Container rc = new RunContainer();
      rc.iadd(0, 1 << 20);
    });
  }

  @Test
  public void iaddRange() {
    for (int i = 0; i < 100; ++i) {
      for (int j = 0; j < 100; ++j) {
        for (int k = 0; k < 50; ++k) {
          BitSet bs = new BitSet();
          RunContainer container = new RunContainer();
          for (int p = 0; p < i; ++p) {
            container.add((char) p);
            bs.set(p);
          }
          for (int p = 0; p < j; ++p) {
            container.add((char) (99 - p));
            bs.set(99 - p);
          }
          container.iadd(49 - k, 50 + k);
          bs.set(49 - k, 50 + k);
          assertEquals(bs.cardinality(), container.getCardinality());

          int nb_runs = 1;
          int lastIndex = bs.nextSetBit(0);
          for (int p = bs.nextSetBit(0); p >= 0; p = bs.nextSetBit(p + 1)) {
            if (p - lastIndex > 1) {
              nb_runs++;
            }
            lastIndex = p;
            assertTrue(container.contains((char) p));
          }
          assertEquals(nb_runs * 4 + 4, container.getSizeInBytes());
        }
      }
    }
  }

  @Test
  public void iaddRange1() {
    Container rc = new RunContainer();
    for (char k = 0; k < 10; ++k) {
      rc.add(k);
    }
    for (char k = 20; k < 30; ++k) {
      rc.add(k);
    }
    for (char k = 40; k < 50; ++k) {
      rc.add(k);
    }
    rc.iadd(5, 21);
    assertEquals(40, rc.getCardinality());
    for (char k = 0; k < 30; ++k) {
      assertTrue(rc.contains(k));
    }
    for (char k = 40; k < 50; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(12, rc.getSizeInBytes());
  }

  @Test
  public void iaddRange10() {
    Container rc = new RunContainer();
    for (char k = 0; k < 10; ++k) {
      rc.add(k);
    }
    for (char k = 20; k < 30; ++k) {
      rc.add(k);
    }
    rc.iadd(15, 35);
    assertEquals(30, rc.getCardinality());
    for (char k = 0; k < 10; ++k) {
      assertTrue(rc.contains(k));
    }
    for (char k = 15; k < 35; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(12, rc.getSizeInBytes());
  }

  @Test
  public void iaddRange11() {
    Container rc = new RunContainer();
    for (char k = 5; k < 10; ++k) {
      rc.add(k);
    }
    for (char k = 20; k < 30; ++k) {
      rc.add(k);
    }
    rc.iadd(0, 20);
    assertEquals(30, rc.getCardinality());
    for (char k = 0; k < 30; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(8, rc.getSizeInBytes());
  }

  @Test
  public void iaddRange12() {
    Container rc = new RunContainer();
    for (char k = 5; k < 10; ++k) {
      rc.add(k);
    }
    for (char k = 20; k < 30; ++k) {
      rc.add(k);
    }
    rc.iadd(0, 35);
    assertEquals(35, rc.getCardinality());
    for (char k = 0; k < 35; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(8, rc.getSizeInBytes());
  }

  @Test
  public void iaddRange2() {
    Container rc = new RunContainer();
    for (char k = 0; k < 10; ++k) {
      rc.add(k);
    }
    for (char k = 20; k < 30; ++k) {
      rc.add(k);
    }
    for (char k = 40; k < 50; ++k) {
      rc.add(k);
    }
    rc.iadd(0, 26);
    assertEquals(40, rc.getCardinality());
    for (char k = 0; k < 30; ++k) {
      assertTrue(rc.contains(k));
    }
    for (char k = 40; k < 50; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(12, rc.getSizeInBytes());
  }

  @Test
  public void iaddRange3() {
    Container rc = new RunContainer();
    for (char k = 0; k < 10; ++k) {
      rc.add(k);
    }
    for (char k = 20; k < 30; ++k) {
      rc.add(k);
    }
    for (char k = 40; k < 50; ++k) {
      rc.add(k);
    }
    rc.iadd(0, 20);
    assertEquals(40, rc.getCardinality());
    for (char k = 0; k < 30; ++k) {
      assertTrue(rc.contains(k));
    }
    for (char k = 40; k < 50; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(12, rc.getSizeInBytes());
  }

  @Test
  public void iaddRange4() {
    Container rc = new RunContainer();
    for (char k = 0; k < 10; ++k) {
      rc.add(k);
    }
    for (char k = 20; k < 30; ++k) {
      rc.add(k);
    }
    for (char k = 40; k < 50; ++k) {
      rc.add(k);
    }
    rc.iadd(10, 21);
    assertEquals(40, rc.getCardinality());
    for (char k = 0; k < 30; ++k) {
      assertTrue(rc.contains(k));
    }
    for (char k = 40; k < 50; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(12, rc.getSizeInBytes());
  }

  @Test
  public void iaddRange5() {
    Container rc = new RunContainer();
    for (char k = 0; k < 10; ++k) {
      rc.add(k);
    }
    for (char k = 20; k < 30; ++k) {
      rc.add(k);
    }
    for (char k = 40; k < 50; ++k) {
      rc.add(k);
    }
    rc.iadd(15, 21);
    assertEquals(35, rc.getCardinality());
    for (char k = 0; k < 10; ++k) {
      assertTrue(rc.contains(k));
    }
    for (char k = 15; k < 30; ++k) {
      assertTrue(rc.contains(k));
    }
    for (char k = 40; k < 50; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(16, rc.getSizeInBytes());
  }

  @Test
  public void iaddRange6() {
    Container rc = new RunContainer();
    for (char k = 5; k < 10; ++k) {
      rc.add(k);
    }
    for (char k = 20; k < 30; ++k) {
      rc.add(k);
    }
    for (char k = 40; k < 50; ++k) {
      rc.add(k);
    }
    rc.iadd(0, 21);
    assertEquals(40, rc.getCardinality());
    for (char k = 0; k < 30; ++k) {
      assertTrue(rc.contains(k));
    }
    for (char k = 40; k < 50; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(12, rc.getSizeInBytes());
  }

  @Test
  public void iaddRange7() {
    Container rc = new RunContainer();
    for (char k = 0; k < 10; ++k) {
      rc.add(k);
    }
    for (char k = 20; k < 30; ++k) {
      rc.add(k);
    }
    for (char k = 40; k < 50; ++k) {
      rc.add(k);
    }
    rc.iadd(15, 25);
    assertEquals(35, rc.getCardinality());
    for (char k = 0; k < 10; ++k) {
      assertTrue(rc.contains(k));
    }
    for (char k = 15; k < 30; ++k) {
      assertTrue(rc.contains(k));
    }
    for (char k = 40; k < 50; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(16, rc.getSizeInBytes());
  }


  @Test
  public void iaddRange8() {
    Container rc = new RunContainer();
    for (char k = 0; k < 10; ++k) {
      rc.add(k);
    }
    for (char k = 20; k < 30; ++k) {
      rc.add(k);
    }
    for (char k = 40; k < 50; ++k) {
      rc.add(k);
    }
    rc.iadd(15, 40);
    assertEquals(45, rc.getCardinality());
    for (char k = 0; k < 10; ++k) {
      assertTrue(rc.contains(k));
    }
    for (char k = 15; k < 50; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(12, rc.getSizeInBytes());
  }



  @Test
  public void iaddRangeAndFuseWithPreviousValueLength() {
    RunContainer container = new RunContainer();
    for (char i = 10; i < 20; ++i) {
      container.add(i);
    }
    container.iadd(20, 30);
    assertEquals(20, container.getCardinality());
    for (char i = 10; i < 30; ++i) {
      assertTrue(container.contains(i));
    }
    assertEquals(8, container.getSizeInBytes());
  }


  @Test
  public void iaddRangeOnNonEmptyContainerAndFuse() {
    RunContainer container = new RunContainer();
    for (char i = 1; i < 20; ++i) {
      container.add(i);
    }
    for (char i = 90; i < 120; ++i) {
      container.add(i);
    }
    container.iadd(10, 100);
    assertEquals(119, container.getCardinality());
    for (char i = 1; i < 120; ++i) {
      assertTrue(container.contains(i));
    }
  }


  @Test
  public void iaddRangeWithinSetBounds() {
    RunContainer container = new RunContainer();
    container.add((char) 10);
    container.add((char) 99);
    container.iadd(10, 100);
    assertEquals(90, container.getCardinality());
    for (char i = 10; i < 100; ++i) {
      assertTrue(container.contains(i));
    }
  }

  @Test
  public void inot1() {
    RunContainer container = new RunContainer();
    container.add((char) 0);
    container.add((char) 2);
    container.add((char) 55);
    container.add((char) 64);
    container.add((char) 256);

    Container result = container.inot(64, 64); // empty range
    assertSame(container, result);
    assertEquals(5, container.getCardinality());
  }

  @Test
  public void inot10() {
    RunContainer container = new RunContainer();
    container.add((char) 300);
    container.add((char) 500);
    container.add((char) 501);
    container.add((char) 502);
    container.add((char) 503);
    container.add((char) 504);
    container.add((char) 505);

    // second run begins inside the range but extends outside
    Container result = container.inot(498, 504);

    assertEquals(5, result.getCardinality());
    for (char i : new char[] {300, 498, 499, 504, 505}) {
      assertTrue(result.contains(i));
    }
  }

  @Test
  public void inot11() {
    RunContainer container = new RunContainer();
    container.add((char) 300);

    container.add((char) 500);
    container.add((char) 501);
    container.add((char) 502);

    container.add((char) 504);

    container.add((char) 510);

    // second run entirely inside range, third run entirely inside range, 4th run entirely outside
    Container result = container.inot(498, 507);

    assertEquals(7, result.getCardinality());
    for (char i : new char[] {300, 498, 499, 503, 505, 506, 510}) {
      assertTrue(result.contains(i));
    }
  }

  @Test
  public void inot12() {
    RunContainer container = new RunContainer();
    container.add((char) 300);

    container.add((char) 500);
    container.add((char) 501);
    container.add((char) 502);

    container.add((char) 504);

    container.add((char) 510);
    container.add((char) 511);

    // second run crosses into range, third run entirely inside range, 4th crosses outside
    Container result = container.inot(501, 511);

    assertEquals(9, result.getCardinality());
    for (char i : new char[] {300, 500, 503, 505, 506, 507, 508, 509, 511}) {
      assertTrue(result.contains(i));
    }
  }

  @Test
  public void inot12A() {
    RunContainer container = new RunContainer();
    container.add((char) 300);
    container.add((char) 301);

    // first run crosses into range
    Container result = container.inot(301, 303);

    assertEquals(2, result.getCardinality());
    for (char i : new char[] {300, 302}) {
      assertTrue(result.contains(i));
    }
  }



  @Test
  public void inot13() {
    RunContainer container = new RunContainer();
    // check for off-by-1 errors that might affect length 1 runs

    for (int i = 100; i < 120; i += 3) {
      container.add((char) i);
    }

    // second run crosses into range, third run entirely inside range, 4th crosses outside
    Container result = container.inot(110, 115);

    assertEquals(10, result.getCardinality());
    for (char i : new char[] {100, 103, 106, 109, 110, 111, 113, 114, 115, 118}) {
      assertTrue(result.contains(i));
    }
  }

  @Test
  public void inot14() {
    inot14once(10, 1);
    inot14once(10, 10);
    inot14once(1000, 100);
    for (int i = 1; i <= 100; ++i) {
      if (i % 10 == 0) {
        System.out.println("inot 14 attempt " + i);
      }
      inot14once(50000, 100);
    }
  }

  private void inot14once(int num, int rangeSize) {
    RunContainer container = new RunContainer();
    Random generator = new Random(1234);
    BitSet checker = new BitSet();
    for (int i = 0; i < num; ++i) {
      int val = (int) (generator.nextDouble() * 65536);
      checker.set(val);
      container.add((char) val);
    }

    int rangeStart = (int) generator.nextDouble() * (65536 - rangeSize);
    int rangeEnd = rangeStart + rangeSize;

    // this test is not checking runcontainer flip if "add" has converted
    // a runcontainer to an array or bitmap container. Flag this as requiring thought, if it happens
    assertTrue(container instanceof RunContainer);

    Container result = container.inot(rangeStart, rangeEnd);
    checker.flip(rangeStart, rangeEnd);

    // esnsure they agree on each possible bit
    for (int i = 0; i < 65536; ++i) {
      assertFalse(result.contains((char) i) ^ checker.get(i));
    }

  }

  @Test
  public void inot15() {
    RunContainer container = new RunContainer();
    for (int i = 0; i < 20000; ++i) {
      container.add((char) i);
    }

    for (int i = 40000; i < 60000; ++i) {
      container.add((char) i);
    }

    Container result = container.inot(15000, 25000);

    // this result should stay as a run container (same one)
    assertSame(container, result);
  }

  @Test
  public void inot2() {
    RunContainer container = new RunContainer();
    container.add((char) 0);
    container.add((char) 2);
    container.add((char) 55);
    container.add((char) 64);
    container.add((char) 256);

    Container result = container.inot(64, 66);
    assertEquals(5, result.getCardinality());
    for (char i : new char[] {0, 2, 55, 65, 256}) {
      assertTrue(result.contains(i));
    }
  }

  @Test
  public void inot3() {
    RunContainer container = new RunContainer();
    // applied to a run-less container
    Container result = container.inot(64, 68);
    assertEquals(4, result.getCardinality());
    for (char i : new char[] {64, 65, 66, 67}) {
      assertTrue(result.contains(i));
    }
  }



  @Test
  public void inot4() {
    RunContainer container = new RunContainer();
    container.add((char) 0);
    container.add((char) 2);
    container.add((char) 55);
    container.add((char) 64);
    container.add((char) 256);

    // all runs are before the range
    Container result = container.inot(300, 303);
    assertEquals(8, result.getCardinality());
    for (char i : new char[] {0, 2, 55, 64, 256, 300, 301, 302}) {
      assertTrue(result.contains(i));
    }
  }


  @Test
  public void inot5() {
    RunContainer container = new RunContainer();
    container.add((char) 500);
    container.add((char) 502);
    container.add((char) 555);
    container.add((char) 564);
    container.add((char) 756);

    // all runs are after the range
    Container result = container.inot(300, 303);
    assertEquals(8, result.getCardinality());
    for (char i : new char[] {500, 502, 555, 564, 756, 300, 301, 302}) {
      assertTrue(result.contains(i));
    }
  }

  @Test
  public void inot6() {
    RunContainer container = new RunContainer();
    container.add((char) 500);
    container.add((char) 501);
    container.add((char) 502);
    container.add((char) 503);

    // one run is strictly within the range
    Container result = container.inot(499, 505);
    assertEquals(2, result.getCardinality());
    for (char i : new char[] {499, 504}) {
      assertTrue(result.contains(i));
    }
  }


  @Test
  public void inot7() {
    RunContainer container = new RunContainer();
    container.add((char) 500);
    container.add((char) 501);
    container.add((char) 502);
    container.add((char) 503);
    container.add((char) 504);
    container.add((char) 505);


    // one run, spans the range
    Container result = container.inot(502, 504);

    assertEquals(4, result.getCardinality());
    for (char i : new char[] {500, 501, 504, 505}) {
      assertTrue(result.contains(i));
    }
  }

  @Test
  public void inot8() {
    RunContainer container = new RunContainer();
    container.add((char) 300);
    container.add((char) 500);
    container.add((char) 501);
    container.add((char) 502);
    container.add((char) 503);
    container.add((char) 504);
    container.add((char) 505);

    // second run, spans the range
    Container result = container.inot(502, 504);

    assertEquals(5, result.getCardinality());
    for (char i : new char[] {300, 500, 501, 504, 505}) {
      assertTrue(result.contains(i));
    }
  }

  @Test
  public void inot9() {
    RunContainer container = new RunContainer();
    container.add((char) 500);
    container.add((char) 501);
    container.add((char) 502);
    container.add((char) 503);
    container.add((char) 504);
    container.add((char) 505);

    // first run, begins inside the range but extends outside
    Container result = container.inot(498, 504);

    assertEquals(4, result.getCardinality());
    for (char i : new char[] {498, 499, 504, 505}) {
      assertTrue(result.contains(i));
    }
  }

  @Test
  public void intersectionTest1() {
    Container ac = new ArrayContainer();
    Container rc = new RunContainer();
    for (int k = 0; k < 100; ++k) {
      ac = ac.add((char) (k * 10));
      rc = rc.add((char) (k * 10));
    }
    assertEquals(ac, ac.and(rc));
    assertEquals(ac, rc.and(ac));
  }

  @Test
  public void intersectionTest2() {
    Container ac = new ArrayContainer();
    Container rc = new RunContainer();
    for (int k = 0; k < 10000; ++k) {
      ac = ac.add((char) k);
      rc = rc.add((char) k);
    }
    assertEquals(ac, ac.and(rc));
    assertEquals(ac, rc.and(ac));
  }

  @Test
  public void intersectionTest3() {
    Container ac = new ArrayContainer();
    Container rc = new RunContainer();
    for (int k = 0; k < 100; ++k) {
      ac = ac.add((char) k);
      rc = rc.add((char) (k + 100));
    }
    assertEquals(0, rc.and(ac).getCardinality());
  }

  @Test
  public void intersectionTest4() {
    Container bc = new BitmapContainer();
    Container rc = new RunContainer();
    for (int k = 0; k < 100; ++k) {
      bc = bc.add((char) (k * 10));
      bc = bc.add((char) (k * 10 + 3));

      rc = rc.add((char) (k * 10 + 5));
      rc = rc.add((char) (k * 10 + 3));
    }
    Container intersection = rc.and(bc);
    assertEquals(100, intersection.getCardinality());
    for (int k = 0; k < 100; ++k) {
      assertTrue(intersection.contains((char) (k * 10 + 3)));
    }
    assertEquals(200, bc.getCardinality());
    assertEquals(200, rc.getCardinality());
  }

  @Test
  public void ior() {
    Container rc1 = new RunContainer();
    Container rc2 = new RunContainer();
    rc1.iadd(0, 128);
    rc2.iadd(128, 256);
    rc1.ior(rc2);
    assertEquals(256, rc1.getCardinality());
  }

  @Test
  public void ior2() {
    Container rc = new RunContainer();
    Container ac = new ArrayContainer();
    rc.iadd(0, 128);
    rc.iadd(256, 512);
    ac.iadd(128, 256);
    rc.ior(ac);
    assertEquals(512, rc.getCardinality());
  }
  @Test
  public void iorNot() {
    Container rc1 = new RunContainer();
    Container rc2 = new ArrayContainer();

    rc1.iadd(257, 258);
    rc2.iadd(128, 256);
    rc1 = rc1.iorNot(rc2, 258);
    assertEquals(130, rc1.getCardinality());

    PeekableCharIterator iterator = rc1.getCharIterator();
    for (int i = 0; i < 128; i++) {
      assertTrue(iterator.hasNext());
      assertEquals(i, iterator.next());
    }
    assertTrue(iterator.hasNext());
    assertEquals(256, iterator.next());

    assertTrue(iterator.hasNext());
    assertEquals(257, iterator.next());

    assertFalse(iterator.hasNext());
  }

  @Test
  public void iorNot2() {
    Container rc1 = new RunContainer();
    Container rc2 = new ArrayContainer();
    rc2.iadd(128, 256).iadd(257, 260);
    rc1 = rc1.iorNot(rc2, 261);
    assertEquals(130, rc1.getCardinality());

    PeekableCharIterator iterator = rc1.getCharIterator();
    for (int i = 0; i < 128; i++) {
      assertTrue(iterator.hasNext());
      assertEquals(i, iterator.next());
    }
    assertTrue(iterator.hasNext());
    assertEquals(256, iterator.next());

    assertTrue(iterator.hasNext());
    assertEquals(260, iterator.next());

    assertFalse(iterator.hasNext());
  }

  @Test
  public void iorNot3() {
    Container rc1 = new RunContainer();
    Container rc2 = new BitmapContainer();

    rc1.iadd(257, 258);
    rc2.iadd(128, 256);
    rc1 = rc1.iorNot(rc2, 258);
    assertEquals(130, rc1.getCardinality());

    PeekableCharIterator iterator = rc1.getCharIterator();
    for (int i = 0; i < 128; i++) {
      assertTrue(iterator.hasNext());
      assertEquals(i, iterator.next());
    }
    assertTrue(iterator.hasNext());
    assertEquals(256, iterator.next());

    assertTrue(iterator.hasNext());
    assertEquals(257, iterator.next());

    assertFalse(iterator.hasNext());
  }

  @Test
  public void iorNot4() {
    Container rc1 = new RunContainer();
    Container rc2 = new RunContainer();

    rc1.iadd(257, 258);
    rc2.iadd(128, 256);
    rc1 = rc1.iorNot(rc2, 258);
    assertEquals(130, rc1.getCardinality());

    PeekableCharIterator iterator = rc1.getCharIterator();
    for (int i = 0; i < 128; i++) {
      assertTrue(iterator.hasNext());
      assertEquals(i, iterator.next());
    }
    assertTrue(iterator.hasNext());
    assertEquals(256, iterator.next());

    assertTrue(iterator.hasNext());
    assertEquals(257, iterator.next());

    assertFalse(iterator.hasNext());
  }

  @Test
  public void orNot() {
    final Container rc1 = new RunContainer();

    {
      Container rc2 = new ArrayContainer();
      rc2.iadd(128, 256);
      Container res = rc1.orNot(rc2, 257);
      assertEquals(129, res.getCardinality());

      PeekableCharIterator iterator = res.getCharIterator();
      for (int i = 0; i < 128; i++) {
        assertTrue(iterator.hasNext());
        assertEquals(i, iterator.next());
      }
      assertTrue(iterator.hasNext());
      assertEquals(256, iterator.next());

      assertFalse(iterator.hasNext());
    }

    {
      Container rc2 = new BitmapContainer();
      rc2.iadd(128, 256);
      Container res = rc1.orNot(rc2, 257);
      assertEquals(129, res.getCardinality());

      PeekableCharIterator iterator = res.getCharIterator();
      for (int i = 0; i < 128; i++) {
        assertTrue(iterator.hasNext());
        assertEquals(i, iterator.next());
      }
      assertTrue(iterator.hasNext());
      assertEquals(256, iterator.next());

      assertFalse(iterator.hasNext());
    }

    {
      Container rc2 = new RunContainer();
      rc2.iadd(128, 256);
      Container res = rc1.orNot(rc2, 257);
      assertEquals(129, res.getCardinality());

      PeekableCharIterator iterator = res.getCharIterator();
      for (int i = 0; i < 128; i++) {
        assertTrue(iterator.hasNext());
        assertEquals(i, iterator.next());
      }
      assertTrue(iterator.hasNext());
      assertEquals(256, iterator.next());

      assertFalse(iterator.hasNext());
    }

  }

  @Test
  public void orNot2() {
    Container rc1 = new RunContainer();
    Container rc2 = new ArrayContainer();
    rc2.iadd(128, 256).iadd(257, 260);
    rc1 = rc1.orNot(rc2, 261);
    assertEquals(130, rc1.getCardinality());

    PeekableCharIterator iterator = rc1.getCharIterator();
    for (int i = 0; i < 128; i++) {
      assertTrue(iterator.hasNext());
      assertEquals(i, iterator.next());
    }
    assertTrue(iterator.hasNext());
    assertEquals(256, iterator.next());

    assertTrue(iterator.hasNext());
    assertEquals(260, iterator.next());

    assertFalse(iterator.hasNext());
  }

  @Test
  public void iremove1() {
    Container rc = new RunContainer();
    rc.add((char) 1);
    rc.iremove(1, 2);
    assertEquals(0, rc.getCardinality());
  }

  @Test
  public void iremove10() {
    Container rc = new RunContainer();
    rc.iadd(5, 10);
    rc.iadd(20, 30);
    rc.iremove(0, 25);
    assertEquals(5, rc.getCardinality());
    for (char k = 25; k < 30; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(8, rc.getSizeInBytes());
  }

  @Test
  public void iremove11() {
    Container rc = new RunContainer();
    rc.iadd(5, 10);
    rc.iadd(20, 30);
    rc.iremove(0, 35);
    assertEquals(0, rc.getCardinality());
  }

  @Test
  public void iremove12() {
    Container rc = new RunContainer();
    rc.add((char) 0);
    rc.add((char) 10);
    rc.iremove(0, 11);
    assertEquals(0, rc.getCardinality());
  }

  @Test
  public void iremove13() {
    Container rc = new RunContainer();
    rc.iadd(0, 10);
    rc.iadd(20, 30);
    rc.iremove(5, 25);
    assertEquals(10, rc.getCardinality());
    for (char k = 0; k < 5; ++k) {
      assertTrue(rc.contains(k));
    }
    for (char k = 25; k < 30; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(12, rc.getSizeInBytes());
  }

  @Test
  public void iremove14() {
    Container rc = new RunContainer();
    rc.iadd(0, 10);
    rc.iadd(20, 30);
    rc.iremove(5, 31);
    assertEquals(5, rc.getCardinality());
    for (char k = 0; k < 5; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(8, rc.getSizeInBytes());
  }

  @Test
  public void iremove15() {
    Container rc = new RunContainer();
    rc.iadd(0, 5);
    rc.iadd(20, 30);
    rc.iremove(5, 25);
    assertEquals(10, rc.getCardinality());
    for (char k = 0; k < 5; ++k) {
      assertTrue(rc.contains(k));
    }
    for (char k = 25; k < 30; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(12, rc.getSizeInBytes());
  }

  @Test
  public void iremove16() {
    Container rc = new RunContainer();
    rc.iadd(0, 5);
    rc.iadd(20, 30);
    rc.iremove(5, 31);
    assertEquals(5, rc.getCardinality());
    for (char k = 0; k < 5; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(8, rc.getSizeInBytes());
  }

  @Test
  public void iremove17() {
    Container rc = new RunContainer();
    rc.iadd(37543, 65536);
    rc.iremove(9795, 65536);
    assertEquals(0, rc.getCardinality());
  }

  @Test
  public void iremove18() {
    Container rc = new RunContainer();
    rc.iadd(100, 200);
    rc.iadd(300, 400);
    rc.iadd(37543, 65000);
    rc.iremove(300, 65000); // start at beginning of run, end at end of another run
    assertEquals(100, rc.getCardinality());
  }

  @Test
  public void iremove19() {
    Container rc = new RunContainer();
    rc.iadd(100, 200);
    rc.iadd(300, 400);
    rc.iadd(64000, 65000);
    rc.iremove(350, 64000); // start midway through run, end at the start of next
    // got 100..199, 300..349, 64000..64999
    assertEquals(1150, rc.getCardinality());
  }

  @Test
  public void iremove2() {
    Container rc = new RunContainer();
    rc.iadd(0, 10);
    rc.iadd(20, 30);
    rc.iremove(0, 21);
    assertEquals(9, rc.getCardinality());
    for (char k = 21; k < 30; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(8, rc.getSizeInBytes());
  }

  @Test
  public void iremove20() {
    Container rc = new RunContainer();
    rc.iadd(100, 200);
    rc.iadd(300, 400);
    rc.iadd(64000, 65000);
    rc.iremove(350, 64001); // start midway through run, end at the start of next
    // got 100..199, 300..349, 64001..64999
    assertEquals(1149, rc.getCardinality());
  }

  @Test
  public void iremove3() {
    Container rc = new RunContainer();
    rc.iadd(0, 10);
    rc.iadd(20, 30);
    rc.iadd(40, 50);
    rc.iremove(0, 21);
    assertEquals(19, rc.getCardinality());
    for (char k = 21; k < 30; ++k) {
      assertTrue(rc.contains(k));
    }
    for (char k = 40; k < 50; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(12, rc.getSizeInBytes());
  }

  @Test
  public void iremove4() {
    Container rc = new RunContainer();
    rc.iadd(0, 10);
    rc.iremove(0, 5);
    assertEquals(5, rc.getCardinality());
    for (char k = 5; k < 10; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(8, rc.getSizeInBytes());
  }

  @Test
  public void iremove5() {
    Container rc = new RunContainer();
    rc.iadd(0, 10);
    rc.iadd(20, 30);
    rc.iremove(0, 31);
    assertEquals(0, rc.getCardinality());
  }

  @Test
  public void iremove6() {
    Container rc = new RunContainer();
    rc.iadd(0, 10);
    rc.iadd(20, 30);
    rc.iremove(0, 25);
    assertEquals(5, rc.getCardinality());
    for (char k = 25; k < 30; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(8, rc.getSizeInBytes());
  }

  @Test
  public void iremove7() {
    Container rc = new RunContainer();
    rc.iadd(0, 10);
    rc.iremove(0, 15);
    assertEquals(0, rc.getCardinality());
  }

  @Test
  public void iremove8() {
    Container rc = new RunContainer();
    rc.iadd(0, 10);
    rc.iadd(20, 30);
    rc.iremove(5, 21);
    assertEquals(14, rc.getCardinality());
    for (char k = 0; k < 5; ++k) {
      assertTrue(rc.contains(k));
    }
    for (char k = 21; k < 30; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(12, rc.getSizeInBytes());
  }

  @Test
  public void iremove9() {
    Container rc = new RunContainer();
    rc.iadd(0, 10);
    rc.iadd(20, 30);
    rc.iremove(15, 21);
    assertEquals(19, rc.getCardinality());
    for (char k = 0; k < 10; ++k) {
      assertTrue(rc.contains(k));
    }
    for (char k = 21; k < 30; ++k) {
      assertTrue(rc.contains(k));
    }
    assertEquals(12, rc.getSizeInBytes());
  }

  @Test
  public void iremoveInvalidRange1() {
    assertThrows(IllegalArgumentException.class, () -> {
      Container rc = new RunContainer();
      rc.iremove(10, 9);
    });
  }

  @Test
  public void iremoveInvalidRange2() {
    assertThrows(IllegalArgumentException.class, () -> {
      Container rc = new RunContainer();
      rc.remove(0, 1 << 20);
    });
  }

  @Test
  public void iremoveRange() {
    for (int i = 0; i < 100; ++i) {
      for (int j = 0; j < 100; ++j) {
        for (int k = 0; k < 50; ++k) {
          BitSet bs = new BitSet();
          RunContainer container = new RunContainer();
          for (int p = 0; p < i; ++p) {
            container.add((char) p);
            bs.set(p);
          }
          for (int p = 0; p < j; ++p) {
            container.add((char) (99 - p));
            bs.set(99 - p);
          }
          container.iremove(49 - k, 50 + k);
          bs.clear(49 - k, 50 + k);
          assertEquals(bs.cardinality(), container.getCardinality());

          int nb_runs = bs.isEmpty() ? 0 : 1;
          int lastIndex = bs.nextSetBit(0);
          for (int p = bs.nextSetBit(0); p >= 0; p = bs.nextSetBit(p + 1)) {
            if (p - lastIndex > 1) {
              nb_runs++;
            }
            lastIndex = p;
            assertTrue(container.contains((char) p));
          }
          assertEquals(nb_runs * 4 + 4, container.getSizeInBytes());
        }
      }
    }
  }

  @Test
  public void iremoveEmptyRange() {
    RunContainer container = new RunContainer();
    assertEquals(0, container.getCardinality());
    container.iremove(0,0);
    assertEquals(0, container.getCardinality());
  }

  @Test
  public void iterator() {
    RunContainer x = new RunContainer();
    for (int k = 0; k < 100; ++k) {
      for (int j = 0; j < k; ++j) {
        x = (RunContainer) x.add((char) (k * 100 + j));
      }
    }
    CharIterator i = x.getCharIterator();
    for (int k = 0; k < 100; ++k) {
      for (int j = 0; j < k; ++j) {
        assertTrue(i.hasNext());
        assertEquals(i.next(), (char) (k * 100 + j));
      }
    }
    assertFalse(i.hasNext());
  }

  @Test
  public void limit() {
    RunContainer container = new RunContainer();
    container.add((char) 0);
    container.add((char) 2);
    container.add((char) 55);
    container.add((char) 64);
    container.add((char) 256);
    Container limit = container.limit(1024);
    assertNotSame(container, limit);
    assertEquals(container, limit);
    limit = container.limit(3);
    assertNotSame(container, limit);
    assertEquals(3, limit.getCardinality());
    assertTrue(limit.contains((char) 0));
    assertTrue(limit.contains((char) 2));
    assertTrue(limit.contains((char) 55));
  }

  @Test
  public void longbacksimpleIterator() {
    RunContainer x = new RunContainer();
    for (int k = 0; k < (1 << 16); ++k) {
      x = (RunContainer) x.add((char) k);
    }
    CharIterator i = x.getReverseCharIterator();
    for (int k = (1 << 16) - 1; k >= 0; --k) {
      assertTrue(i.hasNext());
      assertEquals(i.next(), (char) k);
    }
    assertFalse(i.hasNext());
  }

  @Test
  public void longcsimpleIterator() {
    RunContainer x = new RunContainer();
    for (int k = 0; k < (1 << 16); ++k) {
      x = (RunContainer) x.add((char) k);
    }
    Iterator<Character> i = x.iterator();
    for (int k = 0; k < (1 << 16); ++k) {
      assertTrue(i.hasNext());
      assertEquals(i.next().charValue(), (char) k);
    }
    assertFalse(i.hasNext());
  }

  @Test
  public void longsimpleIterator() {
    RunContainer x = new RunContainer();
    for (int k = 0; k < (1 << 16); ++k) {
      x = (RunContainer) x.add((char) (k));
    }
    CharIterator i = x.getCharIterator();
    for (int k = 0; k < (1 << 16); ++k) {
      assertTrue(i.hasNext());
      assertEquals(i.next(), (char) k);
    }
    assertFalse(i.hasNext());
  }

  @Test
  public void not1() {
    RunContainer container = new RunContainer();
    container.add((char) 0);
    container.add((char) 2);
    container.add((char) 55);
    container.add((char) 64);
    container.add((char) 256);

    Container result = container.not(64, 64); // empty range
    assertNotSame(container, result);
    assertEquals(container, result);
  }

  @Test
  public void not10() {
    RunContainer container = new RunContainer();
    container.add((char) 300);
    container.add((char) 500);
    container.add((char) 501);
    container.add((char) 502);
    container.add((char) 503);
    container.add((char) 504);
    container.add((char) 505);

    // second run begins inside the range but extends outside
    Container result = container.not(498, 504);

    assertEquals(5, result.getCardinality());
    for (char i : new char[] {300, 498, 499, 504, 505}) {
      assertTrue(result.contains(i));
    }
  }

  @Test
  public void not11() {
    RunContainer container = new RunContainer();
    container.add((char) 300);

    container.add((char) 500);
    container.add((char) 501);
    container.add((char) 502);

    container.add((char) 504);

    container.add((char) 510);

    // second run entirely inside range, third run entirely inside range, 4th run entirely outside
    Container result = container.not(498, 507);

    assertEquals(7, result.getCardinality());
    for (char i : new char[] {300, 498, 499, 503, 505, 506, 510}) {
      assertTrue(result.contains(i));
    }
  }


  @Test
  public void not12() {
    RunContainer container = new RunContainer();
    container.add((char) 300);

    container.add((char) 500);
    container.add((char) 501);
    container.add((char) 502);

    container.add((char) 504);

    container.add((char) 510);
    container.add((char) 511);

    // second run crosses into range, third run entirely inside range, 4th crosses outside
    Container result = container.not(501, 511);

    assertEquals(9, result.getCardinality());
    for (char i : new char[] {300, 500, 503, 505, 506, 507, 508, 509, 511}) {
      assertTrue(result.contains(i));
    }
  }


  @Test
  public void not12A() {
    RunContainer container = new RunContainer();
    container.add((char) 300);
    container.add((char) 301);

    // first run crosses into range
    Container result = container.not(301, 303);

    assertEquals(2, result.getCardinality());
    for (char i : new char[] {300, 302}) {
      assertTrue(result.contains(i));
    }
  }

  @Test
  public void not13() {
    RunContainer container = new RunContainer();
    // check for off-by-1 errors that might affect length 1 runs

    for (int i = 100; i < 120; i += 3) {
      container.add((char) i);
    }

    // second run crosses into range, third run entirely inside range, 4th crosses outside
    Container result = container.not(110, 115);

    assertEquals(10, result.getCardinality());
    for (char i : new char[] {100, 103, 106, 109, 110, 111, 113, 114, 115, 118}) {
      assertTrue(result.contains(i));
    }
  }


  @Test
  public void not14() {
    not14once(10, 1);
    not14once(10, 10);
    not14once(1000, 100);

    for (int i = 1; i <= 100; ++i) {
      if (i % 10 == 0) {
        System.out.println("not 14 attempt " + i);
      }
      not14once(50000, 100);
    }
  }


  private void not14once(int num, int rangeSize) {
    RunContainer container = new RunContainer();
    BitSet checker = new BitSet();
    Random generator = new Random(1234);
    for (int i = 0; i < num; ++i) {
      int val = (int) (generator.nextDouble() * 65536);
      checker.set(val);
      container.add((char) val);
    }

    int rangeStart = (int) generator.nextDouble() * (65536 - rangeSize);
    int rangeEnd = rangeStart + rangeSize;

    assertTrue(container instanceof RunContainer);

    Container result = container.not(rangeStart, rangeEnd);
    checker.flip(rangeStart, rangeEnd);

    // esnsure they agree on each possible bit
    for (int i = 0; i < 65536; ++i) {
      assertFalse(result.contains((char) i) ^ checker.get(i));
    }

  }


  @Test
  public void not15() {
    RunContainer container = new RunContainer();
    for (int i = 0; i < 20000; ++i) {
      container.add((char) i);
    }

    for (int i = 40000; i < 60000; ++i) {
      container.add((char) i);
    }

    Container result = container.not(15000, 25000);

    // this result should stay as a run container.
    assertTrue(result instanceof RunContainer);
  }


  @Test
  public void not2() {
    RunContainer container = new RunContainer();
    container.add((char) 0);
    container.add((char) 2);
    container.add((char) 55);
    container.add((char) 64);
    container.add((char) 256);

    Container result = container.not(64, 66);
    assertEquals(5, result.getCardinality());
    for (char i : new char[] {0, 2, 55, 65, 256}) {
      assertTrue(result.contains(i));
    }
  }


  @Test
  public void not3() {
    RunContainer container = new RunContainer();
    // applied to a run-less container
    Container result = container.not(64, 68);
    assertEquals(4, result.getCardinality());
    for (char i : new char[] {64, 65, 66, 67}) {
      assertTrue(result.contains(i));
    }
  }

  @Test
  public void not4() {
    RunContainer container = new RunContainer();
    container.add((char) 0);
    container.add((char) 2);
    container.add((char) 55);
    container.add((char) 64);
    container.add((char) 256);

    // all runs are before the range
    Container result = container.not(300, 303);
    assertEquals(8, result.getCardinality());
    for (char i : new char[] {0, 2, 55, 64, 256, 300, 301, 302}) {
      assertTrue(result.contains(i));
    }
  }


  @Test
  public void not5() {
    RunContainer container = new RunContainer();
    container.add((char) 500);
    container.add((char) 502);
    container.add((char) 555);
    container.add((char) 564);
    container.add((char) 756);

    // all runs are after the range
    Container result = container.not(300, 303);
    assertEquals(8, result.getCardinality());
    for (char i : new char[] {500, 502, 555, 564, 756, 300, 301, 302}) {
      assertTrue(result.contains(i));
    }
  }



  @Test
  public void not6() {
    RunContainer container = new RunContainer();
    container.add((char) 500);
    container.add((char) 501);
    container.add((char) 502);
    container.add((char) 503);

    // one run is strictly within the range
    Container result = container.not(499, 505);
    assertEquals(2, result.getCardinality());
    for (char i : new char[] {499, 504}) {
      assertTrue(result.contains(i));
    }
  }

  @Test
  public void not7() {
    RunContainer container = new RunContainer();
    container.add((char) 500);
    container.add((char) 501);
    container.add((char) 502);
    container.add((char) 503);
    container.add((char) 504);
    container.add((char) 505);


    // one run, spans the range
    Container result = container.not(502, 504);

    assertEquals(4, result.getCardinality());
    for (char i : new char[] {500, 501, 504, 505}) {
      assertTrue(result.contains(i));
    }
  }



  @Test
  public void not8() {
    RunContainer container = new RunContainer();
    container.add((char) 300);
    container.add((char) 500);
    container.add((char) 501);
    container.add((char) 502);
    container.add((char) 503);
    container.add((char) 504);
    container.add((char) 505);

    // second run, spans the range
    Container result = container.not(502, 504);

    assertEquals(5, result.getCardinality());
    for (char i : new char[] {300, 500, 501, 504, 505}) {
      assertTrue(result.contains(i));
    }
  }



  @Test
  public void not9() {
    RunContainer container = new RunContainer();
    container.add((char) 500);
    container.add((char) 501);
    container.add((char) 502);
    container.add((char) 503);
    container.add((char) 504);
    container.add((char) 505);

    // first run, begins inside the range but extends outside
    Container result = container.not(498, 504);

    assertEquals(4, result.getCardinality());
    for (char i : new char[] {498, 499, 504, 505}) {
      assertTrue(result.contains(i));
    }
  }



  @Test
  public void randomFun() {
    final int bitsetperword1 = 32;
    final int bitsetperword2 = 63;

    Container rc1, rc2, ac1, ac2;
    Random rand = new Random(0);
    final int max = 1 << 16;
    final int howmanywords = (1 << 16) / 64;
    int[] values1 = generateUniformHash(rand, bitsetperword1 * howmanywords, max);
    int[] values2 = generateUniformHash(rand, bitsetperword2 * howmanywords, max);


    rc1 = new RunContainer();
    rc1 = fillMeUp(rc1, values1);

    rc2 = new RunContainer();
    rc2 = fillMeUp(rc2, values2);

    ac1 = new ArrayContainer();
    ac1 = fillMeUp(ac1, values1);

    ac2 = new ArrayContainer();
    ac2 = fillMeUp(ac2, values2);

    if (!rc1.equals(ac1)) {
      throw new RuntimeException("first containers do not match");
    }

    if (!rc2.equals(ac2)) {
      throw new RuntimeException("second containers do not match");
    }

    if (!rc1.or(rc2).equals(ac1.or(ac2))) {
      throw new RuntimeException("ors do not match");
    }
    if (!rc1.and(rc2).equals(ac1.and(ac2))) {
      throw new RuntimeException("ands do not match");
    }
    if (!rc1.andNot(rc2).equals(ac1.andNot(ac2))) {
      throw new RuntimeException("andnots do not match");
    }
    if (!rc2.andNot(rc1).equals(ac2.andNot(ac1))) {
      throw new RuntimeException("andnots do not match");
    }
    if (!rc1.xor(rc2).equals(ac1.xor(ac2))) {
      throw new RuntimeException("xors do not match");
    }

  }

  @Test
  public void rank() {
    RunContainer container = new RunContainer();
    container.add((char) 0);
    container.add((char) 2);
    container.add((char) 55);
    container.add((char) 64);
    container.add((char) 256);
    assertEquals(1, container.rank((char) 0));
    assertEquals(2, container.rank((char) 10));
    assertEquals(4, container.rank((char) 128));
    assertEquals(5, container.rank((char) 1024));
  }

  @Test
  public void charRangeRank() {
    Container container = new RunContainer();
    container = container.add(16, 32);
    assertTrue(container instanceof RunContainer);
    // results in correct value: 16
    // assertEquals(16, container.toBitmapContainer().rank((char) 32));
    assertEquals(16, container.rank((char) 32));
  }


  @Test
  public void remove() {
    Container rc = new RunContainer();
    rc.add((char) 1);
    Container newContainer = rc.remove(1, 2);
    assertEquals(0, newContainer.getCardinality());
  }



  @Test
  public void RunContainerArg_ArrayAND() {
    boolean atLeastOneArray = false;
    ArrayList<RunContainer> set = new ArrayList<RunContainer>();
    ArrayList<Container> setb = new ArrayList<Container>();
    getSetOfRunContainers(set, setb);
    for (int k = 0; k < set.size(); ++k) {
      for (int l = 0; l < set.size(); ++l) {
        assertEquals(set.get(k), setb.get(k));
        assertEquals(set.get(l), setb.get(l));
        Container thisContainer = setb.get(k);
        if (thisContainer instanceof BitmapContainer) {
          ; // continue;
        } else {
          atLeastOneArray = true;
        }
        Container c1 = thisContainer.and(set.get(l));
        Container c2 = setb.get(k).and(setb.get(l));
        assertEquals(c1, c2);
      }
    }
    assertTrue(atLeastOneArray);
  }



  @Test
  public void RunContainerArg_ArrayANDNOT() {
    boolean atLeastOneArray = false;
    ArrayList<RunContainer> set = new ArrayList<RunContainer>();
    ArrayList<Container> setb = new ArrayList<Container>();
    getSetOfRunContainers(set, setb);
    for (int k = 0; k < set.size(); ++k) {
      for (int l = 0; l < set.size(); ++l) {
        assertEquals(set.get(k), setb.get(k));
        assertEquals(set.get(l), setb.get(l));
        Container thisContainer = setb.get(k);
        if (thisContainer instanceof BitmapContainer) {
          // continue;
        } else {
          atLeastOneArray = true;
        }

        Container c1 = thisContainer.andNot(set.get(l));
        Container c2 = setb.get(k).andNot(setb.get(l));

        assertEquals(c1, c2);
      }
    }
    assertTrue(atLeastOneArray);
  }

  @Test
  public void RunContainerArg_ArrayANDNOT2() {
    ArrayContainer ac = new ArrayContainer(12, new char[]{0, 2, 4, 8, 10, 15, 16, 48, 50, 61, 80, (char)-2});
    RunContainer rc = new RunContainer(new char[]{7, 3, 17, 2, 20, 3, 30, 3, 36, 6, 60, 5, (char)-3, 2}, 7);
    assertEquals(new ArrayContainer(8, new char[]{0, 2, 4, 15, 16, 48, 50, 80}), ac.andNot(rc));
  }

  @Test
  public void FullRunContainerArg_ArrayANDNOT2() {
    ArrayContainer ac = new ArrayContainer(1, new char[]{3});
    Container rc = RunContainer.full();
    assertEquals(new ArrayContainer(), ac.andNot(rc));
  }

  @Test
  public void RunContainerArg_ArrayANDNOT3() {
    ArrayContainer ac = new ArrayContainer(1, new char[]{5});
    Container rc = new RunContainer(new char[]{3, 10}, 1);
    assertEquals(new ArrayContainer(), ac.andNot(rc));
  }

  @Test
  public void RunContainerArg_ArrayOR() {
    boolean atLeastOneArray = false;
    ArrayList<RunContainer> set = new ArrayList<RunContainer>();
    ArrayList<Container> setb = new ArrayList<Container>();
    getSetOfRunContainers(set, setb);
    for (int k = 0; k < set.size(); ++k) {
      for (int l = 0; l < set.size(); ++l) {
        assertEquals(set.get(k), setb.get(k));
        assertEquals(set.get(l), setb.get(l));
        Container thisContainer = setb.get(k);
        // BitmapContainers are tested separately, but why not test some more?
        if (thisContainer instanceof BitmapContainer) {
          ; // continue;
        } else {
          atLeastOneArray = true;
        }

        Container c1 = thisContainer.or(set.get(l));
        Container c2 = setb.get(k).or(setb.get(l));
        assertEquals(c1, c2);
      }
    }
    assertTrue(atLeastOneArray);
  }

  @Test
  public void RunContainerArg_ArrayXOR() {
    boolean atLeastOneArray = false;
    ArrayList<RunContainer> set = new ArrayList<RunContainer>();
    ArrayList<Container> setb = new ArrayList<Container>();
    getSetOfRunContainers(set, setb);
    for (int k = 0; k < set.size(); ++k) {
      for (int l = 0; l < set.size(); ++l) {
        assertEquals(set.get(k), setb.get(k));
        assertEquals(set.get(l), setb.get(l));
        Container thisContainer = setb.get(k);
        if (thisContainer instanceof BitmapContainer) {
          ; // continue;
        } else {
          atLeastOneArray = true;
        }

        Container c1 = thisContainer.xor(set.get(l));
        Container c2 = setb.get(k).xor(setb.get(l));
        assertEquals(c1, c2);
      }
    }
    assertTrue(atLeastOneArray);
  }


  @Test
  public void RunContainerFromBitmap() {
    Container rc = new RunContainer();
    Container bc = new BitmapContainer();

    rc = rc.add((char) 2);
    bc = bc.add((char) 2);
    rc = rc.add((char) 3);
    bc = bc.add((char) 3);
    rc = rc.add((char) 4);
    bc = bc.add((char) 4);
    rc = rc.add((char) 17);
    bc = bc.add((char) 17);
    for (int i = 192; i < 500; ++i) {
      rc = rc.add((char) i);
      bc = bc.add((char) i);
    }
    rc = rc.add((char) 1700);
    bc = bc.add((char) 1700);
    rc = rc.add((char) 1701);
    bc = bc.add((char) 1701);

    // cases depending on whether we have largest item.
    // this test: no, we don't get near largest word

    RunContainer rc2 = new RunContainer((BitmapContainer) bc, ((RunContainer) rc).nbrruns);
    assertEquals(rc, rc2);
  }


  @Test
  public void RunContainerFromBitmap1() {
    Container rc = new RunContainer();
    Container bc = new BitmapContainer();


    rc = rc.add((char) 2);
    bc = bc.add((char) 2);
    rc = rc.add((char) 3);
    bc = bc.add((char) 3);
    rc = rc.add((char) 4);
    bc = bc.add((char) 4);
    rc = rc.add((char) 17);
    bc = bc.add((char) 17);
    for (int i = 192; i < 500; ++i) {
      rc = rc.add((char) i);
      bc = bc.add((char) i);
    }
    rc = rc.add((char) 1700);
    bc = bc.add((char) 1700);
    rc = rc.add((char) 1701);
    bc = bc.add((char) 1701);

    // cases depending on whether we have largest item.
    // this test: we have a 1 in the largest word but not at end
    rc = rc.add((char) 65530);
    bc = bc.add((char) 65530);

    RunContainer rc2 = new RunContainer((BitmapContainer) bc, ((RunContainer) rc).nbrruns);
    assertEquals(rc, rc2);
  }


  @Test
  public void RunContainerFromBitmap2() {
    Container rc = new RunContainer();
    Container bc = new BitmapContainer();

    rc = rc.add((char) 2);
    bc = bc.add((char) 2);
    rc = rc.add((char) 3);
    bc = bc.add((char) 3);
    rc = rc.add((char) 4);
    bc = bc.add((char) 4);
    rc = rc.add((char) 17);
    bc = bc.add((char) 17);
    for (int i = 192; i < 500; ++i) {
      rc = rc.add((char) i);
      bc = bc.add((char) i);
    }
    rc = rc.add((char) 1700);
    bc = bc.add((char) 1700);
    rc = rc.add((char) 1701);
    bc = bc.add((char) 1701);

    // cases depending on whether we have largest item.
    // this test: we have a 1 in the largest word and at end
    rc = rc.add((char) 65530);
    bc = bc.add((char) 65530);
    rc = rc.add((char) 65535);
    bc = bc.add((char) 65535);


    RunContainer rc2 = new RunContainer((BitmapContainer) bc, ((RunContainer) rc).nbrruns);
    assertEquals(rc, rc2);
  }


  @Test
  public void RunContainerFromBitmap3() {
    Container rc = new RunContainer();
    Container bc = new BitmapContainer();

    rc = rc.add((char) 2);
    bc = bc.add((char) 2);
    rc = rc.add((char) 3);
    bc = bc.add((char) 3);
    rc = rc.add((char) 4);
    bc = bc.add((char) 4);
    rc = rc.add((char) 17);
    bc = bc.add((char) 17);
    for (int i = 192; i < 500; ++i) {
      rc = rc.add((char) i);
      bc = bc.add((char) i);
    }
    rc = rc.add((char) 1700);
    bc = bc.add((char) 1700);
    rc = rc.add((char) 1701);
    bc = bc.add((char) 1701);
    // cases depending on whether we have largest item.
    // this test: we have a lot of 1s in a run at the end

    for (int i = 65000; i < 65535; ++i) {
      rc = rc.add((char) i);
      bc = bc.add((char) i);
    }

    RunContainer rc2 = new RunContainer((BitmapContainer) bc, ((RunContainer) rc).nbrruns);
    assertEquals(rc, rc2);
  }

  @Test
  public void RunContainerVSRunContainerAND() {
    ArrayList<RunContainer> set = new ArrayList<RunContainer>();
    ArrayList<Container> setb = new ArrayList<Container>();
    getSetOfRunContainers(set, setb);
    for (int k = 0; k < set.size(); ++k) {
      for (int l = 0; l < set.size(); ++l) {
        assertEquals(set.get(k), setb.get(k));
        assertEquals(set.get(l), setb.get(l));
        Container c1 = set.get(k).and(set.get(l));
        Container c2 = setb.get(k).and(setb.get(l));
        assertEquals(c1, c2);
      }
    }
  }


  @Test
  public void RunContainerVSRunContainerANDNOT() {
    ArrayList<RunContainer> set = new ArrayList<RunContainer>();
    ArrayList<Container> setb = new ArrayList<Container>();
    getSetOfRunContainers(set, setb);
    for (int k = 0; k < set.size(); ++k) {
      for (int l = 0; l < set.size(); ++l) {
        assertEquals(set.get(k), setb.get(k));
        assertEquals(set.get(l), setb.get(l));
        Container c1 = set.get(k).andNot(set.get(l));
        Container c2 = setb.get(k).andNot(setb.get(l));
        assertEquals(c1, c2);
      }
    }
  }



  @Test
  public void RunContainerVSRunContainerOR() {
    ArrayList<RunContainer> set = new ArrayList<RunContainer>();
    ArrayList<Container> setb = new ArrayList<Container>();
    getSetOfRunContainers(set, setb);
    for (int k = 0; k < set.size(); ++k) {
      for (int l = 0; l < set.size(); ++l) {
        assertEquals(set.get(k), setb.get(k));
        assertEquals(set.get(l), setb.get(l));
        Container c1 = set.get(k).or(set.get(l));
        Container c2 = setb.get(k).or(setb.get(l));
        assertEquals(c1, c2);
      }
    }
  }

  @Test
  public void RunContainerVSRunContainerXOR() {
    ArrayList<RunContainer> set = new ArrayList<RunContainer>();
    ArrayList<Container> setb = new ArrayList<Container>();
    getSetOfRunContainers(set, setb);
    for (int k = 0; k < set.size(); ++k) {
      for (int l = 0; l < set.size(); ++l) {
        assertEquals(set.get(k), setb.get(k));
        assertEquals(set.get(l), setb.get(l));
        Container c1 = set.get(k).xor(set.get(l));
        Container c2 = setb.get(k).xor(setb.get(l));
        assertEquals(c1, c2);
      }
    }
  }



  @Test
  public void safeor() {
    Container rc1 = new RunContainer();
    Container rc2 = new RunContainer();
    for (int i = 0; i < 100; ++i) {
      rc1 = rc1.iadd(i * 4, (i + 1) * 4 - 1);
      rc2 = rc2.iadd(i * 4 + 10000, (i + 1) * 4 - 1 + 10000);
    }
    Container x = rc1.or(rc2);
    rc1.ior(rc2);
    if (!rc1.equals(x)) {
      throw new RuntimeException("bug");
    }
  }

  @Test
  public void orFullToRunContainer() {
    Container rc = Container.rangeOfOnes(0, 1 << 15);
    Container half = new BitmapContainer(1 << 15, 1 << 16);
    assertTrue(rc instanceof RunContainer);
    Container result = rc.or(half);
    assertEquals(1 << 16, result.getCardinality());
    assertTrue(result instanceof RunContainer);
  }

  @Test
  public void orFullToRunContainer2() {
    Container rc = Container.rangeOfOnes((1 << 10) - 200, 1 << 16);
    Container half = new ArrayContainer(0, 1 << 10);
    assertTrue(rc instanceof RunContainer);
    Container result = rc.or(half);
    assertEquals(1 << 16, result.getCardinality());
    assertTrue(result instanceof RunContainer);
  }

  @Test
  public void orFullToRunContainer3() {
    Container rc = Container.rangeOfOnes(0, 1 << 15);
    Container half = Container.rangeOfOnes((1 << 15) - 200, 1 << 16);
    assertTrue(rc instanceof RunContainer);
    Container result = rc.or(half);
    assertEquals(1 << 16, result.getCardinality());
    assertTrue(result instanceof RunContainer);
  }

  @Test
  public void safeSerialization() throws Exception {
    RunContainer container = new RunContainer();
    container.add((char) 0);
    container.add((char) 2);
    container.add((char) 55);
    container.add((char) 64);
    container.add((char) 256);

    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    ObjectOutputStream out = new ObjectOutputStream(bos);
    out.writeObject(container);

    ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
    ObjectInputStream in = new ObjectInputStream(bis);
    RunContainer newContainer = (RunContainer) in.readObject();
    assertEquals(container, newContainer);
    assertEquals(container.serializedSizeInBytes(), newContainer.serializedSizeInBytes());
  }



  @Test
  public void select() {
    RunContainer container = new RunContainer();
    container.add((char) 0);
    container.add((char) 2);
    container.add((char) 55);
    container.add((char) 64);
    container.add((char) 256);
    assertEquals(0, container.select(0));
    assertEquals(2, container.select(1));
    assertEquals(55, container.select(2));
    assertEquals(64, container.select(3));
    assertEquals(256, container.select(4));
  }

  @Test
  public void select2() {
    assertThrows(IllegalArgumentException.class, () -> {
      RunContainer container = new RunContainer();
      container.add((char) 0);
      container.add((char) 3);
      container.add((char) 118);
      container.select(666);
    });
  }

  @Test
  public void simpleIterator() {
    RunContainer x = new RunContainer();
    for (int k = 0; k < 100; ++k) {
      x = (RunContainer) x.add((char) (k));
    }
    CharIterator i = x.getCharIterator();
    for (int k = 0; k < 100; ++k) {
      assertTrue(i.hasNext());
      assertEquals(i.next(), (char) k);
    }
    assertFalse(i.hasNext());
  }


  @Test
  public void testAndNot() {
    int[] array1 = {39173, 39174, 39175, 39176, 39177, 39178, 39179, 39180, 39181, 39182, 39183,
        39184, 39185, 39186, 39187, 39188};
    int[] array2 = {14205};
    RoaringBitmap rb1 = RoaringBitmap.bitmapOf(array1);
    rb1.runOptimize();
    RoaringBitmap rb2 = RoaringBitmap.bitmapOf(array2);
    RoaringBitmap answer = RoaringBitmap.andNot(rb1, rb2);
    assertEquals(answer.getCardinality(), array1.length);
  }



  @Test
  public void testRoaringWithOptimize() {
    // create the same bitmap over and over again, with optimizing it
    final Set<RoaringBitmap> setWithOptimize = new HashSet<RoaringBitmap>();
    final int max = 1000;
    for (int i = 0; i < max; i++) {
      final RoaringBitmap bitmapWithOptimize = new RoaringBitmap();
      bitmapWithOptimize.add(1);
      bitmapWithOptimize.add(2);
      bitmapWithOptimize.add(3);
      bitmapWithOptimize.add(4);
      bitmapWithOptimize.runOptimize();
      setWithOptimize.add(bitmapWithOptimize);
    }
    assertEquals(1, setWithOptimize.size());
  }


  @Test
  public void testRoaringWithoutOptimize() {
    // create the same bitmap over and over again, without optimizing it
    final Set<RoaringBitmap> setWithoutOptimize = new HashSet<RoaringBitmap>();
    final int max = 1000;
    for (int i = 0; i < max; i++) {
      final RoaringBitmap bitmapWithoutOptimize = new RoaringBitmap();
      bitmapWithoutOptimize.add(1);
      bitmapWithoutOptimize.add(2);
      bitmapWithoutOptimize.add(3);
      bitmapWithoutOptimize.add(4);
      setWithoutOptimize.add(bitmapWithoutOptimize);
    }
    assertEquals(1, setWithoutOptimize.size());
  }

  @Test
  public void toBitmapOrArrayContainer() {
    RunContainer rc = new RunContainer();
    rc.iadd(0, DEFAULT_MAX_SIZE / 2);
    Container ac = rc.toBitmapOrArrayContainer(rc.getCardinality());
    assertTrue(ac instanceof ArrayContainer);
    assertEquals(DEFAULT_MAX_SIZE / 2, ac.getCardinality());
    for (char k = 0; k < DEFAULT_MAX_SIZE / 2; ++k) {
      assertTrue(ac.contains(k));
    }
    rc.iadd(DEFAULT_MAX_SIZE / 2, 2 * DEFAULT_MAX_SIZE);
    Container bc = rc.toBitmapOrArrayContainer(rc.getCardinality());
    assertTrue(bc instanceof BitmapContainer);
    assertEquals(2 * DEFAULT_MAX_SIZE, bc.getCardinality());
    for (char k = 0; k < 2 * DEFAULT_MAX_SIZE; ++k) {
      assertTrue(bc.contains(k));
    }
  }

  @Test
  public void union() {
    Container bc = new BitmapContainer();
    Container rc = new RunContainer();
    for (int k = 0; k < 100; ++k) {
      bc = bc.add((char) (k * 10));
      rc = rc.add((char) (k * 10 + 3));
    }
    Container union = rc.or(bc);
    assertEquals(200, union.getCardinality());
    for (int k = 0; k < 100; ++k) {
      assertTrue(union.contains((char) (k * 10)));
      assertTrue(union.contains((char) (k * 10 + 3)));
    }
    assertEquals(100, bc.getCardinality());
    assertEquals(100, rc.getCardinality());
  }


  @Test
  public void union2() {
    System.out.println("union2");
    ArrayContainer ac = new ArrayContainer();
    RunContainer rc = new RunContainer();
    for (int k = 0; k < 100; ++k) {
      ac = (ArrayContainer) ac.add((char) (k * 10));
      rc = (RunContainer) rc.add((char) (k * 10 + 3));
    }
    Container union = rc.or(ac);
    assertEquals(200, union.getCardinality());
    for (int k = 0; k < 100; ++k) {
      assertTrue(union.contains((char) (k * 10)));
      assertTrue(union.contains((char) (k * 10 + 3)));
    }
    assertEquals(100, ac.getCardinality());
    assertEquals(100, rc.getCardinality());
  }


  @Test
  public void xor() {
    Container bc = new BitmapContainer();
    Container rc = new RunContainer();
    for (int k = 0; k < 2 * DEFAULT_MAX_SIZE; ++k) {
      bc = bc.add((char) (k * 10));
      bc = bc.add((char) (k * 10 + 1));
      rc = rc.add((char) (k * 10));
      rc = rc.add((char) (k * 10 + 3));
    }
    Container result = rc.xor(bc);
    assertEquals(4 * DEFAULT_MAX_SIZE, result.getCardinality());
    for (int k = 0; k < 2 * DEFAULT_MAX_SIZE; ++k) {
      assertTrue(result.contains((char) (k * 10 + 1)));
      assertTrue(result.contains((char) (k * 10 + 3)));
    }
    assertEquals(4 * DEFAULT_MAX_SIZE, bc.getCardinality());
    assertEquals(4 * DEFAULT_MAX_SIZE, rc.getCardinality());
  }


  @Test
  public void xor_array() {
    Container bc = new ArrayContainer();
    Container rc = new RunContainer();
    for (int k = 0; k < 2 * DEFAULT_MAX_SIZE; ++k) {
      bc = bc.add((char) (k * 10));
      bc = bc.add((char) (k * 10 + 1));
      rc = rc.add((char) (k * 10));
      rc = rc.add((char) (k * 10 + 3));
    }
    Container result = rc.xor(bc);
    assertEquals(4 * DEFAULT_MAX_SIZE, result.getCardinality());
    for (int k = 0; k < 2 * DEFAULT_MAX_SIZE; ++k) {
      assertTrue(result.contains((char) (k * 10 + 1)));
      assertTrue(result.contains((char) (k * 10 + 3)));
    }
    assertEquals(4 * DEFAULT_MAX_SIZE, bc.getCardinality());
    assertEquals(4 * DEFAULT_MAX_SIZE, rc.getCardinality());
  }



  @Test
  public void xor_array_largecase_runcontainer_best() {
    Container bc = new ArrayContainer();
    Container rc = new RunContainer();
    for (int k = 0; k < 60; ++k) {
      for (int j = 0; j < 99; ++j) {
        rc = rc.add((char) (k * 100 + j)); // most efficiently stored as runs
        bc = bc.add((char) (k * 100 + 98)).add((char) (k * 100 + 99));
      }
    }

    // size ordering preference for rc: run, bitmap, array

    assertTrue(bc instanceof ArrayContainer);
    assertTrue(rc instanceof RunContainer);
    int rcSize = rc.getCardinality();
    int bcSize = bc.getCardinality();

    Container result = rc.xor(bc);

    // input containers should not change (just check card)
    assertEquals(rcSize, rc.getCardinality());
    assertEquals(bcSize, bc.getCardinality());

    // each group of 60, we gain the missing 99th value but lose the 98th. Net wash
    assertEquals(rcSize, result.getCardinality());

    // a runcontainer would be, space-wise, best
    // but the code may (and does) opt to produce a bitmap

    // assertTrue( result instanceof RunContainer);

    for (int k = 0; k < 60; ++k) {
      for (int j = 0; j < 98; ++j) {
        assertTrue(result.contains((char) (k * 100 + j)));
      }
      assertTrue(result.contains((char) (k * 100 + 99)));
    }
  }


  @Test
  public void xor_array_mediumcase() {
    Container bc = new ArrayContainer();
    Container rc = new RunContainer();
    for (int k = 0; k < DEFAULT_MAX_SIZE / 6; ++k) {
      rc = rc.add((char) (k * 10)); // most efficiently stored as runs
      rc = rc.add((char) (k * 10 + 1));
      rc = rc.add((char) (k * 10 + 2));
    }

    for (int k = 0; k < DEFAULT_MAX_SIZE / 12; ++k) {
      bc = bc.add((char) (k * 10));
    }

    // size ordering preference for rc: run, array, bitmap

    assertTrue(bc instanceof ArrayContainer);
    assertTrue(rc instanceof RunContainer);
    int rcSize = rc.getCardinality();
    int bcSize = bc.getCardinality();

    Container result = rc.xor(bc);

    // input containers should not change (just check card)
    assertEquals(rcSize, rc.getCardinality());
    assertEquals(bcSize, bc.getCardinality());

    assertEquals(rcSize - bcSize, result.getCardinality());

    // The result really ought to be a runcontainer, by its size
    // however, as of test writing, the implementation
    // will have converted the result to an array container.
    // This is suboptimal, storagewise, but arguably not an error

    // assertTrue( result instanceof RunContainer);

    for (int k = 0; k < DEFAULT_MAX_SIZE / 12; ++k) {
      assertTrue(result.contains((char) (k * 10 + 1)));
      assertTrue(result.contains((char) (k * 10 + 2)));
    }

    for (int k = DEFAULT_MAX_SIZE / 12; k < DEFAULT_MAX_SIZE / 6; ++k) {
      assertTrue(result.contains((char) (k * 10 + 1)));
      assertTrue(result.contains((char) (k * 10 + 2)));
    }
  }


  @Test
  public void xor_array_smallcase() {
    Container bc = new ArrayContainer();
    Container rc = new RunContainer();
    for (int k = 0; k < DEFAULT_MAX_SIZE / 3; ++k) {
      rc = rc.add((char) (k * 10)); // most efficiently stored as runs
      rc = rc.add((char) (k * 10 + 1));
      rc = rc.add((char) (k * 10 + 2));
      rc = rc.add((char) (k * 10 + 3));
      rc = rc.add((char) (k * 10 + 4));
    }

    // very small array.
    bc = bc.add((char) 1).add((char) 2).add((char) 3).add((char) 4).add((char) 5);

    assertTrue(bc instanceof ArrayContainer);
    assertTrue(rc instanceof RunContainer);
    int rcSize = rc.getCardinality();
    int bcSize = bc.getCardinality();


    Container result = rc.xor(bc);

    // input containers should not change (just check card)
    assertEquals(rcSize, rc.getCardinality());
    assertEquals(bcSize, bc.getCardinality());

    assertEquals(rcSize - 3, result.getCardinality());
    assertTrue(result.contains((char) 5));
    assertTrue(result.contains((char) 0));


    for (int k = 1; k < DEFAULT_MAX_SIZE / 3; ++k) {
      for (int i = 0; i < 5; ++i) {
        assertTrue(result.contains((char) (k * 10 + i)));
      }
    }
  }

  @Test
  public void xor1() {
    Container bc = new BitmapContainer();
    Container rc = new RunContainer();
    rc.add((char) 1);
    Container result = rc.xor(bc);
    assertEquals(1, result.getCardinality());
    assertTrue(result.contains((char) 1));
  }

  @Test
  public void xor1a() {
    Container bc = new ArrayContainer();
    Container rc = new RunContainer();
    rc.add((char) 1);
    Container result = rc.xor(bc);
    assertEquals(1, result.getCardinality());
    assertTrue(result.contains((char) 1));
  }


  @Test
  public void xor2() {
    Container bc = new BitmapContainer();
    Container rc = new RunContainer();
    bc.add((char) 1);
    Container result = rc.xor(bc);
    assertEquals(1, result.getCardinality());
    assertTrue(result.contains((char) 1));
  }


  @Test
  public void xor2a() {
    Container bc = new ArrayContainer();
    Container rc = new RunContainer();
    bc.add((char) 1);
    Container result = rc.xor(bc);
    assertEquals(1, result.getCardinality());
    assertTrue(result.contains((char) 1));
  }


  @Test
  public void xor3() {
    Container bc = new BitmapContainer();
    Container rc = new RunContainer();
    rc.add((char) 1);
    bc.add((char) 1);
    Container result = rc.xor(bc);
    assertEquals(0, result.getCardinality());
  }



  @Test
  public void xor3a() {
    Container bc = new ArrayContainer();
    Container rc = new RunContainer();
    rc.add((char) 1);
    bc.add((char) 1);
    Container result = rc.xor(bc);
    assertEquals(0, result.getCardinality());
  }



  @Test
  public void xor4() {
    Container bc = new ArrayContainer();
    Container rc = new RunContainer();
    Container answer = new ArrayContainer();
    answer = answer.add(28203, 28214);
    rc = rc.add(28203, 28214);
    int[] data = {17739, 17740, 17945, 19077, 19278, 19407};
    for (int x : data) {
      answer = answer.add((char) x);
      bc = bc.add((char) x);
    }
    Container result = rc.xor(bc);
    assertEquals(answer, result);
  }

  @Test
  public void xor5() {
    Container rc1 = new RunContainer();
    Container rc2 = new RunContainer();
    rc2.iadd(1, 13);
    assertEquals(rc2, rc1.xor(rc2));
    assertEquals(rc2, rc2.xor(rc1));
  }

  @Test
  public void intersects1() {
    Container ac = new ArrayContainer();
    ac = ac.add((char) 1);
    ac = ac.add((char) 7);
    ac = ac.add((char) 13);
    ac = ac.add((char) 666);

    Container rc = new RunContainer();

    assertFalse(rc.intersects(ac));
    assertFalse(ac.intersects(rc));

    rc = rc.add((char) 1000);
    assertFalse(rc.intersects(ac));
    assertFalse(ac.intersects(rc));

    rc = rc.remove((char) 1000);
    rc = rc.add(100,200);
    rc = rc.add(300,500);
    assertFalse(rc.intersects(ac));
    assertFalse(ac.intersects(rc));

    rc = rc.add(500,1000);
    assertTrue(rc.intersects(ac));
    assertTrue(ac.intersects(rc));
  }

  @Test
  public void intersects2() {
    Container rc1 = new RunContainer();
    Container rc2 = new RunContainer();

    assertFalse(rc1.intersects(rc2));

    rc1 = rc1.add(10, 50);
    rc2 = rc2.add(100, 500);
    assertFalse(rc1.intersects(rc2));

    rc1 = rc1.add(60, 70);
    assertFalse(rc1.intersects(rc2));

    rc1 = rc1.add(600, 700);
    rc2 = rc2.add(800, 900);
    assertFalse(rc1.intersects(rc2));

    rc2 = rc2.add(30, 40);
    assertTrue(rc1.intersects(rc2));
  }

  @Test
  public void intersects3() {
    Container rc = new RunContainer();
    Container bc = new BitmapContainer();

    rc = rc.add(10, 50);
    bc = bc.add(100, 500);
    assertFalse(rc.intersects(bc));
  }

  @Test
  public void constructor1() {
    assertThrows(RuntimeException.class, () -> new RunContainer(new char[]{1, 2, 10, 3}, 5));
  }

  @Test
  public void ensureCapacity() {
    RunContainer rc = new RunContainer();
    rc.add((char) 13);
    assertTrue(rc.contains((char) 13));

    rc.ensureCapacity(10);
    assertTrue(rc.contains((char) 13));
  }

  @Test
  public void testToString() {
    Container rc = new RunContainer(32200, 35000);
    rc.add((char)-1);
    assertEquals("[32200,34999][65535,65535]", rc.toString());
  }

  @Test
  public void lazyIOR() {
    Container rc = new RunContainer();
    Container ac = new ArrayContainer();

    ac = ac.add(0, 1);
    rc = rc.lazyIOR(ac);
    assertEquals(1, rc.getCardinality());

    rc = new RunContainer();
    rc = rc.add(0, 13);
    rc = rc.lazyIOR(ac);
    assertEquals(13, rc.getCardinality());

    rc = new RunContainer();
    rc = rc.add(0, 1<<16);
    rc = rc.lazyIOR(ac);
    assertEquals(1<<16, rc.getCardinality());
  }

  @Test
  public void lazyOR() {
    Container rc = new RunContainer();
    Container ac = new ArrayContainer();

    ac = ac.add(0, 1);
    rc = rc.lazyOR(ac);
    assertEquals(1, rc.getCardinality());

    rc = new RunContainer();
    rc = rc.add(0, 13);
    rc = rc.lazyOR(ac);
    assertEquals(13, rc.getCardinality());

    rc = new RunContainer();
    rc = rc.add(0, 1<<16);
    rc = rc.lazyOR(ac);
    assertEquals(1<<16, rc.getCardinality());
  }

  @Test
  public void testLazyORFull() {
    Container rc = Container.rangeOfOnes(0, 1 << 15);
    BitmapContainer bc2 = new BitmapContainer(3210, 1 << 16);
    Container rbc = rc.lazyOR(bc2);
    assertEquals(-1, rbc.getCardinality());
    Container repaired = rbc.repairAfterLazy();
    assertEquals(1 << 16, repaired.getCardinality());
    assertTrue(repaired instanceof RunContainer);
  }

  @Test
  public void testLazyORFull2() {
    Container rc = Container.rangeOfOnes((1 << 10) - 200, 1 << 16);
    ArrayContainer ac = new ArrayContainer(0, 1 << 10);
    Container rbc = rc.lazyOR(ac);
    assertEquals(1 << 16, rbc.getCardinality());
    assertTrue(rbc instanceof RunContainer);
  }

  @Test
  public void testLazyORFull3() {
    Container rc = Container.rangeOfOnes(0, 1 << 15);
    Container rc2 = Container.rangeOfOnes(1 << 15, 1 << 16);
    Container result = rc.lazyOR(rc2);
    Container iresult = rc.lazyIOR(rc2);
    assertEquals(1 << 16, result.getCardinality());
    assertEquals(1 << 16, iresult.getCardinality());
    assertTrue(result instanceof RunContainer);
    assertTrue(iresult instanceof RunContainer);
  }

  @Test
  public void testRangeCardinality() {
    BitmapContainer bc = TestBitmapContainer.generateContainer((char) 100, (char) 10000, 5);
    RunContainer rc = new RunContainer(new char[]{7, 300, 400, 900, 1400, 2200}, 3);
    Container result = rc.or(bc);
    assertEquals(8677, result.getCardinality());
  }

  @Test
  public void testRangeCardinality2() {
    BitmapContainer bc = TestBitmapContainer.generateContainer((char) 100, (char) 10000, 5);
    bc.add((char)22345); //important case to have greater element than run container
    bc.add((char)Short.MAX_VALUE);
    RunContainer rc = new RunContainer(new char[]{7, 300, 400, 900, 1400, 18000}, 3);
    assertTrue(rc.getCardinality() > ArrayContainer.DEFAULT_MAX_SIZE);
    Container result = rc.andNot(bc);
    assertEquals(11437, result.getCardinality());
  }

  @Test
  public void testRangeCardinality3() {
    BitmapContainer bc = TestBitmapContainer.generateContainer((char) 100, (char) 10000, 5);
    RunContainer rc = new RunContainer(new char[]{7, 300, 400, 900, 1400, 5200}, 3);
    BitmapContainer result = (BitmapContainer) rc.and(bc);
    assertEquals(5046, result.getCardinality());
  }

  @Test
  public void testRangeCardinality4() {
    BitmapContainer bc = TestBitmapContainer.generateContainer((char) 100, (char) 10000, 5);
    RunContainer rc = new RunContainer(new char[]{7, 300, 400, 900, 1400, 2200}, 3);
    BitmapContainer result = (BitmapContainer) rc.xor(bc);
    assertEquals(6031, result.getCardinality());
  }

  @Test
  public void testFirst_Empty() {
    assertThrows(NoSuchElementException.class, () -> new RunContainer().first());
  }

  @Test
  public void testLast_Empty() {
    assertThrows(NoSuchElementException.class, () -> new RunContainer().last());
  }

  @Test
  public void testFirstLast() {
    Container rc = new RunContainer();
    final int firstInclusive = 1;
    int lastExclusive = firstInclusive;
    for (int i = 0; i < 1 << 16 - 10; ++i) {
      int newLastExclusive = lastExclusive + 10;
      rc = rc.add(lastExclusive, newLastExclusive);
      assertEquals(firstInclusive, rc.first());
      assertEquals(newLastExclusive - 1, rc.last());
      lastExclusive = newLastExclusive;
    }
  }

  @Test
  public void testFirstUnsigned() {
    RoaringBitmap roaringWithRun = new RoaringBitmap();
    roaringWithRun.add(32768L, 65536); // (1 << 15) to (1 << 16).
    assertEquals(roaringWithRun.first(), 32768);
  }

  @Test
  public void testContainsBitmapContainer_EmptyContainsEmpty() {
    Container rc = new RunContainer();
    Container subset = new BitmapContainer();
    assertTrue(rc.contains(subset));
  }

  @Test
  public void testContainsBitmapContainer_IncludeProperSubset() {
    Container rc = new RunContainer().add(0,10);
    Container subset = new BitmapContainer().add(0,9);
    assertTrue(rc.contains(subset));
  }


  @Test
  public void testContainsBitmapContainer_IncludeProperSubsetDifferentStart() {
    Container rc = new RunContainer().add(0,10);
    Container subset = new BitmapContainer().add(1,9);
    assertTrue(rc.contains(subset));
  }

  @Test
  public void testContainsBitmapContainer_ExcludeShiftedSet() {
    Container rc = new RunContainer().add(0,10);
    Container subset = new BitmapContainer().add(2,12);
    assertFalse(rc.contains(subset));
  }

  @Test
  public void testContainsBitmapContainer_IncludeSelf() {
    Container rc = new RunContainer().add(0,10);
    Container subset = new BitmapContainer().add(0,10);
    assertTrue(rc.contains(subset));
  }

  @Test
  public void testContainsBitmapContainer_ExcludeSuperSet() {
    Container rc = new RunContainer().add(0,10);
    Container superset = new BitmapContainer().add(0,20);
    assertFalse(rc.contains(superset));
  }

  @Test
  public void testContainsBitmapContainer_ExcludeDisJointSet() {
    Container rc = new RunContainer().add(0,10);
    Container disjoint = new BitmapContainer().add(20, 40);
    assertFalse(rc.contains(disjoint));
    assertFalse(disjoint.contains(rc));
  }

  @Test
  public void testContainsRunContainer_EmptyContainsEmpty() {
    Container rc = new RunContainer();
    Container subset = new RunContainer();
    assertTrue(rc.contains(subset));
  }

  @Test
  public void testContainsRunContainer_IncludeProperSubset() {
    Container rc = new RunContainer().add(0,10);
    Container subset = new RunContainer().add(0,9);
    assertTrue(rc.contains(subset));
  }

  @Test
  public void testContainsRunContainer_IncludeSelf() {
    Container rc = new RunContainer().add(0,10);
    Container subset = new RunContainer().add(0,10);
    assertTrue(rc.contains(subset));
  }

  @Test
  public void testContainsRunContainer_ExcludeSuperSet() {
    Container rc = new RunContainer().add(0,10);
    Container superset = new RunContainer().add(0,20);
    assertFalse(rc.contains(superset));
  }

  @Test
  public void testContainsRunContainer_IncludeProperSubsetDifferentStart() {
    Container rc = new RunContainer().add(0,10);
    Container subset = new RunContainer().add(1,9);
    assertTrue(rc.contains(subset));
  }

  @Test
  public void testContainsRunContainer_ExcludeShiftedSet() {
    Container rc = new RunContainer().add(0,10);
    Container subset = new RunContainer().add(2,12);
    assertFalse(rc.contains(subset));
  }

  @Test
  public void testContainsRunContainer_ExcludeDisJointSet() {
    Container rc = new RunContainer().add(0,10);
    Container disjoint = new RunContainer().add(20, 40);
    assertFalse(rc.contains(disjoint));
    assertFalse(disjoint.contains(rc));
  }

  @Test
  public void testContainsArrayContainer_EmptyContainsEmpty() {
    Container rc = new RunContainer();
    Container subset = new ArrayContainer();
    assertTrue(rc.contains(subset));
  }

  @Test
  public void testContainsArrayContainer_IncludeProperSubset() {
    Container rc = new RunContainer().add(0,10);
    Container subset = new ArrayContainer().add(0,9);
    assertTrue(rc.contains(subset));
  }

  @Test
  public void testContainsArrayContainer_IncludeProperSubsetDifferentStart() {
    Container rc = new RunContainer().add(0,10);
    Container subset = new ArrayContainer().add(2,9);
    assertTrue(rc.contains(subset));
  }

  @Test
  public void testContainsArrayContainer_ExcludeShiftedSet() {
    Container rc = new RunContainer().add(0,10);
    Container shifted = new ArrayContainer().add(2,12);
    assertFalse(rc.contains(shifted));
  }

  @Test
  public void testContainsArrayContainer_IncludeSelf() {
    Container rc = new RunContainer().add(0,10);
    Container subset = new ArrayContainer().add(0,10);
    assertTrue(rc.contains(subset));
  }

  @Test
  public void testContainsArrayContainer_ExcludeSuperSet() {
    Container rc = new RunContainer().add(0,10);
    Container superset = new ArrayContainer().add(0,20);
    assertFalse(rc.contains(superset));
  }

  @Test
  public void testContainsArrayContainer_ExcludeDisJointSet() {
    Container rc = new RunContainer().add(0, 10);
    Container disjoint = new ArrayContainer().add(20, 40);
    assertFalse(rc.contains(disjoint));
    assertFalse(disjoint.contains(rc));

    disjoint = new ArrayContainer().add((char)512);
    assertFalse(rc.contains(disjoint));
    assertFalse(disjoint.contains(rc));

    rc = rc.add(12,14).add(16,18).add(20,22);
    assertFalse(rc.contains(disjoint));
    assertFalse(disjoint.contains(rc));

    rc.trim();
    assertFalse(rc.contains(disjoint));
    assertFalse(disjoint.contains(rc));



  }

  @Test
  public void testEqualsArrayContainer_Equal() {
    Container rc = new RunContainer().add(0, 10);
    Container ac = new ArrayContainer().add(0, 10);
    assertEquals(rc, ac);
    assertEquals(ac, rc);
  }

  @Test
  public void testEqualsArrayContainer_NotEqual_ArrayLarger() {
    Container rc = new RunContainer().add(0, 10);
    Container ac = new ArrayContainer().add(0, 11);
    assertNotEquals(rc, ac);
    assertNotEquals(ac, rc);
  }

  @Test
  public void testEqualsArrayContainer_NotEqual_ArraySmaller() {
    Container rc = new RunContainer().add(0, 10);
    Container ac = new ArrayContainer().add(0, 9);
    assertNotEquals(rc, ac);
    assertNotEquals(ac, rc);
  }

  @Test
  public void testEqualsArrayContainer_NotEqual_ArrayShifted() {
    Container rc = new RunContainer().add(0, 10);
    Container ac = new ArrayContainer().add(1, 11);
    assertNotEquals(rc, ac);
    assertNotEquals(ac, rc);
  }

  @Test
  public void testEqualsArrayContainer_NotEqual_ArrayDiscontiguous() {
    Container rc = new RunContainer().add(0, 10);
    Container ac = new ArrayContainer().add(0, 11);
    ac.flip((char)9);
    assertNotEquals(rc, ac);
    assertNotEquals(ac, rc);
  }

  @Test
  public void testEquals_FullRunContainerWithArrayContainer() {
    Container full = new RunContainer().add(0, 1 << 16);
    assertNotEquals(full, new ArrayContainer().add(0, 10));
  }

  @Test
  public void testFullConstructor() {
    assertTrue(RunContainer.full().isFull());
  }

  @Test
  public void testRangeConstructor() {
    RunContainer c = new RunContainer(0, 1 << 16);
    assertTrue(c.isFull());
    assertEquals(65536, c.getCardinality());
  }

  @Test
  public void testRangeConstructor2() {
    RunContainer c = new RunContainer(17, 1000);
    assertEquals(983, c.getCardinality());
  }

  @Test
  public void testRangeConstructor3() {
    RunContainer a = new RunContainer(17, 45679);
    RunContainer b = new RunContainer();
    b.iadd(17, 45679);
    assertEquals(a, b);
  }

  @Test
  public void testRangeConstructor4() {
    RunContainer c = new RunContainer(0, 45679);
    assertEquals(45679, c.getCardinality());
  }

  @Test
  public void testSimpleCardinality() {
    RunContainer c = new RunContainer();
    c.add((char) 1);
    c.add((char) 17);
    assertEquals(2, c.getCardinality());
  }

  @Test
  public void testIntersectsWithRange() {
    Container container = new RunContainer().add(0, 10);
    assertTrue(container.intersects(0, 1));
    assertTrue(container.intersects(0, 101));
    assertTrue(container.intersects(0, 1 << 16));
    assertFalse(container.intersects(11, 1 << 16));
  }


  @Test
  public void testIntersectsWithRangeUnsigned() {
    Container container = new RunContainer().add(lower16Bits(-50), lower16Bits(-10));
    assertFalse(container.intersects(0, 1));
    assertTrue(container.intersects(0, lower16Bits(-40)));
    assertFalse(container.intersects(lower16Bits(-100), lower16Bits(-55)));
    //assertFalse(container.intersects(-9, 1 << 16)); // forbidden
    assertTrue(container.intersects(11, 1 << 16));
  }


  @Test
  public void testIntersectsWithRangeManyRuns() {
    Container container = new RunContainer().add(0, 10).add(lower16Bits(-50), lower16Bits(-10));
    assertTrue(container.intersects(0, 1));
    assertTrue(container.intersects(0, 101));
    assertTrue(container.intersects(0, lower16Bits(-1)));
    assertTrue(container.intersects(11, lower16Bits(-1)));
    assertTrue(container.intersects(0, lower16Bits(-40)));
    assertFalse(container.intersects(lower16Bits(-100), lower16Bits(-55)));
    assertFalse(container.intersects(lower16Bits(-9), lower16Bits(-1)));
    assertTrue(container.intersects(11, 1 << 16));
  }

  @Test
  public void testContainsFull() {
    assertTrue(RunContainer.full().contains(0, 1 << 16));
    assertFalse(RunContainer.full().flip((char)(1 << 15)).contains(0, 1 << 16));
  }

  @Test
  public void testContainsRange() {
    Container rc = new RunContainer().add(1, 100).add(5000, 10000);
    assertFalse(rc.contains(0, 100));
    assertFalse(rc.contains(0, 100000));
    assertTrue(rc.contains(1, 100));
    assertTrue(rc.contains(1, 99));
    assertTrue(rc.contains(2, 100));
    assertTrue(rc.contains(5000, 10000));
    assertTrue(rc.contains(5000, 9999));
    assertTrue(rc.contains(5001, 9999));
    assertTrue(rc.contains(5001, 10000));
    assertFalse(rc.contains(100, 5000));
    assertFalse(rc.contains(50, 5000));
    assertFalse(rc.contains(4000, 6000));
    assertFalse(rc.contains(10001, 20000));
  }

  @Test
  public void testContainsRange3() {
    Container rc = new RunContainer().add(1, 100)
            .add(300, 300)
            .add(400, 500)
            .add(502, 600)
            .add(700, 10000);
    assertFalse(rc.contains(0, 100));
    assertFalse(rc.contains(500, 600));
    assertFalse(rc.contains(501, 600));
    assertTrue(rc.contains(502, 600));
    assertFalse(rc.contains(600, 700));
    assertTrue(rc.contains(9999, 10000));
    assertFalse(rc.contains(9999, 10001));
  }

  @Test
  public void testNextValue() {
    RunContainer container = new RunContainer(new char[] { 64, 64 }, 1);
    assertEquals(64, container.nextValue((char)0));
    assertEquals(64, container.nextValue((char)64));
    assertEquals(65, container.nextValue((char)65));
    assertEquals(128, container.nextValue((char)128));
    assertEquals(-1, container.nextValue((char)129));
  }

  @Test
  public void testNextValueBetweenRuns() {
    RunContainer container = new RunContainer(new char[] { 64, 64, 256, 64 }, 2);
    assertEquals(64, container.nextValue((char)0));
    assertEquals(64, container.nextValue((char)64));
    assertEquals(65, container.nextValue((char)65));
    assertEquals(128, container.nextValue((char)128));
    assertEquals(256, container.nextValue((char)129));
    assertEquals(-1, container.nextValue((char)512));
  }

  @Test
  public void testNextValue2() {
    RunContainer container = new RunContainer(new char[] { 64, 64, 200, 300, 5000, 200 }, 3);
    assertEquals(64, container.nextValue((char)0));
    assertEquals(64, container.nextValue((char)63));
    assertEquals(64, container.nextValue((char)64));
    assertEquals(65, container.nextValue((char)65));
    assertEquals(128, container.nextValue((char)128));
    assertEquals(200, container.nextValue((char)129));
    assertEquals(200, container.nextValue((char)199));
    assertEquals(200, container.nextValue((char)200));
    assertEquals(250, container.nextValue((char)250));
    assertEquals(5000, container.nextValue((char)2500));
    assertEquals(5000, container.nextValue((char)5000));
    assertEquals(5200, container.nextValue((char)5200));
    assertEquals(-1, container.nextValue((char)5201));
  }

  @Test
  public void testPreviousValue1() {
    RunContainer container = new RunContainer(new char[] { 64, 64 }, 1);
    assertEquals(-1, container.previousValue((char)0));
    assertEquals(-1, container.previousValue((char)63));
    assertEquals(64, container.previousValue((char)64));
    assertEquals(65, container.previousValue((char)65));
    assertEquals(128, container.previousValue((char)128));
    assertEquals(128, container.previousValue((char)129));
  }

  @Test
  public void testPreviousValue2() {
    RunContainer container = new RunContainer(new char[] { 64, 64, 200, 300, 5000, 200 }, 3);
    assertEquals(-1, container.previousValue((char)0));
    assertEquals(-1, container.previousValue((char)63));
    assertEquals(64, container.previousValue((char)64));
    assertEquals(65, container.previousValue((char)65));
    assertEquals(128, container.previousValue((char)128));
    assertEquals(128, container.previousValue((char)129));
    assertEquals(128, container.previousValue((char)199));
    assertEquals(200, container.previousValue((char)200));
    assertEquals(250, container.previousValue((char)250));
    assertEquals(500, container.previousValue((char)2500));
    assertEquals(5000, container.previousValue((char)5000));
    assertEquals(5200, container.previousValue((char)5200));
  }

  @Test
  public void testPreviousValueUnsigned() {
    RunContainer container = new RunContainer(new char[] { (char)((1 << 15) | 5), (char)0, (char)((1 << 15) | 7), (char)0}, 2);
    assertEquals(-1, container.previousValue((char)((1 << 15) | 4)));
    assertEquals(((1 << 15) | 5), container.previousValue((char)((1 << 15) | 5)));
    assertEquals(((1 << 15) | 5), container.previousValue((char)((1 << 15) | 6)));
    assertEquals(((1 << 15) | 7), container.previousValue((char)((1 << 15) | 7)));
    assertEquals(((1 << 15) | 7), container.previousValue((char)((1 << 15) | 8)));
  }

  @Test
  public void testNextValueUnsigned() {
    RunContainer container = new RunContainer(new char[] { (char)((1 << 15) | 5), (char)0, (char)((1 << 15) | 7), (char)0}, 2);
    assertEquals(((1 << 15) | 5), container.nextValue((char)((1 << 15) | 4)));
    assertEquals(((1 << 15) | 5), container.nextValue((char)((1 << 15) | 5)));
    assertEquals(((1 << 15) | 7), container.nextValue((char)((1 << 15) | 6)));
    assertEquals(((1 << 15) | 7), container.nextValue((char)((1 << 15) | 7)));
    assertEquals(-1, container.nextValue((char)((1 << 15) | 8)));
  }

  @Test
  public void testPreviousAbsentValue1() {
    Container container = new RunContainer().iadd(64, 129);
    assertEquals(0, container.previousAbsentValue((char)0));
    assertEquals(63, container.previousAbsentValue((char)63));
    assertEquals(63, container.previousAbsentValue((char)64));
    assertEquals(63, container.previousAbsentValue((char)65));
    assertEquals(63, container.previousAbsentValue((char)128));
    assertEquals(129, container.previousAbsentValue((char)129));
  }

  @Test
  public void testPreviousAbsentValue2() {
    Container container = new RunContainer().iadd(64, 129).iadd(200, 501).iadd(5000, 5201);
    assertEquals(0, container.previousAbsentValue((char)0));
    assertEquals(63, container.previousAbsentValue((char)63));
    assertEquals(63, container.previousAbsentValue((char)64));
    assertEquals(63, container.previousAbsentValue((char)65));
    assertEquals(63, container.previousAbsentValue((char)128));
    assertEquals(129, container.previousAbsentValue((char)129));
    assertEquals(199, container.previousAbsentValue((char)199));
    assertEquals(199, container.previousAbsentValue((char)200));
    assertEquals(199, container.previousAbsentValue((char)250));
    assertEquals(2500, container.previousAbsentValue((char)2500));
    assertEquals(4999, container.previousAbsentValue((char)5000));
    assertEquals(4999, container.previousAbsentValue((char)5200));
  }

  @Test
  public void testPreviousAbsentValueEmpty() {
    RunContainer container = new RunContainer();
    for (int i = 0; i < 1000; i++) {
      assertEquals(i, container.previousAbsentValue((char)i));
    }
  }

  @Test
  public void testPreviousAbsentValueSparse() {
    RunContainer container = new RunContainer(new char[] { 10, 0, 20, 0, 30, 0}, 3);
    assertEquals(9, container.previousAbsentValue((char)9));
    assertEquals(9, container.previousAbsentValue((char)10));
    assertEquals(11, container.previousAbsentValue((char)11));
    assertEquals(21, container.previousAbsentValue((char)21));
    assertEquals(29, container.previousAbsentValue((char)30));
  }

  @Test
  public void testPreviousAbsentEvenBits() {
    char[] evenBits = new char[1 << 15];
    for (int i = 0; i < 1 << 15; i += 2) {
      evenBits[i] = (char) i;
      evenBits[i + 1] = 0;
    }

    RunContainer container = new RunContainer(evenBits, 1 << 14);
    for (int i = 0; i < 1 << 10; i+=2) {
      assertEquals(i - 1, container.previousAbsentValue((char)i));
      assertEquals(i + 1, container.previousAbsentValue((char)(i+1)));
    }
  }

  @Test
  public void testPreviousAbsentValueUnsigned() {
    RunContainer container = new RunContainer(new char[] { (char)((1 << 15) | 5), 0, (char)((1 << 15) | 7), 0}, 2);
    assertEquals(((1 << 15) | 4), container.previousAbsentValue((char)((1 << 15) | 4)));
    assertEquals(((1 << 15) | 4), container.previousAbsentValue((char)((1 << 15) | 5)));
    assertEquals(((1 << 15) | 6), container.previousAbsentValue((char)((1 << 15) | 6)));
    assertEquals(((1 << 15) | 6), container.previousAbsentValue((char)((1 << 15) | 7)));
    assertEquals(((1 << 15) | 8), container.previousAbsentValue((char)((1 << 15) | 8)));
  }


  @Test
  public void testNextAbsentValue1() {
    Container container = new RunContainer().iadd(64, 129);
    assertEquals(0, container.nextAbsentValue((char)0));
    assertEquals(63, container.nextAbsentValue((char)63));
    assertEquals(129, container.nextAbsentValue((char)64));
    assertEquals(129, container.nextAbsentValue((char)65));
    assertEquals(129, container.nextAbsentValue((char)128));
    assertEquals(129, container.nextAbsentValue((char)129));
  }

  @Test
  public void testNextAbsentValue2() {
    Container container = new RunContainer().iadd(64, 129).iadd(200, 501).iadd(5000, 5201);
    assertEquals(0, container.nextAbsentValue((char)0));
    assertEquals(63, container.nextAbsentValue((char)63));
    assertEquals(129, container.nextAbsentValue((char)64));
    assertEquals(129, container.nextAbsentValue((char)65));
    assertEquals(129, container.nextAbsentValue((char)128));
    assertEquals(129, container.nextAbsentValue((char)129));
    assertEquals(199, container.nextAbsentValue((char)199));
    assertEquals(501, container.nextAbsentValue((char)200));
    assertEquals(501, container.nextAbsentValue((char)250));
    assertEquals(2500, container.nextAbsentValue((char)2500));
    assertEquals(5201, container.nextAbsentValue((char)5000));
    assertEquals(5201, container.nextAbsentValue((char)5200));
  }

  @Test
  public void testNextAbsentValueEmpty() {
    RunContainer container = new RunContainer();
    for (int i = 0; i < 1000; i++) {
      assertEquals(i, container.nextAbsentValue((char)i));
    }
  }

  @Test
  public void testNextAbsentValueSparse() {
    Container container = new RunContainer(new char[] { 10, 0, 20, 0, 30, 0}, 3);
    assertEquals(9, container.nextAbsentValue((char)9));
    assertEquals(11, container.nextAbsentValue((char)10));
    assertEquals(11, container.nextAbsentValue((char)11));
    assertEquals(21, container.nextAbsentValue((char)21));
    assertEquals(31, container.nextAbsentValue((char)30));
  }

  @Test
  public void testNextAbsentEvenBits() {
    char[] evenBits = new char[1 << 15];
    for (int i = 0; i < 1 << 15; i += 2) {
      evenBits[i] = (char) i;
      evenBits[i + 1] = 0;
    }

    RunContainer container = new RunContainer(evenBits, 1 << 14);
    for (int i = 0; i < 1 << 10; i+=2) {
      assertEquals(i + 1, container.nextAbsentValue((char)i));
      assertEquals(i + 1, container.nextAbsentValue((char)(i+1)));
    }
  }

  @Test
  public void testNextAbsentValueUnsigned() {
    RunContainer container = new RunContainer(new char[] { (char)((1 << 15) | 5), 0, (char)((1 << 15) | 7), 0}, 2);
    assertEquals(((1 << 15) | 4), container.nextAbsentValue((char)((1 << 15) | 4)));
    assertEquals(((1 << 15) | 6), container.nextAbsentValue((char)((1 << 15) | 5)));
    assertEquals(((1 << 15) | 6), container.nextAbsentValue((char)((1 << 15) | 6)));
    assertEquals(((1 << 15) | 8), container.nextAbsentValue((char)((1 << 15) | 7)));
    assertEquals(((1 << 15) | 8), container.nextAbsentValue((char)((1 << 15) | 8)));
  }

  @Test
  public void testContains() {
    RunContainer rc = new RunContainer(new char[]{23, 24}, 1);
    assertFalse(rc.contains(48, 49));
  }

  @Test
  public void testIntersects() {
    RunContainer rc = new RunContainer(new char[]{41, 15, 215, 0, 217, 2790, 3065, 170, 3269, 422, 3733, 43, 3833, 16, 3852, 7, 3662, 3, 3901, 2}, 10);
    assertFalse(rc.intersects(57, 215));
  }

  @Test
  public void testRangeConsumer() {
    char[] entries = new char[] {3, 4, 7, 8, 10, 65530, 65534, 65535};
    RunContainer container = new RunContainer();
    container.iadd(3, 5);
    container.iadd(7, 9);
    container.add((char) 10);
    container.add((char) 65530);
    container.iadd(65534, 65536);

    ValidationRangeConsumer consumer = ValidationRangeConsumer.validate(new ValidationRangeConsumer.Value[] {
        ABSENT, ABSENT, ABSENT, PRESENT, PRESENT, ABSENT, ABSENT, PRESENT, PRESENT, ABSENT, PRESENT
    });
    container.forAllUntil(0, (char) 11, consumer);
    assertEquals(11, consumer.getNumberOfValuesConsumed());

    ValidationRangeConsumer consumer2 = ValidationRangeConsumer.validate(new ValidationRangeConsumer.Value[] {
        PRESENT, ABSENT, ABSENT, PRESENT, PRESENT
    });
    container.forAllInRange((char) 4, (char) 9, consumer2);
    assertEquals(5, consumer2.getNumberOfValuesConsumed());

    ValidationRangeConsumer consumer3 = ValidationRangeConsumer.validate(new ValidationRangeConsumer.Value[] {
        PRESENT, ABSENT, ABSENT, ABSENT, PRESENT, PRESENT
    });
    container.forAllFrom((char) 65530, consumer3);
    assertEquals(6, consumer3.getNumberOfValuesConsumed());

    ValidationRangeConsumer consumer4 = ValidationRangeConsumer.ofSize(BitmapContainer.MAX_CAPACITY);
    container.forAll(0, consumer4);
    consumer4.assertAllAbsentExcept(entries, 0);

    ValidationRangeConsumer consumer5 = ValidationRangeConsumer.ofSize(2 * BitmapContainer.MAX_CAPACITY);
    consumer5.acceptAllAbsent(0, BitmapContainer.MAX_CAPACITY);
    container.forAll(BitmapContainer.MAX_CAPACITY, consumer5);
    consumer5.assertAllAbsentExcept(entries, BitmapContainer.MAX_CAPACITY);

    // Completely Empty
    container = new RunContainer();
    ValidationRangeConsumer consumer6 = ValidationRangeConsumer.ofSize(BitmapContainer.MAX_CAPACITY);
    container.forAll(0, consumer6);
    consumer6.assertAllAbsent();

    // Completely Full
    container = new RunContainer();
    container.iadd(0, BitmapContainer.MAX_CAPACITY);
    ValidationRangeConsumer consumer7 = ValidationRangeConsumer.ofSize(BitmapContainer.MAX_CAPACITY);
    container.forAll(0, consumer7);
    consumer7.assertAllPresent();

    int middle = BitmapContainer.MAX_CAPACITY / 2;
    ValidationRangeConsumer consumer8 = ValidationRangeConsumer.ofSize(middle);
    container.forAllFrom((char) middle, consumer8);
    consumer8.assertAllPresent();

    ValidationRangeConsumer consumer9 = ValidationRangeConsumer.ofSize(middle);
    container.forAllUntil(0, (char) middle, consumer9);
    consumer9.assertAllPresent();

    int quarter = middle / 2;
    ValidationRangeConsumer consumer10 = ValidationRangeConsumer.ofSize(middle);
    container.forAllInRange((char) quarter, (char) (middle + quarter), consumer10);
    consumer10.assertAllPresent();
  }

  private static int lower16Bits(int x) {
    return ((char)x) & 0xFFFF;
  }
}

>>> file_path: ../RoaringBitmap/RoaringBitmap/src/test/java/org/roaringbitmap/buffer/TestMappeableRunContainer.java
package org.roaringbitmap.buffer;


import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.parallel.Execution;
import org.junit.jupiter.api.parallel.ExecutionMode;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.LongBuffer;
import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.*;
import static org.roaringbitmap.buffer.MappeableBitmapContainer.MAX_CAPACITY;
import static org.roaringbitmap.buffer.TestMappeableArrayContainer.newArrayContainer;

@Execution(ExecutionMode.CONCURRENT)
public class TestMappeableRunContainer {

  protected static MappeableRunContainer generateContainer(char[] values, int numOfRuns) {
    CharBuffer array = ByteBuffer.allocateDirect(values.length * 2).asCharBuffer();
    for (char v : values) {
      array.put(v);
    }
    return new MappeableRunContainer(array, numOfRuns);
  }

  @Test
  public void constructorArray() {
    MappeableArrayContainer ac = newArrayContainer(1, 100);
    MappeableRunContainer rc = new MappeableRunContainer(ac, 1);
    assertEquals(99, rc.getCardinality());
    for (int i = 1; i < 100; i++) {
      assertTrue(rc.contains((char) i));
    }
  }

  @Test
  public void constructorBitmap() {
    LongBuffer buffer = LongBuffer.allocate(MAX_CAPACITY / 64);
    buffer.put(~0L);
    MappeableBitmapContainer bc = new MappeableBitmapContainer(buffer.asReadOnlyBuffer(), 64);
    MappeableRunContainer rc = new MappeableRunContainer(bc, 1);
    assertEquals(64, rc.getCardinality());
    for (int i = 0; i < 64; i++) {
      assertTrue(rc.contains((char) i));
    }
  }

  @Test
  public void not() {
    MappeableRunContainer rc = newRunContainer(1, 13);
    MappeableContainer result = rc.not(5, 8);
    assertEquals(9, result.getCardinality());
    for (int i = 1; i < 5; i++) {
      assertTrue(rc.contains((char) i));
    }
    for (int i = 8; i < 13; i++) {
      assertTrue(rc.contains((char) i));
    }
  }

  static MappeableRunContainer newRunContainer(int firstOfRun, final int lastOfRun) {
    CharBuffer buffer = CharBuffer.allocate(2);
    buffer.put((char) firstOfRun);
    buffer.put((char) (lastOfRun-firstOfRun-1));
    return new MappeableRunContainer(buffer.asReadOnlyBuffer(), 1);
  }

  @Test
  public void selectInvalidPosition() {
    assertThrows(IllegalArgumentException.class, () -> {
      MappeableContainer bc = new MappeableRunContainer();
      bc = bc.add(1, 13);
      bc.select(100);
    });
  }

  @Test
  public void trim() {
    MappeableContainer rc = new MappeableRunContainer(10);
    rc = rc.add(1, 5);
    rc.trim();
    assertEquals(4, rc.getCardinality());
    for (int i = 1; i < 5; i++) {
      assertTrue(rc.contains((char) i));
    }
  }

  @Test
  public void roundtrip() throws Exception {
    MappeableContainer rc = new MappeableRunContainer();
    rc = rc.add(1, 5);
    final ByteArrayOutputStream bos = new ByteArrayOutputStream();
    try (ObjectOutputStream oo = new ObjectOutputStream(bos)) {
      rc.writeExternal(oo);
    }
    MappeableContainer rc2 = new MappeableRunContainer();
    final ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
    rc2.readExternal(new ObjectInputStream(bis));

    assertEquals(4, rc2.getCardinality());
    for (int i = 1; i < 5; i++) {
      assertTrue(rc2.contains((char) i));
    }
  }

  @Test
  public void andCardinalityArray() {
    MappeableRunContainer rc = new MappeableRunContainer();
    MappeableArrayContainer ac = new MappeableArrayContainer();
    ac.iadd(15, 25);
    assertEquals(0, rc.andCardinality(ac));
    rc.iadd(10, 20);
    assertEquals(5, rc.andCardinality(ac));
    rc.iadd(24, 30);
    assertEquals(6, rc.andCardinality(ac));
  }

  @Test
  public void andCardinalityBitmap() {
    MappeableRunContainer rc = new MappeableRunContainer();
    MappeableBitmapContainer ac = new MappeableBitmapContainer();
    ac.iadd(15, 25);
    assertEquals(0, rc.andCardinality(ac));
    rc.iadd(10, 20);
    assertEquals(5, rc.andCardinality(ac));
    rc.iadd(24, 30);
    assertEquals(6, rc.andCardinality(ac));
  }

  @Test
  public void andCardinalityRun() {
    MappeableRunContainer rc1 = new MappeableRunContainer();
    MappeableRunContainer rc2 = new MappeableRunContainer();
    rc2.iadd(15, 25);
    assertEquals(0, rc1.andCardinality(rc2));
    assertEquals(0, rc2.andCardinality(rc1));
    rc1.iadd(10, 20);
    assertEquals(5, rc1.andCardinality(rc2));
    assertEquals(5, rc2.andCardinality(rc1));
    rc1.iadd(24, 30);
    assertEquals(6, rc1.andCardinality(rc2));
    assertEquals(6, rc2.andCardinality(rc1));
    rc1.iadd(55, 66);
    rc2.iadd(100, 110);
    assertEquals(6, rc1.andCardinality(rc2));
    assertEquals(6, rc2.andCardinality(rc1));
    rc1.iadd(100, 110);
    rc1.iadd(120, 130);
    rc2.iadd(130, 140);
    assertEquals(16, rc1.andCardinality(rc2));
    assertEquals(16, rc2.andCardinality(rc1));
  }

  @Test
  public void orFullToRunContainer() {
    MappeableContainer rc = MappeableContainer.rangeOfOnes(0, 1 << 15);
    MappeableBitmapContainer half = new MappeableBitmapContainer(1 << 15, 1 << 16);
    assertTrue(rc instanceof MappeableRunContainer);
    MappeableContainer result = rc.or(half);
    assertEquals(1 << 16, result.getCardinality());
    assertTrue(result instanceof MappeableRunContainer);
  }

  @Test
  public void orFullToRunContainer2() {
    MappeableContainer rc = MappeableContainer.rangeOfOnes(0, 1 << 15);
    MappeableArrayContainer half = new MappeableArrayContainer(1 << 15, 1 << 16);
    assertTrue(rc instanceof MappeableRunContainer);
    MappeableContainer result = rc.or(half);
    assertEquals(1 << 16, result.getCardinality());
    assertTrue(result instanceof MappeableRunContainer);
  }

  @Test
  public void orFullToRunContainer3() {
    MappeableContainer rc = MappeableContainer.rangeOfOnes(0, 1 << 15);
    MappeableContainer half = MappeableContainer.rangeOfOnes(1 << 15, 1 << 16);
    assertTrue(rc instanceof MappeableRunContainer);
    MappeableContainer result = rc.or(half);
    assertEquals(1 << 16, result.getCardinality());
    assertTrue(result instanceof MappeableRunContainer);
  }

  @Test
  public void testLazyORFull() {
    MappeableContainer rc = MappeableContainer.rangeOfOnes(0, 1 << 15);
    MappeableBitmapContainer bc2 = new MappeableBitmapContainer(3210, 1 << 16);
    MappeableContainer rbc = rc.lazyOR(bc2);
    assertEquals(-1, rbc.getCardinality());
    MappeableContainer repaired = rbc.repairAfterLazy();
    assertEquals(1 << 16, repaired.getCardinality());
    assertTrue(repaired instanceof MappeableRunContainer);
  }

  @Test
  public void testLazyORFull2() {
    MappeableContainer rc = MappeableContainer.rangeOfOnes((1 << 10) - 200, 1 << 16);
    MappeableArrayContainer ac = new MappeableArrayContainer(0, 1 << 10);
    MappeableContainer rbc = rc.lazyOR(ac);
    assertEquals(1 << 16, rbc.getCardinality());
    assertTrue(rbc instanceof MappeableRunContainer);
  }

  @Test
  public void testLazyORFull3() {
    MappeableContainer rc = MappeableContainer.rangeOfOnes(0, 1 << 15);
    MappeableContainer rc2 = MappeableContainer.rangeOfOnes(1 << 15, 1 << 16);
    MappeableContainer result = rc.lazyOR(rc2);
    MappeableContainer iresult = rc.lazyIOR(rc2);
    assertEquals(1 << 16, result.getCardinality());
    assertEquals(1 << 16, iresult.getCardinality());
    assertTrue(result instanceof MappeableRunContainer);
    assertTrue(iresult instanceof MappeableRunContainer);
  }

  @Test
  public void testRangeCardinality() {
    MappeableBitmapContainer bc = TestMappeableBitmapContainer.generateContainer((char) 100, (char) 10000, 5);
    MappeableRunContainer rc = generateContainer(new char[]{7, 300, 400, 900, 1400, 2200}, 3);
    MappeableContainer result = rc.or(bc);
    assertEquals(8677, result.getCardinality());
  }

  @Test
  public void testRangeCardinality2() {
    MappeableBitmapContainer bc = TestMappeableBitmapContainer.generateContainer((char) 100, (char) 10000, 5);
    bc.add((char)22345); //important case to have greater element than run container
    bc.add((char)Short.MAX_VALUE);
    MappeableRunContainer rc = generateContainer(new char[]{7, 300, 400, 900, 1400, 18000}, 3);
    assertTrue(rc.getCardinality() > MappeableArrayContainer.DEFAULT_MAX_SIZE);
    MappeableContainer result = rc.andNot(bc);
    assertEquals(11437, result.getCardinality());
  }

  @Test
  public void testRangeCardinality3() {
    MappeableBitmapContainer bc = TestMappeableBitmapContainer.generateContainer((char) 100, (char) 10000, 5);
    MappeableRunContainer rc = generateContainer(new char[]{7, 300, 400, 900, 1400, 5200}, 3);
    MappeableBitmapContainer result = (MappeableBitmapContainer) rc.and(bc);
    assertEquals(5046, result.getCardinality());
  }

  @Test
  public void testRangeCardinality4() {
    MappeableBitmapContainer bc = TestMappeableBitmapContainer.generateContainer((char) 100, (char) 10000, 5);
    MappeableRunContainer rc = generateContainer(new char[]{7, 300, 400, 900, 1400, 2200}, 3);
    MappeableBitmapContainer result = (MappeableBitmapContainer) rc.xor(bc);
    assertEquals(6031, result.getCardinality());
  }

  @Test
  public void testEqualsArrayContainer_Equal() {
    MappeableContainer rc = new MappeableRunContainer().add(0, 10);
    MappeableContainer ac = new MappeableArrayContainer().add(0, 10);
    assertTrue(rc.equals(ac));
    assertTrue(ac.equals(rc));
  }

  @Test
  public void testEqualsArrayContainer_NotEqual_ArrayLarger() {
    MappeableContainer rc = new MappeableRunContainer().add(0, 10);
    MappeableContainer ac = new MappeableArrayContainer().add(0, 11);
    assertFalse(rc.equals(ac));
    assertFalse(ac.equals(rc));
  }

  @Test
  public void testEqualsArrayContainer_NotEqual_ArraySmaller() {
    MappeableContainer rc = new MappeableRunContainer().add(0, 10);
    MappeableContainer ac = new MappeableArrayContainer().add(0, 9);
    assertFalse(rc.equals(ac));
    assertFalse(ac.equals(rc));
  }

  @Test
  public void testEqualsArrayContainer_NotEqual_ArrayShifted() {
    MappeableContainer rc = new MappeableRunContainer().add(0, 10);
    MappeableContainer ac = new MappeableArrayContainer().add(1, 11);
    assertFalse(rc.equals(ac));
    assertFalse(ac.equals(rc));
  }

  @Test
  public void testEqualsArrayContainer_NotEqual_ArrayDiscontiguous() {
    MappeableContainer rc = new MappeableRunContainer().add(0, 10);
    MappeableContainer ac = new MappeableArrayContainer().add(0, 11);
    ac.flip((char)9);
    assertFalse(rc.equals(ac));
    assertFalse(ac.equals(rc));
  }

  @Test
  public void testAndInto() {
    long[] bits = new long[1024];
    Arrays.fill(bits, 0xAAAAAAAAAAAAAAAAL);
    MappeableRunContainer container = new MappeableRunContainer();
    for (int i = 1; i < 64; i += 2) {
      container.add((char) i);
    }
    container.andInto(bits);
    assertEquals(0xAAAAAAAAAAAAAAAAL, bits[0]);
    container = new MappeableRunContainer();
    for (int i = 0; i < 64; i += 2) {
      container.add((char) i);
    }
    container.andInto(bits);
    assertEquals(0L, bits[0]);
  }

  @Test
  public void testOrInto() {
    long[] bits = new long[1024];
    Arrays.fill(bits, 0xAAAAAAAAAAAAAAAAL);
    MappeableRunContainer container = new MappeableRunContainer();
    for (int i = 1; i < 64; i += 2) {
      container.add((char) i);
    }
    container.orInto(bits);
    assertEquals(0xAAAAAAAAAAAAAAAAL, bits[0]);
    container = new MappeableRunContainer();
    for (int i = 0; i < 64; i += 2) {
      container.add((char) i);
    }
    container.orInto(bits);
    assertEquals(-1L, bits[0]);
  }
}


---------
>> The target benchmark functions are:
package org.roaringbitmap.runcontainer;

import org.openjdk.jmh.annotations.*;
import org.roaringbitmap.buffer.MappeableContainer;
import org.roaringbitmap.buffer.MappeableRunContainer;

import java.util.Random;
import java.util.concurrent.TimeUnit;

@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@Warmup(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)
@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)
public class GetCardinalityMappeableContainerBenchmark {

  @Benchmark
  public int getCardinality_negatedUniformHash(BenchmarkState state) {
    return state.mc1.getCardinality();
  }

  @Benchmark
  public int getCardinality_uniformHash1(BenchmarkState state) {
    return state.mc2.getCardinality();
  }

  @Benchmark
  public int getCardinality_uniformHash2(BenchmarkState state) {
    return state.mc3.getCardinality();
  }

  @Benchmark
  public int getCardinality_crazyRun(BenchmarkState state) {
    return state.mc4.getCardinality();
  }

  @State(Scope.Benchmark)
  public static class BenchmarkState {
    private static final int OFF_VALUES = 32;
    private static final int BIT_SET_PER_WORD2 = 63;
    private static final int BIT_SET_PER_WORD3 = 1;
    MappeableContainer mc1, mc2, mc3, mc4;

    public BenchmarkState() {
      Random rand = new Random();
      final int max = 1 << 16;
      final int howManyWords = (1 << 16) / 64;
      int[] values1 = RandomUtil.negate(RandomUtil.generateUniformHash(rand, OFF_VALUES, max), max);
      int[] values2 = RandomUtil.generateUniformHash(rand, BIT_SET_PER_WORD2 * howManyWords, max);
      int[] values3 = RandomUtil.generateUniformHash(rand, BIT_SET_PER_WORD3 * howManyWords, max);
      int[] values4 = RandomUtil.generateCrazyRun(rand, max);

      mc1 = new MappeableRunContainer();
      mc2 = new MappeableRunContainer();
      mc3 = new MappeableRunContainer();
      mc4 = new MappeableRunContainer();

      for (int i : values1) { mc1.add((char) i); }
      for (int i : values2) { mc2.add((char) i); }
      for (int i : values3) { mc3.add((char) i); }
      for (int i : values4) { mc4.add((char) i); }
    }
  }
}
