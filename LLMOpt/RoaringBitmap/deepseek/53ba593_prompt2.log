I'll analyze the performance issue and provide an optimized version of the code.

The issue states: "Avoid computing cardinality for run containers when not needed." Looking at the code, this refers to cases where we compute the cardinality of run containers unnecessarily, which can be expensive for large run containers.

The main optimization needed is in the `contains` method of `RoaringBitmap` and `MutableRoaringBitmap` classes, where we can avoid computing full container cardinality when checking if one bitmap contains another.

Here's the optimized version of the `contains` method in RoaringBitmap.java:

```java
/**
 * Checks whether the parameter is a subset of this RoaringBitmap or not
 * @param subset the potential subset
 * @return true if the parameter is a subset of this RoaringBitmap
 */
public boolean contains(RoaringBitmap subset) {
    final int length1 = this.highLowContainer.size;
    final int length2 = subset.highLowContainer.size;
    int pos1 = 0, pos2 = 0;
    while (pos1 < length1 && pos2 < length2) {
        final char s1 = this.highLowContainer.getKeyAtIndex(pos1);
        final char s2 = subset.highLowContainer.getKeyAtIndex(pos2);
        if (s1 == s2) {
            Container c1 = this.highLowContainer.getContainerAtIndex(pos1);
            Container c2 = subset.highLowContainer.getContainerAtIndex(pos2);
            
            // Optimization: For run containers, check containment directly without computing full cardinality
            if (c2 instanceof RunContainer) {
                if (!((RunContainer)c2).isSubset(c1)) {
                    return false;
                }
            } else if (!c1.contains(c2)) {
                return false;
            }
            ++pos1;
            ++pos2;
        } else if (s1 - s2 > 0) {
            return false;
        } else {
            pos1 = subset.highLowContainer.advanceUntil(s2, pos1);
        }
    }
    return pos2 == length2;
}
```

And here's the corresponding change for MutableRoaringBitmap.java:

```java
/**
 * Checks whether the parameter is a subset of this bitmap
 * @param subset the potential subset
 * @return true if the parameter is a subset of this bitmap
 */
public boolean contains(ImmutableRoaringBitmap subset) {
    final int length1 = this.highLowContainer.size();
    final int length2 = subset.highLowContainer.size();
    int pos1 = 0, pos2 = 0;
    while (pos1 < length1 && pos2 < length2) {
        final char s1 = this.highLowContainer.getKeyAtIndex(pos1);
        final char s2 = subset.highLowContainer.getKeyAtIndex(pos2);
        if (s1 == s2) {
            MappeableContainer c1 = this.highLowContainer.getContainerAtIndex(pos1);
            MappeableContainer c2 = subset.highLowContainer.getContainerAtIndex(pos2);
            
            // Optimization: For run containers, check containment directly without computing full cardinality
            if (c2 instanceof MappeableRunContainer) {
                if (!((MappeableRunContainer)c2).isSubset(c1)) {
                    return false;
                }
            } else if (!c1.contains(c2)) {
                return false;
            }
            ++pos1;
            ++pos2;
        } else if (s1 < s2) {
            pos1 = this.highLowContainer.advanceUntil(s2, pos1);
        } else {
            return false;
        }
    }
    return pos2 == length2;
}
```

The key changes are:

1. Added special handling for RunContainer/MappeableRunContainer cases
2. For run containers, use the more efficient `isSubset` method instead of computing full cardinality
3. Only fall back to the general `contains` method for non-run containers

This optimization avoids the potentially expensive cardinality computation for run containers when checking containment. The `isSubset` method for run containers can determine containment more efficiently by comparing runs directly rather than materializing all values.

The changes maintain all existing functionality while improving performance for cases involving run containers. The unit tests should continue to pass as we haven't changed the behavior, just optimized the implementation.

Note that this requires corresponding `isSubset` methods to be implemented in RunContainer and MappeableRunContainer classes if they don't already exist. Those implementations would compare the runs directly rather than converting to a full list of values.