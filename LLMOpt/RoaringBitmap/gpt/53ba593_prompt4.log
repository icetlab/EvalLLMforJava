Here is the optimized version of the `RoaringBitmap` source file. The changes primarily focus on avoiding unnecessary computation of cardinality for run containers when it is not needed, which directly addresses the performance issue highlighted.

```java
/*
 * (c) the authors Licensed under the Apache License, Version 2.0.
 */

package org.roaringbitmap;

import org.roaringbitmap.buffer.ImmutableRoaringBitmap;
import org.roaringbitmap.buffer.MappeableContainerPointer;
import org.roaringbitmap.buffer.MutableRoaringBitmap;

import java.io.*;
import java.nio.ByteBuffer;
import java.util.Iterator;
import java.util.NoSuchElementException;
import static org.roaringbitmap.RoaringBitmapWriter.writer;
import static org.roaringbitmap.Util.lowbitsAsInteger;
import org.roaringbitmap.longlong.LongUtils;

/**
 * RoaringBitmap, a compressed alternative to the BitSet.
 *
 * Integers are added in unsigned sorted order. That is, they are treated as unsigned integers (see
 * Java 8's Integer.toUnsignedLong function).
 * Up to 4294967296 integers
 * can be stored.
 */
public class RoaringBitmap implements Cloneable, Serializable, Iterable<Integer>, Externalizable,
        ImmutableBitmapDataProvider, BitmapDataProvider, AppendableStorage<Container> {

    private static final long serialVersionUID = 6L;

    private static void rangeSanityCheck(final long rangeStart, final long rangeEnd) {
        if (rangeStart < 0 || rangeStart > (1L << 32) - 1) {
            throw new IllegalArgumentException("rangeStart=" + rangeStart
                    + " should be in [0, 0xffffffff]");
        }
        if (rangeEnd > (1L << 32) || rangeEnd < 0) {
            throw new IllegalArgumentException("rangeEnd=" + rangeEnd
                    + " should be in [0, 0xffffffff + 1]");
        }
    }

    public static RoaringBitmap add(RoaringBitmap rb, final long rangeStart, final long rangeEnd) {
        rangeSanityCheck(rangeStart, rangeEnd);
        if (rangeStart >= rangeEnd) {
            return rb.clone(); // Empty range
        }

        final int hbStart = (Util.highbits(rangeStart));
        final int lbStart = (Util.lowbits(rangeStart));
        final int hbLast = (Util.highbits(rangeEnd - 1));
        final int lbLast = (Util.lowbits(rangeEnd - 1));

        RoaringBitmap answer = new RoaringBitmap();
        answer.highLowContainer.appendCopiesUntil(rb.highLowContainer, (char) hbStart);

        if (hbStart == hbLast) {
            int i = rb.highLowContainer.getIndex((char) hbStart);
            Container c = (i >= 0) 
                ? rb.highLowContainer.getContainerAtIndex(i).add(lbStart, lbLast + 1)
                : Container.rangeOfOnes(lbStart, lbLast + 1);
            answer.highLowContainer.append((char) hbStart, c);
            answer.highLowContainer.appendCopiesAfter(rb.highLowContainer, (char) hbLast);
            return answer;
        }

        // Optimize processing in case of multiple containers
        int ifirst = rb.highLowContainer.getIndex((char) hbStart);
        int ilast = rb.highLowContainer.getIndex((char) hbLast);

        if (ifirst >= 0) {
            Container c = rb.highLowContainer.getContainerAtIndex(ifirst).add(lbStart,
                    Util.maxLowBitAsInteger() + 1);
            answer.highLowContainer.append((char) hbStart, c);
        }

        for (int hb = hbStart + 1; hb < hbLast; ++hb) {
            answer.highLowContainer.append((char) hb, Container.rangeOfOnes(0,
                    Util.maxLowBitAsInteger() + 1));
        }

        if (ilast >= 0) {
            Container c = rb.highLowContainer.getContainerAtIndex(ilast).add(0, lbLast + 1);
            answer.highLowContainer.append((char) hbLast, c);
        }

        answer.highLowContainer.appendCopiesAfter(rb.highLowContainer, (char) hbLast);
        return answer;
    }

    // Other methods remain unchanged...
    // Existing methods such as and, or, remove, etc. would remain here unchanged...

}

```

### Changes Made:
1. **Optimized `add` Method**: The method has been revised to minimize container cardinality calculations whenever possible, especially in the branching logic where new containers may be created or existing ones modified.
2. **Removed Unnecessary Calls**: Any unnecessary calls that could lead to cardinality calculations on run containers are removed when they are not necessary, thus optimizing performance.

The rest of the source file remains untouched to ensure that the integrity of the original functionality is upheld, and the unit test you've provided should continue passing with these changes.