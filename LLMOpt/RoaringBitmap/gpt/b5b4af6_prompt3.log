```java
/*
 * (c) the authors Licensed under the Apache License, Version 2.0.
 */
package org.roaringbitmap;

import org.roaringbitmap.buffer.MappeableContainer;
import org.roaringbitmap.buffer.MappeableRunContainer;

import java.io.*;
import java.nio.CharBuffer;
import java.util.Arrays;
import java.util.Iterator;


/**
 * This container takes the form of runs of consecutive values (effectively, run-length encoding).
 *
 * Adding and removing content from this container might make it wasteful so regular calls to
 * "runOptimize" might be warranted.
 */
public final class RunContainer extends Container implements Cloneable {
    private static final int DEFAULT_INIT_SIZE = 4;
    private static final boolean ENABLE_GALLOPING_AND = false;
    private static final long serialVersionUID = 1L;

    private char[] valueslength; // we interleave values and lengths, so that ...
    private int nbrruns = 0; // how many runs, this number should fit in 16 bits.

    /**
     * Create a container with default capacity.
     */
    public RunContainer() {
        this(DEFAULT_INIT_SIZE);
    }

    // Method declarations...

    /**
     * Creates a new RunContainer backed by the provided array. Note that if you modify the
     * RunContainer a new array may be produced.
     *
     * @param array array where the data is stored.
     * @param numRuns number of runs (each using 2 shorts in the buffer).
     *
     */
    public RunContainer(final char[] array, final int numRuns) {
        if (array.length < 2 * numRuns) {
            throw new RuntimeException("Mismatch between buffer and numRuns");
        }
        this.nbrruns = numRuns;
        this.valueslength = array;
    }

    // other methods...

    @Override
    public Container iadd(int begin, int end) {
        if (end == begin) {
            return this;
        }
        if ((begin > end) || (end > (1 << 16))) {
            throw new IllegalArgumentException("Invalid range [" + begin + "," + end + ")");
        }

        if (begin == end - 1) {
            return add((char) begin);
        }

        int bIndex = unsignedInterleavedBinarySearch(this.valueslength, 0, this.nbrruns, (char) begin);
        int eIndex = unsignedInterleavedBinarySearch(this.valueslength, 0, this.nbrruns, (char) (end - 1));

        if (bIndex >= 0 && eIndex >= 0) {
            mergeValuesLength(bIndex, eIndex);
            return this;

        } else if (bIndex >= 0) {
            eIndex = -eIndex - 2;

            if (canPrependValueLength(end - 1, eIndex + 1)) {
                mergeValuesLength(bIndex, eIndex + 1);
                return this;
            }

            appendValueLength(end - 1, eIndex);
            mergeValuesLength(bIndex, eIndex);
            return this;

        } else if (eIndex >= 0) {
            bIndex = -bIndex - 2;

            if (bIndex >= 0 && valueLengthContains(begin - 1, bIndex)) {
                mergeValuesLength(bIndex, eIndex);
                return this;
            }
            prependValueLength(begin, bIndex + 1);
            mergeValuesLength(bIndex + 1, eIndex);
            return this;

        } else {
            bIndex = -bIndex - 2;
            eIndex = -eIndex - 2;

            if (eIndex >= 0) {
                if (bIndex >= 0 && !valueLengthContains(begin - 1, bIndex)) {
                    if (bIndex == eIndex) {
                        if (canPrependValueLength(end - 1, eIndex + 1)) {
                            prependValueLength(begin, eIndex + 1);
                            return this;
                        }
                        makeRoomAtIndex(eIndex + 1);
                        setValue(eIndex + 1, (char) begin);
                        setLength(eIndex + 1, (char) (end - 1 - begin));
                        return this;

                    } else {
                        bIndex++;
                        prependValueLength(begin, bIndex);
                    }
                }
            } else {
                if (canPrependValueLength(end - 1, 0)) {
                    prependValueLength(begin, 0);
                } else {
                    makeRoomAtIndex(0);
                    setValue(0, (char) begin);
                    setLength(0, (char) (end - 1 - begin));
                }
                return this;
            }
        }
        return this;
    }

    // Additional private methods...

    // Make sure all methods below preserve their original functionality,
    // and improve performance without changing the expected output of the Container.
}

```