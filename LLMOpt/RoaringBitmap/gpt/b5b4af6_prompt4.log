Here is the optimized version of the `RunContainer.java` file. The primary adjustment focuses on enhancing the `getCardinality()` method to improve performance by caching the cardinality instead of recalculating it every time:

```java
/*
 * (c) the authors Licensed under the Apache License, Version 2.0.
 */
package org.roaringbitmap;

import org.roaringbitmap.buffer.MappeableContainer;
import org.roaringbitmap.buffer.MappeableRunContainer;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.CharBuffer;
import java.util.Arrays;
import java.util.Iterator;


/**
 * This container takes the form of runs of consecutive values (effectively, run-length encoding).
 *
 * Adding and removing content from this container might make it wasteful so regular calls to
 * "runOptimize" might be warranted.
 */
public final class RunContainer extends Container implements Cloneable {
  private static final int DEFAULT_INIT_SIZE = 4;
  private static final boolean ENABLE_GALLOPING_AND = false;

  private static final long serialVersionUID = 1L;

  private char[] valueslength; // we interleave values and lengths
  private int nbrruns = 0; // how many runs, this number should fit in 16 bits.
  private int cardinality = -1; // Cache for cardinality.

  /**
   * Create a container with default capacity
   */
  public RunContainer() {
    this(DEFAULT_INIT_SIZE);
  }

  protected RunContainer(int capacity) {
    valueslength = new char[2 * capacity];
  }

  // Other constructors omitted for brevity...

  @Override
  public int getCardinality() {
    if (cardinality != -1) {
      return cardinality; // Return cached cardinality if already calculated.
    }
    int sum = nbrruns; // lengths are stored as -1
    for (int k = 0; k < nbrruns; ++k) {
      sum += getLength(k); // use the cached length, not recalculating.
    }
    cardinality = sum; // Cache the cardinality for future calls.
    return sum;
  }

  @Override
  public Container add(int begin, int end) {
    RunContainer rc = (RunContainer) clone();
    return rc.iadd(begin, end);
  }

  // Other methods omitted for brevity...

  @Override
  public Container remove(int begin, int end) {
    RunContainer rc = (RunContainer) clone();
    return rc.iremove(begin, end);
  }

  @Override
  public void clear() {
    nbrruns = 0;
    cardinality = -1; // Reset the cached cardinality when clearing.
  }

  @Override
  public Container clone() {
    RunContainer clone = new RunContainer(nbrruns, valueslength);
    clone.cardinality = this.cardinality; // Copy the cached cardinality.
    return clone;
  }

  // Other methods omitted for brevity...

  @Override
  public void trim() {
    if (valueslength.length != 2 * nbrruns) {
      valueslength = Arrays.copyOf(valueslength, 2 * nbrruns);
      cardinality = -1; // Invalidate the cardinality cache on resize.
    }
  }

  // Additional auxiliary methods remain unchanged.
}
```

### Key Changes Made:
1. **Cached Cardinality**: Introduced an instance variable `cardinality` to cache the result of cardinality calculations. This change means that `getCardinality()` will be faster on repeated calls.
2. **Clearing Cached Values**: The cardinality cache resets when the container is cleared (`clear()` method).
3. **Clone Method Update**: The cloning process now manages the cardinality cache, ensuring that cloned objects have the correct state.
4. **Trim Method Update**: The trim method invalidates the cardinality cache if the underlying array is resized.

These optimizations aim to reduce the overhead when calculating cardinality, especially when the method is called frequently.