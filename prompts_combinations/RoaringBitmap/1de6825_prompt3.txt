>> The source files are:
>>> file_path: ../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java
package org.roaringbitmap.art;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import org.roaringbitmap.longlong.LongUtils;

public class Node16 extends Node {

  long firstV = 0L;
  long secondV = 0L;
  Node[] children = new Node[16];

  public Node16(int compressionLength) {
    super(NodeType.NODE16, compressionLength);
  }

  @Override
  public int getChildPos(byte k) {
    byte[] firstBytes = LongUtils.toBDBytes(firstV);
    if (count <= 8) {
      return Node.binarySearch(firstBytes, 0, count, k);
    } else {
      int pos = Node.binarySearch(firstBytes, 0, 8, k);
      if (pos != ILLEGAL_IDX) {
        return pos;
      } else {
        byte[] secondBytes = LongUtils.toBDBytes(secondV);
        pos = Node.binarySearch(secondBytes, 0, (count - 8), k);
        if (pos != ILLEGAL_IDX) {
          return 8 + pos;
        } else {
          return ILLEGAL_IDX;
        }
      }
    }
  }

  @Override
  public SearchResult getNearestChildPos(byte k) {
    byte[] firstBytes = LongUtils.toBDBytes(firstV);
    if (count <= 8) {
      return Node.binarySearchWithResult(firstBytes, 0, count, k);
    } else {
      SearchResult firstResult = Node.binarySearchWithResult(
              firstBytes, 0, 8, k);
      // given the values are "in order" if we found a match or a value larger than
      // the target we are done.
      if (firstResult.outcome == SearchResult.Outcome.FOUND
              || firstResult.hasNextLargerPos()) {
        return firstResult;
      } else {
        byte[] secondBytes = LongUtils.toBDBytes(secondV);
        SearchResult secondResult = Node.binarySearchWithResult(
                secondBytes, 0, (count - 8), k);

        switch(secondResult.outcome) {
          case FOUND:
            return SearchResult.found(8 + secondResult.getKeyPos());
          case NOT_FOUND:
            int lowPos = secondResult.getNextSmallerPos();
            int highPos = secondResult.getNextLargerPos();
            // don't map -1 into the legal range by adding 8!
            if (lowPos>=0){ lowPos += 8;}
            if (highPos>=0){ highPos += 8;}

            if(firstResult.hasNextLargerPos() == false && secondResult.hasNextSmallerPos() == false)
            {
              // this happens when the result is in the gap of the two ranges, the correct
              // "smaller value" is that of first result.
              lowPos = firstResult.getNextSmallerPos();
            }

            return SearchResult.notFound( lowPos, highPos);

          default:
            throw new IllegalStateException("There only two possible search outcomes");
        }
      }
    }
  }

  @Override
  public byte getChildKey(int pos) {
    int posInLong;
    if (pos <= 7) {
      posInLong = pos;
      byte[] firstBytes = LongUtils.toBDBytes(firstV);
      return firstBytes[posInLong];
    } else {
      posInLong = pos - 8;
      byte[] secondBytes = LongUtils.toBDBytes(secondV);
      return secondBytes[posInLong];
    }
  }

  @Override
  public Node getChild(int pos) {
    return children[pos];
  }

  @Override
  public void replaceNode(int pos, Node freshOne) {
    children[pos] = freshOne;
  }

  @Override
  public int getMinPos() {
    return 0;
  }

  @Override
  public int getNextLargerPos(int pos) {
    if (pos == ILLEGAL_IDX) {
      return 0;
    }
    pos++;
    return pos < count ? pos : ILLEGAL_IDX;
  }

  @Override
  public int getMaxPos() {
    return count - 1;
  }

  @Override
  public int getNextSmallerPos(int pos) {
    if (pos == ILLEGAL_IDX) {
      return count - 1;
    }
    pos--;
    return pos >= 0 ? pos : ILLEGAL_IDX;
  }

  /**
   * insert a child into the node with the key byte
   *
   * @param node the node16 to insert into
   * @param child the child node to be inserted
   * @param key the key byte
   * @return the adaptive changed node of the parent node16
   */
  public static Node insert(Node node, Node child, byte key) {
    Node16 currentNode16 = (Node16) node;
    if (currentNode16.count < 8) {
      //first
      byte[] bytes = LongUtils.toBDBytes(currentNode16.firstV);
      bytes[currentNode16.count] = key;
      currentNode16.firstV = LongUtils.fromBDBytes(bytes);
      currentNode16.children[currentNode16.count] = child;
      sortSmallByteArray(bytes, currentNode16.children, 0, currentNode16.count);
      currentNode16.count++;
      currentNode16.firstV = LongUtils.fromBDBytes(bytes);
      return currentNode16;
    } else if (currentNode16.count < 16) {
      //second
      ByteBuffer byteBuffer = ByteBuffer.allocate(16).order(ByteOrder.BIG_ENDIAN);
      byteBuffer.putLong(currentNode16.firstV);
      byteBuffer.putLong(currentNode16.secondV);
      byteBuffer.put(currentNode16.count, key);
      currentNode16.children[currentNode16.count] = child;
      sortSmallByteArray(byteBuffer.array(), currentNode16.children, 0, currentNode16.count);
      currentNode16.count++;
      currentNode16.firstV = byteBuffer.getLong(0);
      currentNode16.secondV = byteBuffer.getLong(8);
      return currentNode16;
    } else {
      Node48 node48 = new Node48(currentNode16.prefixLength);
      byte[] firtBytes = LongUtils.toBDBytes(currentNode16.firstV);
      for (int i = 0; i < 8; i++) {
        byte v = firtBytes[i];
        int unsignedIdx = Byte.toUnsignedInt(v);
        //i won't be beyond 48
        Node48.setOneByte(unsignedIdx, (byte) i, node48.childIndex);
        node48.children[i] = currentNode16.children[i];
      }
      byte[] secondBytes = LongUtils.toBDBytes(currentNode16.secondV);
      for (int i = 8; i < currentNode16.count; i++) {
        byte v = secondBytes[i - 8];
        int unsignedIdx = Byte.toUnsignedInt(v);
        //i won't be beyond 48
        Node48.setOneByte(unsignedIdx, (byte) i, node48.childIndex);
        node48.children[i] = currentNode16.children[i];
      }
      copyPrefix(currentNode16, node48);
      node48.count = currentNode16.count;
      Node freshOne = Node48.insert(node48, child, key);
      return freshOne;
    }
  }

  @Override
  public Node remove(int pos) {
    children[pos] = null;
    ByteBuffer byteBuffer = ByteBuffer.allocate(16).order(ByteOrder.BIG_ENDIAN);
    byte[] bytes = byteBuffer.putLong(firstV).putLong(secondV).array();
    System.arraycopy(bytes, pos + 1, bytes, pos, (16 - pos - 1));
    System.arraycopy(children, pos + 1, children, pos, (16 - pos - 1));
    firstV = byteBuffer.getLong(0);
    secondV = byteBuffer.getLong(8);
    count--;
    if (count <= 3) {
      //shrink to node4
      Node4 node4 = new Node4(prefixLength);
      //copy the keys
      node4.key = (int) (firstV >> 32);
      System.arraycopy(children, 0, node4.children, 0, count);
      node4.count = count;
      copyPrefix(this, node4);
      return node4;
    }
    return this;
  }

  @Override
  public void serializeNodeBody(DataOutput dataOutput) throws IOException {
    //little endian
    dataOutput.writeLong(Long.reverseBytes(firstV));
    dataOutput.writeLong(Long.reverseBytes(secondV));
  }

  @Override
  public void serializeNodeBody(ByteBuffer byteBuffer) throws IOException {
    byteBuffer.putLong(firstV);
    byteBuffer.putLong(secondV);
  }

  @Override
  public void deserializeNodeBody(DataInput dataInput) throws IOException {
    firstV = Long.reverseBytes(dataInput.readLong());
    secondV = Long.reverseBytes(dataInput.readLong());
  }

  @Override
  public void deserializeNodeBody(ByteBuffer byteBuffer) throws IOException {
    this.firstV = byteBuffer.getLong();
    this.secondV = byteBuffer.getLong();
  }

  @Override
  public int serializeNodeBodySizeInBytes() {
    return 16;
  }

  @Override
  public void replaceChildren(Node[] children) {
    int pos = this.getNextLargerPos(ILLEGAL_IDX);
    int offset = 0;
    while (pos != ILLEGAL_IDX) {
      this.children[pos] = children[offset];
      pos = this.getNextLargerPos(pos);
      offset++;
    }
  }
}

---------
>> The unit tests are:
>>> file_path: ../RoaringBitmap/RoaringBitmap/src/test/java/org/roaringbitmap/art/Node16Test.java
package org.roaringbitmap.art;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class Node16Test {

  @Test
  public void test() {
    Node4 node4 = new Node4(0);
    //insert 4 nodes
    for (int i = 0; i < 4; i++) {
      LeafNode leafNode = new LeafNode(i, i);
      node4 = (Node4) Node4.insert(node4, leafNode, (byte) i);
    }
    //insert the fifth node
    LeafNode leafNode4 = new LeafNode(4, 4);
    Node16 node16 = (Node16) Node4.insert(node4, leafNode4, (byte) 4);
    //remove two nodes to shrink to node4
    node16 = (Node16) node16.remove(4);
    Node degenerativeNode = node16.remove(3);
    Assertions.assertTrue(degenerativeNode instanceof Node4);
    //recover to node16 by re-insert two nodes
    Node4 degenerativeNode4 = (Node4) degenerativeNode;
    Node node = Node4.insert(degenerativeNode4, leafNode4, (byte) 4);
    LeafNode leafNode3 = new LeafNode(3, 3);
    node16 = (Node16) Node4.insert(node, leafNode3, (byte) 3);

    byte key = 4;
    Assertions.assertTrue(node16.getChildPos(key) == 4);
    Assertions.assertTrue(node16.getChildKey(4) == key);
    for (int i = 5; i < 12; i++) {
      byte key1 = (byte) i;
      LeafNode leafNode = new LeafNode(i, i);
      node16 = (Node16) Node16.insert(node16, leafNode, key1);
      Assertions.assertEquals(i, node16.getChildPos(key1));
    }
    LeafNode leafNode = new LeafNode(12, 12);
    key = (byte) -2;
    node16 = (Node16) Node16.insert(node16, leafNode, key);
    Assertions.assertEquals(12, node16.getChildPos(key));
    Assertions.assertEquals(key, node16.getChildKey(12));
    leafNode = new LeafNode(13, 13);
    byte key12 = (byte) 12;
    node16 = (Node16) Node16.insert(node16, leafNode, key12);
    Assertions.assertEquals(12, node16.getChildPos(key12));
    Assertions.assertEquals(key12, node16.getChildKey(12));
    Assertions.assertEquals(13, node16.getChildPos(key));
    Assertions.assertEquals(key, node16.getChildKey(13));
  }

  @Test
  public void testGrowToNode48() {
    Node16 node16 = new Node16(0);
    LeafNode leafNode;
    for (int i = 0; i < 16; i++) {
      leafNode = new LeafNode(i, i);
      node16 = (Node16) Node16.insert(node16, leafNode, (byte) i);
    }
    leafNode = new LeafNode(16, 16);
    Node node = Node16.insert(node16, leafNode, (byte) 16);
    Assertions.assertTrue(node instanceof Node48);
    Node48 node48 = (Node48) node;
    int maxPos = node48.getMaxPos();
    Assertions.assertEquals(16, maxPos);
    int pos = node48.getChildPos((byte) 16);
    Assertions.assertEquals(maxPos, pos);
  }

  @Test
  public void testVisit() {
    Node16 node16 = new Node16(0);
    final int insertCount = 15;
    final int lastValue = insertCount - 1;

    // create the data
    for (int i = 0; i < insertCount; i++) {
      LeafNode leafNode = new LeafNode(i, i);
      node16 = (Node16) Node16.insert(node16, leafNode, (byte) i);
    }

    // check the range is as expected
    Assertions.assertEquals(0, node16.getMinPos());
    Assertions.assertEquals(lastValue, node16.getMaxPos());

    // the next larger position of each value is the + 1
    for (int i = 0; i < lastValue; i++) {
      int pos = node16.getNextLargerPos(i);
      LeafNode leafNode = (LeafNode) node16.getChild(pos);
      Assertions.assertEquals(i + 1, leafNode.getContainerIdx());
    }

    // the next smaller position of each value is the -1
    for (int i = lastValue; i >= 1; i--) {
      int pos = node16.getNextSmallerPos(i);
      LeafNode leafNode = (LeafNode) node16.getChild(pos);
      Assertions.assertEquals(i - 1, leafNode.getContainerIdx());
    }
    // there is no illegal_idx valid prior to the first
    Assertions.assertEquals(Node.ILLEGAL_IDX, node16.getNextSmallerPos(0));
  }

  @Test
  public void testDenseNonZeroBasedKeysSearch() {
    Node nodes = new Node16(0);
    final int insertCount = 15;
    final int lastValue = insertCount - 1;
    final int keyOffset = 0x20;

    // create the data
    for (int i = 0; i < insertCount; i++) {
      LeafNode leafNode = new LeafNode(i, i);
      byte key = (byte) (i + keyOffset);
      nodes = Node16.insert(nodes, leafNode, key);
    }
    // check we are testing the correct thing
    Assertions.assertTrue(nodes instanceof Node16);

    // check that searching for each key, is FOUND
    for (int i = 0; i < insertCount; i++) {
      byte key = (byte) (i + keyOffset);
      SearchResult sr = nodes.getNearestChildPos(key);

      Assertions.assertEquals(SearchResult.Outcome.FOUND, sr.outcome);
      Assertions.assertTrue(sr.hasKeyPos());
      // the positions are zero based, even though the keys values are offset
      Assertions.assertEquals(i, sr.getKeyPos());
      Assertions.assertEquals(key, nodes.getChildKey(sr.getKeyPos()));
    }

    // search before the first value "keyOffset", and surprise, nothing will be found
    SearchResult sr = nodes.getNearestChildPos((byte) (keyOffset - 1));
    Assertions.assertEquals(SearchResult.Outcome.NOT_FOUND, sr.outcome);
    Assertions.assertFalse(sr.hasKeyPos());
    Assertions.assertEquals(Node.ILLEGAL_IDX, sr.getNextSmallerPos());

    // search after the last value aka "insertCount", and surprise, nothing will be found
    sr = nodes.getNearestChildPos((byte) (keyOffset + insertCount));
    Assertions.assertEquals(SearchResult.Outcome.NOT_FOUND, sr.outcome);
    Assertions.assertFalse(sr.hasKeyPos());
    Assertions.assertEquals(Node.ILLEGAL_IDX, sr.getNextLargerPos());
  }

  @Test
  public void testSparseNonZeroBasedKeysSearch() {
    Node nodes = new Node16(0);
    final int insertCount = 15;
    final int lastValue = insertCount - 1;

    final int step = 3;
    final int keyOffset = 0x20;

    // create the data
    for (int i = 0; i < insertCount; i++) {
      LeafNode leafNode = new LeafNode(i, i);
      byte key = (byte) ((i * step) + keyOffset);
      nodes = Node16.insert(nodes, leafNode, key);
    }
    // check we are testing the correct thing
    Assertions.assertTrue(nodes instanceof Node16);

    // check that searching for each key, is FOUND
    for (int i = 0; i < insertCount; i++) {
      byte key = (byte) ((i * step) + keyOffset);
      SearchResult sr = nodes.getNearestChildPos(key);

      Assertions.assertEquals(SearchResult.Outcome.FOUND, sr.outcome);
      Assertions.assertTrue(sr.hasKeyPos());
      // the positions are zero based, even though the keys values are offset
      int keyPos = sr.getKeyPos();
      Assertions.assertEquals(i, keyPos);
      Assertions.assertEquals(key, nodes.getChildKey(sr.getKeyPos()));

      // search in the "gaps" before the key
      {
        byte bKey = (byte)(key - 1);
        sr = nodes.getNearestChildPos(bKey);
        Assertions.assertEquals(SearchResult.Outcome.NOT_FOUND, sr.outcome);
        Assertions.assertFalse(sr.hasKeyPos());

        // the value smaller than the first should be INVALID, and the rest should be the prior key
        if (i == 0) {
          Assertions.assertEquals(Node.ILLEGAL_IDX, sr.getNextSmallerPos());
        } else {
          int expect = Byte.toUnsignedInt(key) - step;
          int result = Byte.toUnsignedInt(nodes.getChildKey(sr.getNextSmallerPos()));
          Assertions.assertEquals(  expect, result);
        }
        // the NextLarger of the "key-1" should be the key
        Assertions.assertEquals(keyPos ,sr.getNextLargerPos());
        Assertions.assertEquals(key, nodes.getChildKey(sr.getNextLargerPos()));
      }

      // search in the "gaps" after the key
      {
        byte aKey = (byte) (key + 1);

        sr = nodes.getNearestChildPos(aKey);
        Assertions.assertEquals(SearchResult.Outcome.NOT_FOUND, sr.outcome);
        Assertions.assertFalse(sr.hasKeyPos());

        // the next smaller pos than "key+1" should always be key
        Assertions.assertEquals(keyPos, sr.getNextSmallerPos());
        Assertions.assertEquals(key, nodes.getChildKey(sr.getNextSmallerPos()));

        // the value larger than the last should be INVALID and the rest should be the next key
        if (i == lastValue) {
          Assertions.assertEquals(Node.ILLEGAL_IDX, sr.getNextLargerPos());
        } else {
          int expect = Byte.toUnsignedInt(key) + step;
          int result = Byte.toUnsignedInt(nodes.getChildKey(sr.getNextLargerPos()));
          Assertions.assertEquals(expect, result);
        }
      }
    }

    // search before the first value "keyOffset", and surprise, nothing will be found
    SearchResult sr = nodes.getNearestChildPos((byte) (keyOffset - 1));
    Assertions.assertEquals(SearchResult.Outcome.NOT_FOUND, sr.outcome);
    Assertions.assertFalse(sr.hasKeyPos());
    Assertions.assertEquals(Node.ILLEGAL_IDX, sr.getNextSmallerPos());

    // search after the last value aka "insertCount", and surprise, nothing will be found
    sr = nodes.getNearestChildPos((byte) (keyOffset + (insertCount * step)));
    Assertions.assertEquals(SearchResult.Outcome.NOT_FOUND, sr.outcome);
    Assertions.assertFalse(sr.hasKeyPos());
    Assertions.assertEquals(Node.ILLEGAL_IDX, sr.getNextLargerPos());
  }

  @Test
  public void testWithOffsetBeforeBytes() {
    Node nodes = new Node16(0);
    LeafNode leafNode = new LeafNode(0, 0);
    int insertCount = 16;
    int offset = 40;

    // setup data
    for (int i = 0; i < insertCount; i++) {
      nodes = Node16.insert(nodes, leafNode, (byte) (offset + i));
    }
    // check we are testing the correct data structure
    Assertions.assertTrue(nodes instanceof Node16);

    // The position of a value before the "first" value dose not exist thus ILLEGAL_IDX
    Assertions.assertEquals(Node.ILLEGAL_IDX, nodes.getNextSmallerPos(nodes.getMinPos()));

    // The position of a value after the "last" value dose not exist thus ILLEGAL_IDX
    Assertions.assertEquals(Node.ILLEGAL_IDX, nodes.getNextLargerPos(nodes.getMaxPos()));

    // so for each value in the inserted range the next of the prior should be the same as
    // the location of found current.
    int currentPos = nodes.getMinPos();
    for (int i = 1; i < (insertCount - 1); i++) {
      int nextPos = nodes.getNextLargerPos(currentPos);
      Assertions.assertEquals(nodes.getChildPos((byte) (i + offset)), nextPos);
      currentPos = nextPos;
    }

    // so for each value in the inserted range the next of the prior should be the same as
    // the location of found current.
    currentPos = nodes.getMaxPos();
    for (int i = (insertCount - 2); i > 0; i--) {
      int nextPos = nodes.getNextSmallerPos(currentPos);
      Assertions.assertEquals(nodes.getChildPos((byte) (i + offset)), nextPos);
      currentPos = nextPos;
    }
  }

  @Test
  public void testWithOffsetAndGapsBytes() {
    Node nodes = new Node16(0);
    LeafNode leafNode = new LeafNode(0, 0);
    int insertCount = 16;
    int step = 2;
    int offset = 40;

    // setup data
    for (int i = 0; i < insertCount; i++) {
      nodes = Node16.insert(nodes, leafNode, (byte) (offset + (i * step)));
    }
    // check we are testing the correct data structure
    Assertions.assertTrue(nodes instanceof Node16);

    // The position of a value before the "first" value dose not exist thus ILLEGAL_IDX
    Assertions.assertEquals(Node.ILLEGAL_IDX, nodes.getNextSmallerPos(nodes.getMinPos()));

    // The position of a value after the "last" value dose not exist thus ILLEGAL_IDX
    Assertions.assertEquals(Node.ILLEGAL_IDX, nodes.getNextLargerPos(nodes.getMaxPos()));

    // so for each value in the inserted range the next of the prior should be the same as
    // the location of found current.
    int currentPos = nodes.getMinPos();
    for (int i = 1; i < (insertCount - 1); i++) {
      int nextPos = nodes.getNextLargerPos(currentPos);
      int valKey = offset + i * step;
      Assertions.assertEquals(nodes.getChildPos((byte) valKey), nextPos);
      currentPos = nextPos;
    }

    // so for each value in the inserted range the next of the prior should be the same as
    // the location of found current.
    currentPos = nodes.getMaxPos();
    for (int i = (insertCount - 2); i > 0; i--) {
      int nextPos = nodes.getNextSmallerPos(currentPos);
      int valKey = offset + i * step;
      Assertions.assertEquals(nodes.getChildPos((byte) valKey), nextPos);
      currentPos = nextPos;
    }
  }
}


---------
>> The target benchmark functions are:
package org.roaringbitmap;

import org.openjdk.jmh.annotations.*;
import org.roaringbitmap.longlong.LongUtils;

import java.util.concurrent.TimeUnit;

@BenchmarkMode(Mode.AverageTime)
@Warmup(iterations = 3, timeUnit = TimeUnit.MILLISECONDS, time = 1000)
@Measurement(iterations = 5, timeUnit = TimeUnit.MILLISECONDS, time = 1000)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@State(Scope.Benchmark)
public class IntermediateByteArrayBenchmark {

    public long firstV = 0xaa_b3_41_23_22_25_33_43L; // some random value

    @Benchmark
    public int original() {
        byte[] firtBytes = LongUtils.toBDBytes(firstV);
        int unsignedIdx = 0;
        for (int i = 0; i < 8; i++) {
            byte v = firtBytes[i];
            unsignedIdx += Byte.toUnsignedInt(v);
            // some other stuff...
        }
        return unsignedIdx;
    }

    @Benchmark
    public int optimized() {
        int unsignedIdx = 0;
        for (int i = 0; i < 8; i++) {
            unsignedIdx += Byte.toUnsignedInt((byte) (firstV >>> ((7 - i) << 3)));
            // some other stuff...
        }
        return unsignedIdx;
    }
}

