diff --git a/common/src/main/java/io/netty/util/Recycler.java b/common/src/main/java/io/netty/util/Recycler.java
index dd7b2d73be..f91c074cbf 100644
--- a/common/src/main/java/io/netty/util/Recycler.java
+++ b/common/src/main/java/io/netty/util/Recycler.java
@@ -277,7 +277,7 @@ public abstract class Recycler<T> {
                 return null;
             }
             DefaultHandle<T> handle = handles.relaxedPoll();
-            if (null != handle) {
+            if (handle != null) {
                 handle.toClaimed();
             }
             return handle;
@@ -309,11 +309,17 @@ public abstract class Recycler<T> {
     private static final class BlockingMessageQueue<T> implements MessagePassingQueue<T> {
         private final Queue<T> deque;
         private final int maxCapacity;
+        private final java.util.concurrent.locks.ReentrantLock lock;
+        private final java.util.concurrent.locks.Condition notEmpty;
+        private final java.util.concurrent.locks.Condition notFull;
 
         BlockingMessageQueue(int maxCapacity) {
             this.maxCapacity = maxCapacity;
+            this.lock = new java.util.concurrent.locks.ReentrantLock();
+            this.notEmpty = lock.newCondition();
+            this.notFull = lock.newCondition();
             // This message passing queue is backed by an ArrayDeque instance,
-            // made thread-safe by synchronising on `this` BlockingMessageQueue instance.
+            // made thread-safe by a ReentrantLock.
             // Why ArrayDeque?
             // We use ArrayDeque instead of LinkedList or LinkedBlockingQueue because it's more space efficient.
             // We use ArrayDeque instead of ArrayList because we need the queue APIs.
@@ -325,36 +331,71 @@ public abstract class Recycler<T> {
         }
 
         @Override
-        public synchronized boolean offer(T e) {
-            if (deque.size() == maxCapacity) {
-                return false;
+        public boolean offer(T e) {
+            lock.lock();
+            try {
+                if (deque.size() == maxCapacity) {
+                    return false;
+                }
+                boolean added = deque.offer(e);
+                if (added) {
+                    notEmpty.signal();
+                }
+                return added;
+            } finally {
+                lock.unlock();
             }
-            return deque.offer(e);
         }
 
         @Override
-        public synchronized T poll() {
-            return deque.poll();
+        public T poll() {
+            lock.lock();
+            try {
+                return deque.poll();
+            } finally {
+                lock.unlock();
+            }
         }
 
         @Override
-        public synchronized T peek() {
-            return deque.peek();
+        public T peek() {
+            lock.lock();
+            try {
+                return deque.peek();
+            } finally {
+                lock.unlock();
+            }
         }
 
         @Override
-        public synchronized int size() {
-            return deque.size();
+        public int size() {
+            lock.lock();
+            try {
+                return deque.size();
+            } finally {
+                lock.unlock();
+            }
         }
 
         @Override
-        public synchronized void clear() {
-            deque.clear();
+        public void clear() {
+            lock.lock();
+            try {
+                deque.clear();
+                notFull.signalAll();
+            } finally {
+                lock.unlock();
+            }
         }
 
         @Override
-        public synchronized boolean isEmpty() {
-            return deque.isEmpty();
+        public boolean isEmpty() {
+            lock.lock();
+            try {
+                return deque.isEmpty();
+            } finally {
+                lock.unlock();
+            }
         }
 
         @Override
