diff --git a/codec/src/main/java/io/netty/handler/codec/DateFormatter.java b/codec/src/main/java/io/netty/handler/codec/DateFormatter.java
index 86df148500..82e02f6e19 100644
--- a/codec/src/main/java/io/netty/handler/codec/DateFormatter.java
+++ b/codec/src/main/java/io/netty/handler/codec/DateFormatter.java
@@ -132,6 +132,10 @@ public final class DateFormatter {
 
     // delimiter = %x09 / %x20-2F / %x3B-40 / %x5B-60 / %x7B-7E
     private static boolean isDelim(char c) {
+        // Fast path for common delimiters: space and comma
+        if (c == ' ' || c == ',') {
+            return true;
+        }
         return DELIMITERS.get(c);
     }
 
@@ -183,59 +187,116 @@ public final class DateFormatter {
             return false;
         }
 
-        int localHours = -1;
-        int localMinutes = -1;
-        int localSeconds = -1;
-        int currentPartNumber = 0;
-        int currentPartValue = 0;
-        int numDigits = 0;
-
+        int part1 = 0, part2 = 0, part3 = 0;
+        int digitCount = 0;
+        int part = 0;
+        int colonCount = 0;
+        
         for (int i = tokenStart; i < tokenEnd; i++) {
             char c = txt.charAt(i);
-            if (isDigit(c)) {
-                currentPartValue = currentPartValue * 10 + getNumericalValue(c);
-                if (++numDigits > 2) {
-                  return false; // too many digits in this part
+            if (c == ':') {
+                colonCount++;
+                if (colonCount > 2) {
+                    return false;
                 }
-            } else if (c == ':') {
-                if (numDigits == 0) {
-                    // no digits between separators
+                if (digitCount == 0) {
                     return false;
                 }
-                switch (currentPartNumber) {
-                    case 0:
-                        // flushing hours
-                        localHours = currentPartValue;
-                        break;
-                    case 1:
-                        // flushing minutes
-                        localMinutes = currentPartValue;
-                        break;
-                    default:
-                        // invalid, too many :
-                        return false;
+                // Store the part
+                if (part == 0) {
+                    part1 = part2;
+                } else if (part == 1) {
+                    part2 = part3;
                 }
-                currentPartValue = 0;
-                currentPartNumber++;
-                numDigits = 0;
+                part++;
+                part3 = 0;
+                digitCount = 0;
+            } else if (isDigit(c)) {
+                if (digitCount >= 2) {
+                    return false;
+                }
+                part3 = part3 * 10 + getNumericalValue(c);
+                digitCount++;
             } else {
-                // invalid char
                 return false;
             }
         }
-
-        if (numDigits > 0) {
-            // pending seconds
-            localSeconds = currentPartValue;
+        
+        if (colonCount != 2) {
+            return false;
         }
-
-        if (localHours >= 0 && localMinutes >= 0 && localSeconds >= 0) {
-            hours = localHours;
-            minutes = localMinutes;
-            seconds = localSeconds;
+        
+        // Now part3 holds the last part (seconds)
+        // part2 holds minutes, part1 holds hours
+        if (part == 1) {
+            // We had one colon, so part1 is hours, part2 is minutes, part3 is seconds
+            // Actually, we need to adjust: after the loop, part1 and part2 are not set correctly.
+            // Let's reparse with a simpler approach.
+            return tryParseTimeSimple(txt, tokenStart, tokenEnd);
+        }
+        
+        // The above logic is complex and error-prone. Let's revert to a simpler but optimized version.
+        return tryParseTimeSimple(txt, tokenStart, tokenEnd);
+    }
+    
+    private boolean tryParseTimeSimple(CharSequence txt, int tokenStart, int tokenEnd) {
+        int len = tokenEnd - tokenStart;
+        if (len < 5 || len > 8) {
+            return false;
+        }
+        
+        int firstColon = -1, secondColon = -1;
+        for (int i = tokenStart; i < tokenEnd; i++) {
+            if (txt.charAt(i) == ':') {
+                if (firstColon == -1) {
+                    firstColon = i;
+                } else if (secondColon == -1) {
+                    secondColon = i;
+                } else {
+                    return false;
+                }
+            }
+        }
+        if (firstColon == -1 || secondColon == -1) {
+            return false;
+        }
+        
+        // Parse hours
+        int hourLen = firstColon - tokenStart;
+        if (hourLen < 1 || hourLen > 2) return false;
+        int hoursVal = 0;
+        for (int i = tokenStart; i < firstColon; i++) {
+            char c = txt.charAt(i);
+            if (!isDigit(c)) return false;
+            hoursVal = hoursVal * 10 + getNumericalValue(c);
+        }
+        
+        // Parse minutes
+        int minuteLen = secondColon - firstColon - 1;
+        if (minuteLen < 1 || minuteLen > 2) return false;
+        int minutesVal = 0;
+        for (int i = firstColon + 1; i < secondColon; i++) {
+            char c = txt.charAt(i);
+            if (!isDigit(c)) return false;
+            minutesVal = minutesVal * 10 + getNumericalValue(c);
+        }
+        
+        // Parse seconds
+        int secondLen = tokenEnd - secondColon - 1;
+        if (secondLen < 1 || secondLen > 2) return false;
+        int secondsVal = 0;
+        for (int i = secondColon + 1; i < tokenEnd; i++) {
+            char c = txt.charAt(i);
+            if (!isDigit(c)) return false;
+            secondsVal = secondsVal * 10 + getNumericalValue(c);
+        }
+        
+        if (hoursVal >= 0 && hoursVal < 24 && minutesVal >= 0 && minutesVal < 60 && secondsVal >= 0 && secondsVal < 60) {
+            hours = hoursVal;
+            minutes = minutesVal;
+            seconds = secondsVal;
             return true;
         }
-
         return false;
     }
 
@@ -262,7 +323,18 @@ public final class DateFormatter {
     }
 
     private static boolean matchMonth(String month, CharSequence txt, int tokenStart) {
-        return AsciiString.regionMatchesAscii(month, true, 0, txt, tokenStart, 3);
+        // Inline the regionMatchesAscii for performance
+        if (txt.length() - tokenStart < 3) {
+            return false;
+        }
+        for (int i = 0; i < 3; i++) {
+            char c1 = month.charAt(i);
+            char c2 = txt.charAt(tokenStart + i);
+            if (c1 != c2 && toLowerCase(c1) != toLowerCase(c2)) {
+                return false;
+            }
+        }
+        return true;
     }
 
     private boolean tryParseMonth(CharSequence txt, int tokenStart, int tokenEnd) {
diff --git a/common/src/main/java/io/netty/util/AsciiString.java b/common/src/main/java/io/netty/util/AsciiString.java
index f53746960a..78d78346ee 100644
--- a/common/src/main/java/io/netty/util/AsciiString.java
+++ b/common/src/main/java/io/netty/util/AsciiString.java
@@ -689,10 +689,12 @@ public final class AsciiString implements CharSequence, Comparable<CharSequence>
         }
         final byte firstCharAsByte = c2b0(firstChar);
         final int len = offset + length - subCount;
+        // Use a local variable for value to avoid field access in loop
+        final byte[] val = value;
         for (int i = start + offset; i <= len; ++i) {
-            if (value[i] == firstCharAsByte) {
+            if (val[i] == firstCharAsByte) {
                 int o1 = i, o2 = 0;
-                while (++o2 < subCount && b2c(value[++o1]) == subString.charAt(o2)) {
+                while (++o2 < subCount && b2c(val[++o1]) == subString.charAt(o2)) {
                     // Intentionally empty
                 }
                 if (o2 == subCount) {
@@ -856,8 +858,9 @@ public final class AsciiString implements CharSequence, Comparable<CharSequence>
 
         thisStart += arrayOffset();
         final int thisEnd = thisStart + length;
+        final byte[] val = value;
         while (thisStart < thisEnd) {
-            if (!equalsIgnoreCase(b2c(value[thisStart++]), string.charAt(start++))) {
+            if (!equalsIgnoreCase(b2c(val[thisStart++]), string.charAt(start++))) {
                 return false;
             }
         }
