diff --git a/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
index e657ad86f8..faa58637a4 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
@@ -60,17 +60,13 @@ public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {
     }
 
     private ByteBuf retain0(int increment) {
-        for (;;) {
-            int refCnt = this.refCnt;
-            final int nextCnt = refCnt + increment;
-
-            // Ensure we not resurrect (which means the refCnt was 0) and also that we encountered an overflow.
-            if (nextCnt <= increment) {
-                throw new IllegalReferenceCountException(refCnt, increment);
-            }
-            if (refCntUpdater.compareAndSet(this, refCnt, nextCnt)) {
-                break;
-            }
+        int prev = refCntUpdater.getAndAdd(this, increment);
+        // prev is the value before addition
+        int nextCnt = prev + increment; // Note: may overflow
+        if (prev <= 0 || nextCnt <= increment) {
+            // Rollback the increment
+            refCntUpdater.getAndAdd(this, -increment);
+            throw new IllegalReferenceCountException(prev, increment);
         }
         return this;
     }
@@ -101,13 +97,18 @@ public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {
             if (refCnt < decrement) {
                 throw new IllegalReferenceCountException(refCnt, -decrement);
             }
-
-            if (refCntUpdater.compareAndSet(this, refCnt, refCnt - decrement)) {
-                if (refCnt == decrement) {
-                    deallocate();
-                    return true;
+            if (refCnt > decrement) {
+                // Try to decrement without deallocation
+                if (refCntUpdater.compareAndSet(this, refCnt, refCnt - decrement)) {
+                    return false;
                 }
-                return false;
+                // CAS failed, retry
+                continue;
+            }
+            // refCnt == decrement
+            if (refCntUpdater.compareAndSet(this, decrement, 0)) {
+                deallocate();
+                return true;
             }
         }
     }
diff --git a/common/src/main/java/io/netty/util/AbstractReferenceCounted.java b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java
index 493bcc1872..e2ee58ed6d 100644
--- a/common/src/main/java/io/netty/util/AbstractReferenceCounted.java
+++ b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java
@@ -52,17 +52,13 @@ public abstract class AbstractReferenceCounted implements ReferenceCounted {
     }
 
     private ReferenceCounted retain0(int increment) {
-        for (;;) {
-            int refCnt = this.refCnt;
-            final int nextCnt = refCnt + increment;
-
-            // Ensure we not resurrect (which means the refCnt was 0) and also that we encountered an overflow.
-            if (nextCnt <= increment) {
-                throw new IllegalReferenceCountException(refCnt, increment);
-            }
-            if (refCntUpdater.compareAndSet(this, refCnt, nextCnt)) {
-                break;
-            }
+        int prev = refCntUpdater.getAndAdd(this, increment);
+        // prev is the value before addition
+        int nextCnt = prev + increment; // Note: may overflow
+        if (prev <= 0 || nextCnt <= increment) {
+            // Rollback the increment
+            refCntUpdater.getAndAdd(this, -increment);
+            throw new IllegalReferenceCountException(prev, increment);
         }
         return this;
     }
@@ -88,13 +84,18 @@ public abstract class AbstractReferenceCounted implements ReferenceCounted {
             if (refCnt < decrement) {
                 throw new IllegalReferenceCountException(refCnt, -decrement);
             }
-
-            if (refCntUpdater.compareAndSet(this, refCnt, refCnt - decrement)) {
-                if (refCnt == decrement) {
-                    deallocate();
-                    return true;
+            if (refCnt > decrement) {
+                // Try to decrement without deallocation
+                if (refCntUpdater.compareAndSet(this, refCnt, refCnt - decrement)) {
+                    return false;
                 }
-                return false;
+                // CAS failed, retry
+                continue;
+            }
+            // refCnt == decrement
+            if (refCntUpdater.compareAndSet(this, decrement, 0)) {
+                deallocate();
+                return true;
             }
         }
     }
