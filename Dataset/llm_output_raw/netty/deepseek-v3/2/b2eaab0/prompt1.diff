diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent.java b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
index 0a70c36401..c0fa005221 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
@@ -71,6 +71,7 @@ public final class PlatformDependent {
 
     private static final Pattern MAX_DIRECT_MEMORY_SIZE_ARG_PATTERN = Pattern.compile(
             "\\s*-XX:MaxDirectMemorySize\\s*=\\s*([0-9]+)\\s*([kKmMgG]?)\\s*$");
+    private static final Pattern BIT_PATTERN = Pattern.compile("([1-9][0-9]+)-?bit");
 
     private static final boolean IS_WINDOWS = isWindows0();
     private static final boolean IS_OSX = isOsx0();
@@ -755,59 +756,15 @@ public final class PlatformDependent {
      */
     public static int hashCodeAscii(CharSequence bytes) {
         int hash = HASH_CODE_ASCII_SEED;
-        final int remainingBytes = bytes.length() & 7;
-        // Benchmarking shows that by just naively looping for inputs 8~31 bytes long we incur a relatively large
-        // performance penalty (only achieve about 60% performance of loop which iterates over each char). So because
-        // of this we take special provisions to unroll the looping for these conditions.
-        switch (bytes.length()) {
-            case 31:
-            case 30:
-            case 29:
-            case 28:
-            case 27:
-            case 26:
-            case 25:
-            case 24:
-                hash = hashCodeAsciiCompute(bytes, bytes.length() - 24,
-                        hashCodeAsciiCompute(bytes, bytes.length() - 16,
-                          hashCodeAsciiCompute(bytes, bytes.length() - 8, hash)));
-                break;
-            case 23:
-            case 22:
-            case 21:
-            case 20:
-            case 19:
-            case 18:
-            case 17:
-            case 16:
-                hash = hashCodeAsciiCompute(bytes, bytes.length() - 16,
-                         hashCodeAsciiCompute(bytes, bytes.length() - 8, hash));
-                break;
-            case 15:
-            case 14:
-            case 13:
-            case 12:
-            case 11:
-            case 10:
-            case 9:
-            case 8:
-                hash = hashCodeAsciiCompute(bytes, bytes.length() - 8, hash);
-                break;
-            case 7:
-            case 6:
-            case 5:
-            case 4:
-            case 3:
-            case 2:
-            case 1:
-            case 0:
-                break;
-            default:
-                for (int i = bytes.length() - 8; i >= remainingBytes; i -= 8) {
-                    hash = hashCodeAsciiCompute(bytes, i, hash);
-                }
-                break;
+        final int length = bytes.length();
+        final int remainingBytes = length & 7;
+        
+        // Process 8-byte chunks
+        for (int i = length - 8; i >= remainingBytes; i -= 8) {
+            hash = hashCodeAsciiCompute(bytes, i, hash);
         }
+        
+        // Handle remaining bytes
         switch(remainingBytes) {
             case 7:
                 return ((hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(0)))
@@ -1199,7 +1156,6 @@ public final class PlatformDependent {
 
         // Last resort: guess from VM name and then fall back to most common 64-bit mode.
         String vm = SystemPropertyUtil.get("java.vm.name", "").toLowerCase(Locale.US);
-        Pattern BIT_PATTERN = Pattern.compile("([1-9][0-9]+)-?bit");
         Matcher m = BIT_PATTERN.matcher(vm);
         if (m.find()) {
             return Integer.parseInt(m.group(1));
@@ -1249,9 +1205,13 @@ public final class PlatformDependent {
         int hash = HASH_CODE_ASCII_SEED;
         final int remainingBytes = length & 7;
         final int end = startPos + remainingBytes;
+        
+        // Process 8-byte chunks using long operations
         for (int i = startPos - 8 + length; i >= end; i -= 8) {
             hash = PlatformDependent0.hashCodeAsciiCompute(getLongSafe(bytes, i), hash);
         }
+        
+        // Handle remaining bytes
         switch(remainingBytes) {
         case 7:
             return ((hash * HASH_CODE_C1 + hashCodeAsciiSanitize(bytes[startPos]))
diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
index df45d1614a..6f9c1f7fd9 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
@@ -583,6 +583,7 @@ final class PlatformDependent0 {
     }
 
     private static void copyMemoryWithSafePointPolling(long srcAddr, long dstAddr, long length) {
+        // Use loop unrolling for better performance on large copies
         while (length > 0) {
             long size = Math.min(length, UNSAFE_COPY_THRESHOLD);
             UNSAFE.copyMemory(srcAddr, dstAddr, size);
@@ -604,6 +605,7 @@ final class PlatformDependent0 {
 
     private static void copyMemoryWithSafePointPolling(
             Object src, long srcOffset, Object dst, long dstOffset, long length) {
+        // Use loop unrolling for better performance on large copies
         while (length > 0) {
             long size = Math.min(length, UNSAFE_COPY_THRESHOLD);
             UNSAFE.copyMemory(src, srcOffset, dst, dstOffset, size);
