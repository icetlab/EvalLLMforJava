diff --git a/common/src/main/java/io/netty/util/NetUtil.java b/common/src/main/java/io/netty/util/NetUtil.java
index fbe09ea676..9cc9cf22bd 100644
--- a/common/src/main/java/io/netty/util/NetUtil.java
+++ b/common/src/main/java/io/netty/util/NetUtil.java
@@ -339,22 +339,18 @@ public final class NetUtil {
         return null;
     }
 
-    private static int decimalDigit(String str, int pos) {
-        return str.charAt(pos) - '0';
-    }
+    // Method removed as it's no longer needed after inlining
 
     private static byte ipv4WordToByte(String ip, int from, int toExclusive) {
-        int ret = decimalDigit(ip, from);
-        from++;
-        if (from == toExclusive) {
+        int ret = ip.charAt(from) - '0';
+        if (++from == toExclusive) {
             return (byte) ret;
         }
-        ret = ret * 10 + decimalDigit(ip, from);
-        from++;
-        if (from == toExclusive) {
+        ret = ret * 10 + (ip.charAt(from) - '0');
+        if (++from == toExclusive) {
             return (byte) ret;
         }
-        return (byte) (ret * 10 + decimalDigit(ip, from));
+        return (byte) (ret * 10 + (ip.charAt(from) - '0'));
     }
 
     // visible for tests
@@ -556,21 +552,29 @@ public final class NetUtil {
 
     private static boolean isValidIpV4Word(CharSequence word, int from, int toExclusive) {
         int len = toExclusive - from;
-        char c0, c1, c2;
-        if (len < 1 || len > 3 || (c0 = word.charAt(from)) < '0') {
+        if (len < 1 || len > 3) {
+            return false;
+        }
+        char c0 = word.charAt(from);
+        if (c0 < '0') {
             return false;
         }
         if (len == 3) {
-            return (c1 = word.charAt(from + 1)) >= '0' &&
-                   (c2 = word.charAt(from + 2)) >= '0' &&
+            char c1 = word.charAt(from + 1);
+            char c2 = word.charAt(from + 2);
+            return c1 >= '0' && c2 >= '0' &&
                    (c0 <= '1' && c1 <= '9' && c2 <= '9' ||
                     c0 == '2' && c1 <= '5' && (c2 <= '5' || c1 < '5' && c2 <= '9'));
         }
-        return c0 <= '9' && (len == 1 || isValidNumericChar(word.charAt(from + 1)));
+        if (c0 > '9') {
+            return false;
+        }
+        return len == 1 || (word.charAt(from + 1) >= '0' && word.charAt(from + 1) <= '9');
     }
 
     private static boolean isValidHexChar(char c) {
-        return c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f';
+        // Using bitwise OR and subtraction for faster range checks
+        return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');
     }
 
     private static boolean isValidNumericChar(char c) {
@@ -624,34 +628,70 @@ public final class NetUtil {
     @SuppressWarnings("DuplicateBooleanBranch")
     private static boolean isValidIpV4Address(String ip, int from, int toExcluded) {
         int len = toExcluded - from;
-        int i;
-        return len <= 15 && len >= 7 &&
-                (i = ip.indexOf('.', from + 1)) > 0 && isValidIpV4Word(ip, from, i) &&
-                (i =  ip.indexOf('.', from = i + 2)) > 0 && isValidIpV4Word(ip, from - 1, i) &&
-                (i =  ip.indexOf('.', from = i + 2)) > 0 && isValidIpV4Word(ip, from - 1, i) &&
-                isValidIpV4Word(ip, i + 1, toExcluded);
+        if (len < 7 || len > 15) {
+            return false;
+        }
+        int i = ip.indexOf('.', from + 1);
+        if (i <= 0 || !isValidIpV4Word(ip, from, i)) {
+            return false;
+        }
+        from = i + 2;
+        i = ip.indexOf('.', from);
+        if (i <= 0 || !isValidIpV4Word(ip, from - 1, i)) {
+            return false;
+        }
+        from = i + 2;
+        i = ip.indexOf('.', from);
+        if (i <= 0 || !isValidIpV4Word(ip, from - 1, i)) {
+            return false;
+        }
+        return isValidIpV4Word(ip, i + 1, toExcluded);
     }
 
     @SuppressWarnings("DuplicateBooleanBranch")
     private static boolean isValidIpV4Address(AsciiString ip, int from, int toExcluded) {
         int len = toExcluded - from;
-        int i;
-        return len <= 15 && len >= 7 &&
-                (i = ip.indexOf('.', from + 1)) > 0 && isValidIpV4Word(ip, from, i) &&
-                (i =  ip.indexOf('.', from = i + 2)) > 0 && isValidIpV4Word(ip, from - 1, i) &&
-                (i =  ip.indexOf('.', from = i + 2)) > 0 && isValidIpV4Word(ip, from - 1, i) &&
-                isValidIpV4Word(ip, i + 1, toExcluded);
+        if (len < 7 || len > 15) {
+            return false;
+        }
+        int i = ip.indexOf('.', from + 1);
+        if (i <= 0 || !isValidIpV4Word(ip, from, i)) {
+            return false;
+        }
+        from = i + 2;
+        i = ip.indexOf('.', from);
+        if (i <= 0 || !isValidIpV4Word(ip, from - 1, i)) {
+            return false;
+        }
+        from = i + 2;
+        i = ip.indexOf('.', from);
+        if (i <= 0 || !isValidIpV4Word(ip, from - 1, i)) {
+            return false;
+        }
+        return isValidIpV4Word(ip, i + 1, toExcluded);
     }
 
     @SuppressWarnings("DuplicateBooleanBranch")
     private static boolean isValidIpV4Address0(CharSequence ip, int from, int toExcluded) {
         int len = toExcluded - from;
-        int i;
-        return len <= 15 && len >= 7 &&
-                (i = indexOf(ip, '.', from + 1)) > 0 && isValidIpV4Word(ip, from, i) &&
-                (i =  indexOf(ip, '.', from = i + 2)) > 0 && isValidIpV4Word(ip, from - 1, i) &&
-                (i =  indexOf(ip, '.', from = i + 2)) > 0 && isValidIpV4Word(ip, from - 1, i) &&
-                isValidIpV4Word(ip, i + 1, toExcluded);
+        if (len < 7 || len > 15) {
+            return false;
+        }
+        int i = indexOf(ip, '.', from + 1);
+        if (i <= 0 || !isValidIpV4Word(ip, from, i)) {
+            return false;
+        }
+        from = i + 2;
+        i = indexOf(ip, '.', from);
+        if (i <= 0 || !isValidIpV4Word(ip, from - 1, i)) {
+            return false;
+        }
+        from = i + 2;
+        i = indexOf(ip, '.', from);
+        if (i <= 0 || !isValidIpV4Word(ip, from - 1, i)) {
+            return false;
+        }
+        return isValidIpV4Word(ip, i + 1, toExcluded);
     }
 
     /**
