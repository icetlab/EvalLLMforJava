diff --git a/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
index c8c40a5d24..cde76c0164 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
@@ -1442,11 +1442,20 @@ public abstract class AbstractByteBuf extends ByteBuf {
      * if the buffer was released before.
      */
     protected final void ensureAccessible() {
-        if (checkAccessible && refCnt() == 0) {
+        if (checkAccessible && internalRefCnt() == 0) {
             throw new IllegalReferenceCountException(0);
         }
     }
 
+    /**
+     * Returns the reference count with non-volatile read semantics for performance.
+     * The default implementation returns {@link #refCnt()} (volatile read).
+     * Subclasses may override to provide a non-volatile read.
+     */
+    int internalRefCnt() {
+        return refCnt();
+    }
+
     final void setIndex0(int readerIndex, int writerIndex) {
         this.readerIndex = readerIndex;
         this.writerIndex = writerIndex;
diff --git a/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
index d624d855f4..104ef420aa 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
@@ -17,6 +17,7 @@
 package io.netty.buffer;
 
 import io.netty.util.IllegalReferenceCountException;
+import io.netty.util.internal.PlatformDependent;
 
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
@@ -29,6 +30,18 @@ public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {
 
     private static final AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> refCntUpdater =
             AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, "refCnt");
+    private static final long REF_CNT_OFFSET;
+
+    static {
+        long refCntOffset = -1;
+        try {
+            refCntOffset = PlatformDependent.objectFieldOffset(
+                    AbstractReferenceCountedByteBuf.class.getDeclaredField("refCnt"));
+        } catch (Throwable t) {
+            // Fallback to using the updater if unsafe is not available.
+        }
+        REF_CNT_OFFSET = refCntOffset;
+    }
 
     private volatile int refCnt;
 
@@ -42,6 +55,17 @@ public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {
         return refCnt;
     }
 
+    @Override
+    int internalRefCnt() {
+        // Non-volatile read for performance. This is acceptable because ensureAccessible() is best-effort.
+        if (REF_CNT_OFFSET != -1) {
+            return PlatformDependent.getInt(this, REF_CNT_OFFSET);
+        } else {
+            // Fallback to volatile read if unsafe is not available.
+            return refCnt;
+        }
+    }
+
     /**
      * An unsafe operation intended for use by a subclass that sets the reference count of the buffer directly
      */
