diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent.java b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
index 0a70c36401..416436b4c3 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
@@ -490,35 +490,34 @@ public final class PlatformDependent {
      * Identical to {@link PlatformDependent0#hashCodeAsciiCompute(long, int)} but for {@link CharSequence}.
      */
     private static int hashCodeAsciiCompute(CharSequence value, int offset, int hash) {
+        // Process 8 bytes (two ints) at once
+        int low, high;
         if (BIG_ENDIAN_NATIVE_ORDER) {
-            return hash * HASH_CODE_C1 +
-                    // Low order int
-                    hashCodeAsciiSanitizeInt(value, offset + 4) * HASH_CODE_C2 +
-                    // High order int
-                    hashCodeAsciiSanitizeInt(value, offset);
+            low = hashCodeAsciiSanitizeInt(value, offset + 4);
+            high = hashCodeAsciiSanitizeInt(value, offset);
+        } else {
+            low = hashCodeAsciiSanitizeInt(value, offset);
+            high = hashCodeAsciiSanitizeInt(value, offset + 4);
         }
-        return hash * HASH_CODE_C1 +
-                // Low order int
-                hashCodeAsciiSanitizeInt(value, offset) * HASH_CODE_C2 +
-                // High order int
-                hashCodeAsciiSanitizeInt(value, offset + 4);
+        return hash * HASH_CODE_C1 + low * HASH_CODE_C2 + high;
     }
 
     /**
      * Identical to {@link PlatformDependent0#hashCodeAsciiSanitize(int)} but for {@link CharSequence}.
      */
     private static int hashCodeAsciiSanitizeInt(CharSequence value, int offset) {
+        // Read 4 bytes and mask each with 0x1f
         if (BIG_ENDIAN_NATIVE_ORDER) {
-            // mimic a unsafe.getInt call on a big endian machine
-            return (value.charAt(offset + 3) & 0x1f) |
-                   (value.charAt(offset + 2) & 0x1f) << 8 |
-                   (value.charAt(offset + 1) & 0x1f) << 16 |
-                   (value.charAt(offset) & 0x1f) << 24;
+            return ((value.charAt(offset) & 0x1f) << 24) |
+                   ((value.charAt(offset + 1) & 0x1f) << 16) |
+                   ((value.charAt(offset + 2) & 0x1f) << 8) |
+                    (value.charAt(offset + 3) & 0x1f);
+        } else {
+            return ((value.charAt(offset + 3) & 0x1f) << 24) |
+                   ((value.charAt(offset + 2) & 0x1f) << 16) |
+                   ((value.charAt(offset + 1) & 0x1f) << 8) |
+                    (value.charAt(offset) & 0x1f);
         }
-        return (value.charAt(offset + 3) & 0x1f) << 24 |
-               (value.charAt(offset + 2) & 0x1f) << 16 |
-               (value.charAt(offset + 1) & 0x1f) << 8 |
-               (value.charAt(offset) & 0x1f);
     }
 
     /**
@@ -526,12 +525,12 @@ public final class PlatformDependent {
      */
     private static int hashCodeAsciiSanitizeShort(CharSequence value, int offset) {
         if (BIG_ENDIAN_NATIVE_ORDER) {
-            // mimic a unsafe.getShort call on a big endian machine
-            return (value.charAt(offset + 1) & 0x1f) |
-                    (value.charAt(offset) & 0x1f) << 8;
+            return ((value.charAt(offset) & 0x1f) << 8) |
+                    (value.charAt(offset + 1) & 0x1f);
+        } else {
+            return ((value.charAt(offset + 1) & 0x1f) << 8) |
+                    (value.charAt(offset) & 0x1f);
         }
-        return (value.charAt(offset + 1) & 0x1f) << 8 |
-                (value.charAt(offset) & 0x1f);
     }
 
     /**
@@ -755,79 +754,33 @@ public final class PlatformDependent {
      */
     public static int hashCodeAscii(CharSequence bytes) {
         int hash = HASH_CODE_ASCII_SEED;
-        final int remainingBytes = bytes.length() & 7;
-        // Benchmarking shows that by just naively looping for inputs 8~31 bytes long we incur a relatively large
-        // performance penalty (only achieve about 60% performance of loop which iterates over each char). So because
-        // of this we take special provisions to unroll the looping for these conditions.
-        switch (bytes.length()) {
-            case 31:
-            case 30:
-            case 29:
-            case 28:
-            case 27:
-            case 26:
-            case 25:
-            case 24:
-                hash = hashCodeAsciiCompute(bytes, bytes.length() - 24,
-                        hashCodeAsciiCompute(bytes, bytes.length() - 16,
-                          hashCodeAsciiCompute(bytes, bytes.length() - 8, hash)));
-                break;
-            case 23:
-            case 22:
-            case 21:
-            case 20:
-            case 19:
-            case 18:
-            case 17:
-            case 16:
-                hash = hashCodeAsciiCompute(bytes, bytes.length() - 16,
-                         hashCodeAsciiCompute(bytes, bytes.length() - 8, hash));
-                break;
-            case 15:
-            case 14:
-            case 13:
-            case 12:
-            case 11:
-            case 10:
-            case 9:
-            case 8:
-                hash = hashCodeAsciiCompute(bytes, bytes.length() - 8, hash);
-                break;
-            case 7:
-            case 6:
-            case 5:
-            case 4:
-            case 3:
-            case 2:
-            case 1:
-            case 0:
-                break;
-            default:
-                for (int i = bytes.length() - 8; i >= remainingBytes; i -= 8) {
-                    hash = hashCodeAsciiCompute(bytes, i, hash);
-                }
-                break;
-        }
-        switch(remainingBytes) {
+        final int length = bytes.length();
+        int remainingBytes = length & 7;
+        // Process 8 bytes at a time
+        for (int i = 0; i < length - remainingBytes; i += 8) {
+            hash = hashCodeAsciiCompute(bytes, i, hash);
+        }
+        // Process remaining bytes (0-7)
+        switch (remainingBytes) {
             case 7:
-                return ((hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(0)))
-                              * HASH_CODE_C2 + hashCodeAsciiSanitizeShort(bytes, 1))
-                              * HASH_CODE_C1 + hashCodeAsciiSanitizeInt(bytes, 3);
+                return ((hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(length - 7)))
+                              * HASH_CODE_C2 + hashCodeAsciiSanitizeShort(bytes, length - 6))
+                              * HASH_CODE_C1 + hashCodeAsciiSanitizeInt(bytes, length - 4);
             case 6:
-                return (hash * HASH_CODE_C1 + hashCodeAsciiSanitizeShort(bytes, 0))
-                             * HASH_CODE_C2 + hashCodeAsciiSanitizeInt(bytes, 2);
+                return (hash * HASH_CODE_C1 + hashCodeAsciiSanitizeShort(bytes, length - 6))
+                             * HASH_CODE_C2 + hashCodeAsciiSanitizeInt(bytes, length - 4);
             case 5:
-                return (hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(0)))
-                             * HASH_CODE_C2 + hashCodeAsciiSanitizeInt(bytes, 1);
+                return (hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(length - 5)))
+                             * HASH_CODE_C2 + hashCodeAsciiSanitizeInt(bytes, length - 4);
             case 4:
-                return hash * HASH_CODE_C1 + hashCodeAsciiSanitizeInt(bytes, 0);
+                return hash * HASH_CODE_C1 + hashCodeAsciiSanitizeInt(bytes, length - 4);
             case 3:
-                return (hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(0)))
-                             * HASH_CODE_C2 + hashCodeAsciiSanitizeShort(bytes, 1);
+                return (hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(length - 3)))
+                             * HASH_CODE_C2 + hashCodeAsciiSanitizeShort(bytes, length - 2);
             case 2:
-                return hash * HASH_CODE_C1 + hashCodeAsciiSanitizeShort(bytes, 0);
+                return hash * HASH_CODE_C1 + hashCodeAsciiSanitizeShort(bytes, length - 2);
             case 1:
-                return hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(0));
+                return hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(length - 1));
             default:
                 return hash;
         }
