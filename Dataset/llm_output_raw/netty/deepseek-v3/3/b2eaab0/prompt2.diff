diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent.java b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
index 0a70c36401..bf205a4678 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
@@ -446,44 +446,38 @@ public final class PlatformDependent {
     }
 
     private static long getLongSafe(byte[] bytes, int offset) {
+        long result = 0;
         if (BIG_ENDIAN_NATIVE_ORDER) {
-            return (long) bytes[offset] << 56 |
-                    ((long) bytes[offset + 1] & 0xff) << 48 |
-                    ((long) bytes[offset + 2] & 0xff) << 40 |
-                    ((long) bytes[offset + 3] & 0xff) << 32 |
-                    ((long) bytes[offset + 4] & 0xff) << 24 |
-                    ((long) bytes[offset + 5] & 0xff) << 16 |
-                    ((long) bytes[offset + 6] & 0xff) <<  8 |
-                    (long) bytes[offset + 7] & 0xff;
-        }
-        return (long) bytes[offset] & 0xff |
-                ((long) bytes[offset + 1] & 0xff) << 8 |
-                ((long) bytes[offset + 2] & 0xff) << 16 |
-                ((long) bytes[offset + 3] & 0xff) << 24 |
-                ((long) bytes[offset + 4] & 0xff) << 32 |
-                ((long) bytes[offset + 5] & 0xff) << 40 |
-                ((long) bytes[offset + 6] & 0xff) << 48 |
-                (long) bytes[offset + 7] << 56;
+            for (int i = 0; i < 8; i++) {
+                result = (result << 8) | (bytes[offset + i] & 0xffL);
+            }
+        } else {
+            for (int i = 7; i >= 0; i--) {
+                result = (result << 8) | (bytes[offset + i] & 0xffL);
+            }
+        }
+        return result;
     }
 
     private static int getIntSafe(byte[] bytes, int offset) {
+        int result = 0;
         if (BIG_ENDIAN_NATIVE_ORDER) {
-            return bytes[offset] << 24 |
-                    (bytes[offset + 1] & 0xff) << 16 |
-                    (bytes[offset + 2] & 0xff) << 8 |
-                    bytes[offset + 3] & 0xff;
+            for (int i = 0; i < 4; i++) {
+                result = (result << 8) | (bytes[offset + i] & 0xff);
+            }
+        } else {
+            for (int i = 3; i >= 0; i--) {
+                result = (result << 8) | (bytes[offset + i] & 0xff);
+            }
         }
-        return bytes[offset] & 0xff |
-                (bytes[offset + 1] & 0xff) << 8 |
-                (bytes[offset + 2] & 0xff) << 16 |
-                bytes[offset + 3] << 24;
+        return result;
     }
 
     private static short getShortSafe(byte[] bytes, int offset) {
         if (BIG_ENDIAN_NATIVE_ORDER) {
-            return (short) (bytes[offset] << 8 | (bytes[offset + 1] & 0xff));
+            return (short) ((bytes[offset] & 0xff) << 8 | (bytes[offset + 1] & 0xff));
         }
-        return (short) (bytes[offset] & 0xff | (bytes[offset + 1] << 8));
+        return (short) ((bytes[offset] & 0xff) | (bytes[offset + 1] & 0xff) << 8);
     }
 
     /**
@@ -755,58 +749,12 @@ public final class PlatformDependent {
      */
     public static int hashCodeAscii(CharSequence bytes) {
         int hash = HASH_CODE_ASCII_SEED;
-        final int remainingBytes = bytes.length() & 7;
-        // Benchmarking shows that by just naively looping for inputs 8~31 bytes long we incur a relatively large
-        // performance penalty (only achieve about 60% performance of loop which iterates over each char). So because
-        // of this we take special provisions to unroll the looping for these conditions.
-        switch (bytes.length()) {
-            case 31:
-            case 30:
-            case 29:
-            case 28:
-            case 27:
-            case 26:
-            case 25:
-            case 24:
-                hash = hashCodeAsciiCompute(bytes, bytes.length() - 24,
-                        hashCodeAsciiCompute(bytes, bytes.length() - 16,
-                          hashCodeAsciiCompute(bytes, bytes.length() - 8, hash)));
-                break;
-            case 23:
-            case 22:
-            case 21:
-            case 20:
-            case 19:
-            case 18:
-            case 17:
-            case 16:
-                hash = hashCodeAsciiCompute(bytes, bytes.length() - 16,
-                         hashCodeAsciiCompute(bytes, bytes.length() - 8, hash));
-                break;
-            case 15:
-            case 14:
-            case 13:
-            case 12:
-            case 11:
-            case 10:
-            case 9:
-            case 8:
-                hash = hashCodeAsciiCompute(bytes, bytes.length() - 8, hash);
-                break;
-            case 7:
-            case 6:
-            case 5:
-            case 4:
-            case 3:
-            case 2:
-            case 1:
-            case 0:
-                break;
-            default:
-                for (int i = bytes.length() - 8; i >= remainingBytes; i -= 8) {
-                    hash = hashCodeAsciiCompute(bytes, i, hash);
-                }
-                break;
+        int length = bytes.length();
+        final int remainingBytes = length & 7;
+        
+        // Process 8-byte chunks
+        for (int i = length - 8; i >= remainingBytes; i -= 8) {
+            hash = hashCodeAsciiCompute(bytes, i, hash);
         }
         switch(remainingBytes) {
             case 7:
