diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
index 8c9ad17821..3468e4ff2e 100644
--- a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
@@ -338,18 +338,18 @@ class EpollEventLoop extends SingleThreadEventLoop {
                         // Ensure we always run tasks.
                         runAllTasks();
                     }
-                } else {
+                } else if (strategy > 0) {
                     final long ioStartTime = System.nanoTime();
-
                     try {
-                        if (strategy > 0) {
-                            processReady(events, strategy);
-                        }
+                        processReady(events, strategy);
                     } finally {
                         // Ensure we always run tasks.
                         final long ioTime = System.nanoTime() - ioStartTime;
                         runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
                     }
+                } else {
+                    // No IO events, just run tasks
+                    runAllTasks(0);
                 }
                 if (allowGrowing && strategy == events.length()) {
                     //increase the size of the array as we needed the whole space for the events
@@ -396,71 +396,83 @@ class EpollEventLoop extends SingleThreadEventLoop {
 
         // Using the intermediate collection to prevent ConcurrentModificationException.
         // In the `close()` method, the channel is deleted from `channels` map.
-        AbstractEpollChannel[] localChannels = channels.values().toArray(new AbstractEpollChannel[0]);
+        // Pre-size the array to avoid resizing
+        AbstractEpollChannel[] localChannels = new AbstractEpollChannel[channels.size()];
+        int i = 0;
+        for (AbstractEpollChannel ch : channels.values()) {
+            localChannels[i++] = ch;
+        }
 
         for (AbstractEpollChannel ch: localChannels) {
-            ch.unsafe().close(ch.unsafe().voidPromise());
+            if (ch != null) {
+                ch.unsafe().close(ch.unsafe().voidPromise());
+            }
         }
     }
 
     private void processReady(EpollEventArray events, int ready) {
+        final int eventFdVal = eventFd.intValue();
+        final int timerFdVal = timerFd.intValue();
+        final int epollFdVal = epollFd.intValue();
+        
         for (int i = 0; i < ready; i ++) {
             final int fd = events.fd(i);
-            if (fd == eventFd.intValue() || fd == timerFd.intValue()) {
+            if (fd == eventFdVal || fd == timerFdVal) {
                 // Just ignore as we use ET mode for the eventfd and timerfd.
                 //
                 // See also https://stackoverflow.com/a/12492308/1074097
-            } else {
-                final long ev = events.events(i);
-
-                AbstractEpollChannel ch = channels.get(fd);
-                if (ch != null) {
-                    // Don't change the ordering of processing EPOLLOUT | EPOLLRDHUP / EPOLLIN if you're not 100%
-                    // sure about it!
-                    // Re-ordering can easily introduce bugs and bad side-effects, as we found out painfully in the
-                    // past.
-                    AbstractEpollUnsafe unsafe = (AbstractEpollUnsafe) ch.unsafe();
-
-                    // First check for EPOLLOUT as we may need to fail the connect ChannelPromise before try
-                    // to read from the file descriptor.
-                    // See https://github.com/netty/netty/issues/3785
-                    //
-                    // It is possible for an EPOLLOUT or EPOLLERR to be generated when a connection is refused.
-                    // In either case epollOutReady() will do the correct thing (finish connecting, or fail
-                    // the connection).
-                    // See https://github.com/netty/netty/issues/3848
-                    if ((ev & (Native.EPOLLERR | Native.EPOLLOUT)) != 0) {
-                        // Force flush of data as the epoll is writable again
-                        unsafe.epollOutReady();
-                    }
-
-                    // Check EPOLLIN before EPOLLRDHUP to ensure all data is read before shutting down the input.
-                    // See https://github.com/netty/netty/issues/4317.
-                    //
-                    // If EPOLLIN or EPOLLERR was received and the channel is still open call epollInReady(). This will
-                    // try to read from the underlying file descriptor and so notify the user about the error.
-                    if ((ev & (Native.EPOLLERR | Native.EPOLLIN)) != 0) {
-                        // The Channel is still open and there is something to read. Do it now.
-                        unsafe.epollInReady();
-                    }
-
-                    // Check if EPOLLRDHUP was set, this will notify us for connection-reset in which case
-                    // we may close the channel directly or try to read more data depending on the state of the
-                    // Channel and als depending on the AbstractEpollChannel subtype.
-                    if ((ev & Native.EPOLLRDHUP) != 0) {
-                        unsafe.epollRdHupReady();
-                    }
-                } else {
-                    // We received an event for an fd which we not use anymore. Remove it from the epoll_event set.
-                    try {
-                        Native.epollCtlDel(epollFd.intValue(), fd);
-                    } catch (IOException ignore) {
-                        // This can happen but is nothing we need to worry about as we only try to delete
-                        // the fd from the epoll set as we not found it in our mappings. So this call to
-                        // epollCtlDel(...) is just to ensure we cleanup stuff and so may fail if it was
-                        // deleted before or the file descriptor was closed before.
-                    }
+                continue;
+            }
+            
+            final long ev = events.events(i);
+            AbstractEpollChannel ch = channels.get(fd);
+            if (ch == null) {
+                // We received an event for an fd which we not use anymore. Remove it from the epoll_event set.
+                try {
+                    Native.epollCtlDel(epollFdVal, fd);
+                } catch (IOException ignore) {
+                    // This can happen but is nothing we need to worry about as we only try to delete
+                    // the fd from the epoll set as we not found it in our mappings. So this call to
+                    // epollCtlDel(...) is just to ensure we cleanup stuff and so may fail if it was
+                    // deleted before or the file descriptor was closed before.
                 }
+                continue;
+            }
+            
+            // Don't change the ordering of processing EPOLLOUT | EPOLLRDHUP / EPOLLIN if you're not 100%
+            // sure about it!
+            // Re-ordering can easily introduce bugs and bad side-effects, as we found out painfully in the
+            // past.
+            AbstractEpollUnsafe unsafe = (AbstractEpollUnsafe) ch.unsafe();
+            
+            // First check for EPOLLOUT as we may need to fail the connect ChannelPromise before try
+            // to read from the file descriptor.
+            // See https://github.com/netty/netty/issues/3785
+            //
+            // It is possible for an EPOLLOUT or EPOLLERR to be generated when a connection is refused.
+            // In either case epollOutReady() will do the correct thing (finish connecting, or fail
+            // the connection).
+            // See https://github.com/netty/netty/issues/3848
+            if ((ev & (Native.EPOLLERR | Native.EPOLLOUT)) != 0) {
+                // Force flush of data as the epoll is writable again
+                unsafe.epollOutReady();
+            }
+            
+            // Check EPOLLIN before EPOLLRDHUP to ensure all data is read before shutting down the input.
+            // See https://github.com/netty/netty/issues/4317.
+            //
+            // If EPOLLIN or EPOLLERR was received and the channel is still open call epollInReady(). This will
+            // try to read from the underlying file descriptor and so notify the user about the error.
+            if ((ev & (Native.EPOLLERR | Native.EPOLLIN)) != 0) {
+                // The Channel is still open and there is something to read. Do it now.
+                unsafe.epollInReady();
+            }
+            
+            // Check if EPOLLRDHUP was set, this will notify us for connection-reset in which case
+            // we may close the channel directly or try to read more data depending on the state of the
+            // Channel and als depending on the AbstractEpollChannel subtype.
+            if ((ev & Native.EPOLLRDHUP) != 0) {
+                unsafe.epollRdHupReady();
             }
         }
     }
