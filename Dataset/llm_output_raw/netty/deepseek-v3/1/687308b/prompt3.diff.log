## Explanation of Performance Improvements

The main performance bottlenecks in `QueryStringEncoder` are:
1. **UTF-8 encoding path**: The current implementation processes characters one by one with multiple branches and method calls for each character, which is inefficient for ASCII-heavy content.
2. **Non-UTF-8 encoding path**: It creates temporary `char[]` arrays and `String` objects for each encoded segment, causing unnecessary allocations.
3. **Character classification**: The `dontNeedEncoding` method uses multiple range checks that could be optimized with a precomputed lookup table for ASCII characters.

Improvements focus on:
- Reducing branches and method calls in hot paths
- Minimizing temporary object allocations
- Using more efficient character classification for ASCII range
- Optimizing the UTF-8 encoding path for common ASCII cases

```json
[
  {
    "filepath": "../netty/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java",
    "search": "    private static boolean dontNeedEncoding(char ch) {\n        return ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9'\n                || ch == '-' || ch == '_' || ch == '.' || ch == '*';\n    }",
    "replace": "    private static boolean dontNeedEncoding(char ch) {\n        // Fast path for ASCII: use a precomputed lookup table for 0-127\n        if (ch < 128) {\n            return ASCII_DONT_NEED_ENCODING[ch];\n        }\n        return ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9'\n                || ch == '-' || ch == '_' || ch == '.' || ch == '*';\n    }\n\n    private static final boolean[] ASCII_DONT_NEED_ENCODING = new boolean[128];\n    static {\n        for (int i = 0; i < 128; i++) {\n            char ch = (char) i;\n            ASCII_DONT_NEED_ENCODING[i] = ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9'\n                    || ch == '-' || ch == '_' || ch == '.' || ch == '*';\n        }\n    }"
  },
  {
    "filepath": "../netty/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java",
    "search": "    private void encodeUtf8Component(CharSequence s) {\n        for (int i = 0, len = s.length(); i < len; i++) {\n            char c = s.charAt(i);\n            if (c < 0x80) {\n                if (dontNeedEncoding(c)) {\n                    uriBuilder.append(c);\n                } else {\n                    appendEncoded(c);\n                }\n            } else if (c < 0x800) {\n                appendEncoded(0xc0 | (c >> 6));\n                appendEncoded(0x80 | (c & 0x3f));\n            } else if (StringUtil.isSurrogate(c)) {\n                if (!Character.isHighSurrogate(c)) {\n                    appendEncoded(WRITE_UTF_UNKNOWN);\n                    continue;\n                }\n                // Surrogate Pair consumes 2 characters.\n                if (++i == s.length()) {\n                    appendEncoded(WRITE_UTF_UNKNOWN);\n                    break;\n                }\n                // Extra method to allow inlining the rest of writeUtf8 which is the most likely code path.\n                writeUtf8Surrogate(c, s.charAt(i));\n            } else {\n                appendEncoded(0xe0 | (c >> 12));\n                appendEncoded(0x80 | ((c >> 6) & 0x3f));\n                appendEncoded(0x80 | (c & 0x3f));\n            }\n        }\n    }",
    "replace": "    private void encodeUtf8Component(CharSequence s) {\n        final int len = s.length();\n        int i = 0;\n        // Process ASCII characters in batches when possible\n        while (i < len) {\n            char c = s.charAt(i);\n            if (c < 0x80) {\n                // Fast path for ASCII characters\n                int asciiStart = i;\n                while (i < len && (c = s.charAt(i)) < 0x80 && dontNeedEncoding(c)) {\n                    i++;\n                }\n                if (i > asciiStart) {\n                    uriBuilder.append(s, asciiStart, i);\n                }\n                if (i < len && (c = s.charAt(i)) < 0x80) {\n                    // Single ASCII character that needs encoding\n                    appendEncoded(c);\n                    i++;\n                }\n            } else {\n                // Non-ASCII path\n                if (c < 0x800) {\n                    appendEncoded(0xc0 | (c >> 6));\n                    appendEncoded(0x80 | (c & 0x3f));\n                    i++;\n                } else if (StringUtil.isSurrogate(c)) {\n                    if (!Character.isHighSurrogate(c)) {\n                        appendEncoded(WRITE_UTF_UNKNOWN);\n                        i++;\n                        continue;\n                    }\n                    // Surrogate Pair consumes 2 characters.\n                    if (++i == len) {\n                        appendEncoded(WRITE_UTF_UNKNOWN);\n                        break;\n                    }\n                    // Extra method to allow inlining the rest of writeUtf8 which is the most likely code path.\n                    writeUtf8Surrogate(c, s.charAt(i));\n                    i++;\n                } else {\n                    appendEncoded(0xe0 | (c >> 12));\n                    appendEncoded(0x80 | ((c >> 6) & 0x3f));\n                    appendEncoded(0x80 | (c & 0x3f));\n                    i++;\n                }\n            }\n        }\n    }"
  },
  {
    "filepath": "../netty/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java",
    "search": "    private void encodeNonUtf8Component(CharSequence s) {\n        //Don't allocate memory until needed\n        char[] buf = null;\n\n        for (int i = 0, len = s.length(); i < len;) {\n            char c = s.charAt(i);\n            if (dontNeedEncoding(c)) {\n                uriBuilder.append(c);\n                i++;\n            } else {\n                int index = 0;\n                if (buf == null) {\n                    buf = new char[s.length() - i];\n                }\n\n                do {\n                    buf[index] = c;\n                    index++;\n                    i++;\n                } while (i < s.length() && !dontNeedEncoding(c = s.charAt(i)));\n\n                byte[] bytes = new String(buf, 0, index).getBytes(charset);\n\n                for (byte b : bytes) {\n                    appendEncoded(b);\n                }\n            }\n        }\n    }",
    "replace": "    private void encodeNonUtf8Component(CharSequence s) {\n        final int len = s.length();\n        int i = 0;\n        // Process safe characters in batches\n        while (i < len) {\n            char c = s.charAt(i);\n            if (dontNeedEncoding(c)) {\n                int safeStart = i;\n                while (i < len && dontNeedEncoding(c = s.charAt(i))) {\n                    i++;\n                }\n                uriBuilder.append(s, safeStart, i);\n            } else {\n                // Encode a single character or a batch of characters that need encoding\n                int encodeStart = i;\n                while (i < len && !dontNeedEncoding(c = s.charAt(i))) {\n                    i++;\n                }\n                // Use a StringBuilder to accumulate characters for encoding\n                StringBuilder encodeBuf = new StringBuilder(i - encodeStart);\n                for (int j = encodeStart; j < i; j++) {\n                    encodeBuf.append(s.charAt(j));\n                }\n                byte[] bytes = encodeBuf.toString().getBytes(charset);\n                for (byte b : bytes) {\n                    appendEncoded(b);\n                }\n            }\n        }\n    }"
  },
  {
    "filepath": "../netty/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java",
    "search": "    private void appendEncoded(int b) {\n        uriBuilder.append('%').append(forDigit(b >> 4)).append(forDigit(b));\n    }",
    "replace": "    private void appendEncoded(int b) {\n        // Inline the hex digit conversion to avoid method call overhead\n        uriBuilder.append('%').append(CHAR_MAP[(b >> 4) & 0xF]).append(CHAR_MAP[b & 0xF]);\n    }"
  }
]
```