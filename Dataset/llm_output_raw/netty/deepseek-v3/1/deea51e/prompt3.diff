diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java
index 301a2c51cf..cc22694f97 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java
@@ -112,7 +112,9 @@ final class HpackEncoder {
             throws Http2Exception {
         long headerSize = 0;
         // To ensure we stay consistent with our peer check the size is valid before we potentially modify HPACK state.
-        for (Map.Entry<CharSequence, CharSequence> header : headers) {
+        Iterator<Map.Entry<CharSequence, CharSequence>> itr = headers.iterator();
+        while (itr.hasNext()) {
+            Map.Entry<CharSequence, CharSequence> header = itr.next();
             CharSequence name = header.getKey();
             CharSequence value = header.getValue();
             // OK to increment now and check for bounds after because this value is limited to unsigned int and will not
@@ -127,7 +129,9 @@ final class HpackEncoder {
 
     private void encodeHeadersIgnoreMaxHeaderListSize(ByteBuf out, Http2Headers headers,
                                                       SensitivityDetector sensitivityDetector) throws Http2Exception {
-        for (Map.Entry<CharSequence, CharSequence> header : headers) {
+        Iterator<Map.Entry<CharSequence, CharSequence>> itr = headers.iterator();
+        while (itr.hasNext()) {
+            Map.Entry<CharSequence, CharSequence> header = itr.next();
             CharSequence name = header.getKey();
             CharSequence value = header.getValue();
             encodeHeader(out, name, value, sensitivityDetector.isSensitive(name, value),
@@ -250,16 +254,17 @@ final class HpackEncoder {
      * Encode string literal according to Section 5.2.
      */
     private void encodeStringLiteral(ByteBuf out, CharSequence string) {
+        int strLen = string.length();
         int huffmanLength = hpackHuffmanEncoder.getEncodedLength(string);
-        if (huffmanLength < string.length()) {
+        if (huffmanLength < strLen) {
             encodeInteger(out, 0x80, 7, huffmanLength);
             hpackHuffmanEncoder.encode(out, string);
         } else {
-            encodeInteger(out, 0x00, 7, string.length());
+            encodeInteger(out, 0x00, 7, strLen);
             if (string instanceof AsciiString) {
                 // Fast-path
                 AsciiString asciiString = (AsciiString) string;
-                out.writeBytes(asciiString.array(), asciiString.arrayOffset(), asciiString.length());
+                out.writeBytes(asciiString.array(), asciiString.arrayOffset(), strLen);
             } else {
                 // Only ASCII is allowed in http2 headers, so its fine to use this.
                 // https://tools.ietf.org/html/rfc7540#section-8.1.2
@@ -352,7 +357,7 @@ final class HpackEncoder {
             return null;
         }
         int h = AsciiString.hashCode(name);
-        int i = index(h);
+        int i = h & hashMask;
         for (HeaderEntry e = headerFields[i]; e != null; e = e.next) {
             // To avoid short circuit behavior a bitwise operator is used instead of a boolean operator.
             if (e.hash == h && (equalsConstantTime(name, e.name) & equalsConstantTime(value, e.value)) != 0) {
@@ -371,7 +376,7 @@ final class HpackEncoder {
             return -1;
         }
         int h = AsciiString.hashCode(name);
-        int i = index(h);
+        int i = h & hashMask;
         for (HeaderEntry e = headerFields[i]; e != null; e = e.next) {
             if (e.hash == h && equalsConstantTime(name, e.name) != 0) {
                 return getIndex(e.index);
@@ -454,6 +459,7 @@ final class HpackEncoder {
 
     /**
      * Returns the index into the hash table for the hash code h.
+     * Inlined at call sites for performance.
      */
     private int index(int h) {
         return h & hashMask;
