The performance issue indicates that using `ByteBuffer` for decoding URL components is slower than using `byte[]` directly. The current `decodeComponent` method uses `ByteBuffer` and `CharBuffer` for decoding percent-encoded sequences. We can replace this with a `byte[]` approach that accumulates bytes directly and then decodes them in bulk using `String` constructor, which is simpler and potentially faster.

We'll modify the `decodeComponent` method to:
1. Accumulate percent-encoded bytes into a `byte[]` instead of a `ByteBuffer`.
2. Use `new String(bytes, charset)` to decode the accumulated bytes.
3. Remove the `CharBuffer` and `CharsetDecoder` usage.

We'll also need to adjust the loop logic to handle the byte accumulation correctly.

Let's break this into two changes: first, update the `decodeComponent` method to use `byte[]`, and second, adjust the helper method `decodeHexByte` (if it exists) or inline the hex decoding. However, note that `decodeHexByte` is not provided in the source file; it must be defined elsewhere. Since we only have the provided source, we must assume it's available. We'll keep the hex decoding logic but adapt it for `byte[]`.

Actually, looking at the source, `decodeHexByte` is not defined in this file. It might be from a static import. We need to check the imports: there's `import static io.netty.util.internal.StringUtil.*;` which likely includes `decodeHexByte`. We'll keep that call.

Now, let's create the changes.

Explanation: The overall improvement intent is to replace `ByteBuffer` and `CharBuffer` with `byte[]` and direct `String` construction to improve performance in URL decoding.

```json
[
  {
    "filepath": "../netty/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java",
    "search": "    private static String decodeComponent(String s, int from, int toExcluded, Charset charset, boolean isPath) {\n        int len = toExcluded - from;\n        if (len <= 0) {\n            return EMPTY_STRING;\n        }\n        int firstEscaped = -1;\n        for (int i = from; i < toExcluded; i++) {\n            char c = s.charAt(i);\n            if (c == '%' || c == '+' && !isPath) {\n                firstEscaped = i;\n                break;\n            }\n        }\n        if (firstEscaped == -1) {\n            return s.substring(from, toExcluded);\n        }\n\n        CharsetDecoder decoder = CharsetUtil.decoder(charset);\n\n        // Each encoded byte takes 3 characters (e.g. \"%20\")\n        int decodedCapacity = (toExcluded - firstEscaped) / 3;\n        ByteBuffer byteBuf = ByteBuffer.allocate(decodedCapacity);\n        CharBuffer charBuf = CharBuffer.allocate(decodedCapacity);\n\n        StringBuilder strBuf = new StringBuilder(len);\n        strBuf.append(s, from, firstEscaped);\n\n        for (int i = firstEscaped; i < toExcluded; i++) {\n            char c = s.charAt(i);\n            if (c != '%') {\n                strBuf.append(c != '+' || isPath? c : SPACE);\n                continue;\n            }\n\n            byteBuf.clear();\n            do {\n                if (i + 3 > toExcluded) {\n                    throw new IllegalArgumentException(\"unterminated escape sequence at index \" + i + \" of: \" + s);\n                }\n                byteBuf.put(decodeHexByte(s, i + 1));\n                i += 3;\n            } while (i < toExcluded && s.charAt(i) == '%');\n            i--;\n\n            byteBuf.flip();\n            charBuf.clear();\n            CoderResult result = decoder.reset().decode(byteBuf, charBuf, true);\n            try {\n                if (!result.isUnderflow()) {\n                    result.throwException();\n                }\n                result = decoder.flush(charBuf);\n                if (!result.isUnderflow()) {\n                    result.throwException();\n                }\n            } catch (CharacterCodingException ex) {\n                throw new IllegalStateException(ex);\n            }\n            strBuf.append(charBuf.flip());\n        }\n        return strBuf.toString();\n    }",
    "replace": "    private static String decodeComponent(String s, int from, int toExcluded, Charset charset, boolean isPath) {\n        int len = toExcluded - from;\n        if (len <= 0) {\n            return EMPTY_STRING;\n        }\n        int firstEscaped = -1;\n        for (int i = from; i < toExcluded; i++) {\n            char c = s.charAt(i);\n            if (c == '%' || c == '+' && !isPath) {\n                firstEscaped = i;\n                break;\n            }\n        }\n        if (firstEscaped == -1) {\n            return s.substring(from, toExcluded);\n        }\n\n        // Each encoded byte takes 3 characters (e.g. \"%20\")\n        int decodedCapacity = (toExcluded - firstEscaped) / 3;\n        byte[] bytes = new byte[decodedCapacity];\n        int bytesIdx = 0;\n\n        StringBuilder strBuf = new StringBuilder(len);\n        strBuf.append(s, from, firstEscaped);\n\n        for (int i = firstEscaped; i < toExcluded; i++) {\n            char c = s.charAt(i);\n            if (c != '%') {\n                strBuf.append(c != '+' || isPath? c : SPACE);\n                continue;\n            }\n\n            bytesIdx = 0;\n            do {\n                if (i + 3 > toExcluded) {\n                    throw new IllegalArgumentException(\"unterminated escape sequence at index \" + i + \" of: \" + s);\n                }\n                bytes[bytesIdx++] = decodeHexByte(s, i + 1);\n                i += 3;\n            } while (i < toExcluded && s.charAt(i) == '%');\n            i--;\n\n            strBuf.append(new String(bytes, 0, bytesIdx, charset));\n        }\n        return strBuf.toString();\n    }"
  }
]
```