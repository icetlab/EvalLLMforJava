I will improve the performance of `ByteBufUtil.decodeString` by adding a fast path for `US-ASCII` charset.

The current implementation uses a `CharsetDecoder` for all charsets. For `US-ASCII`, this is unnecessarily complex as each byte can be directly cast to a character. The `CharsetDecoder` also introduces overhead, especially for handling invalid byte sequences, which is not always required for protocols that guarantee ASCII-only characters.

My optimization introduces the following changes:
1.  In `ByteBufUtil.decodeString`, I'll add a check for `CharsetUtil.US_ASCII`.
2.  If the charset is `US-ASCII`, I'll perform a quick check to ensure all bytes in the given buffer slice are valid ASCII characters (values 0-127). This is done to preserve the original behavior of handling non-ASCII characters correctly through the standard `CharsetDecoder`.
3.  If all characters are valid ASCII, a new fast-path is taken:
    - It reuses a thread-local `CharBuffer`, similar to the original implementation, to reduce allocations.
    - It iterates through the buffer's components (`ByteBuffer`s) and directly converts bytes to characters without the `CharsetDecoder` overhead. This is significantly faster.
    - A new private helper method, `decodeAscii(ByteBuffer, CharBuffer)`, is introduced to handle the conversion for a single `ByteBuffer`, avoiding code duplication for single- and multi-component buffers.
4.  If the buffer contains non-ASCII bytes or the charset is not `US-ASCII`, the code falls back to the original, more general-purpose decoding logic.

This change will significantly speed up decoding for pure `US-ASCII` strings, which is a very common case, while ensuring correctness for all other cases.

```json
[
  {
    "filepath": "../netty/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java",
    "search": "    static String decodeString(ByteBuf src, int readerIndex, int len, Charset charset) {\n        if (len == 0) {\n            return StringUtil.EMPTY_STRING;\n        }\n        final CharsetDecoder decoder = CharsetUtil.decoder(charset);\n        final int maxLength = (int) ((double) len * decoder.maxCharsPerByte());\n        CharBuffer dst = CHAR_BUFFERS.get();\n        if (dst.length() < maxLength) {\n            dst = CharBuffer.allocate(maxLength);\n            if (maxLength <= MAX_CHAR_BUFFER_SIZE) {\n                CHAR_BUFFERS.set(dst);\n            }\n        } else {\n            dst.clear();\n        }\n        if (src.nioBufferCount() == 1) {\n            decodeString(decoder, src.nioBuffer(readerIndex, len), dst);\n        } else {\n            // We use a heap buffer as CharsetDecoder is most likely able to use a fast-path if src and dst buffers\n            // are both backed by a byte array.\n            ByteBuf buffer = src.alloc().heapBuffer(len);\n            try {\n                buffer.writeBytes(src, readerIndex, len);\n                // Use internalNioBuffer(...) to reduce object creation.\n                decodeString(decoder, buffer.internalNioBuffer(buffer.readerIndex(), len), dst);\n            } finally {\n                // Release the temporary buffer again.\n                buffer.release();\n            }\n        }\n        return dst.flip().toString();\n    }",
    "replace": "    static String decodeString(ByteBuf src, int readerIndex, int len, Charset charset) {\n        if (len == 0) {\n            return StringUtil.EMPTY_STRING;\n        }\n        if (charset.equals(CharsetUtil.US_ASCII)) {\n            if (src.forEachByte(readerIndex, len, FIND_NON_ASCII) == -1) {\n                // All bytes are ASCII so we can use a fast-path.\n                CharBuffer dst = CHAR_BUFFERS.get();\n                if (dst.length() < len) {\n                    dst = CharBuffer.allocate(len);\n                    if (len <= MAX_CHAR_BUFFER_SIZE) {\n                        CHAR_BUFFERS.set(dst);\n                    }\n                } else {\n                    dst.clear();\n                }\n                if (src.nioBufferCount() == 1) {\n                    decodeAscii(src.nioBuffer(readerIndex, len), dst);\n                } else {\n                    for (ByteBuffer nioBuffer : src.nioBuffers(readerIndex, len)) {\n                        decodeAscii(nioBuffer, dst);\n                    }\n                }\n                return dst.flip().toString();\n            }\n        }\n        final CharsetDecoder decoder = CharsetUtil.decoder(charset);\n        final int maxLength = (int) ((double) len * decoder.maxCharsPerByte());\n        CharBuffer dst = CHAR_BUFFERS.get();\n        if (dst.length() < maxLength) {\n            dst = CharBuffer.allocate(maxLength);\n            if (maxLength <= MAX_CHAR_BUFFER_SIZE) {\n                CHAR_BUFFERS.set(dst);\n            }\n        } else {\n            dst.clear();\n        }\n        if (src.nioBufferCount() == 1) {\n            decodeString(decoder, src.nioBuffer(readerIndex, len), dst);\n        } else {\n            // We use a heap buffer as CharsetDecoder is most likely able to use a fast-path if src and dst buffers\n            // are both backed by a byte array.\n            ByteBuf buffer = src.alloc().heapBuffer(len);\n            try {\n                buffer.writeBytes(src, readerIndex, len);\n                // Use internalNioBuffer(...) to reduce object creation.\n                decodeString(decoder, buffer.internalNioBuffer(buffer.readerIndex(), len), dst);\n            } finally {\n                // Release the temporary buffer again.\n                buffer.release();\n            }\n        }\n        return dst.flip().toString();\n    }"
  },
  {
    "filepath": "../netty/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java",
    "search": "    private static void decodeString(CharsetDecoder decoder, ByteBuffer src, CharBuffer dst) {\n        try {\n            CoderResult cr = decoder.decode(src, dst, true);\n            if (!cr.isUnderflow()) {\n                cr.throwException();\n            }\n            cr = decoder.flush(dst);\n            if (!cr.isUnderflow()) {\n                cr.throwException();\n            }\n        } catch (CharacterCodingException x) {\n            throw new IllegalStateException(x);\n        }\n    }",
    "replace": "    private static void decodeString(CharsetDecoder decoder, ByteBuffer src, CharBuffer dst) {\n        try {\n            CoderResult cr = decoder.decode(src, dst, true);\n            if (!cr.isUnderflow()) {\n                cr.throwException();\n            }\n            cr = decoder.flush(dst);\n            if (!cr.isUnderflow()) {\n                cr.throwException();\n            }\n        } catch (CharacterCodingException x) {\n            throw new IllegalStateException(x);\n        }\n    }\n\n    private static void decodeAscii(ByteBuffer src, CharBuffer dst) {\n        final int remaining = src.remaining();\n        if (src.hasArray()) {\n            final byte[] array = src.array();\n            final int offset = src.arrayOffset() + src.position();\n            for (int i = 0; i < remaining; i++) {\n                dst.put((char) array[offset + i]);\n            }\n            src.position(src.position() + remaining);\n        } else {\n            for (int i = 0; i < remaining; i++) {\n                dst.put((char) src.get());\n            }\n        }\n    }"
  }
]
```