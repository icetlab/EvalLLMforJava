diff --git a/common/src/main/java/io/netty/util/Recycler.java b/common/src/main/java/io/netty/util/Recycler.java
index dd7b2d73be..2cec893848 100644
--- a/common/src/main/java/io/netty/util/Recycler.java
+++ b/common/src/main/java/io/netty/util/Recycler.java
@@ -197,7 +197,10 @@ public abstract class Recycler<T> {
 
     final int threadLocalSize() {
         LocalPool<T> localPool = threadLocal.getIfExists();
-        return localPool == null ? 0 : localPool.pooledHandles.size();
+        if (localPool == null) {
+            return 0;
+        }
+        return localPool.size + localPool.pooledHandles.size();
     }
 
     /**
@@ -255,41 +258,108 @@ public abstract class Recycler<T> {
         }
     }
 
-    private static final class LocalPool<T> {
+        private final class LocalPool<T> {
+        private final int maxCapacity;
         private final int ratioInterval;
+        private final DefaultHandle<T>[] elements;
+        private int size;
+
         private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;
         private int ratioCounter;
 
         @SuppressWarnings("unchecked")
         LocalPool(int maxCapacity, int ratioInterval, int chunkSize) {
+            this.maxCapacity = maxCapacity;
             this.ratioInterval = ratioInterval;
             if (BLOCKING_POOL) {
                 pooledHandles = new BlockingMessageQueue<DefaultHandle<T>>(maxCapacity);
             } else {
                 pooledHandles = (MessagePassingQueue<DefaultHandle<T>>) newMpscQueue(chunkSize, maxCapacity);
             }
+            elements = new DefaultHandle[min(chunkSize, this.maxCapacity)];
             ratioCounter = ratioInterval; // Start at interval so the first one will be recycled.
         }
 
         DefaultHandle<T> claim() {
+            // First try to claim from the local stack.
+            if (size > 0) {
+                size --;
+                DefaultHandle<T> handle = elements[size];
+                elements[size] = null;
+                handle.toClaimed();
+                return handle;
+            }
             MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
             if (handles == null) {
                 return null;
             }
-            DefaultHandle<T> handle = handles.relaxedPoll();
-            if (null != handle) {
+
+            // Scavenge from the MPSC queue.
+            scavenge(handles);
+
+            // Try again, but this time from the scavenged handles.
+            if (size > 0) {
+                size --;
+                DefaultHandle<T> handle = elements[size];
+                elements[size] = null;
                 handle.toClaimed();
-            }
                 return handle;
             }
+            return null;
+        }
+
+        private void scavenge(MessagePassingQueue<DefaultHandle<T>> handles) {
+            if (BLOCKING_POOL) {
+                // The BlockingMessageQueue does not support drain(...), so we need to poll.
+                scavengeWithPoll(handles);
+                return;
+            }
+
+            final int capacity = elements.length;
+            // We want to at least scavenge one element.
+            int numToDrain = max(1, capacity - size);
+            handles.drain(handle -> {
+                if (size < capacity) {
+                    elements[size++] = handle;
+                } else {
+                    // This should not happen if the queue implementation is correct and respects the limit.
+                    // In case it does we need to at least ensure we not fail but instead just drop the handle.
+                    // The handle will simply be GCed so we are good.
+                }
+            }, numToDrain);
+        }
+
+        private void scavengeWithPoll(MessagePassingQueue<DefaultHandle<T>> handles) {
+            final int capacity = elements.length;
+            int numToPoll = max(1, capacity - size);
+            for (int i = 0; i < numToPoll; i++) {
+                DefaultHandle<T> handle = handles.poll();
+                if (handle == null) {
+                    return;
+                }
+                if (size < capacity) {
+                    elements[size++] = handle;
+                }
+            }
+        }
 
         void release(DefaultHandle<T> handle) {
             handle.toAvailable();
+            if (threadLocal.get() == this) {
+                // We are on the correct thread, so we can just add it to the stack.
+                if (size < elements.length) {
+                    elements[size++] = handle;
+                    return;
+                }
+                // We are full, so just drop it.
+            } else {
+                // We are on a different thread, so we need to use the MPSC queue.
                 MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
                 if (handles != null) {
                     handles.relaxedOffer(handle);
                 }
             }
+        }
 
         DefaultHandle<T> newHandle() {
             if (++ratioCounter >= ratioInterval) {
