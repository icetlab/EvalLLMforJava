diff --git a/common/src/main/java/io/netty/util/Recycler.java b/common/src/main/java/io/netty/util/Recycler.java
index a17a9906c4..6effe33656 100644
--- a/common/src/main/java/io/netty/util/Recycler.java
+++ b/common/src/main/java/io/netty/util/Recycler.java
@@ -117,6 +117,8 @@ public abstract class Recycler<T> {
             MessagePassingQueue<DefaultHandle<T>> handles = value.pooledHandles;
             value.pooledHandles = null;
             value.owner = null;
+            value.batchBuffer = null;
+            value.batchHead = value.batchTail = value.batchCount = 0;
             handles.clear();
         }
     };
@@ -211,7 +213,7 @@ public abstract class Recycler<T> {
     @VisibleForTesting
     final int threadLocalSize() {
         LocalPool<T> localPool = threadLocal.getIfExists();
-        return localPool == null ? 0 : localPool.pooledHandles.size() + localPool.batch.size();
+        return localPool == null ? 0 : localPool.pooledHandles.size() + localPool.batchCount;
     }
 
     /**
@@ -297,7 +299,10 @@ public abstract class Recycler<T> {
     private static final class LocalPool<T> implements MessagePassingQueue.Consumer<DefaultHandle<T>> {
         private final int ratioInterval;
         private final int chunkSize;
-        private final ArrayDeque<DefaultHandle<T>> batch;
+        private DefaultHandle<T>[] batchBuffer;
+        private int batchHead;
+        private int batchTail;
+        private int batchCount;
         private volatile Thread owner;
         private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;
         private int ratioCounter;
@@ -306,7 +311,10 @@ public abstract class Recycler<T> {
         LocalPool(int maxCapacity, int ratioInterval, int chunkSize) {
             this.ratioInterval = ratioInterval;
             this.chunkSize = chunkSize;
-            batch = new ArrayDeque<DefaultHandle<T>>(chunkSize);
+            batchBuffer = new DefaultHandle[chunkSize];
+            batchHead = 0;
+            batchTail = 0;
+            batchCount = 0;
             Thread currentThread = Thread.currentThread();
             owner = !BATCH_FAST_TL_ONLY || currentThread instanceof FastThreadLocalThread ? currentThread : null;
             if (BLOCKING_POOL) {
@@ -322,12 +330,18 @@ public abstract class Recycler<T> {
             if (handles == null) {
                 return null;
             }
-            if (batch.isEmpty()) {
+            if (batchCount == 0) {
                 handles.drain(this, chunkSize);
             }
-            DefaultHandle<T> handle = batch.pollFirst();
-            if (null != handle) {
-                handle.toClaimed();
+            DefaultHandle<T> handle = null;
+            if (batchCount > 0) {
+                handle = batchBuffer[batchHead];
+                batchBuffer[batchHead] = null; // Help GC
+                batchHead = (batchHead + 1) % chunkSize;
+                batchCount--;
+                if (null != handle) {
+                    handle.toClaimed();
+                }
             }
             return handle;
         }
@@ -339,8 +353,10 @@ public abstract class Recycler<T> {
                 handle.unguardedToAvailable();
             }
             Thread owner = this.owner;
-            if (owner != null && Thread.currentThread() == owner && batch.size() < chunkSize) {
-                accept(handle);
+            if (owner != null && Thread.currentThread() == owner && batchCount < chunkSize) {
+                batchBuffer[batchTail] = handle;
+                batchTail = (batchTail + 1) % chunkSize;
+                batchCount++;
             } else if (owner != null && isTerminated(owner)) {
                 this.owner = null;
                 pooledHandles = null;
@@ -368,7 +384,14 @@ public abstract class Recycler<T> {
 
         @Override
         public void accept(DefaultHandle<T> e) {
-            batch.addLast(e);
+            if (batchCount == chunkSize) {
+                // Fallback to queue if batch buffer is full
+                pooledHandles.relaxedOffer(e);
+                return;
+            }
+            batchBuffer[batchTail] = e;
+            batchTail = (batchTail + 1) % chunkSize;
+            batchCount++;
         }
     }
 
