diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
index 8c9ad17821..8bbbbae840 100644
--- a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
@@ -57,6 +57,9 @@ class EpollEventLoop extends SingleThreadEventLoop {
     private final FileDescriptor epollFd;
     private final FileDescriptor eventFd;
     private final FileDescriptor timerFd;
+    private final int epollFdInt;
+    private final int eventFdInt;
+    private final int timerFdInt;
     private final IntObjectMap<AbstractEpollChannel> channels = new IntObjectHashMap<AbstractEpollChannel>(4096);
     private final boolean allowGrowing;
     private final EpollEventArray events;
@@ -97,18 +100,21 @@ class EpollEventLoop extends SingleThreadEventLoop {
         try {
             this.epollFd = epollFd = Native.newEpollCreate();
             this.eventFd = eventFd = Native.newEventFd();
+            this.epollFdInt = epollFd.intValue();
+            this.eventFdInt = eventFd.intValue();
             try {
                 // It is important to use EPOLLET here as we only want to get the notification once per
                 // wakeup and don't call eventfd_read(...).
-                Native.epollCtlAdd(epollFd.intValue(), eventFd.intValue(), Native.EPOLLIN | Native.EPOLLET);
+                Native.epollCtlAdd(epollFdInt, eventFdInt, Native.EPOLLIN | Native.EPOLLET);
             } catch (IOException e) {
                 throw new IllegalStateException("Unable to add eventFd filedescriptor to epoll", e);
             }
             this.timerFd = timerFd = Native.newTimerFd();
+            this.timerFdInt = timerFd.intValue();
             try {
                 // It is important to use EPOLLET here as we only want to get the notification once per
                 // wakeup and don't call read(...).
-                Native.epollCtlAdd(epollFd.intValue(), timerFd.intValue(), Native.EPOLLIN | Native.EPOLLET);
+                Native.epollCtlAdd(epollFdInt, timerFdInt, Native.EPOLLIN | Native.EPOLLET);
             } catch (IOException e) {
                 throw new IllegalStateException("Unable to add timerFd filedescriptor to epoll", e);
             }
@@ -168,7 +174,7 @@ class EpollEventLoop extends SingleThreadEventLoop {
     protected void wakeup(boolean inEventLoop) {
         if (!inEventLoop && WAKEN_UP_UPDATER.compareAndSet(this, 0, 1)) {
             // write to the evfd which will then wake-up epoll_wait(...)
-            Native.eventFdWrite(eventFd.intValue(), 1L);
+            Native.eventFdWrite(eventFdInt, 1L);
         }
     }
 
@@ -178,7 +184,7 @@ class EpollEventLoop extends SingleThreadEventLoop {
     void add(AbstractEpollChannel ch) throws IOException {
         assert inEventLoop();
         int fd = ch.socket.intValue();
-        Native.epollCtlAdd(epollFd.intValue(), fd, ch.flags);
+        Native.epollCtlAdd(epollFdInt, fd, ch.flags);
         AbstractEpollChannel old = channels.put(fd, ch);
 
         // We either expect to have no Channel in the map with the same FD or that the FD of the old Channel is already
@@ -191,7 +197,7 @@ class EpollEventLoop extends SingleThreadEventLoop {
      */
     void modify(AbstractEpollChannel ch) throws IOException {
         assert inEventLoop();
-        Native.epollCtlMod(epollFd.intValue(), ch.socket.intValue(), ch.flags);
+        Native.epollCtlMod(epollFdInt, ch.socket.intValue(), ch.flags);
     }
 
     /**
@@ -211,7 +217,7 @@ class EpollEventLoop extends SingleThreadEventLoop {
         } else if (ch.isOpen()) {
             // Remove the epoll. This is only needed if it's still open as otherwise it will be automatically
             // removed once the file-descriptor is closed.
-            Native.epollCtlDel(epollFd.intValue(), fd);
+            Native.epollCtlDel(epollFdInt, fd);
         }
     }
 
@@ -322,7 +328,7 @@ class EpollEventLoop extends SingleThreadEventLoop {
                         // (OK - no wake-up required).
 
                         if (wakenUp == 1) {
-                            Native.eventFdWrite(eventFd.intValue(), 1L);
+                            Native.eventFdWrite(eventFdInt, 1L);
                         }
                         // fallthrough
                     default:
@@ -406,15 +412,16 @@ class EpollEventLoop extends SingleThreadEventLoop {
     private void processReady(EpollEventArray events, int ready) {
         for (int i = 0; i < ready; i ++) {
             final int fd = events.fd(i);
-            if (fd == eventFd.intValue() || fd == timerFd.intValue()) {
+            if (fd == eventFdInt || fd == timerFdInt) {
                 // Just ignore as we use ET mode for the eventfd and timerfd.
                 //
                 // See also https://stackoverflow.com/a/12492308/1074097
-            } else {
-                final long ev = events.events(i);
-
-                AbstractEpollChannel ch = channels.get(fd);
-                if (ch != null) {
+                continue;
+            }
+            
+            final long ev = events.events(i);
+            AbstractEpollChannel ch = channels.get(fd);
+            if (ch == null) {
                     // Don't change the ordering of processing EPOLLOUT | EPOLLRDHUP / EPOLLIN if you're not 100%
                     // sure about it!
                     // Re-ordering can easily introduce bugs and bad side-effects, as we found out painfully in the
@@ -450,17 +457,23 @@ class EpollEventLoop extends SingleThreadEventLoop {
                     if ((ev & Native.EPOLLRDHUP) != 0) {
                         unsafe.epollRdHupReady();
                     }
-                } else {
-                    // We received an event for an fd which we not use anymore. Remove it from the epoll_event set.
-                    try {
-                        Native.epollCtlDel(epollFd.intValue(), fd);
-                    } catch (IOException ignore) {
-                        // This can happen but is nothing we need to worry about as we only try to delete
-                        // the fd from the epoll set as we not found it in our mappings. So this call to
-                        // epollCtlDel(...) is just to ensure we cleanup stuff and so may fail if it was
-                        // deleted before or the file descriptor was closed before.
-                    }
+                // We received an event for an fd which we not use anymore. Remove it from the epoll_event set.
+                try {
+                    Native.epollCtlDel(epollFdInt, fd);
+                } catch (IOException ignore) {
+                    // This can happen but is nothing we need to worry about as we only try to delete
+                    // the fd from the epoll set as we not found it in our mappings. So this call to
+                    // epollCtlDel(...) is just to ensure we cleanup stuff and so may fail if it was
+                    // deleted before or the file descriptor was closed before.
                 }
+                continue;
+            }
+            
+            // Don't change the ordering of processing EPOLLOUT | EPOLLRDHUP / EPOLLIN if you're not 100%
+            // sure about it!
+            // Re-ordering can easily introduce bugs and bad side-effects, as we found out painfully in the
+            // past.
+            AbstractEpollUnsafe unsafe = (AbstractEpollUnsafe) ch.unsafe();
             }
         }
     }
