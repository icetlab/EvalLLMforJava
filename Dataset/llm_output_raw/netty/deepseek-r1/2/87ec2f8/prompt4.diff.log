## Explanation
The current `decodeString` implementation in `ByteBufUtil` performs unnecessary memory copies and uses an inefficient `CharsetDecoder` approach with thread-local buffers. This can be optimized by directly using `new String(byte[], Charset)` when the buffer has an accessible backing array, or copying bytes to an array only when necessary. This leverages Java's built-in string decoding optimizations and reduces overhead.

Here are the specific changes:

1. **Replace `decodeString` method** - Simplify the implementation to use `new String()` for array-backed buffers and fall back to copying for non-array buffers.
2. **Remove unused helper method** - The private `decodeString(CharsetDecoder, ByteBuffer, CharBuffer)` method is no longer needed after the main method refactor.

```json
[
  {
    "filepath": "../netty/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java",
    "search": "    static String decodeString(ByteBuf src, int readerIndex, int len, Charset charset) {\n        if (len == 0) {\n            return StringUtil.EMPTY_STRING;\n        }\n        final CharsetDecoder decoder = CharsetUtil.decoder(charset);\n        final int maxLength = (int) ((double) len * decoder.maxCharsPerByte());\n        CharBuffer dst = CHAR_BUFFERS.get();\n        if (dst.length() < maxLength) {\n            dst = CharBuffer.allocate(maxLength);\n            if (maxLength <= MAX_CHAR_BUFFER_SIZE) {\n                CHAR_BUFFERS.set(dst);\n            }\n        } else {\n            dst.clear();\n        }\n        if (src.nioBufferCount() == 1) {\n            decodeString(decoder, src.nioBuffer(readerIndex, len), dst);\n        } else {\n            // We use a heap buffer as CharsetDecoder is most likely able to use a fast-path if src and dst buffers\n            // are both backed by a byte array.\n            ByteBuf buffer = src.alloc().heapBuffer(len);\n            try {\n                buffer.writeBytes(src, readerIndex, len);\n                // Use internalNioBuffer(...) to reduce object creation.\n                decodeString(decoder, buffer.internalNioBuffer(buffer.readerIndex(), len), dst);\n            } finally {\n                // Release the temporary buffer again.\n                buffer.release();\n            }\n        }\n        return dst.flip().toString();\n    }",
    "replace": "    static String decodeString(ByteBuf src, int readerIndex, int len, Charset charset) {\n        if (len == 0) {\n            return StringUtil.EMPTY_STRING;\n        }\n        if (src.hasArray()) {\n            // Use the underlying byte array if available.\n            int baseOffset = src.arrayOffset() + readerIndex;\n            return new String(src.array(), baseOffset, len, charset);\n        } else {\n            // Otherwise copy to a byte array and then decode.\n            byte[] bytes = new byte[len];\n            src.getBytes(readerIndex, bytes);\n            return new String(bytes, charset);\n        }\n    }"
  },
  {
    "filepath": "../netty/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java",
    "search": "    private static void decodeString(CharsetDecoder decoder, ByteBuffer src, CharBuffer dst) {\n        try {\n            CoderResult cr = decoder.decode(src, dst, true);\n            if (!cr.isUnderflow()) {\n                cr.throwException();\n            }\n            cr = decoder.flush(dst);\n            if (!cr.isUnderflow()) {\n                cr.throwException();\n            }\n        } catch (CharacterCodingException x) {\n            throw new IllegalStateException(x);\n        }\n    }",
    "replace": ""
  }
]
```