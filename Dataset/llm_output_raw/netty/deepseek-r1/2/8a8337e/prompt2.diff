diff --git a/common/src/main/java/io/netty/util/Recycler.java b/common/src/main/java/io/netty/util/Recycler.java
index dd7b2d73be..d5b4ffd4bd 100644
--- a/common/src/main/java/io/netty/util/Recycler.java
+++ b/common/src/main/java/io/netty/util/Recycler.java
@@ -105,6 +105,7 @@ public abstract class Recycler<T> {
             MessagePassingQueue<DefaultHandle<T>> handles = value.pooledHandles;
             value.pooledHandles = null;
             handles.clear();
+            value.fastPathDeque.clear();
         }
     };
 
@@ -197,7 +198,7 @@ public abstract class Recycler<T> {
 
     final int threadLocalSize() {
         LocalPool<T> localPool = threadLocal.getIfExists();
-        return localPool == null ? 0 : localPool.pooledHandles.size();
+        return localPool == null ? 0 : localPool.totalSize();
     }
 
     /**
@@ -257,12 +258,18 @@ public abstract class Recycler<T> {
 
     private static final class LocalPool<T> {
         private final int ratioInterval;
+        private final int maxCapacity;
+        private final Thread ownerThread;
+        private final ArrayDeque<DefaultHandle<T>> fastPathDeque;
         private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;
         private int ratioCounter;
 
         @SuppressWarnings("unchecked")
         LocalPool(int maxCapacity, int ratioInterval, int chunkSize) {
             this.ratioInterval = ratioInterval;
+            this.maxCapacity = maxCapacity;
+            this.ownerThread = Thread.currentThread();
+            this.fastPathDeque = new ArrayDeque<DefaultHandle<T>>(maxCapacity);
             if (BLOCKING_POOL) {
                 pooledHandles = new BlockingMessageQueue<DefaultHandle<T>>(maxCapacity);
             } else {
@@ -272,11 +279,16 @@ public abstract class Recycler<T> {
         }
 
         DefaultHandle<T> claim() {
+            DefaultHandle<T> handle = fastPathDeque.poll();
+            if (handle != null) {
+                handle.toClaimed();
+                return handle;
+            }
             MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
             if (handles == null) {
                 return null;
             }
-            DefaultHandle<T> handle = handles.relaxedPoll();
+            handle = handles.relaxedPoll();
             if (null != handle) {
                 handle.toClaimed();
             }
@@ -285,6 +297,14 @@ public abstract class Recycler<T> {
 
         void release(DefaultHandle<T> handle) {
             handle.toAvailable();
+            if (Thread.currentThread() == ownerThread) {
+                // If the fastPathDeque is not full, then add to it.
+                if (fastPathDeque.size() < maxCapacity) {
+                    fastPathDeque.offer(handle);
+                    return;
+                }
+                // Fall back to the MPSC queue if the fastPathDeque is full.
+            }
             MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
             if (handles != null) {
                 handles.relaxedOffer(handle);
@@ -298,6 +318,15 @@ public abstract class Recycler<T> {
             }
             return null;
         }
+
+        int totalSize() {
+            int size = fastPathDeque.size();
+            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
+            if (handles != null) {
+                size += handles.size();
+            }
+            return size;
+        }
     }
 
     /**
