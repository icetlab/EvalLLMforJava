diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java
index 01b747b3f2..19199ba6ff 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java
@@ -64,6 +64,22 @@ import static io.netty.util.internal.StringUtil.*;
 public class QueryStringDecoder {
 
     private static final int DEFAULT_MAX_PARAMS = 1024;
+    private static final byte[] HEX_TABLE = new byte['f' + 1];
+    
+    static {
+        for (int i = 0; i < HEX_TABLE.length; i++) {
+            HEX_TABLE[i] = -1;
+        }
+        for (int i = '0'; i <= '9'; i++) {
+            HEX_TABLE[i] = (byte) (i - '0');
+        }
+        for (int i = 'A'; i <= 'F'; i++) {
+            HEX_TABLE[i] = (byte) (i - 'A' + 10);
+        }
+        for (int i = 'a'; i <= 'f'; i++) {
+            HEX_TABLE[i] = (byte) (i - 'a' + 10);
+        }
+    }
 
     private final Charset charset;
     private final String uri;
@@ -359,25 +375,45 @@ public class QueryStringDecoder {
         CharBuffer charBuf = CharBuffer.allocate(decodedCapacity);
 
         StringBuilder strBuf = new StringBuilder(len);
-        strBuf.append(s, from, firstEscaped);
+        if (firstEscaped > from) {
+            strBuf.append(s, from, firstEscaped);
+        }
 
         for (int i = firstEscaped; i < toExcluded; i++) {
             char c = s.charAt(i);
             if (c != '%') {
-                strBuf.append(c != '+' || isPath? c : SPACE);
+                strBuf.append(c != '+' || isPath ? c : SPACE);
                 continue;
             }
 
+            if (i + 3 > toExcluded) {
+                throw new IllegalArgumentException("unterminated escape sequence at index " + i + " of: " + s);
+            }
+            
+            byte hex1 = HEX_TABLE[s.charAt(i + 1)];
+            byte hex2 = HEX_TABLE[s.charAt(i + 2)];
+            if (hex1 < 0 || hex2 < 0) {
+                throw new IllegalArgumentException("invalid hex byte '" + s.substring(i + 1, i + 3) + "' at index " + (i + 1) + " of: " + s);
+            }
+            
             byteBuf.clear();
-            do {
+            byteBuf.put((byte) ((hex1 << 4) | hex2));
+            i += 2;
+            
+            while (i + 1 < toExcluded && s.charAt(i + 1) == '%') {
+                i += 1;
                 if (i + 3 > toExcluded) {
                     throw new IllegalArgumentException("unterminated escape sequence at index " + i + " of: " + s);
                 }
-                byteBuf.put(decodeHexByte(s, i + 1));
-                i += 3;
-            } while (i < toExcluded && s.charAt(i) == '%');
-            i--;
-
+                hex1 = HEX_TABLE[s.charAt(i + 1)];
+                hex2 = HEX_TABLE[s.charAt(i + 2)];
+                if (hex1 < 0 || hex2 < 0) {
+                    throw new IllegalArgumentException("invalid hex byte '" + s.substring(i + 1, i + 3) + "' at index " + (i + 1) + " of: " + s);
+                }
+                byteBuf.put((byte) ((hex1 << 4) | hex2));
+                i += 2;
+            }
+            
             byteBuf.flip();
             charBuf.clear();
             CoderResult result = decoder.reset().decode(byteBuf, charBuf, true);
@@ -407,4 +443,17 @@ public class QueryStringDecoder {
         }
         return len;
     }
+    
+    private static byte decodeHexByte(String s, int pos) {
+        int hi = charToHex(s.charAt(pos));
+        int lo = charToHex(s.charAt(pos + 1));
+        if (hi == -1 || lo == -1) {
+            throw new IllegalArgumentException("invalid hex byte '" + s.substring(pos, pos + 2) + "' at index " + pos + " of '" + s + "'");
+        }
+        return (byte) ((hi << 4) | lo);
+    }
+    
+    private static int charToHex(char ch) {
+        return ch < HEX_TABLE.length ? HEX_TABLE[ch] : -1;
+    }
 }
