diff --git a/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
index e657ad86f8..db1e83d58c 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
@@ -60,18 +60,18 @@ public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {
     }
 
     private ByteBuf retain0(int increment) {
-        for (;;) {
-            int refCnt = this.refCnt;
-            final int nextCnt = refCnt + increment;
-
-            // Ensure we not resurrect (which means the refCnt was 0) and also that we encountered an overflow.
-            if (nextCnt <= increment) {
-                throw new IllegalReferenceCountException(refCnt, increment);
+        // Fast path for the common case: try optimistic update first
+        int currentRefCnt;
+        do {
+            currentRefCnt = refCnt;
+            // Check for resurrection (refCnt == 0) and overflow
+            if (currentRefCnt == 0) {
+                throw new IllegalReferenceCountException(0, increment);
             }
-            if (refCntUpdater.compareAndSet(this, refCnt, nextCnt)) {
-                break;
+            if (currentRefCnt > Integer.MAX_VALUE - increment) { // Overflow check
+                throw new IllegalReferenceCountException(currentRefCnt, increment);
             }
-        }
+        } while (!refCntUpdater.compareAndSet(this, currentRefCnt, currentRefCnt + increment));
         return this;
     }
 
@@ -96,20 +96,20 @@ public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {
     }
 
     private boolean release0(int decrement) {
-        for (;;) {
-            int refCnt = this.refCnt;
-            if (refCnt < decrement) {
-                throw new IllegalReferenceCountException(refCnt, -decrement);
-            }
-
-            if (refCntUpdater.compareAndSet(this, refCnt, refCnt - decrement)) {
-                if (refCnt == decrement) {
-                    deallocate();
-                    return true;
-                }
-                return false;
+        // Fast path for the common case: try optimistic update first
+        int currentRefCnt;
+        do {
+            currentRefCnt = refCnt;
+            if (currentRefCnt < decrement) {
+                throw new IllegalReferenceCountException(currentRefCnt, -decrement);
             }
+        } while (!refCntUpdater.compareAndSet(this, currentRefCnt, currentRefCnt - decrement));
+        
+        if (currentRefCnt == decrement) {
+            deallocate();
+            return true;
         }
+        return false;
     }
     /**
      * Called once {@link #refCnt()} is equals 0.
diff --git a/common/src/main/java/io/netty/util/AbstractReferenceCounted.java b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java
index 493bcc1872..2d8eebf56b 100644
--- a/common/src/main/java/io/netty/util/AbstractReferenceCounted.java
+++ b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java
@@ -52,18 +52,18 @@ public abstract class AbstractReferenceCounted implements ReferenceCounted {
     }
 
     private ReferenceCounted retain0(int increment) {
-        for (;;) {
-            int refCnt = this.refCnt;
-            final int nextCnt = refCnt + increment;
-
-            // Ensure we not resurrect (which means the refCnt was 0) and also that we encountered an overflow.
-            if (nextCnt <= increment) {
-                throw new IllegalReferenceCountException(refCnt, increment);
+        // Fast path for the common case: try optimistic update first
+        int currentRefCnt;
+        do {
+            currentRefCnt = refCnt;
+            // Check for resurrection (refCnt == 0) and overflow
+            if (currentRefCnt == 0) {
+                throw new IllegalReferenceCountException(0, increment);
             }
-            if (refCntUpdater.compareAndSet(this, refCnt, nextCnt)) {
-                break;
+            if (currentRefCnt > Integer.MAX_VALUE - increment) { // Overflow check
+                throw new IllegalReferenceCountException(currentRefCnt, increment);
             }
-        }
+        } while (!refCntUpdater.compareAndSet(this, currentRefCnt, currentRefCnt + increment));
         return this;
     }
 
@@ -83,20 +83,20 @@ public abstract class AbstractReferenceCounted implements ReferenceCounted {
     }
 
     private boolean release0(int decrement) {
-        for (;;) {
-            int refCnt = this.refCnt;
-            if (refCnt < decrement) {
-                throw new IllegalReferenceCountException(refCnt, -decrement);
-            }
-
-            if (refCntUpdater.compareAndSet(this, refCnt, refCnt - decrement)) {
-                if (refCnt == decrement) {
-                    deallocate();
-                    return true;
-                }
-                return false;
+        // Fast path for the common case: try optimistic update first
+        int currentRefCnt;
+        do {
+            currentRefCnt = refCnt;
+            if (currentRefCnt < decrement) {
+                throw new IllegalReferenceCountException(currentRefCnt, -decrement);
             }
+        } while (!refCntUpdater.compareAndSet(this, currentRefCnt, currentRefCnt - decrement));
+        
+        if (currentRefCnt == decrement) {
+            deallocate();
+            return true;
         }
+        return false;
     }
 
     /**
