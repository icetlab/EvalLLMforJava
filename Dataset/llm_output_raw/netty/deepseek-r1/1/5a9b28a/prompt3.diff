diff --git a/common/src/main/java/io/netty/util/Recycler.java b/common/src/main/java/io/netty/util/Recycler.java
index a17a9906c4..7c67a0416c 100644
--- a/common/src/main/java/io/netty/util/Recycler.java
+++ b/common/src/main/java/io/netty/util/Recycler.java
@@ -275,13 +275,21 @@ public abstract class Recycler<T> {
 
         void toClaimed() {
             assert state == STATE_AVAILABLE;
-            STATE_UPDATER.lazySet(this, STATE_CLAIMED);
+            // Use plain volatile write instead of lazySet for claimed transition
+            // This ensures immediate visibility for the claiming thread
+            state = STATE_CLAIMED;
         }
 
         void toAvailable() {
-            int prev = STATE_UPDATER.getAndSet(this, STATE_AVAILABLE);
-            if (prev == STATE_AVAILABLE) {
-                throw new IllegalStateException("Object has been recycled already.");
+            // Optimize the common case: use compare-and-set only when needed
+            while (true) {
+                int current = state;
+                if (current == STATE_AVAILABLE) {
+                    throw new IllegalStateException("Object has been recycled already.");
+                }
+                if (STATE_UPDATER.compareAndSet(this, current, STATE_AVAILABLE)) {
+                    return;
+                }
             }
         }
 
@@ -338,17 +346,20 @@ public abstract class Recycler<T> {
             } else {
                 handle.unguardedToAvailable();
             }
+            Thread currentThread = Thread.currentThread();
             Thread owner = this.owner;
-            if (owner != null && Thread.currentThread() == owner && batch.size() < chunkSize) {
-                accept(handle);
-            } else if (owner != null && isTerminated(owner)) {
+            if (owner != null && currentThread == owner && batch.size() < chunkSize) {
+                batch.addLast(handle);
+                return;
+            }
+            if (owner != null && isTerminated(owner)) {
                 this.owner = null;
                 pooledHandles = null;
-            } else {
-                MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
-                if (handles != null) {
-                    handles.relaxedOffer(handle);
-                }
+                return;
+            }
+            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
+            if (handles != null) {
+                handles.relaxedOffer(handle);
             }
         }
 
@@ -370,6 +381,11 @@ public abstract class Recycler<T> {
         public void accept(DefaultHandle<T> e) {
             batch.addLast(e);
         }
+        
+        // Inline the accept call to avoid method invocation overhead in hot path
+        private void addToBatch(DefaultHandle<T> handle) {
+            batch.addLast(handle);
+        }
     }
 
     /**
@@ -397,36 +413,48 @@ public abstract class Recycler<T> {
         }
 
         @Override
-        public synchronized boolean offer(T e) {
-            if (deque.size() == maxCapacity) {
-                return false;
+        public boolean offer(T e) {
+            synchronized (this) {
+                if (deque.size() == maxCapacity) {
+                    return false;
+                }
+                return deque.offer(e);
             }
-            return deque.offer(e);
         }
 
         @Override
-        public synchronized T poll() {
-            return deque.poll();
+        public T poll() {
+            synchronized (this) {
+                return deque.poll();
+            }
         }
 
         @Override
-        public synchronized T peek() {
-            return deque.peek();
+        public T peek() {
+            synchronized (this) {
+                return deque.peek();
+            }
         }
 
         @Override
-        public synchronized int size() {
-            return deque.size();
+        public int size() {
+            synchronized (this) {
+                return deque.size();
+            }
         }
 
         @Override
-        public synchronized void clear() {
-            deque.clear();
+        public void clear() {
+            synchronized (this) {
+                deque.clear();
+            }
         }
 
         @Override
-        public synchronized boolean isEmpty() {
-            return deque.isEmpty();
+        public boolean isEmpty() {
+            synchronized (this) {
+                return deque.isEmpty();
+            }
         }
 
         @Override
