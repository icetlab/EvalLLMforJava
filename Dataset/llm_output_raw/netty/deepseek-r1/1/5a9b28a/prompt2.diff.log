The performance issue indicates that using `ArrayDeque::pollFirst` is inefficient in this context. Looking at the code, the `LocalPool` class uses an `ArrayDeque` for its `batch` field and calls `pollFirst()` in the `claim()` method. The issue likely relates to the overhead of queue operations for small batches.

**Performance Improvement Strategy:**
1. Replace the `ArrayDeque` batch with a simple fixed-size array-based circular buffer to eliminate queue overhead.
2. Use direct array indexing instead of queue operations for better cache locality and reduced method call overhead.
3. Maintain the same FIFO semantics with better performance characteristics for the small, fixed-size batches.

Here are the atomic changes:

```json
[
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "        private final ArrayDeque<DefaultHandle<T>> batch;\n        private volatile Thread owner;\n        private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;\n        private int ratioCounter;",
    "replace": "        private final DefaultHandle<T>[] batch;\n        private int batchHead;\n        private int batchTail;\n        private volatile Thread owner;\n        private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;\n        private int ratioCounter;"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "        @SuppressWarnings(\"unchecked\")\n        LocalPool(int maxCapacity, int ratioInterval, int chunkSize) {\n            this.ratioInterval = ratioInterval;\n            this.chunkSize = chunkSize;\n            batch = new ArrayDeque<DefaultHandle<T>>(chunkSize);\n            Thread currentThread = Thread.currentThread();\n            owner = !BATCH_FAST_TL_ONLY || currentThread instanceof FastThreadLocalThread ? currentThread : null;\n            if (BLOCKING_POOL) {\n                pooledHandles = new BlockingMessageQueue<DefaultHandle<T>>(maxCapacity);\n            } else {\n                pooledHandles = (MessagePassingQueue<DefaultHandle<T>>) newMpscQueue(chunkSize, maxCapacity);\n            }\n            ratioCounter = ratioInterval; // Start at interval so the first one will be recycled.\n        }",
    "replace": "        @SuppressWarnings(\"unchecked\")\n        LocalPool(int maxCapacity, int ratioInterval, int chunkSize) {\n            this.ratioInterval = ratioInterval;\n            this.chunkSize = chunkSize;\n            batch = (DefaultHandle<T>[]) new DefaultHandle[chunkSize];\n            batchHead = 0;\n            batchTail = 0;\n            Thread currentThread = Thread.currentThread();\n            owner = !BATCH_FAST_TL_ONLY || currentThread instanceof FastThreadLocalThread ? currentThread : null;\n            if (BLOCKING_POOL) {\n                pooledHandles = new BlockingMessageQueue<DefaultHandle<T>>(maxCapacity);\n            } else {\n                pooledHandles = (MessagePassingQueue<DefaultHandle<T>>) newMpscQueue(chunkSize, maxCapacity);\n            }\n            ratioCounter = ratioInterval; // Start at interval so the first one will be recycled.\n        }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "        DefaultHandle<T> claim() {\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            if (handles == null) {\n                return null;\n            }\n            if (batch.isEmpty()) {\n                handles.drain(this, chunkSize);\n            }\n            DefaultHandle<T> handle = batch.pollFirst();\n            if (null != handle) {\n                handle.toClaimed();\n            }\n            return handle;\n        }",
    "replace": "        DefaultHandle<T> claim() {\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            if (handles == null) {\n                return null;\n            }\n            if (batchHead == batchTail) {\n                handles.drain(this, chunkSize);\n                if (batchHead == batchTail) {\n                    return null;\n                }\n            }\n            DefaultHandle<T> handle = batch[batchHead];\n            batch[batchHead] = null;\n            batchHead = (batchHead + 1) % batch.length;\n            if (null != handle) {\n                handle.toClaimed();\n            }\n            return handle;\n        }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "        @Override\n        public void accept(DefaultHandle<T> e) {\n            batch.addLast(e);\n        }",
    "replace": "        @Override\n        public void accept(DefaultHandle<T> e) {\n            batch[batchTail] = e;\n            batchTail = (batchTail + 1) % batch.length;\n        }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "            Thread owner = this.owner;\n            if (owner != null && Thread.currentThread() == owner && batch.size() < chunkSize) {\n                accept(handle);\n            } else if (owner != null && isTerminated(owner)) {\n                this.owner = null;\n                pooledHandles = null;\n            } else {\n                MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n                if (handles != null) {\n                    handles.relaxedOffer(handle);\n                }\n            }",
    "replace": "            Thread owner = this.owner;\n            if (owner != null && Thread.currentThread() == owner && ((batchTail + 1) % batch.length) != batchHead) {\n                accept(handle);\n            } else if (owner != null && isTerminated(owner)) {\n                this.owner = null;\n                pooledHandles = null;\n            } else {\n                MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n                if (handles != null) {\n                    handles.relaxedOffer(handle);\n                }\n            }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "    @VisibleForTesting\n    final int threadLocalSize() {\n        LocalPool<T> localPool = threadLocal.getIfExists();\n        return localPool == null ? 0 : localPool.pooledHandles.size() + localPool.batch.size();\n    }",
    "replace": "    @VisibleForTesting\n    final int threadLocalSize() {\n        LocalPool<T> localPool = threadLocal.getIfExists();\n        if (localPool == null) {\n            return 0;\n        }\n        int batchSize = (localPool.batchTail - localPool.batchHead + localPool.batch.length) % localPool.batch.length;\n        return localPool.pooledHandles.size() + batchSize;\n    }"
  }
]
```