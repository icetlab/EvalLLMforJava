diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
index 3c6012601f..2c6c5c8291 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
@@ -438,35 +438,40 @@ final class PlatformDependent0 {
         final long baseOffset1 = BYTE_ARRAY_BASE_OFFSET + startPos1;
         final long baseOffset2 = BYTE_ARRAY_BASE_OFFSET + startPos2;
         final int remainingBytes = length & 7;
-        final long end = baseOffset1 + remainingBytes;
-        for (long i = baseOffset1 - 8 + length, j = baseOffset2 - 8 + length; i >= end; i -= 8, j -= 8) {
-            if (UNSAFE.getLong(bytes1, i) != UNSAFE.getLong(bytes2, j)) {
+        final long limit = baseOffset1 + (length - remainingBytes);
+        for (long l = baseOffset1, r = baseOffset2; l < limit; l += 8, r += 8) {
+            if (UNSAFE.getLong(bytes1, l) != UNSAFE.getLong(bytes2, r)) {
                 return false;
             }
         }
-        switch (remainingBytes) {
-        case 7:
-            return UNSAFE.getInt(bytes1, baseOffset1 + 3) == UNSAFE.getInt(bytes2, baseOffset2 + 3) &&
-                   UNSAFE.getChar(bytes1, baseOffset1 + 1) == UNSAFE.getChar(bytes2, baseOffset2 + 1) &&
-                   UNSAFE.getByte(bytes1, baseOffset1) == UNSAFE.getByte(bytes2, baseOffset2);
-        case 6:
-            return UNSAFE.getInt(bytes1, baseOffset1 + 2) == UNSAFE.getInt(bytes2, baseOffset2 + 2) &&
-                   UNSAFE.getChar(bytes1, baseOffset1) == UNSAFE.getChar(bytes2, baseOffset2);
-        case 5:
-            return UNSAFE.getInt(bytes1, baseOffset1 + 1) == UNSAFE.getInt(bytes2, baseOffset2 + 1) &&
-                   UNSAFE.getByte(bytes1, baseOffset1) == UNSAFE.getByte(bytes2, baseOffset2);
-        case 4:
-            return UNSAFE.getInt(bytes1, baseOffset1) == UNSAFE.getInt(bytes2, baseOffset2);
-        case 3:
-            return UNSAFE.getChar(bytes1, baseOffset1 + 1) == UNSAFE.getChar(bytes2, baseOffset2 + 1) &&
-                   UNSAFE.getByte(bytes1, baseOffset1) == UNSAFE.getByte(bytes2, baseOffset2);
-        case 2:
-            return UNSAFE.getChar(bytes1, baseOffset1) == UNSAFE.getChar(bytes2, baseOffset2);
-        case 1:
-            return UNSAFE.getByte(bytes1, baseOffset1) == UNSAFE.getByte(bytes2, baseOffset2);
-        default:
-            return true;
+        if (remainingBytes != 0) {
+            long l = baseOffset1 + (length - remainingBytes);
+            long r = baseOffset2 + (length - remainingBytes);
+            switch (remainingBytes) {
+            case 7:
+                return UNSAFE.getInt(bytes1, l + 3) == UNSAFE.getInt(bytes2, r + 3) &&
+                       UNSAFE.getChar(bytes1, l + 1) == UNSAFE.getChar(bytes2, r + 1) &&
+                       UNSAFE.getByte(bytes1, l) == UNSAFE.getByte(bytes2, r);
+            case 6:
+                return UNSAFE.getInt(bytes1, l + 2) == UNSAFE.getInt(bytes2, r + 2) &&
+                       UNSAFE.getChar(bytes1, l) == UNSAFE.getChar(bytes2, r);
+            case 5:
+                return UNSAFE.getInt(bytes1, l + 1) == UNSAFE.getInt(bytes2, r + 1) &&
+                       UNSAFE.getByte(bytes1, l) == UNSAFE.getByte(bytes2, r);
+            case 4:
+                return UNSAFE.getInt(bytes1, l) == UNSAFE.getInt(bytes2, r);
+            case 3:
+                return UNSAFE.getChar(bytes1, l + 1) == UNSAFE.getChar(bytes2, r + 1) &&
+                       UNSAFE.getByte(bytes1, l) == UNSAFE.getByte(bytes2, r);
+            case 2:
+                return UNSAFE.getChar(bytes1, l) == UNSAFE.getChar(bytes2, r);
+            case 1:
+                return UNSAFE.getByte(bytes1, l) == UNSAFE.getByte(bytes2, r);
+            default:
+                return true;
+            }
         }
+        return true;
     }
 
     static int equalsConstantTime(byte[] bytes1, int startPos1, byte[] bytes2, int startPos2, int length) {
@@ -474,73 +479,82 @@ final class PlatformDependent0 {
         final long baseOffset1 = BYTE_ARRAY_BASE_OFFSET + startPos1;
         final long baseOffset2 = BYTE_ARRAY_BASE_OFFSET + startPos2;
         final int remainingBytes = length & 7;
-        final long end = baseOffset1 + remainingBytes;
-        for (long i = baseOffset1 - 8 + length, j = baseOffset2 - 8 + length; i >= end; i -= 8, j -= 8) {
-            result |= UNSAFE.getLong(bytes1, i) ^ UNSAFE.getLong(bytes2, j);
+        final long limit = baseOffset1 + (length - remainingBytes);
+        for (long l = baseOffset1, r = baseOffset2; l < limit; l += 8, r += 8) {
+            result |= UNSAFE.getLong(bytes1, l) ^ UNSAFE.getLong(bytes2, r);
         }
-        switch (remainingBytes) {
-            case 7:
-                return ConstantTimeUtils.equalsConstantTime(result |
-                        (UNSAFE.getInt(bytes1, baseOffset1 + 3) ^ UNSAFE.getInt(bytes2, baseOffset2 + 3)) |
-                        (UNSAFE.getChar(bytes1, baseOffset1 + 1) ^ UNSAFE.getChar(bytes2, baseOffset2 + 1)) |
-                        (UNSAFE.getByte(bytes1, baseOffset1) ^ UNSAFE.getByte(bytes2, baseOffset2)), 0);
-            case 6:
-                return ConstantTimeUtils.equalsConstantTime(result |
-                        (UNSAFE.getInt(bytes1, baseOffset1 + 2) ^ UNSAFE.getInt(bytes2, baseOffset2 + 2)) |
-                        (UNSAFE.getChar(bytes1, baseOffset1) ^ UNSAFE.getChar(bytes2, baseOffset2)), 0);
-            case 5:
-                return ConstantTimeUtils.equalsConstantTime(result |
-                        (UNSAFE.getInt(bytes1, baseOffset1 + 1) ^ UNSAFE.getInt(bytes2, baseOffset2 + 1)) |
-                        (UNSAFE.getByte(bytes1, baseOffset1) ^ UNSAFE.getByte(bytes2, baseOffset2)), 0);
-            case 4:
-                return ConstantTimeUtils.equalsConstantTime(result |
-                        (UNSAFE.getInt(bytes1, baseOffset1) ^ UNSAFE.getInt(bytes2, baseOffset2)), 0);
-            case 3:
-                return ConstantTimeUtils.equalsConstantTime(result |
-                        (UNSAFE.getChar(bytes1, baseOffset1 + 1) ^ UNSAFE.getChar(bytes2, baseOffset2 + 1)) |
-                        (UNSAFE.getByte(bytes1, baseOffset1) ^ UNSAFE.getByte(bytes2, baseOffset2)), 0);
-            case 2:
-                return ConstantTimeUtils.equalsConstantTime(result |
-                        (UNSAFE.getChar(bytes1, baseOffset1) ^ UNSAFE.getChar(bytes2, baseOffset2)), 0);
-            case 1:
-                return ConstantTimeUtils.equalsConstantTime(result |
-                        (UNSAFE.getByte(bytes1, baseOffset1) ^ UNSAFE.getByte(bytes2, baseOffset2)), 0);
-            default:
-                return ConstantTimeUtils.equalsConstantTime(result, 0);
+        if (remainingBytes != 0) {
+            long l = baseOffset1 + (length - remainingBytes);
+            long r = baseOffset2 + (length - remainingBytes);
+            switch (remainingBytes) {
+                case 7:
+                    return ConstantTimeUtils.equalsConstantTime(result |
+                            (UNSAFE.getInt(bytes1, l + 3) ^ UNSAFE.getInt(bytes2, r + 3)) |
+                            (UNSAFE.getChar(bytes1, l + 1) ^ UNSAFE.getChar(bytes2, r + 1)) |
+                            (UNSAFE.getByte(bytes1, l) ^ UNSAFE.getByte(bytes2, r)), 0);
+                case 6:
+                    return ConstantTimeUtils.equalsConstantTime(result |
+                            (UNSAFE.getInt(bytes1, l + 2) ^ UNSAFE.getInt(bytes2, r + 2)) |
+                            (UNSAFE.getChar(bytes1, l) ^ UNSAFE.getChar(bytes2, r)), 0);
+                case 5:
+                    return ConstantTimeUtils.equalsConstantTime(result |
+                            (UNSAFE.getInt(bytes1, l + 1) ^ UNSAFE.getInt(bytes2, r + 1)) |
+                            (UNSAFE.getByte(bytes1, l) ^ UNSAFE.getByte(bytes2, r)), 0);
+                case 4:
+                    return ConstantTimeUtils.equalsConstantTime(result |
+                            (UNSAFE.getInt(bytes1, l) ^ UNSAFE.getInt(bytes2, r)), 0);
+                case 3:
+                    return ConstantTimeUtils.equalsConstantTime(result |
+                            (UNSAFE.getChar(bytes1, l + 1) ^ UNSAFE.getChar(bytes2, r + 1)) |
+                            (UNSAFE.getByte(bytes1, l) ^ UNSAFE.getByte(bytes2, r)), 0);
+                case 2:
+                    return ConstantTimeUtils.equalsConstantTime(result |
+                            (UNSAFE.getChar(bytes1, l) ^ UNSAFE.getChar(bytes2, r)), 0);
+                case 1:
+                    return ConstantTimeUtils.equalsConstantTime(result |
+                            (UNSAFE.getByte(bytes1, l) ^ UNSAFE.getByte(bytes2, r)), 0);
+                default:
+                    return ConstantTimeUtils.equalsConstantTime(result, 0);
+            }
         }
+        return ConstantTimeUtils.equalsConstantTime(result, 0);
     }
 
     static int hashCodeAscii(byte[] bytes, int startPos, int length) {
         int hash = HASH_CODE_ASCII_SEED;
         final long baseOffset = BYTE_ARRAY_BASE_OFFSET + startPos;
         final int remainingBytes = length & 7;
-        final long end = baseOffset + remainingBytes;
-        for (long i = baseOffset - 8 + length; i >= end; i -= 8) {
-            hash = hashCodeAsciiCompute(UNSAFE.getLong(bytes, i), hash);
+        final long limit = baseOffset + (length - remainingBytes);
+        for (long l = baseOffset; l < limit; l += 8) {
+            hash = hashCodeAsciiCompute(UNSAFE.getLong(bytes, l), hash);
         }
-        switch(remainingBytes) {
-        case 7:
-            return ((hash * HASH_CODE_C1 + hashCodeAsciiSanitize(UNSAFE.getByte(bytes, baseOffset)))
-                          * HASH_CODE_C2 + hashCodeAsciiSanitize(UNSAFE.getShort(bytes, baseOffset + 1)))
-                          * HASH_CODE_C1 + hashCodeAsciiSanitize(UNSAFE.getInt(bytes, baseOffset + 3));
-        case 6:
-            return (hash * HASH_CODE_C1 + hashCodeAsciiSanitize(UNSAFE.getShort(bytes, baseOffset)))
-                         * HASH_CODE_C2 + hashCodeAsciiSanitize(UNSAFE.getInt(bytes, baseOffset + 2));
-        case 5:
-            return (hash * HASH_CODE_C1 + hashCodeAsciiSanitize(UNSAFE.getByte(bytes, baseOffset)))
-                         * HASH_CODE_C2 + hashCodeAsciiSanitize(UNSAFE.getInt(bytes, baseOffset + 1));
-        case 4:
-            return hash * HASH_CODE_C1 + hashCodeAsciiSanitize(UNSAFE.getInt(bytes, baseOffset));
-        case 3:
-            return (hash * HASH_CODE_C1 + hashCodeAsciiSanitize(UNSAFE.getByte(bytes, baseOffset)))
-                         * HASH_CODE_C2 + hashCodeAsciiSanitize(UNSAFE.getShort(bytes, baseOffset + 1));
-        case 2:
-            return hash * HASH_CODE_C1 + hashCodeAsciiSanitize(UNSAFE.getShort(bytes, baseOffset));
-        case 1:
-            return hash * HASH_CODE_C1 + hashCodeAsciiSanitize(UNSAFE.getByte(bytes, baseOffset));
-        default:
-            return hash;
+        if (remainingBytes != 0) {
+            long l = baseOffset + (length - remainingBytes);
+            switch (remainingBytes) {
+            case 7:
+                return ((hash * HASH_CODE_C1 + hashCodeAsciiSanitize(UNSAFE.getByte(bytes, l)))
+                              * HASH_CODE_C2 + hashCodeAsciiSanitize(UNSAFE.getShort(bytes, l + 1)))
+                              * HASH_CODE_C1 + hashCodeAsciiSanitize(UNSAFE.getInt(bytes, l + 3));
+            case 6:
+                return (hash * HASH_CODE_C1 + hashCodeAsciiSanitize(UNSAFE.getShort(bytes, l)))
+                             * HASH_CODE_C2 + hashCodeAsciiSanitize(UNSAFE.getInt(bytes, l + 2));
+            case 5:
+                return (hash * HASH_CODE_C1 + hashCodeAsciiSanitize(UNSAFE.getByte(bytes, l)))
+                             * HASH_CODE_C2 + hashCodeAsciiSanitize(UNSAFE.getInt(bytes, l + 1));
+            case 4:
+                return hash * HASH_CODE_C1 + hashCodeAsciiSanitize(UNSAFE.getInt(bytes, l));
+            case 3:
+                return (hash * HASH_CODE_C1 + hashCodeAsciiSanitize(UNSAFE.getByte(bytes, l)))
+                             * HASH_CODE_C2 + hashCodeAsciiSanitize(UNSAFE.getShort(bytes, l + 1));
+            case 2:
+                return hash * HASH_CODE_C1 + hashCodeAsciiSanitize(UNSAFE.getShort(bytes, l));
+            case 1:
+                return hash * HASH_CODE_C1 + hashCodeAsciiSanitize(UNSAFE.getByte(bytes, l));
+            default:
+                return hash;
+            }
         }
+        return hash;
     }
 
     static int hashCodeAsciiCompute(long value, int hash) {
