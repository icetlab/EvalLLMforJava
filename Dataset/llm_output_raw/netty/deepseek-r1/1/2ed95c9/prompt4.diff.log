Explanation: The performance of HpackStaticTable can be improved by replacing the linear scan in `getIndexInsensitive` with a perfect hash function. The current implementation uses a hash map for name lookup followed by a linear scan through values with the same name. By creating a perfect hash map for (name, value) pairs, we can achieve O(1) lookup time for exact header field matches.

The plan is to:
1. Precompute a perfect hash map that directly maps (name, value) pairs to their static table indices.
2. Remove the linear scan logic and use the perfect hash map for lookups.
3. Keep the existing `getIndex` method for name-only lookups unchanged since it's already efficient.

```json
[
  {
    "filepath": "../netty/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java",
    "search": "    private static final int MAX_SAME_NAME_FIELD_INDEX = maxSameNameFieldIndex();\n\n    /**\n     * The number of header fields in the static table.\n     */\n    static final int length = STATIC_TABLE.size();",
    "replace": "    /**\n     * The number of header fields in the static table.\n     */\n    static final int length = STATIC_TABLE.size();\n\n    // Perfect hash map for (name, value) pairs to static table indices\n    private static final CharSequenceMap<Integer> PERFECT_HASH_MAP = createPerfectHashMap();"
  },
  {
    "filepath": "../netty/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java",
    "search": "    /**\n     * Returns the index value for the given header field in the static table. Returns -1 if the\n     * header field is not in the static table.\n     */\n    static int getIndexInsensitive(CharSequence name, CharSequence value) {\n        int index = getIndex(name);\n        if (index == NOT_FOUND) {\n            return NOT_FOUND;\n        }\n\n        // Compare values for the first name match\n        HpackHeaderField entry = getEntry(index);\n        if (equalsVariableTime(value, entry.value)) {\n            return index;\n        }\n\n        // Note this assumes all entries for a given header field are sequential.\n        index++;\n        while (index <= MAX_SAME_NAME_FIELD_INDEX) {\n            entry = getEntry(index);\n            if (!equalsVariableTime(name, entry.name)) {\n                // As far as fields with the same name are placed in the table sequentially\n                // and INDEX_BY_NAME returns index of the fist position, - it's safe to\n                // exit immediately.\n                return NOT_FOUND;\n            }\n            if (equalsVariableTime(value, entry.value)) {\n                return index;\n            }\n            index++;\n        }\n\n        return NOT_FOUND;\n    }",
    "replace": "    /**\n     * Returns the index value for the given header field in the static table. Returns -1 if the\n     * header field is not in the static table.\n     */\n    static int getIndexInsensitive(CharSequence name, CharSequence value) {\n        // Use perfect hash map for direct (name, value) lookup\n        Integer index = PERFECT_HASH_MAP.get(name, value);\n        return index == null ? NOT_FOUND : index;\n    }"
  },
  {
    "filepath": "../netty/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java",
    "search": "    /**\n     * Returns the last position in the array that contains multiple\n     * fields with the same name. Starting from this position, all\n     * names are unique. Similar to {@link #getIndexInsensitive(CharSequence, CharSequence)} method\n     * assumes all entries for a given header field are sequential\n     */\n    private static int maxSameNameFieldIndex() {\n        final int length = STATIC_TABLE.size();\n        HpackHeaderField cursor = getEntry(length);\n        for (int index = length - 1; index > 0; index--) {\n            HpackHeaderField entry = getEntry(index);\n            if (equalsVariableTime(entry.name, cursor.name)) {\n                return index + 1;\n            } else {\n                cursor = entry;\n            }\n        }\n        return length;\n    }\n\n    // singleton",
    "replace": "    // create a perfect hash map for (name, value) pairs\n    private static CharSequenceMap<Integer> createPerfectHashMap() {\n        int length = STATIC_TABLE.size();\n        @SuppressWarnings(\"unchecked\")\n        CharSequenceMap<Integer> map = new CharSequenceMap<Integer>(true,\n                UnsupportedValueConverter.<Integer>instance(), length);\n        \n        // Add all (name, value) pairs to the map\n        for (int index = 1; index <= length; index++) {\n            HpackHeaderField entry = getEntry(index);\n            map.set(entry.name, entry.value, index);\n        }\n        return map;\n    }\n\n    // singleton"
  }
]
```