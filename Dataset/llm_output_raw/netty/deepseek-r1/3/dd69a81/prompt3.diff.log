## Explanation

The main performance issue in the `HttpRequestEncoder` is in the `encodeInitialLine` method where URI normalization logic creates unnecessary `StringBuilder` objects and performs redundant string operations. The current implementation:
1. Creates a new `StringBuilder` even when no slash needs to be inserted
2. Performs multiple indexOf/lastIndexOf operations on the same string
3. Uses string concatenation (`uri += SLASH`) which creates new string objects

The improvement focuses on:
- Avoiding `StringBuilder` creation when no modification is needed
- Reducing redundant string index operations
- Using direct buffer writes instead of intermediate string building
- Simplifying the logic flow to reduce branching

```json
[
  {
    "filepath": "../netty/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java",
    "search": "        // Add / as absolute path if no is present.\n        // See http://tools.ietf.org/html/rfc2616#section-5.1.2\n        String uri = request.uri();\n\n        if (uri.isEmpty()) {\n            uri += SLASH;\n        } else {\n            int start = uri.indexOf(\"://\");\n            if (start != -1 && uri.charAt(0) != SLASH) {\n                int startIndex = start + 3;\n                // Correctly handle query params.\n                // See https://github.com/netty/netty/issues/2732\n                int index = uri.indexOf(QUESTION_MARK, startIndex);\n                if (index == -1) {\n                    if (uri.lastIndexOf(SLASH) <= startIndex) {\n                        uri += SLASH;\n                    }\n                } else {\n                    if (uri.lastIndexOf(SLASH, index) <= startIndex) {\n                        int len = uri.length();\n                        StringBuilder sb = new StringBuilder(len + 1);\n                        sb.append(uri, 0, index)\n                          .append(SLASH)\n                          .append(uri, index, len);\n                        uri = sb.toString();\n                    }\n                }\n            }\n        }\n\n        buf.writeCharSequence(uri, CharsetUtil.UTF_8);",
    "replace": "        // Add / as absolute path if no is present.\n        // See http://tools.ietf.org/html/rfc2616#section-5.1.2\n        String uri = request.uri();\n\n        if (uri.isEmpty()) {\n            buf.writeByte(SLASH);\n            return;\n        }\n\n        int start = uri.indexOf(\"://\");\n        if (start == -1 || uri.charAt(0) == SLASH) {\n            // No protocol or already absolute path, write as-is\n            buf.writeCharSequence(uri, CharsetUtil.UTF_8);\n            return;\n        }\n\n        int startIndex = start + 3;\n        int queryIndex = uri.indexOf(QUESTION_MARK, startIndex);\n        \n        // Check if we need to insert a slash\n        boolean needsSlash = false;\n        if (queryIndex == -1) {\n            // No query string\n            needsSlash = uri.lastIndexOf(SLASH) <= startIndex;\n        } else {\n            // Has query string\n            needsSlash = uri.lastIndexOf(SLASH, queryIndex) <= startIndex;\n        }\n\n        if (!needsSlash) {\n            // No slash needed, write as-is\n            buf.writeCharSequence(uri, CharsetUtil.UTF_8);\n            return;\n        }\n\n        // Need to insert a slash\n        if (queryIndex == -1) {\n            // No query string, write whole URI then slash\n            buf.writeCharSequence(uri, CharsetUtil.UTF_8);\n            buf.writeByte(SLASH);\n        } else {\n            // Has query string, write parts separately\n            buf.writeCharSequence(uri, 0, queryIndex, CharsetUtil.UTF_8);\n            buf.writeByte(SLASH);\n            buf.writeCharSequence(uri, queryIndex, uri.length(), CharsetUtil.UTF_8);\n        }"
  },
  {
    "filepath": "../netty/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java",
    "search": "    @Override\n    protected void encodeInitialLine(ByteBuf buf, HttpRequest request) throws Exception {\n        ByteBufUtil.copy(request.method().asciiName(), buf);\n        buf.writeByte(SP);\n\n        // Add / as absolute path if no is present.\n        // See http://tools.ietf.org/html/rfc2616#section-5.1.2\n        String uri = request.uri();\n\n        if (uri.isEmpty()) {\n            buf.writeByte(SLASH);\n            return;\n        }\n\n        int start = uri.indexOf(\"://\");\n        if (start == -1 || uri.charAt(0) == SLASH) {\n            // No protocol or already absolute path, write as-is\n            buf.writeCharSequence(uri, CharsetUtil.UTF_8);\n            return;\n        }\n\n        int startIndex = start + 3;\n        int queryIndex = uri.indexOf(QUESTION_MARK, startIndex);\n        \n        // Check if we need to insert a slash\n        boolean needsSlash = false;\n        if (queryIndex == -1) {\n            // No query string\n            needsSlash = uri.lastIndexOf(SLASH) <= startIndex;\n        } else {\n            // Has query string\n            needsSlash = uri.lastIndexOf(SLASH, queryIndex) <= startIndex;\n        }\n\n        if (!needsSlash) {\n            // No slash needed, write as-is\n            buf.writeCharSequence(uri, CharsetUtil.UTF_8);\n            return;\n        }\n\n        // Need to insert a slash\n        if (queryIndex == -1) {\n            // No query string, write whole URI then slash\n            buf.writeCharSequence(uri, CharsetUtil.UTF_8);\n            buf.writeByte(SLASH);\n        } else {\n            // Has query string, write parts separately\n            buf.writeCharSequence(uri, 0, queryIndex, CharsetUtil.UTF_8);\n            buf.writeByte(SLASH);\n            buf.writeCharSequence(uri, queryIndex, uri.length(), CharsetUtil.UTF_8);\n        }\n\n        buf.writeByte(SP);\n        request.protocolVersion().encode(buf);\n        buf.writeBytes(CRLF);\n    }",
    "replace": "    @Override\n    protected void encodeInitialLine(ByteBuf buf, HttpRequest request) throws Exception {\n        ByteBufUtil.copy(request.method().asciiName(), buf);\n        buf.writeByte(SP);\n\n        // Add / as absolute path if no is present.\n        // See http://tools.ietf.org/html/rfc2616#section-5.1.2\n        String uri = request.uri();\n\n        if (uri.isEmpty()) {\n            buf.writeByte(SLASH);\n        } else {\n            int start = uri.indexOf(\"://\");\n            if (start == -1 || uri.charAt(0) == SLASH) {\n                // No protocol or already absolute path, write as-is\n                buf.writeCharSequence(uri, CharsetUtil.UTF_8);\n            } else {\n                int startIndex = start + 3;\n                int queryIndex = uri.indexOf(QUESTION_MARK, startIndex);\n                \n                // Check if we need to insert a slash\n                boolean needsSlash = false;\n                if (queryIndex == -1) {\n                    // No query string\n                    needsSlash = uri.lastIndexOf(SLASH) <= startIndex;\n                } else {\n                    // Has query string\n                    needsSlash = uri.lastIndexOf(SLASH, queryIndex) <= startIndex;\n                }\n\n                if (!needsSlash) {\n                    // No slash needed, write as-is\n                    buf.writeCharSequence(uri, CharsetUtil.UTF_8);\n                } else if (queryIndex == -1) {\n                    // No query string, write whole URI then slash\n                    buf.writeCharSequence(uri, CharsetUtil.UTF_8);\n                    buf.writeByte(SLASH);\n                } else {\n                    // Has query string, write parts separately\n                    buf.writeCharSequence(uri, 0, queryIndex, CharsetUtil.UTF_8);\n                    buf.writeByte(SLASH);\n                    buf.writeCharSequence(uri, queryIndex, uri.length(), CharsetUtil.UTF_8);\n                }\n            }\n        }\n\n        buf.writeByte(SP);\n        request.protocolVersion().encode(buf);\n        buf.writeBytes(CRLF);\n    }"
  }
]
```