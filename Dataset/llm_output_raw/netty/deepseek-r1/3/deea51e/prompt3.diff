diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java
index 301a2c51cf..1550d476c0 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java
@@ -141,9 +141,12 @@ final class HpackEncoder {
      * <strong>The given {@link CharSequence}s must be immutable!</strong>
      */
     private void encodeHeader(ByteBuf out, CharSequence name, CharSequence value, boolean sensitive, long headerSize) {
+        // Precompute hash for dynamic table lookups
+        int nameHash = AsciiString.hashCode(name);
+        
         // If the header value is sensitive then it must never be indexed
         if (sensitive) {
-            int nameIndex = getNameIndex(name);
+            int nameIndex = getNameIndex(name, nameHash);
             encodeLiteral(out, name, value, IndexType.NEVER, nameIndex);
             return;
         }
@@ -162,12 +165,12 @@ final class HpackEncoder {
 
         // If the headerSize is greater than the max table size then it must be encoded literally
         if (headerSize > maxHeaderTableSize) {
-            int nameIndex = getNameIndex(name);
+            int nameIndex = getNameIndex(name, nameHash);
             encodeLiteral(out, name, value, IndexType.NONE, nameIndex);
             return;
         }
 
-        HeaderEntry headerField = getEntry(name, value);
+        HeaderEntry headerField = getEntry(name, value, nameHash);
         if (headerField != null) {
             int index = getIndex(headerField.index) + HpackStaticTable.length;
             // Section 6.1. Indexed Header Field Representation
@@ -179,8 +182,8 @@ final class HpackEncoder {
                 encodeInteger(out, 0x80, 7, staticTableIndex);
             } else {
                 ensureCapacity(headerSize);
-                encodeLiteral(out, name, value, IndexType.INCREMENTAL, getNameIndex(name));
-                add(name, value, headerSize);
+                encodeLiteral(out, name, value, IndexType.INCREMENTAL, getNameIndex(name, nameHash));
+                add(name, value, headerSize, nameHash);
             }
         }
     }
@@ -293,10 +296,10 @@ final class HpackEncoder {
         encodeStringLiteral(out, value);
     }
 
-    private int getNameIndex(CharSequence name) {
+    private int getNameIndex(CharSequence name, int nameHash) {
         int index = HpackStaticTable.getIndex(name);
         if (index == -1) {
-            index = getIndex(name);
+            index = getIndex(name, nameHash);
             if (index >= 0) {
                 index += HpackStaticTable.length;
             }
@@ -347,15 +350,14 @@ final class HpackEncoder {
      * Returns the header entry with the lowest index value for the header field. Returns null if
      * header field is not in the dynamic table.
      */
-    private HeaderEntry getEntry(CharSequence name, CharSequence value) {
+    private HeaderEntry getEntry(CharSequence name, CharSequence value, int nameHash) {
         if (length() == 0 || name == null || value == null) {
             return null;
         }
-        int h = AsciiString.hashCode(name);
-        int i = index(h);
+        int i = index(nameHash);
         for (HeaderEntry e = headerFields[i]; e != null; e = e.next) {
             // To avoid short circuit behavior a bitwise operator is used instead of a boolean operator.
-            if (e.hash == h && (equalsConstantTime(name, e.name) & equalsConstantTime(value, e.value)) != 0) {
+            if (e.hash == nameHash && (equalsConstantTime(name, e.name) & equalsConstantTime(value, e.value)) != 0) {
                 return e;
             }
         }
@@ -366,14 +368,13 @@ final class HpackEncoder {
      * Returns the lowest index value for the header field name in the dynamic table. Returns -1 if
      * the header field name is not in the dynamic table.
      */
-    private int getIndex(CharSequence name) {
+    private int getIndex(CharSequence name, int nameHash) {
         if (length() == 0 || name == null) {
             return -1;
         }
-        int h = AsciiString.hashCode(name);
-        int i = index(h);
+        int i = index(nameHash);
         for (HeaderEntry e = headerFields[i]; e != null; e = e.next) {
-            if (e.hash == h && equalsConstantTime(name, e.name) != 0) {
+            if (e.hash == nameHash && equalsConstantTime(name, e.name) != 0) {
                 return getIndex(e.index);
             }
         }
@@ -392,7 +393,7 @@ final class HpackEncoder {
      * the size of the table and the new header field is less than the table's maxHeaderTableSize. If the size
      * of the new entry is larger than the table's maxHeaderTableSize, the dynamic table will be cleared.
      */
-    private void add(CharSequence name, CharSequence value, long headerSize) {
+    private void add(CharSequence name, CharSequence value, long headerSize, int nameHash) {
         // Clear the table if the header field size is larger than the maxHeaderTableSize.
         if (headerSize > maxHeaderTableSize) {
             clear();
@@ -404,10 +405,9 @@ final class HpackEncoder {
             remove();
         }
 
-        int h = AsciiString.hashCode(name);
-        int i = index(h);
+        int i = index(nameHash);
         HeaderEntry old = headerFields[i];
-        HeaderEntry e = new HeaderEntry(h, name, value, head.before.index - 1, old);
+        HeaderEntry e = new HeaderEntry(nameHash, name, value, head.before.index - 1, old);
         headerFields[i] = e;
         e.addBefore(head);
         size += headerSize;
