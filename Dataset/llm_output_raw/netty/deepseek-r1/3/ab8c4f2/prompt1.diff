diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java
index 8db29fd7bd..edf8da2828 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java
@@ -159,15 +159,17 @@ final class HpackEncoder {
             return;
         }
 
+        // Check static table first as it's cheaper
+        int staticTableIndex = HpackStaticTable.getIndexInsensitive(name, value);
+        if (staticTableIndex != -1) {
+            encodeInteger(out, 0x80, 7, staticTableIndex);
+            return;
+        }
+
         // If the peer will only use the static table
         if (maxHeaderTableSize == 0) {
-            int staticTableIndex = HpackStaticTable.getIndexInsensitive(name, value);
-            if (staticTableIndex == -1) {
-                int nameIndex = HpackStaticTable.getIndex(name);
-                encodeLiteral(out, name, value, IndexType.NONE, nameIndex);
-            } else {
-                encodeInteger(out, 0x80, 7, staticTableIndex);
-            }
+            int nameIndex = HpackStaticTable.getIndex(name);
+            encodeLiteral(out, name, value, IndexType.NONE, nameIndex);
             return;
         }
 
@@ -184,15 +186,9 @@ final class HpackEncoder {
             // Section 6.1. Indexed Header Field Representation
             encodeInteger(out, 0x80, 7, index);
         } else {
-            int staticTableIndex = HpackStaticTable.getIndexInsensitive(name, value);
-            if (staticTableIndex != -1) {
-                // Section 6.1. Indexed Header Field Representation
-                encodeInteger(out, 0x80, 7, staticTableIndex);
-            } else {
-                ensureCapacity(headerSize);
-                encodeLiteral(out, name, value, IndexType.INCREMENTAL, getNameIndex(name));
-                add(name, value, headerSize);
-            }
+            ensureCapacity(headerSize);
+            encodeLiteral(out, name, value, IndexType.INCREMENTAL, getNameIndex(name));
+            add(name, value, headerSize);
         }
     }
 
@@ -308,7 +304,9 @@ final class HpackEncoder {
     private int getNameIndex(CharSequence name) {
         int index = HpackStaticTable.getIndex(name);
         if (index == -1) {
-            index = getIndex(name);
+            // Precompute hash to avoid recomputing in getIndex
+            int h = AsciiString.hashCode(name);
+            index = getIndex(name, h);
             if (index >= 0) {
                 index += HpackStaticTable.length;
             }
@@ -364,6 +362,10 @@ final class HpackEncoder {
             return null;
         }
         int h = AsciiString.hashCode(name);
+        return getEntryInsensitive(name, value, h);
+    }
+
+    private HeaderEntry getEntryInsensitive(CharSequence name, CharSequence value, int h) {
         int i = index(h);
         for (HeaderEntry e = headerFields[i]; e != null; e = e.next) {
             // Check the value before then name, as it is more likely the value will be different incase there is no
@@ -384,6 +386,10 @@ final class HpackEncoder {
             return -1;
         }
         int h = AsciiString.hashCode(name);
+        return getIndex(name, h);
+    }
+
+    private int getIndex(CharSequence name, int h) {
         int i = index(h);
         for (HeaderEntry e = headerFields[i]; e != null; e = e.next) {
             if (e.hash == h && equalsConstantTime(name, e.name) != 0) {
