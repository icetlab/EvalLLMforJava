diff --git a/common/src/main/java/io/netty/util/NetUtil.java b/common/src/main/java/io/netty/util/NetUtil.java
index fbe09ea676..3a70e2d457 100644
--- a/common/src/main/java/io/netty/util/NetUtil.java
+++ b/common/src/main/java/io/netty/util/NetUtil.java
@@ -90,6 +90,16 @@ public final class NetUtil {
      */
     private static final int IPV6_BYTE_COUNT = 16;
 
+    /**
+     * Precomputed string representation of numbers 0-255 for fast IPv4 address string conversion.
+     */
+    private static final String[] IPV4_OCTET_STRINGS = new String[256];
+    static {
+        for (int i = 0; i < 256; i++) {
+            IPV4_OCTET_STRINGS[i] = Integer.toString(i);
+        }
+    }
+
     /**
      * Maximum amount of value adding characters in between IPV6 separators
      */
@@ -344,17 +354,16 @@ public final class NetUtil {
     }
 
     private static byte ipv4WordToByte(String ip, int from, int toExclusive) {
+        int len = toExclusive - from;
         int ret = decimalDigit(ip, from);
-        from++;
-        if (from == toExclusive) {
+        if (len == 1) {
             return (byte) ret;
         }
-        ret = ret * 10 + decimalDigit(ip, from);
-        from++;
-        if (from == toExclusive) {
+        ret = ret * 10 + decimalDigit(ip, from + 1);
+        if (len == 2) {
             return (byte) ret;
         }
-        return (byte) (ret * 10 + decimalDigit(ip, from));
+        return (byte) (ret * 10 + decimalDigit(ip, from + 2));
     }
 
     // visible for tests
@@ -384,15 +393,15 @@ public final class NetUtil {
      * Converts a 32-bit integer into an IPv4 address.
      */
     public static String intToIpAddress(int i) {
-        StringBuilder buf = new StringBuilder(15);
-        buf.append(i >> 24 & 0xff);
-        buf.append('.');
-        buf.append(i >> 16 & 0xff);
-        buf.append('.');
-        buf.append(i >> 8 & 0xff);
-        buf.append('.');
-        buf.append(i & 0xff);
-        return buf.toString();
+        return new StringBuilder(15)
+                .append(IPV4_OCTET_STRINGS[(i >> 24) & 0xff])
+                .append('.')
+                .append(IPV4_OCTET_STRINGS[(i >> 16) & 0xff])
+                .append('.')
+                .append(IPV4_OCTET_STRINGS[(i >> 8) & 0xff])
+                .append('.')
+                .append(IPV4_OCTET_STRINGS[i & 0xff])
+                .toString();
     }
 
     /**
@@ -415,13 +424,13 @@ public final class NetUtil {
         switch (length) {
             case 4: {
                 return new StringBuilder(15)
-                        .append(bytes[offset] & 0xff)
+                        .append(IPV4_OCTET_STRINGS[bytes[offset] & 0xff])
                         .append('.')
-                        .append(bytes[offset + 1] & 0xff)
+                        .append(IPV4_OCTET_STRINGS[bytes[offset + 1] & 0xff])
                         .append('.')
-                        .append(bytes[offset + 2] & 0xff)
+                        .append(IPV4_OCTET_STRINGS[bytes[offset + 2] & 0xff])
                         .append('.')
-                        .append(bytes[offset + 3] & 0xff).toString();
+                        .append(IPV4_OCTET_STRINGS[bytes[offset + 3] & 0xff]).toString();
             }
             case 16:
                 return toAddressString(bytes, offset, false);
@@ -556,17 +565,30 @@ public final class NetUtil {
 
     private static boolean isValidIpV4Word(CharSequence word, int from, int toExclusive) {
         int len = toExclusive - from;
-        char c0, c1, c2;
-        if (len < 1 || len > 3 || (c0 = word.charAt(from)) < '0') {
+        if (len < 1 || len > 3) {
             return false;
         }
-        if (len == 3) {
-            return (c1 = word.charAt(from + 1)) >= '0' &&
-                   (c2 = word.charAt(from + 2)) >= '0' &&
-                   (c0 <= '1' && c1 <= '9' && c2 <= '9' ||
-                    c0 == '2' && c1 <= '5' && (c2 <= '5' || c1 < '5' && c2 <= '9'));
+        char c0 = word.charAt(from);
+        if (c0 < '0' || c0 > '9') {
+            return false;
+        }
+        if (len == 1) {
+            return true;
+        }
+        char c1 = word.charAt(from + 1);
+        if (c1 < '0' || c1 > '9') {
+            return false;
+        }
+        if (len == 2) {
+            return true;
+        }
+        char c2 = word.charAt(from + 2);
+        if (c2 < '0' || c2 > '9') {
+            return false;
         }
-        return c0 <= '9' && (len == 1 || isValidNumericChar(word.charAt(from + 1)));
+        // Check if the 3-digit number is <= 255
+        int value = (c0 - '0') * 100 + (c1 - '0') * 10 + (c2 - '0');
+        return value <= 255 && (c0 != '0' || (c1 == '0' && c2 == '0'));
     }
 
     private static boolean isValidHexChar(char c) {
@@ -718,6 +740,7 @@ public final class NetUtil {
         int ipv4Separators = 0;
         int tmp;
         boolean needsShift = false;
+        final int ipLengthMinusOne = ipLength - 1;
         for (; i < ipLength; ++i) {
             final char c = ip.charAt(i);
             switch (c) {
