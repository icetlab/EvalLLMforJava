diff --git a/common/src/main/java/io/netty/util/NetUtil.java b/common/src/main/java/io/netty/util/NetUtil.java
index fbe09ea676..b945de720c 100644
--- a/common/src/main/java/io/netty/util/NetUtil.java
+++ b/common/src/main/java/io/netty/util/NetUtil.java
@@ -359,13 +359,28 @@ public final class NetUtil {
 
     // visible for tests
     static byte[] validIpV4ToBytes(String ip) {
-        int i;
-        return new byte[] {
-                ipv4WordToByte(ip, 0, i = ip.indexOf('.', 1)),
-                ipv4WordToByte(ip, i + 1, i = ip.indexOf('.', i + 2)),
-                ipv4WordToByte(ip, i + 1, i = ip.indexOf('.', i + 2)),
-                ipv4WordToByte(ip, i + 1, ip.length())
-        };
+        // Optimized IPv4 parsing: parse directly without multiple indexOf calls
+        byte[] result = new byte[4];
+        int start = 0;
+        int byteIndex = 0;
+        
+        for (int i = 0; i <= ip.length(); i++) {
+            if (i == ip.length() || ip.charAt(i) == '.') {
+                // Parse octet directly
+                int octet = 0;
+                for (int j = start; j < i; j++) {
+                    octet = octet * 10 + (ip.charAt(j) - '0');
+                }
+                result[byteIndex++] = (byte) octet;
+                start = i + 1;
+                
+                if (byteIndex == 4) {
+                    break;
+                }
+            }
+        }
+        
+        return result;
     }
 
     /**
@@ -384,15 +399,66 @@ public final class NetUtil {
      * Converts a 32-bit integer into an IPv4 address.
      */
     public static String intToIpAddress(int i) {
-        StringBuilder buf = new StringBuilder(15);
-        buf.append(i >> 24 & 0xff);
-        buf.append('.');
-        buf.append(i >> 16 & 0xff);
-        buf.append('.');
-        buf.append(i >> 8 & 0xff);
-        buf.append('.');
-        buf.append(i & 0xff);
-        return buf.toString();
+        // Optimized: use char array instead of StringBuilder for simple concatenation
+        char[] chars = new char[15];
+        int pos = 0;
+        
+        // First octet
+        int octet = (i >> 24) & 0xff;
+        if (octet >= 100) {
+            chars[pos++] = (char) ('0' + octet / 100);
+            octet %= 100;
+            chars[pos++] = (char) ('0' + octet / 10);
+            octet %= 10;
+        } else if (octet >= 10) {
+            chars[pos++] = (char) ('0' + octet / 10);
+            octet %= 10;
+        }
+        chars[pos++] = (char) ('0' + octet);
+        chars[pos++] = '.';
+        
+        // Second octet
+        octet = (i >> 16) & 0xff;
+        if (octet >= 100) {
+            chars[pos++] = (char) ('0' + octet / 100);
+            octet %= 100;
+            chars[pos++] = (char) ('0' + octet / 10);
+            octet %= 10;
+        } else if (octet >= 10) {
+            chars[pos++] = (char) ('0' + octet / 10);
+            octet %= 10;
+        }
+        chars[pos++] = (char) ('0' + octet);
+        chars[pos++] = '.';
+        
+        // Third octet
+        octet = (i >> 8) & 0xff;
+        if (octet >= 100) {
+            chars[pos++] = (char) ('0' + octet / 100);
+            octet %= 100;
+            chars[pos++] = (char) ('0' + octet / 10);
+            octet %= 10;
+        } else if (octet >= 10) {
+            chars[pos++] = (char) ('0' + octet / 10);
+            octet %= 10;
+        }
+        chars[pos++] = (char) ('0' + octet);
+        chars[pos++] = '.';
+        
+        // Fourth octet
+        octet = i & 0xff;
+        if (octet >= 100) {
+            chars[pos++] = (char) ('0' + octet / 100);
+            octet %= 100;
+            chars[pos++] = (char) ('0' + octet / 10);
+            octet %= 10;
+        } else if (octet >= 10) {
+            chars[pos++] = (char) ('0' + octet / 10);
+            octet %= 10;
+        }
+        chars[pos++] = (char) ('0' + octet);
+        
+        return new String(chars, 0, pos);
     }
 
     /**
@@ -556,25 +622,59 @@ public final class NetUtil {
 
     private static boolean isValidIpV4Word(CharSequence word, int from, int toExclusive) {
         int len = toExclusive - from;
-        char c0, c1, c2;
-        if (len < 1 || len > 3 || (c0 = word.charAt(from)) < '0') {
+        if (len < 1 || len > 3) {
+            return false;
+        }
+        
+        char c0 = word.charAt(from);
+        if (c0 < '0' || c0 > '9') {
+            return false;
+        }
+        
+        if (len == 1) {
+            return true;
+        }
+        
+        char c1 = word.charAt(from + 1);
+        if (c1 < '0' || c1 > '9') {
+            return false;
+        }
+        
+        if (len == 2) {
+            return true;
+        }
+        
+        char c2 = word.charAt(from + 2);
+        if (c2 < '0' || c2 > '9') {
+            return false;
+        }
+        
+        // Check if value is <= 255
+        int value = (c0 - '0') * 100 + (c1 - '0') * 10 + (c2 - '0');
+        if (value > 255) {
             return false;
         }
-        if (len == 3) {
-            return (c1 = word.charAt(from + 1)) >= '0' &&
-                   (c2 = word.charAt(from + 2)) >= '0' &&
-                   (c0 <= '1' && c1 <= '9' && c2 <= '9' ||
-                    c0 == '2' && c1 <= '5' && (c2 <= '5' || c1 < '5' && c2 <= '9'));
+        
+        // Additional validation for leading zeros
+        if (c0 == '0') {
+            // Leading zero only allowed for single digit (0) or two-digit with second digit 0-9
+            return len == 1 || (c1 == '0' && len == 2) || (len == 3 && c1 == '0' && c2 == '0');
         }
-        return c0 <= '9' && (len == 1 || isValidNumericChar(word.charAt(from + 1)));
+        
+        return true;
     }
 
     private static boolean isValidHexChar(char c) {
-        return c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f';
+        // Optimized: use single range checks with bit manipulation
+        // '0'-'9': 0x30-0x39, 'A'-'F': 0x41-0x46, 'a'-'f': 0x61-0x66
+        int ch = c;
+        return (ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'F') || (ch >= 'a' && ch <= 'f');
     }
 
     private static boolean isValidNumericChar(char c) {
-        return c >= '0' && c <= '9';
+        // Optimized: direct comparison
+        int ch = c;
+        return ch >= '0' && ch <= '9';
     }
 
     private static boolean isValidIPv4MappedChar(char c) {
@@ -616,20 +716,42 @@ public final class NetUtil {
     }
 
     private static boolean isValidIpV4Address(CharSequence ip, int from, int toExcluded) {
-        return ip instanceof String ? isValidIpV4Address((String) ip, from, toExcluded) :
-                ip instanceof AsciiString ? isValidIpV4Address((AsciiString) ip, from, toExcluded) :
-                        isValidIpV4Address0(ip, from, toExcluded);
+        // Fast path for common String type to avoid instanceof checks in most cases
+        if (ip instanceof String) {
+            return isValidIpV4Address((String) ip, from, toExcluded);
+        }
+        if (ip instanceof AsciiString) {
+            return isValidIpV4Address((AsciiString) ip, from, toExcluded);
+        }
+        return isValidIpV4Address0(ip, from, toExcluded);
     }
 
     @SuppressWarnings("DuplicateBooleanBranch")
     private static boolean isValidIpV4Address(String ip, int from, int toExcluded) {
         int len = toExcluded - from;
+        if (len < 7 || len > 15) {
+            return false;
+        }
+        
+        // Fast path: check character composition first
+        int dotCount = 0;
+        for (int j = from; j < toExcluded; j++) {
+            char c = ip.charAt(j);
+            if (c == '.') {
+                dotCount++;
+            } else if (c < '0' || c > '9') {
+                return false;
+            }
+        }
+        if (dotCount != 3) {
+            return false;
+        }
+        
         int i;
-        return len <= 15 && len >= 7 &&
-                (i = ip.indexOf('.', from + 1)) > 0 && isValidIpV4Word(ip, from, i) &&
-                (i =  ip.indexOf('.', from = i + 2)) > 0 && isValidIpV4Word(ip, from - 1, i) &&
-                (i =  ip.indexOf('.', from = i + 2)) > 0 && isValidIpV4Word(ip, from - 1, i) &&
-                isValidIpV4Word(ip, i + 1, toExcluded);
+        return (i = ip.indexOf('.', from + 1)) > 0 && isValidIpV4Word(ip, from, i) &&
+               (i = ip.indexOf('.', i + 2)) > 0 && isValidIpV4Word(ip, i + 1, i) &&
+               (i = ip.indexOf('.', i + 2)) > 0 && isValidIpV4Word(ip, i + 1, i) &&
+               isValidIpV4Word(ip, i + 1, toExcluded);
     }
 
     @SuppressWarnings("DuplicateBooleanBranch")
