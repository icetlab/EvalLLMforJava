The performance issue is about reducing contention by moving from a static global AtomicLong for task ID generation to a per-instance (per event loop) non-volatile counter. This eliminates contention when multiple event loops schedule tasks concurrently.

```json
[
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java",
    "search": "import java.util.concurrent.atomic.AtomicLong;",
    "replace": ""
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java",
    "search": "    private static final AtomicLong nextTaskId = new AtomicLong();",
    "replace": ""
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java",
    "search": "    private final long id = nextTaskId.getAndIncrement();",
    "replace": "    private long id;"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java",
    "search": "    @Override\n    public void priorityQueueIndex(DefaultPriorityQueue<?> queue, int i) {\n        queueIndex = i;\n    }",
    "replace": "    @Override\n    public void priorityQueueIndex(DefaultPriorityQueue<?> queue, int i) {\n        queueIndex = i;\n    }\n\n    void setId(long id) {\n        this.id = id;\n    }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java",
    "search": "    PriorityQueue<ScheduledFutureTask<?>> scheduledTaskQueue;\n\n    protected AbstractScheduledEventExecutor() {",
    "replace": "    PriorityQueue<ScheduledFutureTask<?>> scheduledTaskQueue;\n    private long nextTaskId;\n\n    protected AbstractScheduledEventExecutor() {"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java",
    "search": "    private <V> ScheduledFuture<V> schedule(final ScheduledFutureTask<V> task) {\n        if (inEventLoop()) {\n            scheduledTaskQueue().add(task);\n        } else {\n            executeScheduledRunnable(new Runnable() {\n                @Override\n                public void run() {\n                    scheduledTaskQueue().add(task);\n                }\n            }, true, task.deadlineNanos());\n        }\n\n        return task;\n    }",
    "replace": "    private <V> ScheduledFuture<V> schedule(final ScheduledFutureTask<V> task) {\n        if (inEventLoop()) {\n            task.setId(nextTaskId++);\n            scheduledTaskQueue().add(task);\n        } else {\n            executeScheduledRunnable(new Runnable() {\n                @Override\n                public void run() {\n                    task.setId(nextTaskId++);\n                    scheduledTaskQueue().add(task);\n                }\n            }, true, task.deadlineNanos());\n        }\n\n        return task;\n    }"
  }
]
```