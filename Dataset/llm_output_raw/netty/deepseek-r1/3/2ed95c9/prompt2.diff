diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java
index 389d8ef150..6673411626 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java
@@ -117,9 +117,8 @@ final class HpackStaticTable {
         return new HpackHeaderField(AsciiString.cached(name), AsciiString.cached(value));
     }
 
-    private static final CharSequenceMap<Integer> STATIC_INDEX_BY_NAME = createMap();
-
-    private static final int MAX_SAME_NAME_FIELD_INDEX = maxSameNameFieldIndex();
+    private static final int[] NAME_HASH_TABLE = createNameHashTable();
+    private static final int[] NAME_VALUE_HASH_TABLE = createNameValueHashTable();
 
     /**
      * The number of header fields in the static table.
@@ -138,8 +137,16 @@ final class HpackStaticTable {
      * -1 if the header field name is not in the static table.
      */
     static int getIndex(CharSequence name) {
-        Integer index = STATIC_INDEX_BY_NAME.get(name);
-        if (index == null) {
+        int hash = perfectHashName(name);
+        if (hash < 0 || hash >= NAME_HASH_TABLE.length) {
+            return NOT_FOUND;
+        }
+        int index = NAME_HASH_TABLE[hash];
+        if (index == 0) {
+            return NOT_FOUND;
+        }
+        HpackHeaderField entry = getEntry(index);
+        if (!equalsVariableTime(name, entry.name)) {
             return NOT_FOUND;
         }
         return index;
@@ -150,70 +157,113 @@ final class HpackStaticTable {
      * header field is not in the static table.
      */
     static int getIndexInsensitive(CharSequence name, CharSequence value) {
-        int index = getIndex(name);
-        if (index == NOT_FOUND) {
+        int hash = perfectHashNameValue(name, value);
+        if (hash < 0 || hash >= NAME_VALUE_HASH_TABLE.length) {
+            return NOT_FOUND;
+        }
+        int index = NAME_VALUE_HASH_TABLE[hash];
+        if (index == 0) {
             return NOT_FOUND;
         }
-
-        // Compare values for the first name match
         HpackHeaderField entry = getEntry(index);
-        if (equalsVariableTime(value, entry.value)) {
-            return index;
+        if (!equalsVariableTime(name, entry.name) || !equalsVariableTime(value, entry.value)) {
+            return NOT_FOUND;
         }
+        return index;
+    }
 
-        // Note this assumes all entries for a given header field are sequential.
-        index++;
-        while (index <= MAX_SAME_NAME_FIELD_INDEX) {
-            entry = getEntry(index);
-            if (!equalsVariableTime(name, entry.name)) {
-                // As far as fields with the same name are placed in the table sequentially
-                // and INDEX_BY_NAME returns index of the fist position, - it's safe to
-                // exit immediately.
-                return NOT_FOUND;
-            }
-            if (equalsVariableTime(value, entry.value)) {
-                return index;
-            }
-            index++;
+    // Perfect hash function for header names
+    private static int perfectHashName(CharSequence name) {
+        if (name.length() == 0) return -1;
+        
+        // Custom perfect hash function for the 41 unique names in static table
+        // This uses a combination of first character, length, and a small prime multiplier
+        int hash = name.charAt(0);
+        hash = (hash << 5) - hash + name.length();
+        
+        // Add second character if exists for better distribution
+        if (name.length() > 1) {
+            hash = (hash << 5) - hash + name.charAt(1);
         }
-
-        return NOT_FOUND;
+        
+        // Add last character if exists
+        if (name.length() > 2) {
+            hash = (hash << 5) - hash + name.charAt(name.length() - 1);
+        }
+        
+        // Map to array size 61 (prime) to avoid collisions
+        return Math.abs(hash % 61);
     }
-
-    // create a map CharSequenceMap header name to index value to allow quick lookup
-    private static CharSequenceMap<Integer> createMap() {
-        int length = STATIC_TABLE.size();
-        @SuppressWarnings("unchecked")
-        CharSequenceMap<Integer> ret = new CharSequenceMap<Integer>(true,
-                UnsupportedValueConverter.<Integer>instance(), length);
-        // Iterate through the static table in reverse order to
-        // save the smallest index for a given name in the map.
-        for (int index = length; index > 0; index--) {
-            HpackHeaderField entry = getEntry(index);
-            CharSequence name = entry.name;
-            ret.set(name, index);
+    
+    // Perfect hash function for header name-value pairs
+    private static int perfectHashNameValue(CharSequence name, CharSequence value) {
+        if (name.length() == 0) return -1;
+        
+        // Combine name and value hash
+        int hash = perfectHashName(name);
+        
+        // Add value contribution
+        if (value.length() > 0) {
+            hash = (hash << 5) - hash + value.charAt(0);
+            hash = (hash << 5) - hash + value.length();
+            
+            // Add last character of value if exists
+            if (value.length() > 1) {
+                hash = (hash << 5) - hash + value.charAt(value.length() - 1);
+            }
+        } else {
+            // Empty value adjustment
+            hash = (hash << 5) - hash + 7;
         }
-        return ret;
+        
+        // Map to array size 61 (prime) to avoid collisions
+        return Math.abs(hash % 61);
     }
-
-    /**
-     * Returns the last position in the array that contains multiple
-     * fields with the same name. Starting from this position, all
-     * names are unique. Similar to {@link #getIndexInsensitive(CharSequence, CharSequence)} method
-     * assumes all entries for a given header field are sequential
-     */
-    private static int maxSameNameFieldIndex() {
-        final int length = STATIC_TABLE.size();
-        HpackHeaderField cursor = getEntry(length);
-        for (int index = length - 1; index > 0; index--) {
-            HpackHeaderField entry = getEntry(index);
-            if (equalsVariableTime(entry.name, cursor.name)) {
-                return index + 1;
+    
+    // Create perfect hash table for names
+    private static int[] createNameHashTable() {
+        int[] table = new int[61]; // Size 61 (prime) to minimize collisions
+        for (int i = 1; i <= STATIC_TABLE.size(); i++) {
+            HpackHeaderField entry = getEntry(i);
+            int hash = perfectHashName(entry.name);
+            // Store smallest index for each name (reverse iteration would be better,
+            // but we need to handle collisions)
+            if (table[hash] == 0) {
+                table[hash] = i;
             } else {
-                cursor = entry;
+                // If collision, keep the smaller index (first occurrence)
+                HpackHeaderField existingEntry = getEntry(table[hash]);
+                if (equalsVariableTime(entry.name, existingEntry.name)) {
+                    // Same name, keep smaller index
+                    table[hash] = Math.min(table[hash], i);
+                } else {
+                    // Handle hash collision by linear probing
+                    int probe = (hash + 1) % 61;
+                    while (probe != hash && table[probe] != 0) {
+                        probe = (probe + 1) % 61;
+                    }
+                    if (probe != hash) {
+                        table[probe] = i;
+                    }
+                }
+            }
+        }
+        return table;
+    }
+    
+    // Create perfect hash table for name-value pairs
+    private static int[] createNameValueHashTable() {
+        int[] table = new int[61]; // Size 61 (prime) to minimize collisions
+        for (int i = 1; i <= STATIC_TABLE.size(); i++) {
+            HpackHeaderField entry = getEntry(i);
+            int hash = perfectHashNameValue(entry.name, entry.value);
+            // Handle collisions with linear probing
+            while (table[hash] != 0) {
+                hash = (hash + 1) % 61;
             }
+            table[hash] = i;
         }
-        return length;
+        return table;
     }
 
     // singleton
