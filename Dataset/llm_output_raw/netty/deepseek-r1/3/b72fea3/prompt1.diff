diff --git a/codec/src/main/java/io/netty/handler/codec/DateFormatter.java b/codec/src/main/java/io/netty/handler/codec/DateFormatter.java
index 86df148500..a426b72103 100644
--- a/codec/src/main/java/io/netty/handler/codec/DateFormatter.java
+++ b/codec/src/main/java/io/netty/handler/codec/DateFormatter.java
@@ -45,20 +45,20 @@ import java.util.TimeZone;
  */
 public final class DateFormatter {
 
-    private static final BitSet DELIMITERS = new BitSet();
+    private static final boolean[] DELIMITERS = new boolean[128];
     static {
-        DELIMITERS.set(0x09);
+        DELIMITERS[0x09] = true;
         for (char c = 0x20; c <= 0x2F; c++) {
-            DELIMITERS.set(c);
+            DELIMITERS[c] = true;
         }
         for (char c = 0x3B; c <= 0x40; c++) {
-            DELIMITERS.set(c);
+            DELIMITERS[c] = true;
         }
         for (char c = 0x5B; c <= 0x60; c++) {
-            DELIMITERS.set(c);
+            DELIMITERS[c] = true;
         }
         for (char c = 0x7B; c <= 0x7E; c++) {
-            DELIMITERS.set(c);
+            DELIMITERS[c] = true;
         }
     }
 
@@ -132,7 +132,7 @@ public final class DateFormatter {
 
     // delimiter = %x09 / %x20-2F / %x3B-40 / %x5B-60 / %x7B-7E
     private static boolean isDelim(char c) {
-        return DELIMITERS.get(c);
+        return c < 128 && DELIMITERS[c];
     }
 
     private static boolean isDigit(char c) {
@@ -262,7 +262,20 @@ public final class DateFormatter {
     }
 
     private static boolean matchMonth(String month, CharSequence txt, int tokenStart) {
-        return AsciiString.regionMatchesAscii(month, true, 0, txt, tokenStart, 3);
+        // Fast path for ASCII month matching
+        if (tokenStart + 3 > txt.length()) {
+            return false;
+        }
+        char c0 = txt.charAt(tokenStart);
+        char c1 = txt.charAt(tokenStart + 1);
+        char c2 = txt.charAt(tokenStart + 2);
+        
+        // Convert to uppercase for comparison (ASCII only)
+        if (c0 >= 'a' && c0 <= 'z') c0 = (char)(c0 - 32);
+        if (c1 >= 'a' && c1 <= 'z') c1 = (char)(c1 - 32);
+        if (c2 >= 'a' && c2 <= 'z') c2 = (char)(c2 - 32);
+        
+        return month.charAt(0) == c0 && month.charAt(1) == c1 && month.charAt(2) == c2;
     }
 
     private boolean tryParseMonth(CharSequence txt, int tokenStart, int tokenEnd) {
@@ -272,32 +285,77 @@ public final class DateFormatter {
             return false;
         }
 
-        if (matchMonth("Jan", txt, tokenStart)) {
-            month = Calendar.JANUARY;
-        } else if (matchMonth("Feb", txt, tokenStart)) {
-            month = Calendar.FEBRUARY;
-        } else if (matchMonth("Mar", txt, tokenStart)) {
-            month = Calendar.MARCH;
-        } else if (matchMonth("Apr", txt, tokenStart)) {
-            month = Calendar.APRIL;
-        } else if (matchMonth("May", txt, tokenStart)) {
-            month = Calendar.MAY;
-        } else if (matchMonth("Jun", txt, tokenStart)) {
-            month = Calendar.JUNE;
-        } else if (matchMonth("Jul", txt, tokenStart)) {
-            month = Calendar.JULY;
-        } else if (matchMonth("Aug", txt, tokenStart)) {
-            month = Calendar.AUGUST;
-        } else if (matchMonth("Sep", txt, tokenStart)) {
-            month = Calendar.SEPTEMBER;
-        } else if (matchMonth("Oct", txt, tokenStart)) {
-            month = Calendar.OCTOBER;
-        } else if (matchMonth("Nov", txt, tokenStart)) {
-            month = Calendar.NOVEMBER;
-        } else if (matchMonth("Dec", txt, tokenStart)) {
-            month = Calendar.DECEMBER;
-        } else {
-            return false;
+        // Single character check first to avoid unnecessary comparisons
+        char firstChar = txt.charAt(tokenStart);
+        if (firstChar >= 'a' && firstChar <= 'z') firstChar = (char)(firstChar - 32);
+        
+        switch (firstChar) {
+            case 'J':
+                if (matchMonth("JAN", txt, tokenStart)) {
+                    month = Calendar.JANUARY;
+                } else if (matchMonth("JUN", txt, tokenStart)) {
+                    month = Calendar.JUNE;
+                } else if (matchMonth("JUL", txt, tokenStart)) {
+                    month = Calendar.JULY;
+                } else {
+                    return false;
+                }
+                break;
+            case 'F':
+                if (matchMonth("FEB", txt, tokenStart)) {
+                    month = Calendar.FEBRUARY;
+                } else {
+                    return false;
+                }
+                break;
+            case 'M':
+                if (matchMonth("MAR", txt, tokenStart)) {
+                    month = Calendar.MARCH;
+                } else if (matchMonth("MAY", txt, tokenStart)) {
+                    month = Calendar.MAY;
+                } else {
+                    return false;
+                }
+                break;
+            case 'A':
+                if (matchMonth("APR", txt, tokenStart)) {
+                    month = Calendar.APRIL;
+                } else if (matchMonth("AUG", txt, tokenStart)) {
+                    month = Calendar.AUGUST;
+                } else {
+                    return false;
+                }
+                break;
+            case 'S':
+                if (matchMonth("SEP", txt, tokenStart)) {
+                    month = Calendar.SEPTEMBER;
+                } else {
+                    return false;
+                }
+                break;
+            case 'O':
+                if (matchMonth("OCT", txt, tokenStart)) {
+                    month = Calendar.OCTOBER;
+                } else {
+                    return false;
+                }
+                break;
+            case 'N':
+                if (matchMonth("NOV", txt, tokenStart)) {
+                    month = Calendar.NOVEMBER;
+                } else {
+                    return false;
+                }
+                break;
+            case 'D':
+                if (matchMonth("DEC", txt, tokenStart)) {
+                    month = Calendar.DECEMBER;
+                } else {
+                    return false;
+                }
+                break;
+            default:
+                return false;
         }
 
         return true;
@@ -333,13 +391,15 @@ public final class DateFormatter {
 
     private boolean parseToken(CharSequence txt, int tokenStart, int tokenEnd) {
         // return true if all parts are found
-        if (!timeFound) {
-            timeFound = tryParseTime(txt, tokenStart, tokenEnd);
-            if (timeFound) {
-                return dayOfMonthFound && monthFound && yearFound;
+        // Try month first as it's the most distinctive token
+        if (!monthFound) {
+            monthFound = tryParseMonth(txt, tokenStart, tokenEnd);
+            if (monthFound) {
+                return timeFound && dayOfMonthFound && yearFound;
             }
         }
 
+        // Then try day of month (1-2 digits)
         if (!dayOfMonthFound) {
             dayOfMonthFound = tryParseDayOfMonth(txt, tokenStart, tokenEnd);
             if (dayOfMonthFound) {
@@ -347,15 +407,17 @@ public final class DateFormatter {
             }
         }
 
-        if (!monthFound) {
-            monthFound = tryParseMonth(txt, tokenStart, tokenEnd);
-            if (monthFound) {
-                return timeFound && dayOfMonthFound && yearFound;
+        // Then try year (2 or 4 digits)
+        if (!yearFound) {
+            yearFound = tryParseYear(txt, tokenStart, tokenEnd);
+            if (yearFound) {
+                return timeFound && dayOfMonthFound && monthFound;
             }
         }
 
-        if (!yearFound) {
-            yearFound = tryParseYear(txt, tokenStart, tokenEnd);
+        // Time is usually last and has colons
+        if (!timeFound) {
+            timeFound = tryParseTime(txt, tokenStart, tokenEnd);
         }
         return timeFound && dayOfMonthFound && monthFound && yearFound;
     }
@@ -391,23 +453,23 @@ public final class DateFormatter {
     }
 
     private boolean normalizeAndValidate() {
-        if (dayOfMonth < 1
-                || dayOfMonth > 31
-                || hours > 23
-                || minutes > 59
-                || seconds > 59) {
+        // Quick validation checks first
+        if (dayOfMonth < 1 || dayOfMonth > 31 || hours > 23 || minutes > 59 || seconds > 59) {
             return false;
         }
 
-        if (year >= 70 && year <= 99) {
-            year += 1900;
-        } else if (year >= 0 && year < 70) {
-            year += 2000;
-        } else if (year < 1601) {
-            // invalid value
-            return false;
+        // Optimize year normalization with bitwise operations
+        if (year < 100) {
+            // For years 00-99, add 1900 or 2000
+            if (year >= 70) {
+                year += 1900;
+            } else {
+                year += 2000;
+            }
         }
-        return true;
+        
+        // Final validation
+        return year >= 1601;
     }
 
     private Date computeDate() {
