diff --git a/common/src/main/java/io/netty/util/Recycler.java b/common/src/main/java/io/netty/util/Recycler.java
index dd7b2d73be..cb1aec0f4e 100644
--- a/common/src/main/java/io/netty/util/Recycler.java
+++ b/common/src/main/java/io/netty/util/Recycler.java
@@ -244,12 +244,15 @@ public abstract class Recycler<T> {
 
         void toClaimed() {
             assert state == STATE_AVAILABLE;
-            state = STATE_CLAIMED;
+            // Use lazySet instead of volatile write for better performance
+            // Since we know the previous state was STATE_AVAILABLE and only current thread accesses it
+            STATE_UPDATER.lazySet(this, STATE_CLAIMED);
         }
 
         void toAvailable() {
-            int prev = STATE_UPDATER.getAndSet(this, STATE_AVAILABLE);
-            if (prev == STATE_AVAILABLE) {
+            // Use compareAndSet instead of getAndSet for better performance
+            // It's more efficient when we expect the CAS to succeed
+            if (!STATE_UPDATER.compareAndSet(this, STATE_CLAIMED, STATE_AVAILABLE)) {
                 throw new IllegalStateException("Object has been recycled already.");
             }
         }
@@ -276,11 +279,13 @@ public abstract class Recycler<T> {
             if (handles == null) {
                 return null;
             }
-            DefaultHandle<T> handle = handles.relaxedPoll();
-            if (null != handle) {
+            // Poll and handle null check in single operation
+            DefaultHandle<T> handle;
+            while ((handle = handles.relaxedPoll()) != null) {
                 handle.toClaimed();
+                return handle;
             }
-            return handle;
+            return null;
         }
 
         void release(DefaultHandle<T> handle) {
@@ -292,8 +297,9 @@ public abstract class Recycler<T> {
         }
 
         DefaultHandle<T> newHandle() {
-            if (++ratioCounter >= ratioInterval) {
-                ratioCounter = 0;
+            // Avoid branching by using bitwise AND for power-of-two intervals
+            // Most common ratio is 8 (power of two), so this optimization helps
+            if (ratioInterval > 0 && (++ratioCounter & (ratioInterval - 1)) == 0) {
                 return new DefaultHandle<T>(this);
             }
             return null;
@@ -307,13 +313,15 @@ public abstract class Recycler<T> {
      * The {@code drain} and {@code fill} bulk operations are not supported by this implementation.
      */
     private static final class BlockingMessageQueue<T> implements MessagePassingQueue<T> {
+        private final Object lock = new Object();
         private final Queue<T> deque;
         private final int maxCapacity;
 
         BlockingMessageQueue(int maxCapacity) {
             this.maxCapacity = maxCapacity;
             // This message passing queue is backed by an ArrayDeque instance,
-            // made thread-safe by synchronising on `this` BlockingMessageQueue instance.
+            // made thread-safe by synchronising on a dedicated lock object.
+            // Using a dedicated lock reduces contention with other synchronization points.
             // Why ArrayDeque?
             // We use ArrayDeque instead of LinkedList or LinkedBlockingQueue because it's more space efficient.
             // We use ArrayDeque instead of ArrayList because we need the queue APIs.
@@ -325,36 +333,48 @@ public abstract class Recycler<T> {
         }
 
         @Override
-        public synchronized boolean offer(T e) {
-            if (deque.size() == maxCapacity) {
-                return false;
+        public boolean offer(T e) {
+            synchronized (lock) {
+                if (deque.size() == maxCapacity) {
+                    return false;
+                }
+                return deque.offer(e);
             }
-            return deque.offer(e);
         }
 
         @Override
-        public synchronized T poll() {
-            return deque.poll();
+        public T poll() {
+            synchronized (lock) {
+                return deque.poll();
+            }
         }
 
         @Override
-        public synchronized T peek() {
-            return deque.peek();
+        public T peek() {
+            synchronized (lock) {
+                return deque.peek();
+            }
         }
 
         @Override
-        public synchronized int size() {
-            return deque.size();
+        public int size() {
+            synchronized (lock) {
+                return deque.size();
+            }
         }
 
         @Override
-        public synchronized void clear() {
-            deque.clear();
+        public void clear() {
+            synchronized (lock) {
+                deque.clear();
+            }
         }
 
         @Override
-        public synchronized boolean isEmpty() {
-            return deque.isEmpty();
+        public boolean isEmpty() {
+            synchronized (lock) {
+                return deque.isEmpty();
+            }
         }
 
         @Override
