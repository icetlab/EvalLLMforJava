diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent.java b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
index 0a70c36401..fd7be91dde 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
@@ -755,7 +755,36 @@ public final class PlatformDependent {
      */
     public static int hashCodeAscii(CharSequence bytes) {
         int hash = HASH_CODE_ASCII_SEED;
-        final int remainingBytes = bytes.length() & 7;
+        int len = bytes.length();
+        int rem = len & 7;
+        // process 8-byte chunks
+        for (int i = 0; i < len - rem; i += 8) {
+            hash = hashCodeAsciiCompute(bytes, i, hash);
+        }
+        // process remaining bytes
+        switch (rem) {
+            case 7:
+                return ((hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(0)))
+                        * HASH_CODE_C2 + hashCodeAsciiSanitizeShort(bytes, 1))
+                        * HASH_CODE_C1 + hashCodeAsciiSanitizeInt(bytes, 3);
+            case 6:
+                return (hash * HASH_CODE_C1 + hashCodeAsciiSanitizeShort(bytes, 0))
+                        * HASH_CODE_C2 + hashCodeAsciiSanitizeInt(bytes, 2);
+            case 5:
+                return (hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(0)))
+                        * HASH_CODE_C2 + hashCodeAsciiSanitizeInt(bytes, 1);
+            case 4:
+                return hash * HASH_CODE_C1 + hashCodeAsciiSanitizeInt(bytes, 0);
+            case 3:
+                return (hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(0)))
+                        * HASH_CODE_C2 + hashCodeAsciiSanitizeShort(bytes, 1);
+            case 2:
+                return hash * HASH_CODE_C1 + hashCodeAsciiSanitizeShort(bytes, 0);
+            case 1:
+                return hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(0));
+            default:
+                return hash;
+        }
         // Benchmarking shows that by just naively looping for inputs 8~31 bytes long we incur a relatively large
         // performance penalty (only achieve about 60% performance of loop which iterates over each char). So because
         // of this we take special provisions to unroll the looping for these conditions.
