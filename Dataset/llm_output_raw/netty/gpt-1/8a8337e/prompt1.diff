diff --git a/common/src/main/java/io/netty/util/Recycler.java b/common/src/main/java/io/netty/util/Recycler.java
index dd7b2d73be..349ebcfb95 100644
--- a/common/src/main/java/io/netty/util/Recycler.java
+++ b/common/src/main/java/io/netty/util/Recycler.java
@@ -26,6 +26,7 @@ import org.jctools.queues.MessagePassingQueue;
 import java.util.ArrayDeque;
 import java.util.Queue;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import static io.netty.util.internal.PlatformDependent.newMpscQueue;
 import static java.lang.Math.max;
@@ -197,7 +198,7 @@ public abstract class Recycler<T> {
 
     final int threadLocalSize() {
         LocalPool<T> localPool = threadLocal.getIfExists();
-        return localPool == null ? 0 : localPool.pooledHandles.size();
+        return localPool == null ? 0 : localPool.localCount.get();
     }
 
     /**
@@ -259,6 +260,7 @@ public abstract class Recycler<T> {
         private final int ratioInterval;
         private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;
         private int ratioCounter;
+        private final AtomicInteger localCount = new AtomicInteger(0);
 
         @SuppressWarnings("unchecked")
         LocalPool(int maxCapacity, int ratioInterval, int chunkSize) {
@@ -277,7 +279,8 @@ public abstract class Recycler<T> {
                 return null;
             }
             DefaultHandle<T> handle = handles.relaxedPoll();
-            if (null != handle) {
+            if (handle != null) {
+                localCount.decrementAndGet();
                 handle.toClaimed();
             }
             return handle;
@@ -285,6 +288,7 @@ public abstract class Recycler<T> {
 
         void release(DefaultHandle<T> handle) {
             handle.toAvailable();
+            localCount.incrementAndGet();
             MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
             if (handles != null) {
                 handles.relaxedOffer(handle);
