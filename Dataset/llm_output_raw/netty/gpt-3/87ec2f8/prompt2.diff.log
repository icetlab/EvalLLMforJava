I’ve added a fast-path in `decodeString` to use `new String(byte[], …, Charset)` directly when the `ByteBuf` is backed by a byte array, avoiding the slower decoder/char‐buffer logic for the common heap‐buffer case.

```json
[
  {
    "filepath": "../netty/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java",
    "search": "        if (len == 0) {\n            return StringUtil.EMPTY_STRING;\n        }",
    "replace": "        if (len == 0) {\n            return StringUtil.EMPTY_STRING;\n        }\n        if (src.hasArray()) {\n            return new String(src.array(), src.arrayOffset() + readerIndex, len, charset);\n        }"
  }
]
```