diff --git a/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
index e657ad86f8..d67aaf620c 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
@@ -21,6 +21,8 @@ import io.netty.util.IllegalReferenceCountException;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
 import static io.netty.util.internal.ObjectUtil.checkPositive;
+import sun.misc.Unsafe;
+import java.lang.reflect.Field;
 
 /**
  * Abstract base class for {@link ByteBuf} implementations that count references.
@@ -32,6 +34,21 @@ public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {
 
     private volatile int refCnt;
 
+    private static final Unsafe UNSAFE;
+    private static final long REF_CNT_FIELD_OFFSET;
+
+    static {
+        try {
+            Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");
+            unsafeField.setAccessible(true);
+            UNSAFE = (Unsafe) unsafeField.get(null);
+            REF_CNT_FIELD_OFFSET = UNSAFE.objectFieldOffset(
+                    AbstractReferenceCountedByteBuf.class.getDeclaredField("refCnt"));
+        } catch (Exception e) {
+            throw new Error(e);
+        }
+    }
+
     protected AbstractReferenceCountedByteBuf(int maxCapacity) {
         super(maxCapacity);
         refCntUpdater.set(this, 1);
@@ -60,17 +77,12 @@ public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {
     }
 
     private ByteBuf retain0(int increment) {
-        for (;;) {
-            int refCnt = this.refCnt;
-            final int nextCnt = refCnt + increment;
-
-            // Ensure we not resurrect (which means the refCnt was 0) and also that we encountered an overflow.
-            if (nextCnt <= increment) {
-                throw new IllegalReferenceCountException(refCnt, increment);
-            }
-            if (refCntUpdater.compareAndSet(this, refCnt, nextCnt)) {
-                break;
-            }
+        int oldRef = UNSAFE.getAndAddInt(this, REF_CNT_FIELD_OFFSET, increment);
+        int nextCnt = oldRef + increment;
+        if (oldRef <= 0 || nextCnt <= increment) {
+            // revert on overflow or resurrect
+            UNSAFE.getAndAddInt(this, REF_CNT_FIELD_OFFSET, -increment);
+            throw new IllegalReferenceCountException(oldRef, increment);
         }
         return this;
     }
@@ -96,21 +108,19 @@ public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {
     }
 
     private boolean release0(int decrement) {
-        for (;;) {
-            int refCnt = this.refCnt;
-            if (refCnt < decrement) {
-                throw new IllegalReferenceCountException(refCnt, -decrement);
-            }
-
-            if (refCntUpdater.compareAndSet(this, refCnt, refCnt - decrement)) {
-                if (refCnt == decrement) {
+        int oldRef = UNSAFE.getAndAddInt(this, REF_CNT_FIELD_OFFSET, -decrement);
+        if (oldRef < decrement) {
+            // revert on underflow
+            UNSAFE.getAndAddInt(this, REF_CNT_FIELD_OFFSET, decrement);
+            throw new IllegalReferenceCountException(oldRef, -decrement);
+        }
+        int newRef = oldRef - decrement;
+        if (newRef == 0) {
             deallocate();
             return true;
         }
         return false;
     }
-        }
-    }
     /**
      * Called once {@link #refCnt()} is equals 0.
      */
diff --git a/common/src/main/java/io/netty/util/AbstractReferenceCounted.java b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java
index 493bcc1872..642f81f027 100644
--- a/common/src/main/java/io/netty/util/AbstractReferenceCounted.java
+++ b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java
@@ -18,6 +18,8 @@ package io.netty.util;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
 import static io.netty.util.internal.ObjectUtil.checkPositive;
+import sun.misc.Unsafe;
+import java.lang.reflect.Field;
 
 /**
  * Abstract base class for classes wants to implement {@link ReferenceCounted}.
@@ -29,6 +31,21 @@ public abstract class AbstractReferenceCounted implements ReferenceCounted {
 
     private volatile int refCnt = 1;
 
+    private static final Unsafe UNSAFE;
+    private static final long REF_CNT_FIELD_OFFSET;
+
+    static {
+        try {
+            Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");
+            unsafeField.setAccessible(true);
+            UNSAFE = (Unsafe) unsafeField.get(null);
+            REF_CNT_FIELD_OFFSET = UNSAFE.objectFieldOffset(
+                    AbstractReferenceCounted.class.getDeclaredField("refCnt"));
+        } catch (Exception e) {
+            throw new Error(e);
+        }
+    }
+
     @Override
     public final int refCnt() {
         return refCnt;
@@ -52,17 +69,12 @@ public abstract class AbstractReferenceCounted implements ReferenceCounted {
     }
 
     private ReferenceCounted retain0(int increment) {
-        for (;;) {
-            int refCnt = this.refCnt;
-            final int nextCnt = refCnt + increment;
-
-            // Ensure we not resurrect (which means the refCnt was 0) and also that we encountered an overflow.
-            if (nextCnt <= increment) {
-                throw new IllegalReferenceCountException(refCnt, increment);
-            }
-            if (refCntUpdater.compareAndSet(this, refCnt, nextCnt)) {
-                break;
-            }
+        int oldRef = UNSAFE.getAndAddInt(this, REF_CNT_FIELD_OFFSET, increment);
+        int nextCnt = oldRef + increment;
+        if (oldRef <= 0 || nextCnt <= increment) {
+            // revert on overflow or resurrect
+            UNSAFE.getAndAddInt(this, REF_CNT_FIELD_OFFSET, -increment);
+            throw new IllegalReferenceCountException(oldRef, increment);
         }
         return this;
     }
@@ -83,21 +95,19 @@ public abstract class AbstractReferenceCounted implements ReferenceCounted {
     }
 
     private boolean release0(int decrement) {
-        for (;;) {
-            int refCnt = this.refCnt;
-            if (refCnt < decrement) {
-                throw new IllegalReferenceCountException(refCnt, -decrement);
-            }
-
-            if (refCntUpdater.compareAndSet(this, refCnt, refCnt - decrement)) {
-                if (refCnt == decrement) {
+        int oldRef = UNSAFE.getAndAddInt(this, REF_CNT_FIELD_OFFSET, -decrement);
+        if (oldRef < decrement) {
+            // revert on underflow
+            UNSAFE.getAndAddInt(this, REF_CNT_FIELD_OFFSET, decrement);
+            throw new IllegalReferenceCountException(oldRef, -decrement);
+        }
+        int newRef = oldRef - decrement;
+        if (newRef == 0) {
             deallocate();
             return true;
         }
         return false;
     }
-        }
-    }
 
     /**
      * Called once {@link #refCnt()} is equals 0.
