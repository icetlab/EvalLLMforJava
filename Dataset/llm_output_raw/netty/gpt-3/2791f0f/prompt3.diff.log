Iâ€™ve optimized task polling to use a single poll() call instead of peek+remove and reduced array allocations in cancelScheduledTasks by sizing the toArray call. These changes cut down on method calls and temporary objects.

```json
[
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java",
    "search": "final ScheduledFutureTask<?>[] scheduledTasks =\n                scheduledTaskQueue.toArray(new ScheduledFutureTask<?>[0]);",
    "replace": "ScheduledFutureTask<?>[] scheduledTasks =\n                scheduledTaskQueue.toArray(new ScheduledFutureTask<?>[scheduledTaskQueue.size()]);"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java",
    "search": "Queue<ScheduledFutureTask<?>> scheduledTaskQueue = this.scheduledTaskQueue;\n        ScheduledFutureTask<?> scheduledTask = scheduledTaskQueue == null ? null : scheduledTaskQueue.peek();\n        if (scheduledTask == null || scheduledTask.deadlineNanos() - nanoTime > 0) {\n            return null;\n        }\n        scheduledTaskQueue.remove();\n        return scheduledTask;",
    "replace": "PriorityQueue<ScheduledFutureTask<?>> q = this.scheduledTaskQueue;\n        if (q == null) {\n            return null;\n        }\n        ScheduledFutureTask<?> task = q.peek();\n        if (task == null || task.deadlineNanos() - nanoTime > 0) {\n            return null;\n        }\n        return q.poll();"
  }
]
```