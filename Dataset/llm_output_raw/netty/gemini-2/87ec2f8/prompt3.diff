diff --git a/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
index e7afab3672..2ac357417d 100644
--- a/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
@@ -760,48 +760,75 @@ public final class ByteBufUtil {
         if (len == 0) {
             return StringUtil.EMPTY_STRING;
         }
-        final CharsetDecoder decoder = CharsetUtil.decoder(charset);
-        final int maxLength = (int) ((double) len * decoder.maxCharsPerByte());
+        if (charset.equals(CharsetUtil.US_ASCII)) {
             CharBuffer dst = CHAR_BUFFERS.get();
-        if (dst.length() < maxLength) {
-            dst = CharBuffer.allocate(maxLength);
-            if (maxLength <= MAX_CHAR_BUFFER_SIZE) {
+            if (dst.length() < len) {
+                dst = CharBuffer.allocate(len);
+                if (len <= MAX_CHAR_BUFFER_SIZE) {
                     CHAR_BUFFERS.set(dst);
                 }
             } else {
                 dst.clear();
             }
-        if (src.nioBufferCount() == 1) {
-            decodeString(decoder, src.nioBuffer(readerIndex, len), dst);
+            if (src.hasArray()) {
+                final byte[] array = src.array();
+                final int start = src.arrayOffset() + readerIndex;
+                final char[] chars = dst.array();
+                final int dstStart = dst.arrayOffset() + dst.position();
+                for (int i = 0; i < len; i++) {
+                    chars[dstStart + i] = (char) (array[start + i] & 0xff);
+                }
+                dst.position(dst.position() + len);
             } else {
-            // We use a heap buffer as CharsetDecoder is most likely able to use a fast-path if src and dst buffers
-            // are both backed by a byte array.
-            ByteBuf buffer = src.alloc().heapBuffer(len);
-            try {
-                buffer.writeBytes(src, readerIndex, len);
-                // Use internalNioBuffer(...) to reduce object creation.
-                decodeString(decoder, buffer.internalNioBuffer(buffer.readerIndex(), len), dst);
-            } finally {
-                // Release the temporary buffer again.
-                buffer.release();
+                final CharBuffer finalDst = dst;
+                src.forEachByte(readerIndex, len, new ByteProcessor() {
+                    @Override
+                    public boolean process(byte value) {
+                        finalDst.put((char) (value & 0xff));
+                        return true;
                     }
+                });
             }
             return dst.flip().toString();
         }
 
-    private static void decodeString(CharsetDecoder decoder, ByteBuffer src, CharBuffer dst) {
+        final CharsetDecoder decoder = CharsetUtil.decoder(charset);
+        final int maxLength = (int) ((double) len * decoder.maxCharsPerByte());
+        CharBuffer dst = CHAR_BUFFERS.get();
+        if (dst.length() < maxLength) {
+            dst = CharBuffer.allocate(maxLength);
+            if (maxLength <= MAX_CHAR_BUFFER_SIZE) {
+                CHAR_BUFFERS.set(dst);
+            }
+        } else {
+            dst.clear();
+        }
         try {
-            CoderResult cr = decoder.decode(src, dst, true);
+            if (src.nioBufferCount() == 1) {
+                ByteBuffer nioBuffer = src.nioBuffer(readerIndex, len);
+                CoderResult cr = decoder.decode(nioBuffer, dst, true);
+                if (!cr.isUnderflow()) {
+                    cr.throwException();
+                }
+            } else {
+                ByteBuffer[] nioBuffers = src.nioBuffers(readerIndex, len);
+                for (int i = 0; i < nioBuffers.length; i++) {
+                    ByteBuffer bb = nioBuffers[i];
+                    boolean endOfInput = i == nioBuffers.length - 1;
+                    CoderResult cr = decoder.decode(bb, dst, endOfInput);
                     if (!cr.isUnderflow()) {
                         cr.throwException();
                     }
-            cr = decoder.flush(dst);
+                }
+            }
+            CoderResult cr = decoder.flush(dst);
             if (!cr.isUnderflow()) {
                 cr.throwException();
             }
         } catch (CharacterCodingException x) {
             throw new IllegalStateException(x);
         }
+        return dst.flip().toString();
     }
 
     /**
