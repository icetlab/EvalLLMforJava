diff --git a/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
index e657ad86f8..7cdcad8bca 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
@@ -34,19 +34,24 @@ public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {
 
     protected AbstractReferenceCountedByteBuf(int maxCapacity) {
         super(maxCapacity);
-        refCntUpdater.set(this, 1);
+        refCntUpdater.set(this, 2);
     }
 
         @Override
     public int refCnt() {
-        return refCnt;
+        int refCnt = this.refCnt;
+        // If refCnt is odd, it is deallocated. In this case, we return 0.
+        if ((refCnt & 1) != 0) {
+            return 0;
+        }
+        return refCnt >>> 1;
     }
 
     /**
      * An unsafe operation intended for use by a subclass that sets the reference count of the buffer directly
      */
         protected final void setRefCnt(int refCnt) {
-        refCntUpdater.set(this, refCnt);
+        refCntUpdater.set(this, refCnt > 0 ? refCnt << 1 : 1);
     }
 
     @Override
@@ -59,18 +64,17 @@ public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {
         return retain0(checkPositive(increment, "increment"));
     }
 
-    private ByteBuf retain0(int increment) {
-        for (;;) {
-            int refCnt = this.refCnt;
-            final int nextCnt = refCnt + increment;
+        private ByteBuf retain0(final int increment) {
+        int rawIncrement = increment << 1;
+        int prevRawRefCnt = refCntUpdater.getAndAdd(this, rawIncrement);
 
-            // Ensure we not resurrect (which means the refCnt was 0) and also that we encountered an overflow.
-            if (nextCnt <= increment) {
-                throw new IllegalReferenceCountException(refCnt, increment);
-            }
-            if (refCntUpdater.compareAndSet(this, refCnt, nextCnt)) {
-                break;
+        if ((prevRawRefCnt & 1) != 0) {
+            throw new IllegalReferenceCountException(0, increment);
         }
+        if (prevRawRefCnt <= 0 || prevRawRefCnt + rawIncrement < prevRawRefCnt) {
+            // Revert the change and throw an exception.
+            refCntUpdater.getAndAdd(this, -rawIncrement);
+            throw new IllegalReferenceCountException(prevRawRefCnt >>> 1, increment);
         }
         return this;
     }
@@ -96,20 +100,18 @@ public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {
     }
 
         private boolean release0(int decrement) {
-        for (;;) {
-            int refCnt = this.refCnt;
-            if (refCnt < decrement) {
-                throw new IllegalReferenceCountException(refCnt, -decrement);
-            }
-
-            if (refCntUpdater.compareAndSet(this, refCnt, refCnt - decrement)) {
-                if (refCnt == decrement) {
+        int rawDecrement = decrement << 1;
+        int prevRawRefCnt = refCntUpdater.getAndAdd(this, -rawDecrement);
+        if (prevRawRefCnt == rawDecrement) {
             deallocate();
             return true;
         }
-                return false;
-            }
+        if (prevRawRefCnt < rawDecrement || (prevRawRefCnt & 1) != 0) {
+            // Revert the change and throw an exception.
+            refCntUpdater.getAndAdd(this, rawDecrement);
+            throw new IllegalReferenceCountException(prevRawRefCnt >>> 1, -decrement);
         }
+        return false;
     }
     /**
      * Called once {@link #refCnt()} is equals 0.
diff --git a/common/src/main/java/io/netty/util/AbstractReferenceCounted.java b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java
index 493bcc1872..5d3341a1a5 100644
--- a/common/src/main/java/io/netty/util/AbstractReferenceCounted.java
+++ b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java
@@ -27,18 +27,23 @@ public abstract class AbstractReferenceCounted implements ReferenceCounted {
     private static final AtomicIntegerFieldUpdater<AbstractReferenceCounted> refCntUpdater =
             AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCounted.class, "refCnt");
 
-    private volatile int refCnt = 1;
+        private volatile int refCnt = 2;
 
         @Override
     public final int refCnt() {
-        return refCnt;
+        int refCnt = this.refCnt;
+        // If refCnt is odd, it is deallocated. In this case, we return 0.
+        if ((refCnt & 1) != 0) {
+            return 0;
+        }
+        return refCnt >>> 1;
     }
 
     /**
      * An unsafe operation intended for use by a subclass that sets the reference count of the buffer directly
      */
         protected final void setRefCnt(int refCnt) {
-        refCntUpdater.set(this, refCnt);
+        refCntUpdater.set(this, refCnt > 0 ? refCnt << 1 : 1);
     }
 
     @Override
@@ -51,18 +56,18 @@ public abstract class AbstractReferenceCounted implements ReferenceCounted {
         return retain0(checkPositive(increment, "increment"));
     }
 
-    private ReferenceCounted retain0(int increment) {
-        for (;;) {
-            int refCnt = this.refCnt;
-            final int nextCnt = refCnt + increment;
+        private ReferenceCounted retain0(final int increment) {
+        int rawIncrement = increment << 1;
+        int prevRawRefCnt = refCntUpdater.getAndAdd(this, rawIncrement);
 
-            // Ensure we not resurrect (which means the refCnt was 0) and also that we encountered an overflow.
-            if (nextCnt <= increment) {
-                throw new IllegalReferenceCountException(refCnt, increment);
-            }
-            if (refCntUpdater.compareAndSet(this, refCnt, nextCnt)) {
-                break;
+        if ((prevRawRefCnt & 1) != 0) {
+            throw new IllegalReferenceCountException(0, increment);
         }
+
+        if (prevRawRefCnt <= 0 || prevRawRefCnt + rawIncrement < prevRawRefCnt) {
+            // Revert the change and throw an exception.
+            refCntUpdater.getAndAdd(this, -rawIncrement);
+            throw new IllegalReferenceCountException(prevRawRefCnt >>> 1, increment);
         }
         return this;
     }
@@ -83,20 +88,18 @@ public abstract class AbstractReferenceCounted implements ReferenceCounted {
     }
 
         private boolean release0(int decrement) {
-        for (;;) {
-            int refCnt = this.refCnt;
-            if (refCnt < decrement) {
-                throw new IllegalReferenceCountException(refCnt, -decrement);
-            }
-
-            if (refCntUpdater.compareAndSet(this, refCnt, refCnt - decrement)) {
-                if (refCnt == decrement) {
+        int rawDecrement = decrement << 1;
+        int prevRawRefCnt = refCntUpdater.getAndAdd(this, -rawDecrement);
+        if (prevRawRefCnt == rawDecrement) {
             deallocate();
             return true;
         }
-                return false;
-            }
+        if (prevRawRefCnt < rawDecrement || (prevRawRefCnt & 1) != 0) {
+            // Revert the change and throw an exception.
+            refCntUpdater.getAndAdd(this, rawDecrement);
+            throw new IllegalReferenceCountException(prevRawRefCnt >>> 1, -decrement);
         }
+        return false;
     }
 
     /**
