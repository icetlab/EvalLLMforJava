The performance issue is that scheduling a task from a non-event-loop thread causes an unnecessary `Runnable` allocation. This can be avoided by making the `ScheduledFutureTask` itself perform the scheduling logic.

My plan is to modify `AbstractScheduledEventExecutor` to pass the `ScheduledFutureTask` directly to the `execute` method. Then, I will update `ScheduledFutureTask` to handle this. I'll introduce a state field in `ScheduledFutureTask` to distinguish between its two roles:
1.  When first run, it will add itself to the `scheduledTaskQueue`.
2.  On subsequent runs (when polled from the queue), it will execute the actual user-provided task.

This change eliminates the allocation of a separate `Runnable` for scheduling, improving performance by reducing object creation and garbage collection pressure, especially in scenarios with high scheduling rates from external threads.

```json
[
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java",
    "search": "    private <V> ScheduledFuture<V> schedule(final ScheduledFutureTask<V> task) {\n        if (inEventLoop()) {\n            scheduledTaskQueue().add(task.setId(nextTaskId++));\n        } else {\n            final long deadlineNanos = task.deadlineNanos();\n            final Runnable addToQueue = new Runnable() {\n                @Override\n                public void run() {\n                    scheduledTaskQueue().add(task.setId(nextTaskId++));\n                }\n            };\n            if (beforeScheduledTaskSubmitted(deadlineNanos)) {\n                execute(addToQueue);\n            } else {\n                lazyExecute(addToQueue);\n                // Second hook after scheduling to facilitate race-avoidance\n                if (afterScheduledTaskSubmitted(deadlineNanos)) {\n                    execute(WAKEUP_TASK);\n                }\n            }\n        }\n\n        return task;\n    }",
    "replace": "    private <V> ScheduledFuture<V> schedule(final ScheduledFutureTask<V> task) {\n        if (inEventLoop()) {\n            scheduledTaskQueue().add(task.setId(nextTaskId++));\n        } else {\n            long deadlineNanos = task.deadlineNanos();\n            if (beforeScheduledTaskSubmitted(deadlineNanos)) {\n                execute(task);\n            } else {\n                lazyExecute(task);\n                // Second hook after scheduling to facilitate race-avoidance\n                if (afterScheduledTaskSubmitted(deadlineNanos)) {\n                    execute(WAKEUP_TASK);\n                }\n            }\n        }\n\n        return task;\n    }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java",
    "search": "    // set once when added to priority queue\n    private long id;",
    "replace": "    // SFT_SCHEDULED is used to ensure that the task is only ever submitted to the queue once.\n    private static final byte SFT_SCHEDULED = 1;\n\n    private byte SFT_state;\n\n    // set once when added to priority queue\n    private long id;"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java",
    "search": "    @Override\n    public void run() {\n        assert executor().inEventLoop();\n        try {\n            if (periodNanos == 0) {\n                if (setUncancellableInternal()) {\n                    V result = runTask();\n                    setSuccessInternal(result);\n                }\n            } else {\n                // check if is done as it may was cancelled\n                if (!isCancelled()) {\n                    runTask();\n                    if (!executor().isShutdown()) {\n                        if (periodNanos > 0) {\n                            deadlineNanos += periodNanos;\n                        } else {\n                            deadlineNanos = nanoTime() - periodNanos;\n                        }\n                        if (!isCancelled()) {\n                            // scheduledTaskQueue can never be null as we lazy init it before submit the task!\n                            Queue<ScheduledFutureTask<?>> scheduledTaskQueue =\n                                    ((AbstractScheduledEventExecutor) executor()).scheduledTaskQueue;\n                            assert scheduledTaskQueue != null;\n                            scheduledTaskQueue.add(this);\n                        }\n                    }\n                }\n            }\n        } catch (Throwable cause) {\n            setFailureInternal(cause);\n        }\n    }",
    "replace": "    @Override\n    public void run() {\n        assert executor().inEventLoop();\n        if ((SFT_state & SFT_SCHEDULED) == 0) {\n            SFT_state |= SFT_SCHEDULED;\n            AbstractScheduledEventExecutor exec = (AbstractScheduledEventExecutor) executor();\n            exec.scheduledTaskQueue().add(setId(exec.nextTaskId++));\n            return;\n        }\n        if (isPeriodic()) {\n            runPeriodic();\n        } else {\n            super.run();\n        }\n    }\n\n    private void runPeriodic() {\n        assert executor().inEventLoop();\n        try {\n            // check if is done as it may was cancelled\n            if (!isCancelled()) {\n                runTask();\n                if (!executor().isShutdown()) {\n                    long p = periodNanos;\n                    if (p > 0) {\n                        deadlineNanos += p;\n                    } else {\n                        deadlineNanos = nanoTime() - p;\n                    }\n                    if (!isCancelled()) {\n                        // scheduledTaskQueue can never be null as we lazy init it before submit the task!\n                        Queue<ScheduledFutureTask<?>> scheduledTaskQueue =\n                                ((AbstractScheduledEventExecutor) executor()).scheduledTaskQueue;\n                        assert scheduledTaskQueue != null;\n                        scheduledTaskQueue.add(this);\n                    }\n                }\n            }\n        } catch (Throwable cause) {\n            setFailureInternal(cause);\n        }\n    }\n\n    private boolean isPeriodic() {\n        return periodNanos != 0;\n    }"
  }
]
```