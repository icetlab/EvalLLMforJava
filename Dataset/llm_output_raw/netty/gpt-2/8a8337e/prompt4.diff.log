I have introduced a simple per-thread stack in LocalPool so that same‐thread releases bypass the MPSC queue entirely, reducing contention and queue overhead. Cross‐thread releases still go through the existing queue. Below are the atomic changes:

```json
[
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "import java.util.Queue;",
    "replace": "import java.util.Queue;\nimport java.util.ArrayDeque;"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "private static final class LocalPool<T> {",
    "replace": "private static final class LocalPool<T> {\n        private final int maxCapacity;\n        private final Thread ownerThread;\n        private final ArrayDeque<DefaultHandle<T>> stack;"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "LocalPool(int maxCapacity, int ratioInterval, int chunkSize) {",
    "replace": "LocalPool(int maxCapacity, int ratioInterval, int chunkSize) {\n            this.maxCapacity = maxCapacity;\n            this.ownerThread = Thread.currentThread();\n            this.stack = new ArrayDeque<>(maxCapacity);"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "DefaultHandle<T> claim() {\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            if (handles == null) {\n                return null;\n            }\n            DefaultHandle<T> handle = handles.relaxedPoll();\n            if (null != handle) {\n                handle.toClaimed();\n            }\n            return handle;\n        }",
    "replace": "DefaultHandle<T> claim() {\n            DefaultHandle<T> handle = stack.pollFirst();\n            if (handle != null) {\n                handle.toClaimed();\n                return handle;\n            }\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            if (handles == null) {\n                return null;\n            }\n            handle = handles.relaxedPoll();\n            if (handle != null) {\n                handle.toClaimed();\n            }\n            return handle;\n        }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "void release(DefaultHandle<T> handle) {\n            handle.toAvailable();\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            if (handles != null) {\n                handles.relaxedOffer(handle);\n            }\n        }",
    "replace": "void release(DefaultHandle<T> handle) {\n            handle.toAvailable();\n            if (Thread.currentThread() == ownerThread) {\n                if (stack.size() < maxCapacity) {\n                    stack.offerFirst(handle);\n                }\n            } else {\n                MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n                if (handles != null) {\n                    handles.relaxedOffer(handle);\n                }\n            }\n        }"
  }
]
```