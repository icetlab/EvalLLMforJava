The primary optimization here is to replace the full `getAndSet` memory barrier with a single compare-and-set (CAS) in the handle recycling path. This both simplifies the logic and reduces overhead on the hot path for object reuse.

```json
[
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "void toAvailable() {\n            int prev = STATE_UPDATER.getAndSet(this, STATE_AVAILABLE);\n            if (prev == STATE_AVAILABLE) {\n                throw new IllegalStateException(\"Object has been recycled already.\");\n            }\n        }",
    "replace": "void toAvailable() {\n            // Use CAS to switch from CLAIMED to AVAILABLE; faster than getAndSet\n            if (!STATE_UPDATER.compareAndSet(this, STATE_CLAIMED, STATE_AVAILABLE)) {\n                throw new IllegalStateException(\"Object has been recycled already.\");\n            }\n        }"
  }
]
```