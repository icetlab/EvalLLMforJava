diff --git a/common/src/main/java/io/netty/util/Recycler.java b/common/src/main/java/io/netty/util/Recycler.java
index dd7b2d73be..98ced71731 100644
--- a/common/src/main/java/io/netty/util/Recycler.java
+++ b/common/src/main/java/io/netty/util/Recycler.java
@@ -25,6 +25,7 @@ import org.jctools.queues.MessagePassingQueue;
 
 import java.util.ArrayDeque;
 import java.util.Queue;
+import java.util.ArrayDeque;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
 import static io.netty.util.internal.PlatformDependent.newMpscQueue;
@@ -256,12 +257,18 @@ public abstract class Recycler<T> {
     }
 
     private static final class LocalPool<T> {
+        private final int maxCapacity;
+        private final Thread ownerThread;
+        private final ArrayDeque<DefaultHandle<T>> stack;
         private final int ratioInterval;
         private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;
         private int ratioCounter;
 
         @SuppressWarnings("unchecked")
         LocalPool(int maxCapacity, int ratioInterval, int chunkSize) {
+            this.maxCapacity = maxCapacity;
+            this.ownerThread = Thread.currentThread();
+            this.stack = new ArrayDeque<>(maxCapacity);
             this.ratioInterval = ratioInterval;
             if (BLOCKING_POOL) {
                 pooledHandles = new BlockingMessageQueue<DefaultHandle<T>>(maxCapacity);
@@ -272,12 +279,17 @@ public abstract class Recycler<T> {
         }
 
         DefaultHandle<T> claim() {
+            DefaultHandle<T> handle = stack.pollFirst();
+            if (handle != null) {
+                handle.toClaimed();
+                return handle;
+            }
             MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
             if (handles == null) {
                 return null;
             }
-            DefaultHandle<T> handle = handles.relaxedPoll();
-            if (null != handle) {
+            handle = handles.relaxedPoll();
+            if (handle != null) {
                 handle.toClaimed();
             }
             return handle;
@@ -285,11 +297,17 @@ public abstract class Recycler<T> {
 
         void release(DefaultHandle<T> handle) {
             handle.toAvailable();
+            if (Thread.currentThread() == ownerThread) {
+                if (stack.size() < maxCapacity) {
+                    stack.offerFirst(handle);
+                }
+            } else {
                 MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
                 if (handles != null) {
                     handles.relaxedOffer(handle);
                 }
             }
+        }
 
         DefaultHandle<T> newHandle() {
             if (++ratioCounter >= ratioInterval) {
