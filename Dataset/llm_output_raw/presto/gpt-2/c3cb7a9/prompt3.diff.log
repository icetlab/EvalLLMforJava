The following change removes repeated Optional.get() calls and branches just once per invocation of `process`, reducing overhead in the hot path of page indexing.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java",
    "search": "public TransformationState<PagesIndexWithHashStrategies> process(Optional<Page> pendingInputOptional)\n        {\n            if (resetPagesIndex) {\n                pagesIndexWithHashStrategies.pagesIndex.clear();\n                updateMemoryUsage();\n                resetPagesIndex = false;\n            }\n\n            boolean finishing = !pendingInputOptional.isPresent();\n            if (finishing && pagesIndexWithHashStrategies.pagesIndex.getPositionCount() == 0) {\n                memoryContext.close();\n                return TransformationState.finished();\n            }\n\n            if (!finishing) {\n                Page pendingInput = pendingInputOptional.get();\n                pendingInputPosition = updatePagesIndex(pagesIndexWithHashStrategies, pendingInput, pendingInputPosition, Optional.empty());\n                updateMemoryUsage();\n            }\n\n            // If we have unused input or are finishing, then we have buffered a full group\n            if (finishing || pendingInputPosition < pendingInputOptional.get().getPositionCount()) {\n                sortPagesIndexIfNecessary(pagesIndexWithHashStrategies, orderChannels, ordering);\n                resetPagesIndex = true;\n                return TransformationState.ofResult(pagesIndexWithHashStrategies, false);\n            }\n\n            pendingInputPosition = 0;\n            return TransformationState.needsMoreData();\n        }",
    "replace": "public TransformationState<PagesIndexWithHashStrategies> process(Optional<Page> pendingInputOptional)\n        {\n            if (resetPagesIndex) {\n                pagesIndexWithHashStrategies.pagesIndex.clear();\n                updateMemoryUsage();\n                resetPagesIndex = false;\n            }\n\n            boolean finishing = !pendingInputOptional.isPresent();\n            Page page = finishing ? null : pendingInputOptional.get();\n            int positionCount = finishing ? -1 : page.getPositionCount();\n            if (finishing && pagesIndexWithHashStrategies.pagesIndex.getPositionCount() == 0) {\n                memoryContext.close();\n                return TransformationState.finished();\n            }\n\n            if (!finishing) {\n                pendingInputPosition = updatePagesIndex(pagesIndexWithHashStrategies, page, pendingInputPosition, Optional.empty());\n                updateMemoryUsage();\n            }\n\n            // If we have unused input or are finishing, then we have buffered a full group\n            if (finishing || pendingInputPosition < positionCount) {\n                sortPagesIndexIfNecessary(pagesIndexWithHashStrategies, orderChannels, ordering);\n                resetPagesIndex = true;\n                return TransformationState.ofResult(pagesIndexWithHashStrategies, false);\n            }\n\n            pendingInputPosition = 0;\n            return TransformationState.needsMoreData();\n        }"
  }
]
```