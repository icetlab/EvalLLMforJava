diff --git a/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java b/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java
index 93aeb97e76..5ea1f250bc 100644
--- a/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java
+++ b/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java
@@ -176,6 +176,9 @@ public class ByteSelectiveStreamReader
     {
         int streamPosition = 0;
         outputPositionCount = 0;
+        // cache filter allowances
+        int precedingToFail = filter.getPrecedingPositionsToFail();
+        int succeedingToFail = filter.getSucceedingPositionsToFail();
         for (int i = 0; i < positionCount; i++) {
             int position = positions[i];
             if (position > streamPosition) {
@@ -183,8 +186,9 @@ public class ByteSelectiveStreamReader
                 streamPosition = position;
             }
 
-            if (presentStream != null && !presentStream.nextBit()) {
-                if ((nonDeterministicFilter && filter.testNull()) || nullsAllowed) {
+            boolean isNullValue = presentStream != null && !presentStream.nextBit();
+            if (isNullValue) {
+                if (nullsAllowed) {
                     if (outputRequired) {
                         nulls[outputPositionCount] = true;
                     }
@@ -207,12 +211,11 @@ public class ByteSelectiveStreamReader
             }
             streamPosition++;
 
-            if (filter != null) {
-                outputPositionCount -= filter.getPrecedingPositionsToFail();
-                int succeedingPositionsToFail = filter.getSucceedingPositionsToFail();
-                if (succeedingPositionsToFail > 0) {
+            // apply filter failure allowances
+                outputPositionCount -= precedingToFail;
+                if (succeedingToFail > 0) {
                     int positionsToSkip = 0;
-                    for (int j = 0; j < succeedingPositionsToFail; j++) {
+                    for (int j = 0; j < succeedingToFail; j++) {
                         i++;
                         int nextPosition = positions[i];
                         positionsToSkip += 1 + nextPosition - streamPosition;
@@ -221,7 +224,6 @@ public class ByteSelectiveStreamReader
                     skip(positionsToSkip);
                 }
         }
-        }
         return streamPosition;
     }
 
@@ -232,6 +234,9 @@ public class ByteSelectiveStreamReader
 
         if (nonDeterministicFilter) {
             outputPositionCount = 0;
+        // cache filter allowances
+        int precedingToFail = filter.getPrecedingPositionsToFail();
+        int succeedingToFail = filter.getSucceedingPositionsToFail();
             for (int i = 0; i < positionCount; i++) {
                 if (filter.testNull()) {
                     outputPositionCount++;
@@ -247,6 +252,9 @@ public class ByteSelectiveStreamReader
         }
         else {
             outputPositionCount = 0;
+        // cache filter allowances
+        int precedingToFail = filter.getPrecedingPositionsToFail();
+        int succeedingToFail = filter.getSucceedingPositionsToFail();
         }
 
         allNulls = true;
@@ -272,7 +280,8 @@ public class ByteSelectiveStreamReader
                 streamPosition = position;
             }
 
-            if (presentStream != null && !presentStream.nextBit()) {
+            boolean isNullValue = presentStream != null && !presentStream.nextBit();
+            if (isNullValue) {
                 nulls[i] = true;
             }
             else {
