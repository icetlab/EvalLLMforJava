Iâ€™ve added a reusable `Block[]` array to avoid allocating a new array on every call to `getPartitionFunctionArguments`, reducing GC pressure and improving throughput.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java",
    "search": "private final List<Optional<Block>> partitionConstants;",
    "replace": "private final List<Optional<Block>> partitionConstants;\n        private final Block[] partitionFunctionArguments;"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java",
    "search": "this.partitionConstants = requireNonNull(partitionConstants, \"partitionConstants is null\").stream()\n                    .map(constant -> constant.map(ConstantExpression::getValueBlock))\n                    .collect(toImmutableList());",
    "replace": "this.partitionConstants = requireNonNull(partitionConstants, \"partitionConstants is null\").stream()\n                    .map(constant -> constant.map(ConstantExpression::getValueBlock))\n                    .collect(toImmutableList());\n            // reuse a single Block[] to avoid repeated allocations\n            this.partitionFunctionArguments = new Block[partitionChannels.size()];"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java",
    "search": "private Page getPartitionFunctionArguments(Page page)\n        {\n            Block[] blocks = new Block[partitionChannels.size()];\n            for (int i = 0; i < blocks.length; i++) {\n                Optional<Block> partitionConstant = partitionConstants.get(i);\n                if (partitionConstant.isPresent()) {\n                    blocks[i] = new RunLengthEncodedBlock(partitionConstant.get(), page.getPositionCount());\n                }\n                else {\n                    blocks[i] = page.getBlock(partitionChannels.get(i));\n                }\n            }\n            return new Page(page.getPositionCount(), blocks);\n        }",
    "replace": "private Page getPartitionFunctionArguments(Page page)\n        {\n            // fill the reusable Block[] instead of allocating a new one\n            for (int i = 0; i < partitionFunctionArguments.length; i++) {\n                Optional<Block> partitionConstant = partitionConstants.get(i);\n                if (partitionConstant.isPresent()) {\n                    partitionFunctionArguments[i] = new RunLengthEncodedBlock(partitionConstant.get(), page.getPositionCount());\n                }\n                else {\n                    partitionFunctionArguments[i] = page.getBlock(partitionChannels.get(i));\n                }\n            }\n            return new Page(page.getPositionCount(), partitionFunctionArguments);\n        }"
  }
]
```