Iâ€™ve replaced the linear-binary search in findEndPosition with an exponential + binary search to reduce the number of comparisons when groups are small relative to the overall data, while preserving exact behavior and all existing tests.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java",
    "search": "    @VisibleForTesting\n    static int findEndPosition(int startPosition, int endPosition, BiPredicate<Integer, Integer> comparator)\n    {\n        checkArgument(startPosition >= 0, \"startPosition must be greater or equal than zero: %s\", startPosition);\n        checkArgument(startPosition < endPosition, \"startPosition (%s) must be less than endPosition (%s)\", startPosition, endPosition);\n\n        int left = startPosition;\n        int right = endPosition;\n\n        while (left + 1 < right) {\n            int middle = (left + right) >>> 1;\n\n            if (comparator.test(startPosition, middle)) {\n                left = middle;\n            }\n            else {\n                right = middle;\n            }\n        }\n\n        return right;\n    }",
    "replace": "    @VisibleForTesting\n    static int findEndPosition(int startPosition, int endPosition, BiPredicate<Integer, Integer> comparator)\n    {\n        checkArgument(startPosition >= 0, \"startPosition must be greater or equal than zero: %s\", startPosition);\n        checkArgument(startPosition < endPosition, \"startPosition (%s) must be less than endPosition (%s)\", startPosition, endPosition);\n\n        // Fast path: only one element or next element is different\n        int nextPos = startPosition + 1;\n        if (nextPos >= endPosition || !comparator.test(startPosition, nextPos)) {\n            return nextPos;\n        }\n\n        // Exponential search to find an upper bound where elements differ\n        int low = nextPos;\n        int step = 2;\n        int high;\n        while (true) {\n            int idx = startPosition + step;\n            if (idx >= endPosition) {\n                high = endPosition;\n                break;\n            }\n            if (!comparator.test(startPosition, idx)) {\n                high = idx;\n                break;\n            }\n            low = idx;\n            step <<= 1;\n        }\n\n        // Binary search between last equal (low) and first different (high)\n        while (low + 1 < high) {\n            int mid = (low + high) >>> 1;\n            if (comparator.test(startPosition, mid)) {\n                low = mid;\n            }\n            else {\n                high = mid;\n            }\n        }\n\n        return high;\n    }"
  }
]
```