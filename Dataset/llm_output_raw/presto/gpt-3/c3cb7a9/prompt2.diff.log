Iâ€™ve optimized the `findEndPosition` method by replacing its plain binary search with an exponential (galloping) search to quickly bracket the group boundary and then a binary refinement. This reduces the number of expensive comparator invocations, especially when groups are small relative to the data size.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java",
    "search": "@VisibleForTesting\n    static int findEndPosition(int startPosition, int endPosition, BiPredicate<Integer, Integer> comparator)\n    {\n        checkArgument(startPosition >= 0, \"startPosition must be greater or equal than zero: %s\", startPosition);\n        checkArgument(startPosition < endPosition, \"startPosition (%s) must be less than endPosition (%s)\", startPosition, endPosition);\n\n        int left = startPosition;\n        int right = endPosition;\n\n        while (left + 1 < right) {\n            int middle = (left + right) >>> 1;\n\n            if (comparator.test(startPosition, middle)) {\n                left = middle;\n            }\n            else {\n                right = middle;\n            }\n        }\n\n        return right;\n    }",
    "replace": "@VisibleForTesting\n    static int findEndPosition(int startPosition, int endPosition, BiPredicate<Integer, Integer> comparator)\n    {\n        checkArgument(startPosition >= 0, \"startPosition must be greater or equal than zero: %s\", startPosition);\n        checkArgument(startPosition < endPosition, \"startPosition (%s) must be less than endPosition (%s)\", startPosition, endPosition);\n\n        // Quick check for immediate next position\n        int next = startPosition + 1;\n        if (next >= endPosition || !comparator.test(startPosition, next)) {\n            return next;\n        }\n\n        // Exponential search to find a window where values differ\n        int bound = 1;\n        while (startPosition + bound < endPosition && comparator.test(startPosition, startPosition + bound)) {\n            bound <<= 1;\n        }\n\n        // Define binary search bounds\n        int low = startPosition + (bound >> 1) + 1;\n        int high = Math.min(startPosition + bound, endPosition);\n\n        // Binary refinement to find exact boundary\n        while (low < high) {\n            int mid = low + ((high - low) >>> 1);\n            if (comparator.test(startPosition, mid)) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }"
  }
]
```