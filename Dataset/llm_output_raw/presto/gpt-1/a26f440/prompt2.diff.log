I’ve added a fast‐path in `mergeNewValues` to handle small, initial distributions without performing the full merge logic, which should significantly reduce overhead when the number of centroids is below the compression threshold. Functionality and existing tests remain unchanged.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "private void mergeNewValues(boolean force, double compression)\n    {\n        if (unmergedWeight == 0) {\n            return;\n        }\n\n        if (force || unmergedWeight > 0) {\n            // note that we run the merge in reverse every other merge to avoid left-to-right bias in merging\n            merge(tempMean, tempWeight, tempUsed, order, unmergedWeight, mergeCount % 2 == 1, compression);\n            mergeCount++;\n            tempUsed = 0;\n            unmergedWeight = 0;\n        }\n    }",
    "replace": "private void mergeNewValues(boolean force, double compression)\n    {\n        if (unmergedWeight == 0) {\n            return;\n        }\n\n        // fast path: if no existing centroids and few pending points, just sort and adopt them directly\n        if (activeCentroids == 0 && tempUsed <= compression) {\n            int count = tempUsed;\n            // initialize order 0..count-1\n            for (int i = 0; i < count; i++) {\n                order[i] = i;\n            }\n            // sort pending values\n            sort(order, tempMean, count);\n            // reverse every other merge to avoid bias\n            if (mergeCount % 2 == 1) {\n                reverse(order, 0, count);\n            }\n            // adopt weights and means directly\n            totalWeight += unmergedWeight;\n            for (int i = 0; i < count; i++) {\n                int idx = order[i];\n                mean[i] = tempMean[idx];\n                weight[i] = tempWeight[idx];\n            }\n            activeCentroids = count;\n            tempUsed = 0;\n            unmergedWeight = 0;\n            mergeCount++;\n            return;\n        }\n\n        if (force || unmergedWeight > 0) {\n            // note that we run the merge in reverse every other merge to avoid left-to-right bias in merging\n            merge(tempMean, tempWeight, tempUsed, order, unmergedWeight, mergeCount % 2 == 1, compression);\n            mergeCount++;\n            tempUsed = 0;\n            unmergedWeight = 0;\n        }\n    }"
  }
]
```