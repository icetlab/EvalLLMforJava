diff --git a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java
index 30e0088e35..73491af078 100644
--- a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java
+++ b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java
@@ -188,6 +188,14 @@ public class OptimizedPartitionedOutputOperator
     @VisibleForTesting
     static DecodedBlockNode decodeBlock(BlockFlattener flattener, Closer blockLeaseCloser, Block block)
     {
+        // Skip flatten for already-flat blocks
+        if (!(block instanceof ArrayBlock)
+                && !(block instanceof MapBlock)
+                && !(block instanceof RowBlock)
+                && !(block instanceof DictionaryBlock)
+                && !(block instanceof RunLengthEncodedBlock)) {
+            return new DecodedBlockNode(block, ImmutableList.of());
+        }
         BlockLease lease = flattener.flatten(block);
         blockLeaseCloser.register(lease::close);
         Block decodedBlock = lease.get();
@@ -441,15 +449,21 @@ public class OptimizedPartitionedOutputOperator
             Block nullBlock = nullChannel.isPresent() ? page.getBlock(nullChannel.getAsInt()) : null;
             Page partitionFunctionArgs = getPartitionFunctionArguments(page);
 
-            for (int position = 0; position < positionCount; position++) {
-                boolean shouldReplicate = (replicatesAnyRow && !hasAnyRowBeenReplicated) ||
-                        nullBlock != null && nullBlock.isNull(position);
-
-                if (shouldReplicate) {
+            int startPosition = 0;
+            // replicate first row once if requested
+            if (replicatesAnyRow && !hasAnyRowBeenReplicated && positionCount > 0) {
                 for (int i = 0; i < partitionBuffers.length; i++) {
-                        partitionBuffers[i].addPosition(position);
+                    partitionBuffers[i].addPosition(0);
                 }
                 hasAnyRowBeenReplicated = true;
+                startPosition = 1;
+            }
+            for (int position = startPosition; position < positionCount; position++) {
+                // only null-driven replication remains
+                if (nullBlock != null && nullBlock.isNull(position)) {
+                    for (int i = 0; i < partitionBuffers.length; i++) {
+                        partitionBuffers[i].addPosition(position);
+                    }
                 }
                 else {
                     int partition = partitionFunction.getPartition(partitionFunctionArgs, position);
