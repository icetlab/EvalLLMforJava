Iâ€™ve added a fast path in readNoFilter to handle contiguous reads when there is a null stream: it reads all null flags in bulk, counts non-null values, bulk-reads those bytes, and then unpacks them into the values array. This avoids per-position branching and skipping.

```json
[
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java",
    "search": "if (presentStream == null && positions[positionCount - 1] == positionCount - 1) {\n            // contiguous chunk of rows, no nulls\n            dataStream.next(values, positionCount);\n            outputPositionCount = positionCount;\n            return positionCount;\n        }",
    "replace": "if (presentStream == null && positions[positionCount - 1] == positionCount - 1) {\n            // contiguous chunk of rows, no nulls\n            dataStream.next(values, positionCount);\n            outputPositionCount = positionCount;\n            return positionCount;\n        }\n        // contiguous chunk of rows with nulls\n        if (presentStream != null && positions[positionCount - 1] == positionCount - 1) {\n            // read null flags\n            for (int i = 0; i < positionCount; i++) {\n                nulls[i] = !presentStream.nextBit();\n            }\n            // count non-null values\n            int nonNullCount = 0;\n            for (boolean isNull : nulls) {\n                if (!isNull) {\n                    nonNullCount++;\n                }\n            }\n            // read non-null bytes\n            dataStream.next(values, nonNullCount);\n            // unpack values into positions including nulls\n            values = ReaderUtils.unpackByteNulls(values, nulls);\n            outputPositionCount = positionCount;\n            return positionCount;\n        }"
  }
]
```