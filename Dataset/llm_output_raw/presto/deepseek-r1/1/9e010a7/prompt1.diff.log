Looking at the `MapToMapCast.java` file, I can identify several performance optimizations we can make. The main performance issues are:

1. **Duplicate key detection inefficiency**: The current implementation processes all keys first to build a key block, then uses a `TypedSet` to detect duplicates. This requires two passes over the key data and creates an intermediate key block.

2. **Redundant operations**: The `TypedSet` is built from the key block, but we could detect duplicates during the initial key processing phase.

3. **MethodHandle invocation overhead**: The current code calls `invokeExact` multiple times in loops, which has overhead.

Let me implement these improvements:

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java",
    "search": "    @UsedByGeneratedCode\n    public static Block mapCast(\n            MethodHandle keyProcessFunction,\n            MethodHandle valueProcessFunction,\n            Type toMapType,\n            SqlFunctionProperties properties,\n            Block fromMap)\n    {\n        checkState(toMapType.getTypeParameters().size() == 2, \"Expect two type parameters for toMapType\");\n        Type toKeyType = toMapType.getTypeParameters().get(0);\n        TypedSet typedSet = new TypedSet(toKeyType, fromMap.getPositionCount() / 2, \"map-to-map cast\");\n        BlockBuilder keyBlockBuilder = toKeyType.createBlockBuilder(null, fromMap.getPositionCount() / 2);\n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            try {\n                keyProcessFunction.invokeExact(fromMap, i, properties, keyBlockBuilder);\n            }\n            catch (Throwable t) {\n                throw internalError(t);\n            }\n        }\n        Block keyBlock = keyBlockBuilder.build();\n\n        BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);\n        BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();\n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            if (typedSet.add(keyBlock, i / 2)) {\n                toKeyType.appendTo(keyBlock, i / 2, blockBuilder);\n                if (fromMap.isNull(i + 1)) {\n                    blockBuilder.appendNull();\n                    continue;\n                }\n\n                try {\n                    valueProcessFunction.invokeExact(fromMap, i + 1, properties, blockBuilder);\n                }\n                catch (Throwable t) {\n                    throw internalError(t);\n                }\n            }\n            else {\n                // if there are duplicated keys, fail it!\n                throw new PrestoException(INVALID_CAST_ARGUMENT, \"duplicate keys\");\n            }\n        }\n\n        mapBlockBuilder.closeEntry();\n        return (Block) toMapType.getObject(mapBlockBuilder, mapBlockBuilder.getPositionCount() - 1);\n    }",
    "replace": "    @UsedByGeneratedCode\n    public static Block mapCast(\n            MethodHandle keyProcessFunction,\n            MethodHandle valueProcessFunction,\n            Type toMapType,\n            SqlFunctionProperties properties,\n            Block fromMap)\n    {\n        checkState(toMapType.getTypeParameters().size() == 2, \"Expect two type parameters for toMapType\");\n        Type toKeyType = toMapType.getTypeParameters().get(0);\n        \n        int entryCount = fromMap.getPositionCount() / 2;\n        BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);\n        BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();\n        \n        // Create a temporary block builder for duplicate detection\n        BlockBuilder tempKeyBlockBuilder = toKeyType.createBlockBuilder(null, 1);\n        BlockBuilder duplicateCheckBuilder = toKeyType.createBlockBuilder(null, entryCount);\n        \n        // Process keys and values in a single pass\n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            // Clear the temporary builder\n            tempKeyBlockBuilder = toKeyType.createBlockBuilder(null, 1);\n            \n            // Process the key\n            try {\n                keyProcessFunction.invokeExact(fromMap, i, properties, tempKeyBlockBuilder);\n            }\n            catch (Throwable t) {\n                throw internalError(t);\n            }\n            \n            Block tempKeyBlock = tempKeyBlockBuilder.build();\n            \n            // Check for duplicates using the duplicate check builder\n            boolean isDuplicate = false;\n            for (int j = 0; j < duplicateCheckBuilder.getPositionCount(); j++) {\n                if (toKeyType.equalTo(tempKeyBlock, 0, duplicateCheckBuilder, j)) {\n                    isDuplicate = true;\n                    break;\n                }\n            }\n            \n            if (isDuplicate) {\n                throw new PrestoException(INVALID_CAST_ARGUMENT, \"duplicate keys\");\n            }\n            \n            // Add to duplicate check and write to final block\n            toKeyType.appendTo(tempKeyBlock, 0, duplicateCheckBuilder);\n            toKeyType.appendTo(tempKeyBlock, 0, blockBuilder);\n            \n            if (fromMap.isNull(i + 1)) {\n                blockBuilder.appendNull();\n                continue;\n            }\n\n            try {\n                valueProcessFunction.invokeExact(fromMap, i + 1, properties, blockBuilder);\n            }\n            catch (Throwable t) {\n                throw internalError(t);\n            }\n        }\n\n        mapBlockBuilder.closeEntry();\n        return (Block) toMapType.getObject(mapBlockBuilder, mapBlockBuilder.getPositionCount() - 1);\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java",
    "search": "    private MethodHandle nullChecker(Class<?> javaType)\n    {\n        if (javaType == Long.class) {\n            return CHECK_LONG_IS_NOT_NULL;\n        }\n        else if (javaType == Double.class) {\n            return CHECK_DOUBLE_IS_NOT_NULL;\n        }\n        else if (javaType == Boolean.class) {\n            return CHECK_BOOLEAN_IS_NOT_NULL;\n        }\n        else if (javaType == Slice.class) {\n            return CHECK_SLICE_IS_NOT_NULL;\n        }\n        else if (javaType == Block.class) {\n            return CHECK_BLOCK_IS_NOT_NULL;\n        }\n        else {\n            throw new IllegalArgumentException(\"Unknown java type \" + javaType);\n        }\n    }",
    "replace": "    private MethodHandle nullChecker(Class<?> javaType)\n    {\n        switch (javaType.getSimpleName()) {\n            case \"Long\":\n                return CHECK_LONG_IS_NOT_NULL;\n            case \"Double\":\n                return CHECK_DOUBLE_IS_NOT_NULL;\n            case \"Boolean\":\n                return CHECK_BOOLEAN_IS_NOT_NULL;\n            case \"Slice\":\n                return CHECK_SLICE_IS_NOT_NULL;\n            case \"Block\":\n                return CHECK_BLOCK_IS_NOT_NULL;\n            default:\n                throw new IllegalArgumentException(\"Unknown java type \" + javaType);\n        }\n    }"
  }
]
```