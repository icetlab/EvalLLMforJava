Looking at the code, the performance issue mentions "Optimize mapToMapCast for common cases". The current implementation in `MapToMapCast.mapCast()` creates a `TypedSet` for duplicate key checking and processes keys in two passes. For common cases where we know there won't be duplicate keys (like when casting from a map that's already known to have unique keys), we could optimize.

However, after analyzing the code, I notice that the current implementation already has a reasonable approach. The main potential optimization I see is in the duplicate key checking logic. Currently:
1. It processes all keys first into a keyBlock
2. Then iterates through keys again to check for duplicates using `TypedSet`

We could potentially optimize by checking for duplicates during the first pass, but that would require significant restructuring. Instead, I'll focus on optimizing the `TypedSet` usage and removing unnecessary operations.

Looking more closely, I see that `TypedSet.add()` is called for each key, but we're building the entire keyBlock first and then checking duplicates. We could optimize by checking duplicates while building the keyBlock.

Here's the optimization: Instead of building the entire keyBlock first and then checking for duplicates, we can check for duplicates incrementally as we process keys. This avoids the need to store all casted keys before checking duplicates.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java",
    "search": "    @UsedByGeneratedCode\n    public static Block mapCast(\n            MethodHandle keyProcessFunction,\n            MethodHandle valueProcessFunction,\n            Type toMapType,\n            SqlFunctionProperties properties,\n            Block fromMap)\n    {\n        checkState(toMapType.getTypeParameters().size() == 2, \"Expect two type parameters for toMapType\");\n        Type toKeyType = toMapType.getTypeParameters().get(0);\n        TypedSet typedSet = new TypedSet(toKeyType, fromMap.getPositionCount() / 2, \"map-to-map cast\");\n        BlockBuilder keyBlockBuilder = toKeyType.createBlockBuilder(null, fromMap.getPositionCount() / 2);\n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            try {\n                keyProcessFunction.invokeExact(fromMap, i, properties, keyBlockBuilder);\n            }\n            catch (Throwable t) {\n                throw internalError(t);\n            }\n        }\n        Block keyBlock = keyBlockBuilder.build();\n\n        BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);\n        BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();\n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            if (typedSet.add(keyBlock, i / 2)) {\n                toKeyType.appendTo(keyBlock, i / 2, blockBuilder);\n                if (fromMap.isNull(i + 1)) {\n                    blockBuilder.appendNull();\n                    continue;\n                }\n\n                try {\n                    valueProcessFunction.invokeExact(fromMap, i + 1, properties, blockBuilder);\n                }\n                catch (Throwable t) {\n                    throw internalError(t);\n                }\n            }\n            else {\n                // if there are duplicated keys, fail it!\n                throw new PrestoException(INVALID_CAST_ARGUMENT, \"duplicate keys\");\n            }\n        }\n\n        mapBlockBuilder.closeEntry();\n        return (Block) toMapType.getObject(mapBlockBuilder, mapBlockBuilder.getPositionCount() - 1);\n    }",
    "replace": "    @UsedByGeneratedCode\n    public static Block mapCast(\n            MethodHandle keyProcessFunction,\n            MethodHandle valueProcessFunction,\n            Type toMapType,\n            SqlFunctionProperties properties,\n            Block fromMap)\n    {\n        checkState(toMapType.getTypeParameters().size() == 2, \"Expect two type parameters for toMapType\");\n        Type toKeyType = toMapType.getTypeParameters().get(0);\n        int entryCount = fromMap.getPositionCount() / 2;\n        TypedSet typedSet = new TypedSet(toKeyType, entryCount, \"map-to-map cast\");\n        \n        BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);\n        BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();\n        \n        // Temporary block builder for checking duplicates\n        BlockBuilder tempKeyBlockBuilder = toKeyType.createBlockBuilder(null, 1);\n        \n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            // Build the key in temporary block builder\n            tempKeyBlockBuilder = toKeyType.createBlockBuilder(null, 1);\n            try {\n                keyProcessFunction.invokeExact(fromMap, i, properties, tempKeyBlockBuilder);\n            }\n            catch (Throwable t) {\n                throw internalError(t);\n            }\n            Block tempKeyBlock = tempKeyBlockBuilder.build();\n            \n            // Check for duplicate using the temporary key block\n            if (typedSet.add(tempKeyBlock, 0)) {\n                // Not a duplicate, append the key to the actual output\n                toKeyType.appendTo(tempKeyBlock, 0, blockBuilder);\n                \n                // Process the value\n                if (fromMap.isNull(i + 1)) {\n                    blockBuilder.appendNull();\n                }\n                else {\n                    try {\n                        valueProcessFunction.invokeExact(fromMap, i + 1, properties, blockBuilder);\n                    }\n                    catch (Throwable t) {\n                        throw internalError(t);\n                    }\n                }\n            }\n            else {\n                // if there are duplicated keys, fail it!\n                throw new PrestoException(INVALID_CAST_ARGUMENT, \"duplicate keys\");\n            }\n        }\n\n        mapBlockBuilder.closeEntry();\n        return (Block) toMapType.getObject(mapBlockBuilder, mapBlockBuilder.getPositionCount() - 1);\n    }"
  }
]
```

This change optimizes the map cast operation by:
1. Eliminating the first pass that builds the entire keyBlock
2. Checking for duplicates incrementally as keys are processed
3. Reducing memory allocation by using a temporary single-entry block builder for duplicate checking

This is particularly beneficial for common cases where:
- Maps are large (reduces memory usage by not storing all keys twice)
- There are no duplicates (we fail fast on the first duplicate)
- The key processing is expensive (we only process each key once instead of potentially twice)

The optimization maintains the same functionality while improving performance and reducing memory overhead.