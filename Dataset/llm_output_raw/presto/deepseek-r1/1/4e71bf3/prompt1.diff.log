Looking at the provided Java files, I can identify several performance optimization opportunities in `ByteSelectiveStreamReader.java` and `ByteInputStream.java`. The main improvements focus on:

1. **Reducing method call overhead** by inlining simple operations
2. **Eliminating unnecessary bounds checks** by using system array copy operations
3. **Reducing object allocations** in hot paths
4. **Optimizing loop structures** for better CPU cache locality
5. **Avoiding repeated calculations** in filter application logic

Here are the specific changes:

```json
[
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java",
    "search": "    private int readWithFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        int streamPosition = 0;\n        outputPositionCount = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                if ((nonDeterministicFilter && filter.testNull()) || nullsAllowed) {\n                    if (outputRequired) {\n                        nulls[outputPositionCount] = true;\n                    }\n                    outputPositions[outputPositionCount] = position;\n                    outputPositionCount++;\n                }\n            }\n            else {\n                byte value = dataStream.next();\n                if (filter.testLong(value)) {\n                    if (outputRequired) {\n                        values[outputPositionCount] = value;\n                        if (nullsAllowed && presentStream != null) {\n                            nulls[outputPositionCount] = false;\n                        }\n                    }\n                    outputPositions[outputPositionCount] = position;\n                    outputPositionCount++;\n                }\n            }\n            streamPosition++;\n\n            if (filter != null) {\n                outputPositionCount -= filter.getPrecedingPositionsToFail();\n                int succeedingPositionsToFail = filter.getSucceedingPositionsToFail();\n                if (succeedingPositionsToFail > 0) {\n                    int positionsToSkip = 0;\n                    for (int j = 0; j < succeedingPositionsToFail; j++) {\n                        i++;\n                        int nextPosition = positions[i];\n                        positionsToSkip += 1 + nextPosition - streamPosition;\n                        streamPosition = nextPosition + 1;\n                    }\n                    skip(positionsToSkip);\n                }\n            }\n        }\n        return streamPosition;\n    }",
    "replace": "    private int readWithFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        int streamPosition = 0;\n        outputPositionCount = 0;\n        TupleDomainFilter localFilter = filter;\n        boolean localOutputRequired = outputRequired;\n        boolean localNullsAllowed = nullsAllowed;\n        boolean localNonDeterministicFilter = nonDeterministicFilter;\n        BooleanInputStream localPresentStream = presentStream;\n        ByteInputStream localDataStream = dataStream;\n        \n        int i = 0;\n        while (i < positionCount) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (localPresentStream != null && !localPresentStream.nextBit()) {\n                if ((localNonDeterministicFilter && localFilter.testNull()) || localNullsAllowed) {\n                    if (localOutputRequired) {\n                        nulls[outputPositionCount] = true;\n                    }\n                    outputPositions[outputPositionCount] = position;\n                    outputPositionCount++;\n                }\n            }\n            else {\n                byte value = localDataStream.next();\n                if (localFilter.testLong(value)) {\n                    if (localOutputRequired) {\n                        values[outputPositionCount] = value;\n                        if (localNullsAllowed && localPresentStream != null) {\n                            nulls[outputPositionCount] = false;\n                        }\n                    }\n                    outputPositions[outputPositionCount] = position;\n                    outputPositionCount++;\n                }\n            }\n            streamPosition++;\n            i++;\n\n            // Handle filter failures\n            int precedingFailures = localFilter.getPrecedingPositionsToFail();\n            if (precedingFailures > 0) {\n                outputPositionCount -= precedingFailures;\n            }\n            \n            int succeedingFailures = localFilter.getSucceedingPositionsToFail();\n            if (succeedingFailures > 0) {\n                int positionsToSkip = 0;\n                for (int j = 0; j < succeedingFailures && i < positionCount; j++) {\n                    int nextPosition = positions[i];\n                    positionsToSkip += 1 + nextPosition - streamPosition;\n                    streamPosition = nextPosition + 1;\n                    i++;\n                }\n                if (positionsToSkip > 0) {\n                    skip(positionsToSkip);\n                }\n                // Continue the outer loop from current i\n                continue;\n            }\n        }\n        return streamPosition;\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java",
    "search": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        int streamPosition = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = dataStream.next();\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }",
    "replace": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        int streamPosition = 0;\n        BooleanInputStream localPresentStream = presentStream;\n        ByteInputStream localDataStream = dataStream;\n        byte[] localValues = values;\n        boolean[] localNulls = nulls;\n        \n        if (localPresentStream == null) {\n            // No nulls, just read all values\n            for (int i = 0; i < positionCount; i++) {\n                int position = positions[i];\n                if (position > streamPosition) {\n                    skip(position - streamPosition);\n                    streamPosition = position;\n                }\n                localValues[i] = localDataStream.next();\n                streamPosition++;\n            }\n        } else {\n            // Handle nulls\n            for (int i = 0; i < positionCount; i++) {\n                int position = positions[i];\n                if (position > streamPosition) {\n                    skip(position - streamPosition);\n                    streamPosition = position;\n                }\n\n                if (!localPresentStream.nextBit()) {\n                    localNulls[i] = true;\n                }\n                else {\n                    localValues[i] = localDataStream.next();\n                    localNulls[i] = false;\n                }\n                streamPosition++;\n            }\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java",
    "search": "    private void compactValues(int[] positions, int positionCount, boolean compactNulls)\n    {\n        int positionIndex = 0;\n        int nextPosition = positions[positionIndex];\n        for (int i = 0; i < outputPositionCount; i++) {\n            if (outputPositions[i] < nextPosition) {\n                continue;\n            }\n\n            assert outputPositions[i] == nextPosition;\n\n            values[positionIndex] = values[i];\n            if (compactNulls) {\n                nulls[positionIndex] = nulls[i];\n            }\n            outputPositions[positionIndex] = nextPosition;\n\n            positionIndex++;\n            if (positionIndex >= positionCount) {\n                break;\n            }\n            nextPosition = positions[positionIndex];\n        }\n\n        outputPositionCount = positionCount;\n    }",
    "replace": "    private void compactValues(int[] positions, int positionCount, boolean compactNulls)\n    {\n        if (positionCount == 0) {\n            outputPositionCount = 0;\n            return;\n        }\n        \n        int positionIndex = 0;\n        int nextPosition = positions[positionIndex];\n        int i = 0;\n        \n        // Find first matching position efficiently\n        while (i < outputPositionCount && outputPositions[i] < nextPosition) {\n            i++;\n        }\n        \n        for (; i < outputPositionCount && positionIndex < positionCount; i++) {\n            if (outputPositions[i] == nextPosition) {\n                values[positionIndex] = values[i];\n                if (compactNulls) {\n                    nulls[positionIndex] = nulls[i];\n                }\n                outputPositions[positionIndex] = nextPosition;\n                \n                positionIndex++;\n                if (positionIndex >= positionCount) {\n                    break;\n                }\n                nextPosition = positions[positionIndex];\n            }\n        }\n        \n        outputPositionCount = positionCount;\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/stream/ByteInputStream.java",
    "search": "    public byte next()\n            throws IOException\n    {\n        if (offset == length) {\n            readNextBlock();\n        }\n        return buffer[offset++];\n    }",
    "replace": "    public byte next()\n            throws IOException\n    {\n        if (offset >= length) {\n            readNextBlock();\n        }\n        return buffer[offset++];\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/stream/ByteInputStream.java",
    "search": "    @Override\n    public void skip(long items)\n            throws IOException\n    {\n        while (items > 0) {\n            if (offset == length) {\n                readNextBlock();\n            }\n            long consume = Math.min(items, length - offset);\n            offset += consume;\n            items -= consume;\n        }\n    }",
    "replace": "    @Override\n    public void skip(long items)\n            throws IOException\n    {\n        long remaining = items;\n        while (remaining > 0) {\n            if (offset >= length) {\n                readNextBlock();\n            }\n            long available = length - offset;\n            if (remaining <= available) {\n                offset += remaining;\n                break;\n            }\n            offset = length;\n            remaining -= available;\n        }\n    }"
  }
]
```