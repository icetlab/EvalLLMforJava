The `findEndPosition` method is a critical performance hotspot in `WindowOperator`, used to find group boundaries during window function processing. The current binary search implementation performs O(log n) comparisons even for small groups, which is inefficient when groups are small relative to partition size. The optimized version uses an exponential search (galloping search) first to quickly locate the approximate boundary when groups are small, then performs binary search within the narrowed range. This approach maintains O(log n) worst-case complexity but significantly reduces comparisons for small groups, which are common in real-world window operations.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java",
    "search": "    @VisibleForTesting\n    static int findEndPosition(int startPosition, int endPosition, BiPredicate<Integer, Integer> comparator)\n    {\n        checkArgument(startPosition >= 0, \"startPosition must be greater or equal than zero: %s\", startPosition);\n        checkArgument(startPosition < endPosition, \"startPosition (%s) must be less than endPosition (%s)\", startPosition, endPosition);\n\n        int left = startPosition;\n        int right = endPosition;\n\n        while (left + 1 < right) {\n            int middle = (left + right) >>> 1;\n\n            if (comparator.test(startPosition, middle)) {\n                left = middle;\n            }\n            else {\n                right = middle;\n            }\n        }\n\n        return right;\n    }",
    "replace": "    @VisibleForTesting\n    static int findEndPosition(int startPosition, int endPosition, BiPredicate<Integer, Integer> comparator)\n    {\n        checkArgument(startPosition >= 0, \"startPosition must be greater or equal than zero: %s\", startPosition);\n        checkArgument(startPosition < endPosition, \"startPosition (%s) must be less than endPosition (%s)\", startPosition, endPosition);\n\n        int left = startPosition;\n        int step = 1;\n        int right = left + step;\n\n        // Exponential search to find the range [left, right) where the boundary lies.\n        while (right < endPosition && comparator.test(startPosition, right)) {\n            left = right;\n            step *= 2;\n            right = left + step;\n        }\n        if (right > endPosition) {\n            right = endPosition;\n        }\n\n        // Now, the first index that is not equal (or endPosition) is in [left, right).\n        // We know that left is equal and right is not equal (or we are at the end).\n        // Perform binary search to find the first index that is not equal.\n        while (left + 1 < right) {\n            int middle = (left + right) >>> 1;\n\n            if (comparator.test(startPosition, middle)) {\n                left = middle;\n            }\n            else {\n                right = middle;\n            }\n        }\n\n        return right;\n    }"
  }
]
```