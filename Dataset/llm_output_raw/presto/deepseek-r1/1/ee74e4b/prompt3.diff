diff --git a/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java b/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java
index 979fc2cb80..56a2764ce0 100644
--- a/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java
+++ b/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java
@@ -150,11 +150,13 @@ public class PageProcessor
         private final SqlFunctionProperties properties;
         private final DriverYieldSignal yieldSignal;
         private final LocalMemoryContext memoryContext;
+        private final ReferenceCountMap referenceCountMap;
 
         private Page page;
         private Block[] previouslyComputedResults;
         private SelectedPositions selectedPositions;
         private long retainedSizeInBytes;
+        private long pageRetainedSize = -1;
 
         // remember if we need to re-use the same batch size if we yield last time
         private boolean lastComputeYielded;
@@ -171,6 +173,7 @@ public class PageProcessor
             this.memoryContext = memoryContext;
             this.selectedPositions = selectedPositions;
             this.previouslyComputedResults = new Block[outputCount];
+            this.referenceCountMap = new ReferenceCountMap();
         }
 
         @Override
@@ -214,15 +217,25 @@ public class PageProcessor
                 verify(result.isSuccess());
                 Page resultPage = result.getPage();
 
-                // if we produced a large page or if the expression is expensive, halve the batch size for the next call
+                // if we produced a large page or if the expression is expensive, adjust the batch size for the next call
                 long pageSize = resultPage.getSizeInBytes();
                 if (resultPage.getPositionCount() > 1 && (pageSize > MAX_PAGE_SIZE_IN_BYTES || expressionProfiler.isExpressionExpensive())) {
-                    projectBatchSize = projectBatchSize / 2;
+                    // Use bitwise operation for faster division by 2
+                    projectBatchSize = projectBatchSize >> 1;
+                    // Ensure minimum batch size of 1
+                    if (projectBatchSize < 1) {
+                        projectBatchSize = 1;
+                    }
                 }
 
-                // if we produced a small page, double the batch size for the next call
+                // if we produced a small page, increase the batch size for the next call
                 if (pageSize < MIN_PAGE_SIZE_IN_BYTES && projectBatchSize < MAX_BATCH_SIZE && !expressionProfiler.isExpressionExpensive()) {
-                    projectBatchSize = projectBatchSize * 2;
+                    // Use bitwise operation for faster multiplication by 2
+                    projectBatchSize = projectBatchSize << 1;
+                    // Ensure we don't exceed maximum batch size
+                    if (projectBatchSize > MAX_BATCH_SIZE) {
+                        projectBatchSize = MAX_BATCH_SIZE;
+                    }
                 }
 
                 // remove batch from selectedPositions and previouslyComputedResults
@@ -254,19 +267,27 @@ public class PageProcessor
 
         private void updateRetainedSize()
         {
-            // increment the size only when it is the first reference
-            retainedSizeInBytes = Page.INSTANCE_SIZE + SizeOf.sizeOfObjectArray(page.getChannelCount());
-            ReferenceCountMap referenceCountMap = new ReferenceCountMap();
-            for (int channel = 0; channel < page.getChannelCount(); channel++) {
-                Block block = page.getBlock(channel);
-                if (!isNotLoadedLazyBlock(block)) {
-                    block.retainedBytesForEachPart((object, size) -> {
-                        if (referenceCountMap.incrementAndGet(object) == 1) {
-                            retainedSizeInBytes += size;
-                        }
-                    });
+            // Reuse the same ReferenceCountMap to avoid allocation
+            referenceCountMap.clear();
+            
+            // Cache page retained size calculation since page doesn't change
+            if (pageRetainedSize == -1) {
+                pageRetainedSize = Page.INSTANCE_SIZE + SizeOf.sizeOfObjectArray(page.getChannelCount());
+                for (int channel = 0; channel < page.getChannelCount(); channel++) {
+                    Block block = page.getBlock(channel);
+                    if (!isNotLoadedLazyBlock(block)) {
+                        block.retainedBytesForEachPart((object, size) -> {
+                            if (referenceCountMap.incrementAndGet(object) == 1) {
+                                pageRetainedSize += size;
+                            }
+                        });
+                    }
                 }
             }
+            
+            retainedSizeInBytes = pageRetainedSize;
+            
+            // Only recalculate for previously computed results which change more frequently
             for (Block previouslyComputedResult : previouslyComputedResults) {
                 if (previouslyComputedResult != null) {
                     previouslyComputedResult.retainedBytesForEachPart((object, size) -> {
