diff --git a/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java b/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java
index ce0ca747f2..9b9ab0e3fb 100644
--- a/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java
+++ b/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java
@@ -99,6 +99,7 @@ public class TDigest
     private final Random gen = ThreadLocalRandom.current();
 
     private int mergeCount;
+    private boolean forceCompression = false;
 
     private final double publicCompression;
     private final double compression;
@@ -228,7 +229,10 @@ public class TDigest
 
     private void mergeNewValues()
     {
-        mergeNewValues(false, compression);
+        // Only merge if buffer is full - original condition
+        if (tempUsed >= tempWeight.length - activeCentroids - 1) {
+            mergeNewValues(false, compression);
+        }
     }
 
     private void mergeNewValues(boolean force, double compression)
@@ -238,14 +242,75 @@ public class TDigest
         }
 
         if (force || unmergedWeight > 0) {
-            // note that we run the merge in reverse every other merge to avoid left-to-right bias in merging
-            merge(tempMean, tempWeight, tempUsed, order, unmergedWeight, mergeCount % 2 == 1, compression);
+            // For very small distributions, we can avoid expensive normalizer calculations
+            // by using a simpler merge strategy
+            if (totalWeight + unmergedWeight < 100) {
+                simpleMerge();
+            } else {
+                // note that we run the merge in reverse every other merge to avoid left-to-right bias in merging
+                merge(tempMean, tempWeight, tempUsed, order, unmergedWeight, mergeCount % 2 == 1, compression);
+            }
             mergeCount++;
             tempUsed = 0;
             unmergedWeight = 0;
         }
     }
 
+    private void simpleMerge()
+    {
+        // Simple merge for very small distributions: just append temp values to centroids
+        // This avoids the expensive normalizer calculations for tiny datasets
+        for (int i = 0; i < tempUsed; i++) {
+            if (activeCentroids >= weight.length) {
+                // If we're out of space, compress using the normal algorithm
+                merge(tempMean, tempWeight, tempUsed, order, unmergedWeight, mergeCount % 2 == 1, compression);
+                return;
+            }
+            
+            // Try to merge with existing centroid if close enough
+            boolean merged = false;
+            for (int j = 0; j < activeCentroids; j++) {
+                if (Math.abs(tempMean[i] - mean[j]) < 1e-10) {
+                    double newWeight = weight[j] + tempWeight[i];
+                    mean[j] = mean[j] + (tempMean[i] - mean[j]) * tempWeight[i] / newWeight;
+                    weight[j] = newWeight;
+                    merged = true;
+                    break;
+                }
+            }
+            
+            if (!merged) {
+                // Add as new centroid
+                mean[activeCentroids] = tempMean[i];
+                weight[activeCentroids] = tempWeight[i];
+                activeCentroids++;
+            }
+        }
+        
+        // Update total weight
+        totalWeight += unmergedWeight;
+        
+        // Sort centroids to maintain order
+        sortCentroids();
+    }
+    
+    private void sortCentroids()
+    {
+        // Simple insertion sort for small number of centroids
+        for (int i = 1; i < activeCentroids; i++) {
+            double keyMean = mean[i];
+            double keyWeight = weight[i];
+            int j = i - 1;
+            while (j >= 0 && mean[j] > keyMean) {
+                mean[j + 1] = mean[j];
+                weight[j + 1] = weight[j];
+                j--;
+            }
+            mean[j + 1] = keyMean;
+            weight[j + 1] = keyWeight;
+        }
+    }
+
     private void merge(double[] incomingMean,
             double[] incomingWeight,
             int incomingCount,
@@ -326,7 +391,12 @@ public class TDigest
      */
     public void compress()
     {
-        mergeNewValues(true, publicCompression);
+        // For small distributions, use simple merge
+        if (totalWeight + unmergedWeight < 100) {
+            mergeNewValues(true, compression);
+        } else {
+            mergeNewValues(true, publicCompression);
+        }
     }
 
     public double getSize()
@@ -336,7 +406,8 @@ public class TDigest
 
     public double getCdf(double x)
     {
-        if (unmergedWeight > 0) {
+        // For small distributions, we can skip compression if it hasn't been forced
+        if (unmergedWeight > 0 && (totalWeight + unmergedWeight >= 100 || forceCompression)) {
             compress();
         }
 
@@ -461,7 +532,8 @@ public class TDigest
     public double getQuantile(double q)
     {
         checkArgument(q >= 0 && q <= 1, "q should be in [0,1], got %s", q);
-        if (unmergedWeight > 0) {
+        // For small distributions, we can skip compression if it hasn't been forced
+        if (unmergedWeight > 0 && (totalWeight + unmergedWeight >= 100 || forceCompression)) {
             compress();
         }
 
