diff --git a/presto-geospatial/src/main/java/com/facebook/presto/plugin/geospatial/GeoFunctions.java b/presto-geospatial/src/main/java/com/facebook/presto/plugin/geospatial/GeoFunctions.java
index 73db90dd6d..d288b45134 100644
--- a/presto-geospatial/src/main/java/com/facebook/presto/plugin/geospatial/GeoFunctions.java
+++ b/presto-geospatial/src/main/java/com/facebook/presto/plugin/geospatial/GeoFunctions.java
@@ -41,8 +41,10 @@ import org.locationtech.jts.operation.valid.IsValidOp;
 import org.locationtech.jts.operation.valid.TopologyValidationError;
 
 import java.util.EnumSet;
+import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 
 import static com.esri.core.geometry.ogc.OGCGeometry.createFromEsriGeometry;
 import static com.facebook.presto.geospatial.GeometryUtils.GeometryTypeName.LINE_STRING;
@@ -97,13 +99,15 @@ public final class GeoFunctions
         return serialize(geometry);
     }
 
+    private static final Set<GeometryTypeName> AREA_VALID_TYPES = EnumSet.of(POLYGON, MULTI_POLYGON);
+
     @Description("Returns the area of a polygon using Euclidean measurement on a 2D plane (based on spatial ref) in projected units")
     @ScalarFunction("ST_Area")
     @SqlType(DOUBLE)
     public static double stArea(@SqlType(GEOMETRY_TYPE_NAME) Slice input)
     {
         OGCGeometry geometry = deserialize(input);
-        validateType("ST_Area", geometry, EnumSet.of(POLYGON, MULTI_POLYGON));
+        validateType("ST_Area", geometry, AREA_VALID_TYPES);
         return geometry.getEsriGeometry().calculateArea2D();
     }
 
@@ -268,13 +272,15 @@ public final class GeoFunctions
         return utf8Slice(error.toString());
     }
 
+    private static final Set<GeometryTypeName> LENGTH_VALID_TYPES = EnumSet.of(LINE_STRING, MULTI_LINE_STRING);
+
     @Description("Returns the length of a LineString or Multi-LineString using Euclidean measurement on a 2D plane (based on spatial ref) in projected units")
     @ScalarFunction("ST_Length")
     @SqlType(DOUBLE)
     public static double stLength(@SqlType(GEOMETRY_TYPE_NAME) Slice input)
     {
         OGCGeometry geometry = deserialize(input);
-        validateType("ST_Length", geometry, EnumSet.of(LINE_STRING, MULTI_LINE_STRING));
+        validateType("ST_Length", geometry, LENGTH_VALID_TYPES);
         return geometry.getEsriGeometry().calculateLength2D();
     }
 
@@ -359,6 +365,8 @@ public final class GeoFunctions
         return ((MultiVertexGeometry) geometry.getEsriGeometry()).getPointCount();
     }
 
+    private static final Set<GeometryTypeName> IS_RING_VALID_TYPES = EnumSet.of(LINE_STRING);
+
     @SqlNullable
     @Description("Returns TRUE if and only if the line is closed and simple")
     @ScalarFunction("ST_IsRing")
@@ -366,7 +374,7 @@ public final class GeoFunctions
     public static Boolean stIsRing(@SqlType(GEOMETRY_TYPE_NAME) Slice input)
     {
         OGCGeometry geometry = deserialize(input);
-        validateType("ST_IsRing", geometry, EnumSet.of(LINE_STRING));
+        validateType("ST_IsRing", geometry, IS_RING_VALID_TYPES);
         OGCLineString line = (OGCLineString) geometry;
         return line.isClosed() && line.isSimple();
     }
@@ -637,11 +645,14 @@ public final class GeoFunctions
         return geometry;
     }
 
+    private static final Map<Set<GeometryTypeName>, String> VALID_TYPES_CACHE = new ConcurrentHashMap<>();
+
     private static void validateType(String function, OGCGeometry geometry, Set<GeometryTypeName> validTypes)
     {
         GeometryTypeName type = GeometryUtils.valueOf(geometry.geometryType());
         if (!validTypes.contains(type)) {
-            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, format("%s only applies to %s. Input type is: %s", function, OR_JOINER.join(validTypes), type));
+            String validTypesStr = VALID_TYPES_CACHE.computeIfAbsent(validTypes, OR_JOINER::join);
+            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, format("%s only applies to %s. Input type is: %s", function, validTypesStr, type));
         }
     }
 
@@ -655,12 +666,13 @@ public final class GeoFunctions
     {
         double xSum = 0;
         double ySum = 0;
-        for (int i = 0; i < multiVertex.getPointCount(); i++) {
+        int pointCount = multiVertex.getPointCount();
+        for (int i = 0; i < pointCount; i++) {
             Point point = multiVertex.getPoint(i);
             xSum += point.getX();
             ySum += point.getY();
         }
-        return new Point(xSum / multiVertex.getPointCount(), ySum / multiVertex.getPointCount());
+        return new Point(xSum / pointCount, ySum / pointCount);
     }
 
     // Lines centroid is weighted mean of each line segment, weight in terms of line length
@@ -737,13 +749,15 @@ public final class GeoFunctions
         double signedArea = 0;
         for (int i = 0; i < pointCount; i++) {
             Point current = polygon.getPoint(i);
-            Point next = polygon.getPoint((i + 1) % polygon.getPointCount());
+            Point next = polygon.getPoint((i + 1) % pointCount);
             double ladder = current.getX() * next.getY() - next.getX() * current.getY();
             xSum += (current.getX() + next.getX()) * ladder;
             ySum += (current.getY() + next.getY()) * ladder;
-            signedArea += ladder / 2;
+            signedArea += ladder;
         }
-        return new Point(xSum / (signedArea * 6), ySum / (signedArea * 6));
+        signedArea /= 2.0;
+        double divisor = signedArea * 6.0;
+        return new Point(xSum / divisor, ySum / divisor);
     }
 
     // MultiPolygon centroid is weighted mean of each polygon, weight in terms of polygon area
