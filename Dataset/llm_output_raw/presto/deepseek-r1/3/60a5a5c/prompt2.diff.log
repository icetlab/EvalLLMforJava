Explanation:
The performance issue indicates we should reuse the compression buffer when serializing pages to avoid repeated allocations. Currently, in `PagesSerde.serialize()`, a new `ByteBuffer` is allocated for compression every time a page is serialized. We can reuse a single buffer instance to reduce memory allocation overhead.

We'll modify the `PagesSerde` class to:
1. Add a reusable `ByteBuffer` field for compression
2. Reuse this buffer across serializations, resizing it when needed
3. Ensure thread safety since the class is already annotated `@NotThreadSafe`

Note: We're only modifying the source file (`PagesSerde.java`), not the test files.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/execution/buffer/PagesSerde.java",
    "search": "    private final BlockEncodingSerde blockEncodingSerde;\n    private final Optional<Compressor> compressor;\n    private final Optional<Decompressor> decompressor;\n    private final Optional<SpillCipher> spillCipher;",
    "replace": "    private final BlockEncodingSerde blockEncodingSerde;\n    private final Optional<Compressor> compressor;\n    private final Optional<Decompressor> decompressor;\n    private final Optional<SpillCipher> spillCipher;\n    private ByteBuffer compressionBuffer;"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/execution/buffer/PagesSerde.java",
    "search": "        if (compressor.isPresent()) {\n            ByteBuffer compressionBuffer = ByteBuffer.allocate(compressor.get().maxCompressedLength(uncompressedSize));\n            compressor.get().compress(slice.toByteBuffer(), compressionBuffer);\n            compressionBuffer.flip();\n            if ((((double) compressionBuffer.remaining()) / uncompressedSize) <= MINIMUM_COMPRESSION_RATIO) {\n                slice = Slices.wrappedBuffer(compressionBuffer);\n                markers = COMPRESSED.set(markers);\n            }\n        }",
    "replace": "        if (compressor.isPresent()) {\n            int maxCompressedLength = compressor.get().maxCompressedLength(uncompressedSize);\n            if (compressionBuffer == null || compressionBuffer.capacity() < maxCompressedLength) {\n                compressionBuffer = ByteBuffer.allocate(maxCompressedLength);\n            }\n            compressionBuffer.clear();\n            compressor.get().compress(slice.toByteBuffer(), compressionBuffer);\n            compressionBuffer.flip();\n            if ((((double) compressionBuffer.remaining()) / uncompressedSize) <= MINIMUM_COMPRESSION_RATIO) {\n                slice = Slices.wrappedBuffer(compressionBuffer.slice());\n                markers = COMPRESSED.set(markers);\n            }\n        }"
  }
]
```