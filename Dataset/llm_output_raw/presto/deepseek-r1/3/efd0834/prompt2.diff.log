The performance issue indicates that retained size calculations in `PageProcessor` can be eliminated when pages are not retained for further processing. Specifically, the `updateRetainedSize()` method is called during construction and after each batch, but this calculation is unnecessary if the page is processed immediately and not cached. The optimization removes the initial retained size calculation in the constructor and defers it until the first batch is processed, while maintaining correct memory accounting for the processing lifecycle.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java",
    "search": "        private ProjectSelectedPositions(ConnectorSession session, DriverYieldSignal yieldSignal, LocalMemoryContext memoryContext, Page page, SelectedPositions selectedPositions)\n        {\n            this.session = session;\n            this.yieldSignal = yieldSignal;\n            this.page = page;\n            this.memoryContext = memoryContext;\n            this.selectedPositions = selectedPositions;\n            this.previouslyComputedResults = new Block[projections.size()];\n            updateRetainedSize();\n        }",
    "replace": "        private ProjectSelectedPositions(ConnectorSession session, DriverYieldSignal yieldSignal, LocalMemoryContext memoryContext, Page page, SelectedPositions selectedPositions)\n        {\n            this.session = session;\n            this.yieldSignal = yieldSignal;\n            this.page = page;\n            this.memoryContext = memoryContext;\n            this.selectedPositions = selectedPositions;\n            this.previouslyComputedResults = new Block[projections.size()];\n            memoryContext.setBytes(0);\n        }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java",
    "search": "        @Override\n        public ProcessState<Page> process()\n        {\n            int batchSize;\n            while (true) {\n                if (selectedPositions.isEmpty()) {\n                    memoryContext.setBytes(0);\n                    verify(!lastComputeYielded);\n                    return finished();\n                }\n\n                // we always process one chunk\n                if (lastComputeYielded) {\n                    // re-use the batch size from the last checkpoint\n                    verify(lastComputeBatchSize > 0);\n                    batchSize = lastComputeBatchSize;\n                    lastComputeYielded = false;\n                    lastComputeBatchSize = 0;\n                }\n                else {\n                    batchSize = Math.min(selectedPositions.size(), projectBatchSize);\n                }\n                ProcessBatchResult result = processBatch(batchSize);",
    "replace": "        @Override\n        public ProcessState<Page> process()\n        {\n            int batchSize;\n            while (true) {\n                if (selectedPositions.isEmpty()) {\n                    memoryContext.setBytes(0);\n                    verify(!lastComputeYielded);\n                    return finished();\n                }\n\n                if (retainedSizeInBytes == 0) {\n                    updateRetainedSize();\n                }\n\n                // we always process one chunk\n                if (lastComputeYielded) {\n                    // re-use the batch size from the last checkpoint\n                    verify(lastComputeBatchSize > 0);\n                    batchSize = lastComputeBatchSize;\n                    lastComputeYielded = false;\n                    lastComputeBatchSize = 0;\n                }\n                else {\n                    batchSize = Math.min(selectedPositions.size(), projectBatchSize);\n                }\n                ProcessBatchResult result = processBatch(batchSize);"
  }
]
```