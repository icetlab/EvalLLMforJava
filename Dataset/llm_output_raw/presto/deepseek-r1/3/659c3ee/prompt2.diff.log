Looking at the `ByteSelectiveStreamReader`, I need to optimize the `readNoFilter` method for cases where there's no filter and nulls are present. The current implementation processes positions one by one even when they're contiguous, which can be optimized by bulk reading.

The main optimization opportunity is in the `readNoFilter` method. When there's no filter and positions are contiguous, we can read data in bulk using `dataStream.next(values, positionCount)` instead of calling `dataStream.next()` for each position individually.

Here are the changes:

```json
[
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java",
    "search": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        if (presentStream == null && positions[positionCount - 1] == positionCount - 1) {\n            // contiguous chunk of rows, no nulls\n            dataStream.next(values, positionCount);\n            outputPositionCount = positionCount;\n            return positionCount;\n        }\n\n        int streamPosition = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = dataStream.next();\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }",
    "replace": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        if (presentStream == null && positions[positionCount - 1] == positionCount - 1) {\n            // contiguous chunk of rows, no nulls\n            dataStream.next(values, positionCount);\n            outputPositionCount = positionCount;\n            return positionCount;\n        }\n        \n        // Check if positions are contiguous\n        boolean positionsContiguous = true;\n        for (int i = 0; i < positionCount; i++) {\n            if (positions[i] != positions[0] + i) {\n                positionsContiguous = false;\n                break;\n            }\n        }\n        \n        // Optimized path: contiguous positions with nulls\n        if (positionsContiguous && presentStream != null) {\n            int streamPosition = positions[0];\n            if (streamPosition > 0) {\n                skip(streamPosition);\n            }\n            \n            // Read null bits in bulk\n            for (int i = 0; i < positionCount; i++) {\n                nulls[i] = !presentStream.nextBit();\n            }\n            \n            // Read data values for non-null positions\n            for (int i = 0; i < positionCount; i++) {\n                if (!nulls[i]) {\n                    values[i] = dataStream.next();\n                }\n            }\n            \n            outputPositionCount = positionCount;\n            return streamPosition + positionCount;\n        }\n\n        // Fallback to original implementation for non-contiguous positions\n        int streamPosition = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = dataStream.next();\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }"
  }
]
```