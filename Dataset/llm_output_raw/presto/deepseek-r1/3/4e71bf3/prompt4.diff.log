Looking at the performance issue description ("Optimize boolean reader when reading contiguous rows with no nulls and no filter"), I need to optimize the `ByteSelectiveStreamReader` for the common case of reading contiguous rows without nulls and without filters. The current implementation processes each position individually, which can be optimized by reading data in bulk.

The main optimization opportunity is in the `readNoFilter` method. When there's no filter and no nulls (presentStream == null), we can read values directly in bulk rather than one by one. This is particularly beneficial when reading contiguous rows.

Here are the optimizations:

1. **Add bulk reading capability to ByteInputStream**: Add a method to read multiple bytes at once into an array, which is more efficient than calling `next()` repeatedly.
2. **Optimize readNoFilter for contiguous positions**: When positions are contiguous (which is common), skip the gap checking and read values directly in bulk.
3. **Add a fast path for contiguous positions without nulls**: This avoids per-element checks and branching.

```json
[
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java",
    "search": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        int streamPosition = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = dataStream.next();\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }",
    "replace": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        int streamPosition = 0;\n        \n        // Fast path: contiguous positions with no nulls\n        if (presentStream == null && positionCount > 0 && isContiguous(positions, positionCount)) {\n            if (positions[0] > streamPosition) {\n                skip(positions[0] - streamPosition);\n                streamPosition = positions[0];\n            }\n            // Read all values in bulk\n            for (int i = 0; i < positionCount; i++) {\n                values[i] = dataStream.next();\n            }\n            streamPosition += positionCount;\n            outputPositionCount = positionCount;\n            return streamPosition;\n        }\n        \n        // Original code for non-contiguous positions or with nulls\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = dataStream.next();\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }\n    \n    private boolean isContiguous(int[] positions, int positionCount) {\n        if (positionCount <= 1) {\n            return true;\n        }\n        for (int i = 1; i < positionCount; i++) {\n            if (positions[i] != positions[i - 1] + 1) {\n                return false;\n            }\n        }\n        return true;\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/stream/ByteInputStream.java",
    "search": "    public byte next()\n            throws IOException\n    {\n        if (offset == length) {\n            readNextBlock();\n        }\n        return buffer[offset++];\n    }",
    "replace": "    public byte next()\n            throws IOException\n    {\n        if (offset == length) {\n            readNextBlock();\n        }\n        return buffer[offset++];\n    }\n    \n    public void next(byte[] values, int offset, int length)\n            throws IOException\n    {\n        int remaining = length;\n        int destOffset = offset;\n        \n        while (remaining > 0) {\n            if (this.offset == this.length) {\n                readNextBlock();\n            }\n            int toCopy = Math.min(remaining, this.length - this.offset);\n            System.arraycopy(buffer, this.offset, values, destOffset, toCopy);\n            this.offset += toCopy;\n            destOffset += toCopy;\n            remaining -= toCopy;\n        }\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java",
    "search": "        // Fast path: contiguous positions with no nulls\n        if (presentStream == null && positionCount > 0 && isContiguous(positions, positionCount)) {\n            if (positions[0] > streamPosition) {\n                skip(positions[0] - streamPosition);\n                streamPosition = positions[0];\n            }\n            // Read all values in bulk\n            for (int i = 0; i < positionCount; i++) {\n                values[i] = dataStream.next();\n            }\n            streamPosition += positionCount;\n            outputPositionCount = positionCount;\n            return streamPosition;\n        }",
    "replace": "        // Fast path: contiguous positions with no nulls\n        if (presentStream == null && positionCount > 0 && isContiguous(positions, positionCount)) {\n            if (positions[0] > streamPosition) {\n                skip(positions[0] - streamPosition);\n                streamPosition = positions[0];\n            }\n            // Read all values in bulk using the optimized method\n            dataStream.next(values, 0, positionCount);\n            streamPosition += positionCount;\n            outputPositionCount = positionCount;\n            return streamPosition;\n        }"
  }
]
```