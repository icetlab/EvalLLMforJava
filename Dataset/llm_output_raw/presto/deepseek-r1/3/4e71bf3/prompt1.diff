diff --git a/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java b/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java
index da887a9ba3..a0fae8fe3c 100644
--- a/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java
+++ b/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java
@@ -176,16 +176,24 @@ public class ByteSelectiveStreamReader
     {
         int streamPosition = 0;
         outputPositionCount = 0;
-        for (int i = 0; i < positionCount; i++) {
+        TupleDomainFilter localFilter = filter;
+        boolean localOutputRequired = outputRequired;
+        boolean localNullsAllowed = nullsAllowed;
+        boolean localNonDeterministicFilter = nonDeterministicFilter;
+        BooleanInputStream localPresentStream = presentStream;
+        ByteInputStream localDataStream = dataStream;
+        
+        int i = 0;
+        while (i < positionCount) {
             int position = positions[i];
             if (position > streamPosition) {
                 skip(position - streamPosition);
                 streamPosition = position;
             }
 
-            if (presentStream != null && !presentStream.nextBit()) {
-                if ((nonDeterministicFilter && filter.testNull()) || nullsAllowed) {
-                    if (outputRequired) {
+            if (localPresentStream != null && !localPresentStream.nextBit()) {
+                if ((localNonDeterministicFilter && localFilter.testNull()) || localNullsAllowed) {
+                    if (localOutputRequired) {
                         nulls[outputPositionCount] = true;
                     }
                     outputPositions[outputPositionCount] = position;
@@ -193,11 +201,11 @@ public class ByteSelectiveStreamReader
                 }
             }
             else {
-                byte value = dataStream.next();
-                if (filter.testLong(value)) {
-                    if (outputRequired) {
+                byte value = localDataStream.next();
+                if (localFilter.testLong(value)) {
+                    if (localOutputRequired) {
                         values[outputPositionCount] = value;
-                        if (nullsAllowed && presentStream != null) {
+                        if (localNullsAllowed && localPresentStream != null) {
                             nulls[outputPositionCount] = false;
                         }
                     }
@@ -206,20 +214,28 @@ public class ByteSelectiveStreamReader
                 }
             }
             streamPosition++;
+            i++;
 
-            if (filter != null) {
-                outputPositionCount -= filter.getPrecedingPositionsToFail();
-                int succeedingPositionsToFail = filter.getSucceedingPositionsToFail();
-                if (succeedingPositionsToFail > 0) {
-                    int positionsToSkip = 0;
-                    for (int j = 0; j < succeedingPositionsToFail; j++) {
-                        i++;
-                        int nextPosition = positions[i];
-                        positionsToSkip += 1 + nextPosition - streamPosition;
-                        streamPosition = nextPosition + 1;
-                    }
+            // Handle filter failures
+            int precedingFailures = localFilter.getPrecedingPositionsToFail();
+            if (precedingFailures > 0) {
+                outputPositionCount -= precedingFailures;
+            }
+            
+            int succeedingFailures = localFilter.getSucceedingPositionsToFail();
+            if (succeedingFailures > 0) {
+                int positionsToSkip = 0;
+                for (int j = 0; j < succeedingFailures && i < positionCount; j++) {
+                    int nextPosition = positions[i];
+                    positionsToSkip += 1 + nextPosition - streamPosition;
+                    streamPosition = nextPosition + 1;
+                    i++;
+                }
+                if (positionsToSkip > 0) {
                     skip(positionsToSkip);
                 }
+                // Continue the outer loop from current i
+                continue;
             }
         }
         return streamPosition;
@@ -258,23 +274,40 @@ public class ByteSelectiveStreamReader
     {
         // filter == null implies outputRequired == true
         int streamPosition = 0;
-        for (int i = 0; i < positionCount; i++) {
-            int position = positions[i];
-            if (position > streamPosition) {
-                skip(position - streamPosition);
-                streamPosition = position;
+        BooleanInputStream localPresentStream = presentStream;
+        ByteInputStream localDataStream = dataStream;
+        byte[] localValues = values;
+        boolean[] localNulls = nulls;
+        
+        if (localPresentStream == null) {
+            // No nulls, just read all values
+            for (int i = 0; i < positionCount; i++) {
+                int position = positions[i];
+                if (position > streamPosition) {
+                    skip(position - streamPosition);
+                    streamPosition = position;
+                }
+                localValues[i] = localDataStream.next();
+                streamPosition++;
             }
+        } else {
+            // Handle nulls
+            for (int i = 0; i < positionCount; i++) {
+                int position = positions[i];
+                if (position > streamPosition) {
+                    skip(position - streamPosition);
+                    streamPosition = position;
+                }
 
-            if (presentStream != null && !presentStream.nextBit()) {
-                nulls[i] = true;
-            }
-            else {
-                values[i] = dataStream.next();
-                if (presentStream != null) {
-                    nulls[i] = false;
+                if (!localPresentStream.nextBit()) {
+                    localNulls[i] = true;
                 }
+                else {
+                    localValues[i] = localDataStream.next();
+                    localNulls[i] = false;
+                }
+                streamPosition++;
             }
-            streamPosition++;
         }
         outputPositionCount = positionCount;
         return streamPosition;
@@ -394,28 +427,36 @@ public class ByteSelectiveStreamReader
 
     private void compactValues(int[] positions, int positionCount, boolean compactNulls)
     {
+        if (positionCount == 0) {
+            outputPositionCount = 0;
+            return;
+        }
+        
         int positionIndex = 0;
         int nextPosition = positions[positionIndex];
-        for (int i = 0; i < outputPositionCount; i++) {
-            if (outputPositions[i] < nextPosition) {
-                continue;
-            }
-
-            assert outputPositions[i] == nextPosition;
-
-            values[positionIndex] = values[i];
-            if (compactNulls) {
-                nulls[positionIndex] = nulls[i];
-            }
-            outputPositions[positionIndex] = nextPosition;
-
-            positionIndex++;
-            if (positionIndex >= positionCount) {
-                break;
+        int i = 0;
+        
+        // Find first matching position efficiently
+        while (i < outputPositionCount && outputPositions[i] < nextPosition) {
+            i++;
+        }
+        
+        for (; i < outputPositionCount && positionIndex < positionCount; i++) {
+            if (outputPositions[i] == nextPosition) {
+                values[positionIndex] = values[i];
+                if (compactNulls) {
+                    nulls[positionIndex] = nulls[i];
+                }
+                outputPositions[positionIndex] = nextPosition;
+                
+                positionIndex++;
+                if (positionIndex >= positionCount) {
+                    break;
+                }
+                nextPosition = positions[positionIndex];
             }
-            nextPosition = positions[positionIndex];
         }
-
+        
         outputPositionCount = positionCount;
     }
 
diff --git a/presto-orc/src/main/java/com/facebook/presto/orc/stream/ByteInputStream.java b/presto-orc/src/main/java/com/facebook/presto/orc/stream/ByteInputStream.java
index 21edc123eb..3ac52ebff3 100644
--- a/presto-orc/src/main/java/com/facebook/presto/orc/stream/ByteInputStream.java
+++ b/presto-orc/src/main/java/com/facebook/presto/orc/stream/ByteInputStream.java
@@ -100,20 +100,25 @@ public class ByteInputStream
     public void skip(long items)
             throws IOException
     {
-        while (items > 0) {
-            if (offset == length) {
+        long remaining = items;
+        while (remaining > 0) {
+            if (offset >= length) {
                 readNextBlock();
             }
-            long consume = Math.min(items, length - offset);
-            offset += consume;
-            items -= consume;
+            long available = length - offset;
+            if (remaining <= available) {
+                offset += remaining;
+                break;
+            }
+            offset = length;
+            remaining -= available;
         }
     }
 
     public byte next()
             throws IOException
     {
-        if (offset == length) {
+        if (offset >= length) {
             readNextBlock();
         }
         return buffer[offset++];
