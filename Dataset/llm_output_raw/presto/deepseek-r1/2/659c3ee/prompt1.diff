diff --git a/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java b/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java
index 93aeb97e76..586aabcc69 100644
--- a/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java
+++ b/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java
@@ -145,6 +145,10 @@ public class ByteSelectiveStreamReader
 
         if (outputRequired) {
             ensureValuesCapacity(positionCount, nullsAllowed && presentStream != null);
+            // Initialize outputPositions array once
+            if (outputPositions == null || outputPositions.length < positionCount) {
+                outputPositions = new int[positionCount];
+            }
         }
 
         outputPositions = initializeOutputPositions(outputPositions, positions, positionCount);
@@ -176,6 +180,16 @@ public class ByteSelectiveStreamReader
     {
         int streamPosition = 0;
         outputPositionCount = 0;
+        boolean localOutputRequired = outputRequired;
+        boolean localNullsAllowed = nullsAllowed;
+        boolean localNonDeterministicFilter = nonDeterministicFilter;
+        BooleanInputStream localPresentStream = presentStream;
+        ByteInputStream localDataStream = dataStream;
+        byte[] localValues = values;
+        boolean[] localNulls = nulls;
+        int[] localOutputPositions = outputPositions;
+        TupleDomainFilter localFilter = filter;
+        
         for (int i = 0; i < positionCount; i++) {
             int position = positions[i];
             if (position > streamPosition) {
@@ -183,45 +197,46 @@ public class ByteSelectiveStreamReader
                 streamPosition = position;
             }
 
-            if (presentStream != null && !presentStream.nextBit()) {
-                if ((nonDeterministicFilter && filter.testNull()) || nullsAllowed) {
-                    if (outputRequired) {
-                        nulls[outputPositionCount] = true;
+            if (localPresentStream != null && !localPresentStream.nextBit()) {
+                if ((localNonDeterministicFilter && localFilter.testNull()) || localNullsAllowed) {
+                    if (localOutputRequired) {
+                        localNulls[outputPositionCount] = true;
                     }
-                    outputPositions[outputPositionCount] = position;
+                    localOutputPositions[outputPositionCount] = position;
                     outputPositionCount++;
                 }
             }
             else {
-                byte value = dataStream.next();
-                if (filter.testLong(value)) {
-                    if (outputRequired) {
-                        values[outputPositionCount] = value;
-                        if (nullsAllowed && presentStream != null) {
-                            nulls[outputPositionCount] = false;
+                byte value = localDataStream.next();
+                if (localFilter.testLong(value)) {
+                    if (localOutputRequired) {
+                        localValues[outputPositionCount] = value;
+                        if (localNullsAllowed && localPresentStream != null) {
+                            localNulls[outputPositionCount] = false;
                         }
                     }
-                    outputPositions[outputPositionCount] = position;
+                    localOutputPositions[outputPositionCount] = position;
                     outputPositionCount++;
                 }
             }
             streamPosition++;
 
-            if (filter != null) {
-                outputPositionCount -= filter.getPrecedingPositionsToFail();
-                int succeedingPositionsToFail = filter.getSucceedingPositionsToFail();
-                if (succeedingPositionsToFail > 0) {
-                    int positionsToSkip = 0;
-                    for (int j = 0; j < succeedingPositionsToFail; j++) {
-                        i++;
-                        int nextPosition = positions[i];
-                        positionsToSkip += 1 + nextPosition - streamPosition;
-                        streamPosition = nextPosition + 1;
-                    }
-                    skip(positionsToSkip);
+            outputPositionCount -= localFilter.getPrecedingPositionsToFail();
+            int succeedingPositionsToFail = localFilter.getSucceedingPositionsToFail();
+            if (succeedingPositionsToFail > 0) {
+                int positionsToSkip = 0;
+                for (int j = 0; j < succeedingPositionsToFail; j++) {
+                    i++;
+                    int nextPosition = positions[i];
+                    positionsToSkip += 1 + nextPosition - streamPosition;
+                    streamPosition = nextPosition + 1;
                 }
+                skip(positionsToSkip);
             }
         }
+        values = localValues;
+        nulls = localNulls;
+        outputPositions = localOutputPositions;
         return streamPosition;
     }
 
@@ -265,6 +280,11 @@ public class ByteSelectiveStreamReader
         }
 
         int streamPosition = 0;
+        BooleanInputStream localPresentStream = presentStream;
+        ByteInputStream localDataStream = dataStream;
+        byte[] localValues = values;
+        boolean[] localNulls = nulls;
+        
         for (int i = 0; i < positionCount; i++) {
             int position = positions[i];
             if (position > streamPosition) {
@@ -272,18 +292,20 @@ public class ByteSelectiveStreamReader
                 streamPosition = position;
             }
 
-            if (presentStream != null && !presentStream.nextBit()) {
-                nulls[i] = true;
+            if (localPresentStream != null && !localPresentStream.nextBit()) {
+                localNulls[i] = true;
             }
             else {
-                values[i] = dataStream.next();
-                if (presentStream != null) {
-                    nulls[i] = false;
+                localValues[i] = localDataStream.next();
+                if (localPresentStream != null) {
+                    localNulls[i] = false;
                 }
             }
             streamPosition++;
         }
         outputPositionCount = positionCount;
+        values = localValues;
+        nulls = localNulls;
         return streamPosition;
     }
 
@@ -294,8 +316,17 @@ public class ByteSelectiveStreamReader
             presentStream.skip(items);
         }
         else if (presentStream != null) {
-            int dataToSkip = presentStream.countBitsSet(items);
-            dataStream.skip(dataToSkip);
+            // Optimize for dense non-null sequences
+            if (items > 64) {
+                int dataToSkip = presentStream.countBitsSet(items);
+                dataStream.skip(dataToSkip);
+            } else {
+                for (int i = 0; i < items; i++) {
+                    if (presentStream.nextBit()) {
+                        dataStream.next();
+                    }
+                }
+            }
         }
         else {
             dataStream.skip(items);
@@ -304,10 +335,11 @@ public class ByteSelectiveStreamReader
 
     private void ensureValuesCapacity(int capacity, boolean recordNulls)
     {
-        values = ensureCapacity(values, capacity);
-
-        if (recordNulls) {
-            nulls = ensureCapacity(nulls, capacity);
+        if (values == null || values.length < capacity) {
+            values = new byte[capacity];
+        }
+        if (recordNulls && (nulls == null || nulls.length < capacity)) {
+            nulls = new boolean[capacity];
         }
     }
 
@@ -403,18 +435,22 @@ public class ByteSelectiveStreamReader
     {
         int positionIndex = 0;
         int nextPosition = positions[positionIndex];
+        byte[] localValues = values;
+        boolean[] localNulls = nulls;
+        int[] localOutputPositions = outputPositions;
+        
         for (int i = 0; i < outputPositionCount; i++) {
-            if (outputPositions[i] < nextPosition) {
+            if (localOutputPositions[i] < nextPosition) {
                 continue;
             }
 
-            assert outputPositions[i] == nextPosition;
+            assert localOutputPositions[i] == nextPosition;
 
-            values[positionIndex] = values[i];
+            localValues[positionIndex] = localValues[i];
             if (compactNulls) {
-                nulls[positionIndex] = nulls[i];
+                localNulls[positionIndex] = localNulls[i];
             }
-            outputPositions[positionIndex] = nextPosition;
+            localOutputPositions[positionIndex] = nextPosition;
 
             positionIndex++;
             if (positionIndex >= positionCount) {
@@ -424,6 +460,9 @@ public class ByteSelectiveStreamReader
         }
 
         outputPositionCount = positionCount;
+        values = localValues;
+        nulls = localNulls;
+        outputPositions = localOutputPositions;
     }
 
     @Override
