diff --git a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java
index 79b56c6971..a2d8586272 100644
--- a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java
+++ b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java
@@ -176,8 +176,12 @@ public class SliceDirectSelectiveStreamReader
                 if (totalPositionCount > positionCount) {
                     packByteArrayOffsetsAndNulls(data, offsets, isNullVector, positions, positionCount);
                 }
+                else if (nullsAllowed) {
+                    // If we're processing all positions, we can use the isNullVector directly
+                    nulls = isNullVector;
+                }
 
-                if (nullsAllowed) {
+                if (nullsAllowed && totalPositionCount > positionCount) {
                     System.arraycopy(isNullVector, 0, nulls, 0, positionCount);
                 }
             }
@@ -239,15 +243,13 @@ public class SliceDirectSelectiveStreamReader
             else {
                 filteredPositionCount = evaluateFilterWithNull(positions, positionCount);
 
-                if (outputRequired) {
-                    if (filteredPositionCount > 0) {
-                        if (outputRequired && totalPositionCount > filteredPositionCount) {
-                            packByteArrayOffsetsAndNulls(data, offsets, isNullVector, outputPositions, filteredPositionCount);
-                        }
+                if (outputRequired && filteredPositionCount > 0) {
+                    if (totalPositionCount > filteredPositionCount) {
+                        packByteArrayOffsetsAndNulls(data, offsets, isNullVector, outputPositions, filteredPositionCount);
+                    }
 
-                        if (nullsAllowed) {
-                            System.arraycopy(isNullVector, 0, nulls, 0, filteredPositionCount);
-                        }
+                    if (nullsAllowed) {
+                        System.arraycopy(isNullVector, 0, nulls, 0, filteredPositionCount);
                     }
                 }
             }
@@ -267,7 +269,8 @@ public class SliceDirectSelectiveStreamReader
             }
 
             int offset = outputRequired ? offsets[outputPositionCount] : 0;
-            if (presentStream != null && isNullVector[position]) {
+            boolean isNull = presentStream != null && isNullVector[position];
+            if (isNull) {
                 if ((nonDeterministicFilter && filter.testNull()) || nullsAllowed) {
                     if (outputRequired) {
                         offsets[outputPositionCount + 1] = offset;
@@ -279,11 +282,11 @@ public class SliceDirectSelectiveStreamReader
             }
             else {
                 int length = lengthVector[lengthIndex];
-                int dataOffset = outputRequired ? offset : 0;
                 if (filter.testLength(length)) {
                     if (dataStream != null) {
                         dataStream.skip(dataToSkip);
                         dataToSkip = 0;
+                        int dataOffset = outputRequired ? offset : 0;
                         dataStream.next(data, dataOffset, dataOffset + length);
                         if (filter.testBytes(data, dataOffset, length)) {
                             if (outputRequired) {
@@ -648,10 +651,14 @@ public class SliceDirectSelectiveStreamReader
             lengthVector = ensureCapacity(lengthVector, nonNullCount);
             lengthStream.nextIntVector(nonNullCount, lengthVector, 0);
 
-            if (useBatchMode(positionCount, totalPositions)) {
+            boolean useBatch = useBatchMode(positionCount, totalPositions);
+            if (useBatch) {
                 for (int i = 0; i < nonNullCount; i++) {
-                    totalLength += lengthVector[i];
-                    maxLength = Math.max(maxLength, lengthVector[i]);
+                    int length = lengthVector[i];
+                    totalLength += length;
+                    if (length > maxLength) {
+                        maxLength = length;
+                    }
                 }
             }
             else {
@@ -661,8 +668,11 @@ public class SliceDirectSelectiveStreamReader
                     boolean isNotNull = nullCount == 0 || !isNullVector[i];
                     if (i == positions[positionIndex]) {
                         if (isNotNull) {
-                            totalLength += lengthVector[lengthIndex];
-                            maxLength = Math.max(maxLength, lengthVector[lengthIndex]);
+                            int length = lengthVector[lengthIndex];
+                            totalLength += length;
+                            if (length > maxLength) {
+                                maxLength = length;
+                            }
                             lengthIndex++;
                         }
                         positionIndex++;
@@ -710,31 +720,30 @@ public class SliceDirectSelectiveStreamReader
 
     private boolean useBatchMode(int positionCount, int totalPositionCount)
     {
-        return true;
         // maxCodePointCount < 0 means it's unbounded varchar VARCHAR.
         // If the types are VARCHAR(N) or CHAR(N), the length of the string need to be calculated and truncated.
-//        if (lengthStream == null || maxCodePointCount >= 0) {
-//            return false;
-//        }
-//
-//        double inputFilterRate = (double) (totalPositionCount - positionCount) / totalPositionCount;
-//        if (filter == null) {  // readNoFilter
-//            // When there is no filter, batch mode performs better for almost all inputFilterRate.
-//            // But to limit data buffer size, we enable it for the range of [0.0f, 0.5f]
-//            if (inputFilterRate >= 0.0f && inputFilterRate <= 0.5f) {
-//                return true;
-//            }
-//
-//            return false;
-//        }
-//        else { // readWithFilter
-//            // When there is filter, batch mode performs better for almost all inputFilterRate except when inputFilterRate is around 0.1f.
-//            // To limit data buffer size, we enable it for the range of [0.0f, 0.05f] and [0.15f, 0.5f]
-//            if (inputFilterRate >= 0.0f && inputFilterRate <= 0.05f || inputFilterRate >= 0.15f && inputFilterRate <= 0.5f) {
-//                return true;
-//            }
-//
-//            return false;
-//        }
+        if (lengthStream == null || maxCodePointCount >= 0) {
+            return false;
+        }
+
+        double inputFilterRate = (double) (totalPositionCount - positionCount) / totalPositionCount;
+        if (filter == null) {  // readNoFilter
+            // When there is no filter, batch mode performs better for almost all inputFilterRate.
+            // But to limit data buffer size, we enable it for the range of [0.0f, 0.5f]
+            if (inputFilterRate >= 0.0f && inputFilterRate <= 0.5f) {
+                return true;
+            }
+
+            return false;
+        }
+        else { // readWithFilter
+            // When there is filter, batch mode performs better for almost all inputFilterRate except when inputFilterRate is around 0.1f.
+            // To limit data buffer size, we enable it for the range of [0.0f, 0.05f] and [0.15f, 0.5f]
+            if (inputFilterRate >= 0.0f && inputFilterRate <= 0.05f || inputFilterRate >= 0.15f && inputFilterRate <= 0.5f) {
+                return true;
+            }
+
+            return false;
+        }
     }
 }
