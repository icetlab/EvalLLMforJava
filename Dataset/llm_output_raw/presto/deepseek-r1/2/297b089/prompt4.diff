diff --git a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java
index 79b56c6971..5a94dcbe13 100644
--- a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java
+++ b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java
@@ -186,6 +186,13 @@ public class SliceDirectSelectiveStreamReader
         }
 
         int streamPosition = 0;
+        // Pre-calculate local variables for faster access
+        boolean hasPresentStream = presentStream != null;
+        byte[] localData = data;
+        Slice localDataAsSlice = dataAsSlice;
+        int localMaxCodePointCount = maxCodePointCount;
+        boolean localIsCharType = isCharType;
+        
         for (int i = 0; i < positionCount; i++) {
             int position = positions[i];
             if (position > streamPosition) {
@@ -194,22 +201,25 @@ public class SliceDirectSelectiveStreamReader
             }
 
             int offset = offsets[i];
-            if (presentStream != null && isNullVector[position]) {
-                if (offsets != null) {
-                    offsets[i + 1] = offset;
-                }
+            if (hasPresentStream && isNullVector[position]) {
+                offsets[i + 1] = offset;
                 nulls[i] = true;
             }
             else {
                 int length = lengthVector[lengthIndex];
                 int truncatedLength = 0;
                 if (length > 0) {
-                    dataStream.next(data, offset, offset + length);
-                    truncatedLength = computeTruncatedLength(dataAsSlice, offset, length, maxCodePointCount, isCharType);
+                    dataStream.next(localData, offset, offset + length);
+                    if (localMaxCodePointCount >= 0) {
+                        truncatedLength = computeTruncatedLength(localDataAsSlice, offset, length, localMaxCodePointCount, localIsCharType);
+                    }
+                    else {
+                        truncatedLength = length;
+                    }
                 }
                 offsets[i + 1] = offset + truncatedLength;
                 lengthIndex++;
-                if (presentStream != null) {
+                if (hasPresentStream) {
                     nulls[i] = false;
                 }
             }
@@ -404,10 +414,13 @@ public class SliceDirectSelectiveStreamReader
     private int evaluateFilter(int[] positions, int positionCount)
     {
         int positionsIndex = 0;
+        int[] localOutputPositions = outputPositions;
+        int[] localLengthVector = lengthVector;
+        
         for (int i = 0; i < positionCount; i++) {
             int position = positions[i];
-            if (filter.testLength(lengthVector[position])) {
-                outputPositions[positionsIndex++] = position;  // compact positions on the fly
+            if (filter.testLength(localLengthVector[position])) {
+                localOutputPositions[positionsIndex++] = position;  // compact positions on the fly
             }
         }
 
@@ -418,9 +431,9 @@ public class SliceDirectSelectiveStreamReader
                 filteredPositionCount = positionsIndex;
             }
             else {
-                int totalPositionCount = outputPositions[positionsIndex - 1] + 1;
-                convertLengthVectorToOffsetVector(lengthVector, totalPositionCount, offsets);
-                filteredPositionCount = testBytes(outputPositions, positionsIndex);
+                int totalPositionCount = localOutputPositions[positionsIndex - 1] + 1;
+                convertLengthVectorToOffsetVector(localLengthVector, totalPositionCount, offsets);
+                filteredPositionCount = testBytes(localOutputPositions, positionsIndex);
             }
         }
 
@@ -650,25 +663,38 @@ public class SliceDirectSelectiveStreamReader
 
             if (useBatchMode(positionCount, totalPositions)) {
                 for (int i = 0; i < nonNullCount; i++) {
-                    totalLength += lengthVector[i];
-                    maxLength = Math.max(maxLength, lengthVector[i]);
+                    int length = lengthVector[i];
+                    totalLength += length;
+                    if (length > maxLength) {
+                        maxLength = length;
+                    }
                 }
             }
             else {
-                int positionIndex = 0;
-                int lengthIndex = 0;
-                for (int i = 0; i < totalPositions; i++) {
+                // Optimized: Process only requested positions
+                int positionIdx = 0;
+                int lengthIdx = 0;
+                int nextPosition = positions[0];
+                
+                for (int i = 0; i < totalPositions && positionIdx < positionCount; i++) {
                     boolean isNotNull = nullCount == 0 || !isNullVector[i];
-                    if (i == positions[positionIndex]) {
+                    
+                    if (i == nextPosition) {
                         if (isNotNull) {
-                            totalLength += lengthVector[lengthIndex];
-                            maxLength = Math.max(maxLength, lengthVector[lengthIndex]);
-                            lengthIndex++;
+                            int length = lengthVector[lengthIdx];
+                            totalLength += length;
+                            if (length > maxLength) {
+                                maxLength = length;
+                            }
+                            lengthIdx++;
+                        }
+                        positionIdx++;
+                        if (positionIdx < positionCount) {
+                            nextPosition = positions[positionIdx];
                         }
-                        positionIndex++;
                     }
                     else if (isNotNull) {
-                        lengthIndex++;
+                        lengthIdx++;
                     }
                 }
             }
