diff --git a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java
index 79b56c6971..b2b1a5224a 100644
--- a/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java
+++ b/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java
@@ -194,10 +194,9 @@ public class SliceDirectSelectiveStreamReader
             }
 
             int offset = offsets[i];
-            if (presentStream != null && isNullVector[position]) {
-                if (offsets != null) {
-                    offsets[i + 1] = offset;
-                }
+            boolean isNull = presentStream != null && isNullVector[position];
+            if (isNull) {
+                offsets[i + 1] = offset;
                 nulls[i] = true;
             }
             else {
@@ -267,7 +266,8 @@ public class SliceDirectSelectiveStreamReader
             }
 
             int offset = outputRequired ? offsets[outputPositionCount] : 0;
-            if (presentStream != null && isNullVector[position]) {
+            boolean isNull = presentStream != null && isNullVector[position];
+            if (isNull) {
                 if ((nonDeterministicFilter && filter.testNull()) || nullsAllowed) {
                     if (outputRequired) {
                         offsets[outputPositionCount + 1] = offset;
@@ -404,27 +404,30 @@ public class SliceDirectSelectiveStreamReader
     private int evaluateFilter(int[] positions, int positionCount)
     {
         int positionsIndex = 0;
+        // Pre-calculate offsets if we have dataStream
+        boolean hasDataStream = dataStream != null;
+        int totalPositionCount = hasDataStream ? positions[positionCount - 1] + 1 : 0;
+        
+        if (hasDataStream) {
+            convertLengthVectorToOffsetVector(lengthVector, totalPositionCount, offsets);
+        }
+        
         for (int i = 0; i < positionCount; i++) {
             int position = positions[i];
             if (filter.testLength(lengthVector[position])) {
-                outputPositions[positionsIndex++] = position;  // compact positions on the fly
-            }
-        }
-
-        int filteredPositionCount = 0;
-        if (positionsIndex > 0) {
-            if (dataStream == null) {
-                // The length check has passed and there is no need to run testBytes because there is no data
-                filteredPositionCount = positionsIndex;
-            }
-            else {
-                int totalPositionCount = outputPositions[positionsIndex - 1] + 1;
-                convertLengthVectorToOffsetVector(lengthVector, totalPositionCount, offsets);
-                filteredPositionCount = testBytes(outputPositions, positionsIndex);
+                if (hasDataStream) {
+                    int dataOffset = offsets[position];
+                    int length = offsets[position + 1] - dataOffset;
+                    if (filter.testBytes(data, dataOffset, length)) {
+                        outputPositions[positionsIndex++] = position;
+                    }
+                } else {
+                    outputPositions[positionsIndex++] = position;
+                }
             }
         }
 
-        return filteredPositionCount;
+        return positionsIndex;
     }
 
     private int evaluateFilterWithNull(int[] positions, int positionCount)
@@ -458,6 +461,7 @@ public class SliceDirectSelectiveStreamReader
         return positionsIndex;
     }
 
+    // This method is no longer used after optimizing evaluateFilter
     private int testBytes(int[] positions, int positionCount)
     {
         int positionsIndex = 0;
@@ -633,7 +637,6 @@ public class SliceDirectSelectiveStreamReader
         outputPositionCount = 0;
 
         int totalLength = 0;
-        int maxLength = 0;
         int dataLength = 0;
 
         int totalPositions = positions[positionCount - 1] + 1;
@@ -648,29 +651,9 @@ public class SliceDirectSelectiveStreamReader
             lengthVector = ensureCapacity(lengthVector, nonNullCount);
             lengthStream.nextIntVector(nonNullCount, lengthVector, 0);
 
-            if (useBatchMode(positionCount, totalPositions)) {
-                for (int i = 0; i < nonNullCount; i++) {
-                    totalLength += lengthVector[i];
-                    maxLength = Math.max(maxLength, lengthVector[i]);
-                }
-            }
-            else {
-                int positionIndex = 0;
-                int lengthIndex = 0;
-                for (int i = 0; i < totalPositions; i++) {
-                    boolean isNotNull = nullCount == 0 || !isNullVector[i];
-                    if (i == positions[positionIndex]) {
-                        if (isNotNull) {
-                            totalLength += lengthVector[lengthIndex];
-                            maxLength = Math.max(maxLength, lengthVector[lengthIndex]);
-                            lengthIndex++;
-                        }
-                        positionIndex++;
-                    }
-                    else if (isNotNull) {
-                        lengthIndex++;
-                    }
-                }
+            // Since useBatchMode always returns true, we only need the batch mode logic
+            for (int i = 0; i < nonNullCount; i++) {
+                totalLength += lengthVector[i];
             }
 
             // TODO Do not throw if outputRequired == false
@@ -691,16 +674,10 @@ public class SliceDirectSelectiveStreamReader
             offsets = ensureCapacity(offsets, totalPositions + 1);
         }
         else {
-            if (useBatchMode(positionCount, totalPositions)) {
-                dataLength = totalLength;
-                if (filter != null) {
-                    offsets = ensureCapacity(offsets, totalPositions + 1);
-                }
-            }
-            else {
-                dataLength = maxLength;
+            dataLength = totalLength;
+            if (filter != null) {
+                offsets = ensureCapacity(offsets, totalPositions + 1);
             }
-
             data = ensureCapacity(data, dataLength);
         }
 
@@ -710,31 +687,7 @@ public class SliceDirectSelectiveStreamReader
 
     private boolean useBatchMode(int positionCount, int totalPositionCount)
     {
+        // Always use batch mode for optimal performance
         return true;
-        // maxCodePointCount < 0 means it's unbounded varchar VARCHAR.
-        // If the types are VARCHAR(N) or CHAR(N), the length of the string need to be calculated and truncated.
-//        if (lengthStream == null || maxCodePointCount >= 0) {
-//            return false;
-//        }
-//
-//        double inputFilterRate = (double) (totalPositionCount - positionCount) / totalPositionCount;
-//        if (filter == null) {  // readNoFilter
-//            // When there is no filter, batch mode performs better for almost all inputFilterRate.
-//            // But to limit data buffer size, we enable it for the range of [0.0f, 0.5f]
-//            if (inputFilterRate >= 0.0f && inputFilterRate <= 0.5f) {
-//                return true;
-//            }
-//
-//            return false;
-//        }
-//        else { // readWithFilter
-//            // When there is filter, batch mode performs better for almost all inputFilterRate except when inputFilterRate is around 0.1f.
-//            // To limit data buffer size, we enable it for the range of [0.0f, 0.05f] and [0.15f, 0.5f]
-//            if (inputFilterRate >= 0.0f && inputFilterRate <= 0.05f || inputFilterRate >= 0.15f && inputFilterRate <= 0.5f) {
-//                return true;
-//            }
-//
-//            return false;
-//        }
     }
 }
