diff --git a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java
index 30e0088e35..609fee7913 100644
--- a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java
+++ b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java
@@ -433,25 +433,43 @@ public class OptimizedPartitionedOutputOperator
         {
             // Populate positions to copy for each destination partition.
             int positionCount = page.getPositionCount();
+            int partitionCount = partitionBuffers.length;
 
-            for (int i = 0; i < partitionBuffers.length; i++) {
+            for (int i = 0; i < partitionCount; i++) {
                 partitionBuffers[i].resetPositions(positionCount);
             }
 
             Block nullBlock = nullChannel.isPresent() ? page.getBlock(nullChannel.getAsInt()) : null;
             Page partitionFunctionArgs = getPartitionFunctionArguments(page);
 
-            for (int position = 0; position < positionCount; position++) {
-                boolean shouldReplicate = (replicatesAnyRow && !hasAnyRowBeenReplicated) ||
-                        nullBlock != null && nullBlock.isNull(position);
-
-                if (shouldReplicate) {
-                    for (int i = 0; i < partitionBuffers.length; i++) {
+            // Optimize: Pre-check if we need to replicate any row at all
+            boolean needToReplicateAnyRow = replicatesAnyRow && !hasAnyRowBeenReplicated;
+            boolean hasNullBlock = nullBlock != null;
+            
+            if (needToReplicateAnyRow) {
+                // Replicate all positions to all partitions
+                for (int position = 0; position < positionCount; position++) {
+                    for (int i = 0; i < partitionCount; i++) {
                         partitionBuffers[i].addPosition(position);
                     }
-                    hasAnyRowBeenReplicated = true;
                 }
-                else {
+                hasAnyRowBeenReplicated = true;
+            } else if (hasNullBlock) {
+                // Check each position for null and partition accordingly
+                for (int position = 0; position < positionCount; position++) {
+                    if (nullBlock.isNull(position)) {
+                        // Replicate to all partitions
+                        for (int i = 0; i < partitionCount; i++) {
+                            partitionBuffers[i].addPosition(position);
+                        }
+                    } else {
+                        int partition = partitionFunction.getPartition(partitionFunctionArgs, position);
+                        partitionBuffers[partition].addPosition(position);
+                    }
+                }
+            } else {
+                // Normal partitioning without replication
+                for (int position = 0; position < positionCount; position++) {
                     int partition = partitionFunction.getPartition(partitionFunctionArgs, position);
                     partitionBuffers[partition].addPosition(position);
                 }
@@ -504,17 +522,20 @@ public class OptimizedPartitionedOutputOperator
 
         private Page getPartitionFunctionArguments(Page page)
         {
-            Block[] blocks = new Block[partitionChannels.size()];
-            for (int i = 0; i < blocks.length; i++) {
+            int argCount = partitionChannels.size();
+            Block[] blocks = new Block[argCount];
+            int positionCount = page.getPositionCount();
+            
+            for (int i = 0; i < argCount; i++) {
                 Optional<Block> partitionConstant = partitionConstants.get(i);
                 if (partitionConstant.isPresent()) {
-                    blocks[i] = new RunLengthEncodedBlock(partitionConstant.get(), page.getPositionCount());
+                    blocks[i] = new RunLengthEncodedBlock(partitionConstant.get(), positionCount);
                 }
                 else {
                     blocks[i] = page.getBlock(partitionChannels.get(i));
                 }
             }
-            return new Page(page.getPositionCount(), blocks);
+            return new Page(positionCount, blocks);
         }
 
         private static int getFixedWidthTypeSize(Type type)
@@ -595,23 +616,29 @@ public class OptimizedPartitionedOutputOperator
 
             // Due to the limitation of buffer size, we append the data batch by batch
             int offset = 0;
-            do {
+            int remaining = positionCount;
+            while (remaining > 0) {
                 int batchSize = calculateNextBatchSize(fixedWidthRowSize, variableWidthChannels, offset);
-
+                
+                // Set up all buffers for this batch
                 for (int i = 0; i < channelCount; i++) {
                     blockEncodingBuffers[i].setNextBatch(offset, batchSize);
+                }
+                
+                // Append data for all buffers
+                for (int i = 0; i < channelCount; i++) {
                     blockEncodingBuffers[i].appendDataInBatch();
                 }
 
                 bufferedRowCount += batchSize;
                 offset += batchSize;
+                remaining -= batchSize;
 
                 if (bufferFull) {
                     flush(outputBuffer);
                     bufferFull = false;
                 }
             }
-            while (offset < positionCount);
         }
 
         private void initializeBlockEncodingBuffers(DecodedBlockNode[] decodedBlocks)
@@ -636,40 +663,49 @@ public class OptimizedPartitionedOutputOperator
             }
 
             serializedRowSizes = ensureCapacity(serializedRowSizes, positionCount, SMALL, INITIALIZE);
+            
+            // Initialize with fixed width size first
+            for (int i = 0; i < positionCount; i++) {
+                serializedRowSizes[i] = fixedWidthRowSize;
+            }
 
+            // Accumulate variable width sizes
             for (int i : variableWidthChannels) {
                 blockEncodingBuffers[i].accumulateSerializedRowSizes(serializedRowSizes);
             }
-
-            for (int i = 0; i < positionCount; i++) {
-                serializedRowSizes[i] += fixedWidthRowSize;
-            }
         }
 
         private int calculateNextBatchSize(int fixedWidthRowSize, List<Integer> variableWidthChannels, int startPosition)
         {
             int bytesRemaining = capacity - getSerializedBuffersSizeInBytes();
+            int remainingPositions = positionCount - startPosition;
 
             if (variableWidthChannels.isEmpty()) {
+                if (fixedWidthRowSize == 0) {
+                    // All rows have zero size
+                    return remainingPositions;
+                }
                 int maxPositionsFit = max(bytesRemaining / fixedWidthRowSize, 1);
-                if (maxPositionsFit <= positionCount - startPosition) {
+                if (maxPositionsFit < remainingPositions) {
                     bufferFull = true;
                     return maxPositionsFit;
                 }
-                return positionCount - startPosition;
+                return remainingPositions;
             }
 
             verify(serializedRowSizes != null);
+            int batchSize = 0;
             for (int i = startPosition; i < positionCount; i++) {
                 bytesRemaining -= serializedRowSizes[i];
-
+                batchSize++;
+                
                 if (bytesRemaining <= 0) {
                     bufferFull = true;
-                    return max(i - startPosition, 1);
+                    return max(batchSize, 1);
                 }
             }
 
-            return positionCount - startPosition;
+            return batchSize;
         }
 
         private void flush(OutputBuffer outputBuffer)
