Looking at the `BooleanSelectiveStreamReader.readNoFilter()` method, I can see the performance issue. When reading contiguous rows with no nulls and no filter, the method processes positions one by one, calling `skip()` for each gap and reading individual bits. This can be optimized by bulk reading when positions are contiguous.

**Improvement Intent**: Optimize `readNoFilter()` for contiguous positions by reading bits in bulk instead of one by one, reducing method call overhead and improving throughput for common cases.

```json
[
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/BooleanSelectiveStreamReader.java",
    "search": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        int streamPosition = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = (byte) (dataStream.nextBit() ? 1 : 0);\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }",
    "replace": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        int streamPosition = 0;\n        \n        // Check if positions are contiguous to enable bulk reading\n        boolean isContiguous = isContiguous(positions, positionCount);\n        \n        if (isContiguous && presentStream == null) {\n            // Fast path: contiguous positions with no nulls\n            int startPosition = positions[0];\n            if (startPosition > streamPosition) {\n                skip(startPosition - streamPosition);\n            }\n            streamPosition = startPosition;\n            \n            // Bulk read bits for the entire contiguous range\n            for (int i = 0; i < positionCount; i++) {\n                values[i] = (byte) (dataStream.nextBit() ? 1 : 0);\n                streamPosition++;\n            }\n        }\n        else if (isContiguous && presentStream != null) {\n            // Contiguous positions with potential nulls\n            int startPosition = positions[0];\n            if (startPosition > streamPosition) {\n                skip(startPosition - streamPosition);\n            }\n            streamPosition = startPosition;\n            \n            for (int i = 0; i < positionCount; i++) {\n                if (!presentStream.nextBit()) {\n                    nulls[i] = true;\n                }\n                else {\n                    values[i] = (byte) (dataStream.nextBit() ? 1 : 0);\n                    nulls[i] = false;\n                }\n                streamPosition++;\n            }\n        }\n        else {\n            // Non-contiguous positions, use original algorithm\n            for (int i = 0; i < positionCount; i++) {\n                int position = positions[i];\n                if (position > streamPosition) {\n                    skip(position - streamPosition);\n                    streamPosition = position;\n                }\n\n                if (presentStream != null && !presentStream.nextBit()) {\n                    nulls[i] = true;\n                }\n                else {\n                    values[i] = (byte) (dataStream.nextBit() ? 1 : 0);\n                    if (presentStream != null) {\n                        nulls[i] = false;\n                    }\n                }\n                streamPosition++;\n            }\n        }\n        \n        outputPositionCount = positionCount;\n        return streamPosition;\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/BooleanSelectiveStreamReader.java",
    "search": "    private void skip(int items)\n            throws IOException\n    {\n        if (dataStream == null) {\n            presentStream.skip(items);\n        }\n        else if (presentStream != null) {\n            int dataToSkip = presentStream.countBitsSet(items);\n            dataStream.skip(dataToSkip);\n        }\n        else {\n            dataStream.skip(items);\n        }\n    }",
    "replace": "    private void skip(int items)\n            throws IOException\n    {\n        if (dataStream == null) {\n            presentStream.skip(items);\n        }\n        else if (presentStream != null) {\n            int dataToSkip = presentStream.countBitsSet(items);\n            dataStream.skip(dataToSkip);\n        }\n        else {\n            dataStream.skip(items);\n        }\n    }\n    \n    private boolean isContiguous(int[] positions, int positionCount)\n    {\n        if (positionCount <= 1) {\n            return true;\n        }\n        \n        // Check if positions form a contiguous sequence\n        for (int i = 1; i < positionCount; i++) {\n            if (positions[i] != positions[i - 1] + 1) {\n                return false;\n            }\n        }\n        return true;\n    }"
  }
]
```