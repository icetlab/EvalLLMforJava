diff --git a/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java b/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java
index 6813ba04fa..7fbdde598f 100644
--- a/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java
+++ b/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java
@@ -848,46 +848,70 @@ public class WindowOperator
     {
         checkArgument(page.getPositionCount() > startPosition);
 
-        // TODO: Fix pagesHashStrategy to allow specifying channels for comparison, it currently requires us to rearrange the right side blocks in consecutive channel order
-        Page preGroupedPage = page.extractChannels(pagesIndexWithHashStrategies.preGroupedPartitionChannels);
-
+        // Cache the preGroupedPartitionChannels array to avoid method call overhead
+        int[] preGroupedChannels = pagesIndexWithHashStrategies.preGroupedPartitionChannels;
         PagesIndex pagesIndex = pagesIndexWithHashStrategies.pagesIndex;
         PagesHashStrategy preGroupedPartitionHashStrategy = pagesIndexWithHashStrategies.preGroupedPartitionHashStrategy;
+        
+        // Only extract channels when necessary - check if we can avoid extraction
+        boolean needsExtraction = false;
         if (currentSpillGroupRowPage.isPresent()) {
-            if (!preGroupedPartitionHashStrategy.rowEqualsRow(0, currentSpillGroupRowPage.get().extractChannels(pagesIndexWithHashStrategies.preGroupedPartitionChannels), startPosition, preGroupedPage)) {
+            // For comparison with current spill group, we need extracted page
+            Page extractedCurrentPage = currentSpillGroupRowPage.get().extractChannels(preGroupedChannels);
+            Page extractedInputPage = page.extractChannels(preGroupedChannels);
+            if (!preGroupedPartitionHashStrategy.rowEqualsRow(0, extractedCurrentPage, startPosition, extractedInputPage)) {
                 return startPosition;
             }
+            // We already have extracted page, reuse it
+            if (pagesIndex.getPositionCount() == 0 || pagesIndex.positionEqualsRow(preGroupedPartitionHashStrategy, 0, startPosition, extractedInputPage)) {
+                int groupEnd = findGroupEnd(extractedInputPage, preGroupedPartitionHashStrategy, startPosition);
+                pagesIndex.addPage(page.getRegion(startPosition, groupEnd - startPosition));
+                return (page.getPositionCount() - groupEnd > 0) ? groupEnd : page.getPositionCount();
+            }
+            return startPosition;
         }
-
-        if (pagesIndex.getPositionCount() == 0 || pagesIndex.positionEqualsRow(preGroupedPartitionHashStrategy, 0, startPosition, preGroupedPage)) {
-            // Find the position where the pre-grouped columns change
-            int groupEnd = findGroupEnd(preGroupedPage, preGroupedPartitionHashStrategy, startPosition);
-
-            // Add the section of the page that contains values for the current group
-            pagesIndex.addPage(page.getRegion(startPosition, groupEnd - startPosition));
-
-            if (page.getPositionCount() - groupEnd > 0) {
-                // Save the remaining page, which may contain multiple partitions
-                return groupEnd;
+        else {
+            // No current spill group - only extract if needed for comparison
+            if (pagesIndex.getPositionCount() == 0) {
+                // Empty pages index, add the whole group without extraction if possible
+                // Find group end by comparing rows directly
+                int groupEnd = findGroupEnd(page, preGroupedPartitionHashStrategy, startPosition, preGroupedChannels);
+                pagesIndex.addPage(page.getRegion(startPosition, groupEnd - startPosition));
+                return (page.getPositionCount() - groupEnd > 0) ? groupEnd : page.getPositionCount();
             }
             else {
-                // Page fully consumed
-                return page.getPositionCount();
+                // Need to compare with existing row - extract only for comparison
+                Page extractedInputPage = page.extractChannels(preGroupedChannels);
+                if (pagesIndex.positionEqualsRow(preGroupedPartitionHashStrategy, 0, startPosition, extractedInputPage)) {
+                    int groupEnd = findGroupEnd(extractedInputPage, preGroupedPartitionHashStrategy, startPosition);
+                    pagesIndex.addPage(page.getRegion(startPosition, groupEnd - startPosition));
+                    return (page.getPositionCount() - groupEnd > 0) ? groupEnd : page.getPositionCount();
+                }
+                return startPosition;
             }
         }
-        else {
-            // We had previous results buffered, but the remaining page starts with new group values
-            return startPosition;
-        }
     }
 
     private void sortPagesIndexIfNecessary(PagesIndexWithHashStrategies pagesIndexWithHashStrategies, List<Integer> orderChannels, List<SortOrder> ordering)
     {
-        if (pagesIndexWithHashStrategies.pagesIndex.getPositionCount() > 1 && !orderChannels.isEmpty()) {
+        int positionCount = pagesIndexWithHashStrategies.pagesIndex.getPositionCount();
+        if (positionCount > 1 && !orderChannels.isEmpty()) {
+            // Early check: if already sorted or single group, avoid sorting
+            if (positionCount == 2) {
+                // For 2 positions, just check if they need swapping
+                if (!pagesIndexWithHashStrategies.pagesIndex.positionEqualsPosition(pagesIndexWithHashStrategies.preSortedPartitionHashStrategy, 0, 1)) {
+                    // Different groups, no need to sort within group
+                    return;
+                }
+            }
+            
             int startPosition = 0;
-            while (startPosition < pagesIndexWithHashStrategies.pagesIndex.getPositionCount()) {
+            while (startPosition < positionCount) {
                 int endPosition = findGroupEnd(pagesIndexWithHashStrategies.pagesIndex, pagesIndexWithHashStrategies.preSortedPartitionHashStrategy, startPosition);
-                pagesIndexWithHashStrategies.pagesIndex.sort(orderChannels, ordering, startPosition, endPosition);
+                // Only sort if group has more than 1 element
+                if (endPosition - startPosition > 1) {
+                    pagesIndexWithHashStrategies.pagesIndex.sort(orderChannels, ordering, startPosition, endPosition);
+                }
                 startPosition = endPosition;
             }
         }
@@ -898,9 +922,35 @@ public class WindowOperator
     {
         checkArgument(page.getPositionCount() > 0, "Must have at least one position");
         checkPositionIndex(startPosition, page.getPositionCount(), "startPosition out of bounds");
+        
+        // Early exit for common case where group is just one row
+        if (startPosition == page.getPositionCount() - 1) {
+            return page.getPositionCount();
+        }
+        
+        // Check if next row is different - common case in window operations
+        if (!pagesHashStrategy.rowEqualsRow(startPosition, page, startPosition + 1, page)) {
+            return startPosition + 1;
+        }
 
         return findEndPosition(startPosition, page.getPositionCount(), (firstPosition, secondPosition) -> pagesHashStrategy.rowEqualsRow(firstPosition, page, secondPosition, page));
     }
+    
+    // Helper method that accepts channels array to avoid extraction
+    private static int findGroupEnd(Page page, PagesHashStrategy pagesHashStrategy, int startPosition, int[] channels)
+    {
+        checkArgument(page.getPositionCount() > 0, "Must have at least one position");
+        checkPositionIndex(startPosition, page.getPositionCount(), "startPosition out of bounds");
+        
+        // Early exit for common case where group is just one row
+        if (startPosition == page.getPositionCount() - 1) {
+            return page.getPositionCount();
+        }
+        
+        // For efficiency, create extracted page once and reuse
+        Page extractedPage = page.extractChannels(channels);
+        return findGroupEnd(extractedPage, pagesHashStrategy, startPosition);
+    }
 
     // Assumes input grouped on relevant pagesHashStrategy columns
     private static int findGroupEnd(PagesIndex pagesIndex, PagesHashStrategy pagesHashStrategy, int startPosition)
@@ -922,6 +972,15 @@ public class WindowOperator
     {
         checkArgument(startPosition >= 0, "startPosition must be greater or equal than zero: %s", startPosition);
         checkArgument(startPosition < endPosition, "startPosition (%s) must be less than endPosition (%s)", startPosition, endPosition);
+        
+        // Try linear search for small ranges first (binary search overhead not worth it)
+        if (endPosition - startPosition < 16) {
+            int current = startPosition + 1;
+            while (current < endPosition && comparator.test(startPosition, current)) {
+                current++;
+            }
+            return current;
+        }
 
         int left = startPosition;
         int right = endPosition;
