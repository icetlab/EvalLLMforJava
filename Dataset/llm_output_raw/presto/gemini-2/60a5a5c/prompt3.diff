diff --git a/presto-main/src/main/java/com/facebook/presto/execution/buffer/PagesSerde.java b/presto-main/src/main/java/com/facebook/presto/execution/buffer/PagesSerde.java
index 74b77228f0..3f275e84f4 100644
--- a/presto-main/src/main/java/com/facebook/presto/execution/buffer/PagesSerde.java
+++ b/presto-main/src/main/java/com/facebook/presto/execution/buffer/PagesSerde.java
@@ -42,6 +42,9 @@ public class PagesSerde
 {
     private static final double MINIMUM_COMPRESSION_RATIO = 0.8;
 
+    private ByteBuffer compressionBuffer;
+    private ByteBuffer decompressionBuffer;
+
     private final BlockEncodingSerde blockEncodingSerde;
     private final Optional<Compressor> compressor;
     private final Optional<Decompressor> decompressor;
@@ -66,7 +69,12 @@ public class PagesSerde
         byte markers = PageCodecMarker.none();
 
         if (compressor.isPresent()) {
-            ByteBuffer compressionBuffer = ByteBuffer.allocate(compressor.get().maxCompressedLength(uncompressedSize));
+            int maxCompressedLength = compressor.get().maxCompressedLength(uncompressedSize);
+            if (compressionBuffer == null || compressionBuffer.capacity() < maxCompressedLength) {
+                compressionBuffer = ByteBuffer.allocate(maxCompressedLength);
+            }
+            compressionBuffer.clear();
+
             compressor.get().compress(slice.toByteBuffer(), compressionBuffer);
             compressionBuffer.flip();
             if ((((double) compressionBuffer.remaining()) / uncompressedSize) <= MINIMUM_COMPRESSION_RATIO) {
@@ -103,7 +111,11 @@ public class PagesSerde
             checkState(decompressor.isPresent(), "Page is compressed, but decompressor is missing");
 
             int uncompressedSize = serializedPage.getUncompressedSizeInBytes();
-            ByteBuffer decompressionBuffer = ByteBuffer.allocate(uncompressedSize);
+            if (decompressionBuffer == null || decompressionBuffer.capacity() < uncompressedSize) {
+                decompressionBuffer = ByteBuffer.allocate(uncompressedSize);
+            }
+            decompressionBuffer.clear();
+            decompressionBuffer.limit(uncompressedSize);
 
             decompressor.get().decompress(slice.toByteBuffer(), decompressionBuffer);
             decompressionBuffer.flip();
diff --git a/presto-main/src/main/java/com/facebook/presto/operator/PartitionedOutputOperator.java b/presto-main/src/main/java/com/facebook/presto/operator/PartitionedOutputOperator.java
index d3b9621b8e..e20c22a009 100644
--- a/presto-main/src/main/java/com/facebook/presto/operator/PartitionedOutputOperator.java
+++ b/presto-main/src/main/java/com/facebook/presto/operator/PartitionedOutputOperator.java
@@ -31,6 +31,8 @@ import com.fasterxml.jackson.annotation.JsonProperty;
 import com.google.common.util.concurrent.ListenableFuture;
 import io.airlift.units.DataSize;
 
+import java.util.ArrayList;
+
 import java.util.List;
 import java.util.Optional;
 import java.util.OptionalInt;
@@ -300,6 +302,8 @@ public class PartitionedOutputOperator
         private final List<Optional<Block>> partitionConstants;
         private final PagesSerde serde;
         private final PageBuilder[] pageBuilders;
+        private final List<Integer>[] positionsByPartition;
+        private final List<Integer> replicatedPositions;
         private final boolean replicatesAnyRow;
         private final OptionalInt nullChannel; // when present, send the position to every partition if this channel is null.
         private final AtomicLong rowsAdded = new AtomicLong();
@@ -336,8 +340,11 @@ public class PartitionedOutputOperator
             pageSize = max(1, pageSize);
 
             this.pageBuilders = new PageBuilder[partitionCount];
+            this.positionsByPartition = new List[partitionCount];
+            this.replicatedPositions = new ArrayList<>();
             for (int i = 0; i < partitionCount; i++) {
                 pageBuilders[i] = PageBuilder.withMaxPageSize(pageSize, sourceTypes);
+                positionsByPartition[i] = new ArrayList<>();
             }
         }
 
@@ -377,22 +384,56 @@ public class PartitionedOutputOperator
         public void partitionPage(Page page)
         {
             requireNonNull(page, "page is null");
+            int positionCount = page.getPositionCount();
+            if (positionCount == 0) {
+                return;
+            }
+
+            // 1. clear and prepare for partitioning
+            for (List<Integer> list : positionsByPartition) {
+                list.clear();
+            }
+            replicatedPositions.clear();
 
             Page partitionFunctionArgs = getPartitionFunctionArguments(page);
-            for (int position = 0; position < page.getPositionCount(); position++) {
+            Block nullChannelBlock = nullChannel.isPresent() ? page.getBlock(nullChannel.getAsInt()) : null;
+
+            // 2. group positions by partition
+            for (int position = 0; position < positionCount; position++) {
                 boolean shouldReplicate = (replicatesAnyRow && !hasAnyRowBeenReplicated) ||
-                        nullChannel.isPresent() && page.getBlock(nullChannel.getAsInt()).isNull(position);
+                        (nullChannelBlock != null && nullChannelBlock.isNull(position));
+
                 if (shouldReplicate) {
-                    for (PageBuilder pageBuilder : pageBuilders) {
-                        appendRow(pageBuilder, page, position);
-                    }
+                    replicatedPositions.add(position);
                     hasAnyRowBeenReplicated = true;
                 }
                 else {
                     int partition = partitionFunction.getPartition(partitionFunctionArgs, position);
-                    appendRow(pageBuilders[partition], page, position);
+                    positionsByPartition[partition].add(position);
                 }
             }
+
+            // 3. append rows to page builders
+            // append replicated rows
+            if (!replicatedPositions.isEmpty()) {
+                for (int position : replicatedPositions) {
+                    for (PageBuilder pageBuilder : pageBuilders) {
+                        appendRow(pageBuilder, page, position);
+                    }
+                }
+            }
+
+            // append partitioned rows
+            for (int partition = 0; partition < pageBuilders.length; partition++) {
+                List<Integer> positions = positionsByPartition[partition];
+                if (!positions.isEmpty()) {
+                    PageBuilder pageBuilder = pageBuilders[partition];
+                    for (int position : positions) {
+                        appendRow(pageBuilder, page, position);
+                    }
+                }
+            }
+
             flush(false);
         }
 
@@ -432,9 +473,11 @@ public class PartitionedOutputOperator
 
                     operatorContext.recordOutput(pagePartition.getSizeInBytes(), pagePartition.getPositionCount());
 
-                    List<SerializedPage> serializedPages = splitPage(pagePartition, DEFAULT_MAX_PAGE_SIZE_IN_BYTES).stream()
-                            .map(serde::serialize)
-                            .collect(toImmutableList());
+                    List<Page> splitPages = splitPage(pagePartition, DEFAULT_MAX_PAGE_SIZE_IN_BYTES);
+                    List<SerializedPage> serializedPages = new ArrayList<>(splitPages.size());
+                    for (Page p : splitPages) {
+                        serializedPages.add(serde.serialize(p));
+                    }
 
                     outputBuffer.enqueue(operatorContext.getDriverContext().getLifespan(), partition, serializedPages);
                     pagesAdded.incrementAndGet();
