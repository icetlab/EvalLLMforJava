My goal is to improve the performance of map key lookups, specifically when the key is a `Slice`. The current implementation in `SingleMapBlock.seekKeyExact(Slice nativeValue)` uses a `MethodHandle` (`keyBlockNativeEquals.invokeExact`) for key comparison. This method handle likely resolves to a function that creates a new `Slice` object for the key stored in the block at each comparison, leading to significant garbage collection overhead when performing many lookups.

To optimize this, I will replace the generic `MethodHandle` invocation with a specialized, more direct comparison logic. The new implementation will:
1.  First check if the key at the current position in the block is null. If it is, it will preserve the original behavior of throwing a `NotSupportedException`, as map keys are not expected to be null.
2.  If the key is not null, it will perform a highly efficient, in-place comparison. It will first check if the length of the slice-based key matches the length of the `nativeValue` slice. If the lengths match, it will then use `Block.bytesEqual()` to perform a byte-by-byte comparison without allocating a new `Slice` object.

This change is confined to the `seekKeyExact(Slice nativeValue)` method, directly addressing the reported performance bottleneck while maintaining the correctness and behavior of the original code.

```json
[
  {
    "filepath": "../presto/presto-common/src/main/java/com/facebook/presto/common/block/SingleMapBlock.java",
    "search": "    public int seekKeyExact(Slice nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        mapBlock.ensureHashTableLoaded();\n        int[] hashTable = mapBlock.getHashTables().get();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        int hashTableOffset = offset / 2 * HASH_MULTIPLIER;\n        int hashTableSize = positionCount / 2 * HASH_MULTIPLIER;\n        int position = computePosition(hashCode, hashTableSize);\n        while (true) {\n            int keyPosition = hashTable[hashTableOffset + position];\n            if (keyPosition == -1) {\n                return -1;\n            }\n            Boolean match;\n            try {\n                // assuming maps with indeterminate keys are not supported\n                match = (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue);\n            }\n            catch (Throwable throwable) {\n                throw handleThrowable(throwable);\n            }\n            checkNotIndeterminate(match);\n            if (match) {\n                return keyPosition * 2 + 1;\n            }\n            position++;\n            if (position == hashTableSize) {\n                position = 0;\n            }\n        }\n    }",
    "replace": "    public int seekKeyExact(Slice nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        mapBlock.ensureHashTableLoaded();\n        int[] hashTable = mapBlock.getHashTables().get();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        int hashTableOffset = offset / 2 * HASH_MULTIPLIER;\n        int hashTableSize = positionCount / 2 * HASH_MULTIPLIER;\n        int position = computePosition(hashCode, hashTableSize);\n        while (true) {\n            int keyPosition = hashTable[hashTableOffset + position];\n            if (keyPosition == -1) {\n                return -1;\n            }\n            int keyPositionInBlock = offset / 2 + keyPosition;\n            Block keyBlock = mapBlock.getRawKeyBlock();\n            if (keyBlock.isNull(keyPositionInBlock)) {\n                // This is what checkNotIndeterminate would do if keyBlockNativeEquals returned null.\n                // We do this explicitly because the method is optimized to avoid the method handle invocation.\n                checkNotIndeterminate(null);\n            }\n            else {\n                // Fast path for Slice equality comparison to avoid creating a new Slice object for every comparison.\n                if (keyBlock.getSliceLength(keyPositionInBlock) == nativeValue.length() &&\n                        keyBlock.bytesEqual(keyPositionInBlock, 0, nativeValue, 0, nativeValue.length())) {\n                    return keyPosition * 2 + 1;\n                }\n            }\n            position++;\n            if (position == hashTableSize) {\n                position = 0;\n            }\n        }\n    }"
  }
]
```