My overall improvement strategy is to enhance performance and maintainability in `SingleMapBlock.java`. I will achieve this by:
1.  Pre-calculating `keyOffset` and `mapSize` in the constructor to avoid redundant division operations in performance-sensitive methods.
2.  Refactoring the duplicated hash table probing logic from the various `seekKey` and `seekKeyExact` methods into a single private helper method. This reduces code duplication, improves readability, and centralizes the hot-spot logic for any future optimizations.

These changes will make the code cleaner and may provide a slight performance boost by reducing arithmetic operations in tight loops and enabling better JIT compiler optimizations.

```json
[
  {
    "filepath": "../presto/presto-common/src/main/java/com/facebook/presto/common/block/SingleMapBlock.java",
    "search": "    private final int offset;\n    private final int positionCount;  // The number of keys in this single map * 2\n    private final AbstractMapBlock mapBlock;\n\n    SingleMapBlock(int offset, int positionCount, AbstractMapBlock mapBlock)\n    {\n        this.offset = offset;\n        this.positionCount = positionCount;\n        this.mapBlock = mapBlock;\n    }",
    "replace": "    private final int offset;\n    private final int positionCount;  // The number of keys in this single map * 2\n    private final AbstractMapBlock mapBlock;\n    private final int keyOffset;\n    private final int mapSize;\n\n    SingleMapBlock(int offset, int positionCount, AbstractMapBlock mapBlock)\n    {\n        this.offset = offset;\n        this.positionCount = positionCount;\n        this.mapBlock = mapBlock;\n        this.keyOffset = offset / 2;\n        this.mapSize = positionCount / 2;\n    }"
  },
  {
    "filepath": "../presto/presto-common/src/main/java/com/facebook/presto/common/block/SingleMapBlock.java",
    "search": "    @Override\n    public long getSizeInBytes()\n    {\n        return mapBlock.getRawKeyBlock().getRegionSizeInBytes(offset / 2, positionCount / 2) +\n                mapBlock.getRawValueBlock().getRegionSizeInBytes(offset / 2, positionCount / 2) +\n                sizeOfIntArray(positionCount / 2 * HASH_MULTIPLIER);\n    }",
    "replace": "    @Override\n    public long getSizeInBytes()\n    {\n        return mapBlock.getRawKeyBlock().getRegionSizeInBytes(keyOffset, mapSize) +\n                mapBlock.getRawValueBlock().getRegionSizeInBytes(keyOffset, mapSize) +\n                sizeOfIntArray(mapSize * HASH_MULTIPLIER);\n    }"
  },
  {
    "filepath": "../presto/presto-common/src/main/java/com/facebook/presto/common/block/SingleMapBlock.java",
    "search": "    public int seekKey(Object nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        mapBlock.ensureHashTableLoaded();\n        int[] hashTable = mapBlock.getHashTables().get();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invoke(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        int hashTableOffset = offset / 2 * HASH_MULTIPLIER;\n        int hashTableSize = positionCount / 2 * HASH_MULTIPLIER;\n        int position = computePosition(hashCode, hashTableSize);\n        while (true) {\n            int keyPosition = hashTable[hashTableOffset + position];\n            if (keyPosition == -1) {\n                return -1;\n            }\n            Boolean match;\n            try {\n                // assuming maps with indeterminate keys are not supported\n                match = (Boolean) mapBlock.keyBlockNativeEquals.invoke(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue);\n            }\n            catch (Throwable throwable) {\n                throw handleThrowable(throwable);\n            }\n            checkNotIndeterminate(match);\n            if (match) {\n                return keyPosition * 2 + 1;\n            }\n            position++;\n            if (position == hashTableSize) {\n                position = 0;\n            }\n        }\n    }\n\n    // The next 5 seekKeyExact functions are the same as seekKey\n    // except MethodHandle.invoke is replaced with invokeExact.\n\n    public int seekKeyExact(long nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        mapBlock.ensureHashTableLoaded();\n        int[] hashTable = mapBlock.getHashTables().get();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        int hashTableOffset = offset / 2 * HASH_MULTIPLIER;\n        int hashTableSize = positionCount / 2 * HASH_MULTIPLIER;\n        int position = computePosition(hashCode, hashTableSize);\n        while (true) {\n            int keyPosition = hashTable[hashTableOffset + position];\n            if (keyPosition == -1) {\n                return -1;\n            }\n            Boolean match;\n            try {\n                // assuming maps with indeterminate keys are not supported\n                match = (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue);\n            }\n            catch (Throwable throwable) {\n                throw handleThrowable(throwable);\n            }\n            checkNotIndeterminate(match);\n            if (match) {\n                return keyPosition * 2 + 1;\n            }\n            position++;\n            if (position == hashTableSize) {\n                position = 0;\n            }\n        }\n    }\n\n    public int seekKeyExact(boolean nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        mapBlock.ensureHashTableLoaded();\n        int[] hashTable = mapBlock.getHashTables().get();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        int hashTableOffset = offset / 2 * HASH_MULTIPLIER;\n        int hashTableSize = positionCount / 2 * HASH_MULTIPLIER;\n        int position = computePosition(hashCode, hashTableSize);\n        while (true) {\n            int keyPosition = hashTable[hashTableOffset + position];\n            if (keyPosition == -1) {\n                return -1;\n            }\n            Boolean match;\n            try {\n                // assuming maps with indeterminate keys are not supported\n                match = (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue);\n            }\n            catch (Throwable throwable) {\n                throw handleThrowable(throwable);\n            }\n            checkNotIndeterminate(match);\n            if (match) {\n                return keyPosition * 2 + 1;\n            }\n            position++;\n            if (position == hashTableSize) {\n                position = 0;\n            }\n        }\n    }\n\n    public int seekKeyExact(double nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        mapBlock.ensureHashTableLoaded();\n        int[] hashTable = mapBlock.getHashTables().get();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        int hashTableOffset = offset / 2 * HASH_MULTIPLIER;\n        int hashTableSize = positionCount / 2 * HASH_MULTIPLIER;\n        int position = computePosition(hashCode, hashTableSize);\n        while (true) {\n            int keyPosition = hashTable[hashTableOffset + position];\n            if (keyPosition == -1) {\n                return -1;\n            }\n            Boolean match;\n            try {\n                // assuming maps with indeterminate keys are not supported\n                match = (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue);\n            }\n            catch (Throwable throwable) {\n                throw handleThrowable(throwable);\n            }\n            checkNotIndeterminate(match);\n            if (match) {\n                return keyPosition * 2 + 1;\n            }\n            position++;\n            if (position == hashTableSize) {\n                position = 0;\n            }\n        }\n    }\n\n    public int seekKeyExact(Slice nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        mapBlock.ensureHashTableLoaded();\n        int[] hashTable = mapBlock.getHashTables().get();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        int hashTableOffset = offset / 2 * HASH_MULTIPLIER;\n        int hashTableSize = positionCount / 2 * HASH_MULTIPLIER;\n        int position = computePosition(hashCode, hashTableSize);\n        while (true) {\n            int keyPosition = hashTable[hashTableOffset + position];\n            if (keyPosition == -1) {\n                return -1;\n            }\n            Boolean match;\n            try {\n                // assuming maps with indeterminate keys are not supported\n                match = (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue);\n            }\n            catch (Throwable throwable) {\n                throw handleThrowable(throwable);\n            }\n            checkNotIndeterminate(match);\n            if (match) {\n                return keyPosition * 2 + 1;\n            }\n            position++;\n            if (position == hashTableSize) {\n                position = 0;\n            }\n        }\n    }\n\n    public int seekKeyExact(Block nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        mapBlock.ensureHashTableLoaded();\n        int[] hashTable = mapBlock.getHashTables().get();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        int hashTableOffset = offset / 2 * HASH_MULTIPLIER;\n        int hashTableSize = positionCount / 2 * HASH_MULTIPLIER;\n        int position = computePosition(hashCode, hashTableSize);\n        while (true) {\n            int keyPosition = hashTable[hashTableOffset + position];\n            if (keyPosition == -1) {\n                return -1;\n            }\n            Boolean match;\n            try {\n                // assuming maps with indeterminate keys are not supported\n                match = (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue);\n            }\n            catch (Throwable throwable) {\n                throw handleThrowable(throwable);\n            }\n            checkNotIndeterminate(match);\n            if (match) {\n                return keyPosition * 2 + 1;\n            }\n            position++;\n            if (position == hashTableSize) {\n                position = 0;\n            }\n        }\n    }",
    "replace": "    public int seekKey(Object nativeValue)\n    {\n        if (mapSize == 0) {\n            return -1;\n        }\n        mapBlock.ensureHashTableLoaded();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invoke(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        return seekKeyInternal(hashCode, keyPosition -> {\n            // assuming maps with indeterminate keys are not supported\n            return (Boolean) mapBlock.keyBlockNativeEquals.invoke(mapBlock.getRawKeyBlock(), keyOffset + keyPosition, nativeValue);\n        });\n    }\n\n    // The next 5 seekKeyExact functions are the same as seekKey\n    // except MethodHandle.invoke is replaced with invokeExact.\n\n    public int seekKeyExact(long nativeValue)\n    {\n        if (mapSize == 0) {\n            return -1;\n        }\n        mapBlock.ensureHashTableLoaded();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        return seekKeyInternal(hashCode, keyPosition -> {\n            // assuming maps with indeterminate keys are not supported\n            return (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), keyOffset + keyPosition, nativeValue);\n        });\n    }\n\n    public int seekKeyExact(boolean nativeValue)\n    {\n        if (mapSize == 0) {\n            return -1;\n        }\n        mapBlock.ensureHashTableLoaded();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        return seekKeyInternal(hashCode, keyPosition -> {\n            // assuming maps with indeterminate keys are not supported\n            return (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), keyOffset + keyPosition, nativeValue);\n        });\n    }\n\n    public int seekKeyExact(double nativeValue)\n    {\n        if (mapSize == 0) {\n            return -1;\n        }\n        mapBlock.ensureHashTableLoaded();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        return seekKeyInternal(hashCode, keyPosition -> {\n            // assuming maps with indeterminate keys are not supported\n            return (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), keyOffset + keyPosition, nativeValue);\n        });\n    }\n\n    public int seekKeyExact(Slice nativeValue)\n    {\n        if (mapSize == 0) {\n            return -1;\n        }\n        mapBlock.ensureHashTableLoaded();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        return seekKeyInternal(hashCode, keyPosition -> {\n            // assuming maps with indeterminate keys are not supported\n            return (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), keyOffset + keyPosition, nativeValue);\n        });\n    }\n\n    public int seekKeyExact(Block nativeValue)\n    {\n        if (mapSize == 0) {\n            return -1;\n        }\n        mapBlock.ensureHashTableLoaded();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        return seekKeyInternal(hashCode, keyPosition -> {\n            // assuming maps with indeterminate keys are not supported\n            return (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), keyOffset + keyPosition, nativeValue);\n        });\n    }\n\n    @FunctionalInterface\n    private interface EqualityChecker\n    {\n        boolean equals(int keyPosition) throws Throwable;\n    }\n\n    private int seekKeyInternal(long hashCode, EqualityChecker equalityChecker)\n    {\n        // This method is hot and should not be changed without running benchmarks.\n        int[] hashTable = getHashTable();\n        int hashTableOffset = keyOffset * HASH_MULTIPLIER;\n        int hashTableSize = mapSize * HASH_MULTIPLIER;\n        int position = computePosition(hashCode, hashTableSize);\n\n        while (true) {\n            int keyPosition = hashTable[hashTableOffset + position];\n            if (keyPosition == -1) {\n                return -1;\n            }\n\n            Boolean match;\n            try {\n                match = equalityChecker.equals(keyPosition);\n            }\n            catch (Throwable throwable) {\n                throw handleThrowable(throwable);\n            }\n            checkNotIndeterminate(match);\n            if (match) {\n                return keyPosition * 2 + 1;\n            }\n\n            position++;\n            if (position == hashTableSize) {\n                position = 0;\n            }\n        }\n    }"
  }
]
```