The overall improvement is to optimize the T-Digest data structure for small distributions by avoiding the upfront allocation of large internal arrays. This is achieved by introducing a "small mode" that uses smaller, temporary arrays to buffer initial data points. The T-Digest transitions to its "large mode," allocating the full-sized arrays, only when the number of points exceeds a certain threshold or when an operation requiring the full structure (like `compress` or `merge`) is invoked. This lazy initialization significantly reduces the memory footprint for numerous small T-Digest instances, improving performance in scenarios where many such digests are created and merged.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "    private final double compression;\n\n    // points to the first unused centroid\n    private int activeCentroids;\n\n    private double totalWeight;\n\n    private final double[] weight;\n\n    private final double[] mean;\n\n    private double unmergedWeight;\n\n    // this is the index of the next temporary centroid\n    // this is a more Java-like convention than activeCentroids uses\n    private int tempUsed;\n    private final double[] tempWeight;\n    private final double[] tempMean;\n\n    // array used for sorting the temp centroids\n    // to avoid allocations during operation\n    private final int[] order;",
    "replace": "    private final double compression;\n\n    // points to the first unused centroid\n    private int activeCentroids;\n\n    private double totalWeight;\n\n    private double[] weight;\n\n    private double[] mean;\n\n    private double unmergedWeight;\n\n    // this is the index of the next temporary centroid\n    // this is a more Java-like convention than activeCentroids uses\n    private int tempUsed;\n    private double[] tempWeight;\n    private double[] tempMean;\n\n    // array used for sorting the temp centroids\n    // to avoid allocations during operation\n    private int[] order;\n\n    private static final int MAX_UNMERGED_SIZE = 200;"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "    private TDigest(double compression)\n    {\n        // ensure compression >= 10\n        // default size = 2 * ceil(compression)\n        // default bufferSize = 5 * size\n        // ensure size > 2 * compression + weightLimitFudge\n        // ensure bufferSize > 2 * size\n\n        checkArgument(compression <= MAX_COMPRESSION_FACTOR, \"Compression factor cannot exceed %s\", MAX_COMPRESSION_FACTOR);\n        this.publicCompression = max(compression, 10);\n        // publicCompression is how many centroids the user asked for\n        // compression is how many we actually keep\n        this.compression = 2 * publicCompression;\n\n        // having a big buffer is good for speed\n        int bufferSize = 5 * (int) ceil(this.publicCompression + sizeFudge);\n        int size = (int) ceil(this.compression + sizeFudge);\n\n        weight = new double[size];\n        mean = new double[size];\n        tempWeight = new double[bufferSize];\n        tempMean = new double[bufferSize];\n        order = new int[bufferSize];\n\n        activeCentroids = 0;\n    }",
    "replace": "    private TDigest(double compression)\n    {\n        // ensure compression >= 10\n        // default size = 2 * ceil(compression)\n        // default bufferSize = 5 * size\n        // ensure size > 2 * compression + weightLimitFudge\n        // ensure bufferSize > 2 * size\n\n        checkArgument(compression <= MAX_COMPRESSION_FACTOR, \"Compression factor cannot exceed %s\", MAX_COMPRESSION_FACTOR);\n        this.publicCompression = max(compression, 10);\n        // publicCompression is how many centroids the user asked for\n        // compression is how many we actually keep\n        this.compression = 2 * publicCompression;\n\n        activeCentroids = 0;\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "    public static TDigest createTDigest(Slice slice)\n    {\n        if (slice == null) {\n            return null;\n        }\n\n        SliceInput sliceInput = new BasicSliceInput(slice);\n        try {\n            byte format = sliceInput.readByte();\n            checkArgument(format == 0, \"Invalid serialization format for TDigest; expected '0'\");\n            byte type = sliceInput.readByte();\n            checkArgument(type == 0, \"Invalid type for TDigest; expected '0' (type double)\");\n            double min = sliceInput.readDouble();\n            double max = sliceInput.readDouble();\n            double publicCompression = max(10, sliceInput.readDouble());\n            TDigest r = new TDigest(publicCompression);\n            r.setMinMax(min, max);\n            r.totalWeight = sliceInput.readDouble();\n            r.activeCentroids = sliceInput.readInt();\n            sliceInput.readBytes(wrappedDoubleArray(r.weight), r.activeCentroids * SIZE_OF_DOUBLE);\n            sliceInput.readBytes(wrappedDoubleArray(r.mean), r.activeCentroids * SIZE_OF_DOUBLE);\n            sliceInput.close();\n            return r;\n        }\n        catch (IndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(\"Incorrect slice serialization format\");\n        }\n    }",
    "replace": "    public static TDigest createTDigest(Slice slice)\n    {\n        if (slice == null) {\n            return null;\n        }\n\n        SliceInput sliceInput = new BasicSliceInput(slice);\n        try {\n            byte format = sliceInput.readByte();\n            checkArgument(format == 0, \"Invalid serialization format for TDigest; expected '0'\");\n            byte type = sliceInput.readByte();\n            checkArgument(type == 0, \"Invalid type for TDigest; expected '0' (type double)\");\n            double min = sliceInput.readDouble();\n            double max = sliceInput.readDouble();\n            double publicCompression = max(10, sliceInput.readDouble());\n            TDigest r = new TDigest(publicCompression);\n            r.initialize();\n            r.setMinMax(min, max);\n            r.totalWeight = sliceInput.readDouble();\n            r.activeCentroids = sliceInput.readInt();\n            sliceInput.readBytes(wrappedDoubleArray(r.weight), r.activeCentroids * SIZE_OF_DOUBLE);\n            sliceInput.readBytes(wrappedDoubleArray(r.mean), r.activeCentroids * SIZE_OF_DOUBLE);\n            sliceInput.close();\n            return r;\n        }\n        catch (IndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(\"Incorrect slice serialization format\");\n        }\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "    public void add(double x, long w)\n    {\n        checkArgument(!Double.isNaN(x), \"Cannot add NaN to t-digest\");\n        checkArgument(w > 0L, \"weight must be > 0\");\n\n        if (tempUsed >= tempWeight.length - activeCentroids - 1) {\n            mergeNewValues();\n        }\n        int where = tempUsed++;\n        tempWeight[where] = w;\n        tempMean[where] = x;\n        unmergedWeight += w;\n        if (x < min) {\n            min = x;\n        }\n        if (x > max) {\n            max = x;\n        }\n    }",
    "replace": "    public void add(double x, long w)\n    {\n        checkArgument(!Double.isNaN(x), \"Cannot add NaN to t-digest\");\n        checkArgument(w > 0L, \"weight must be > 0\");\n\n        if (weight == null) { // not initialized\n            if (tempMean == null) {\n                tempMean = new double[MAX_UNMERGED_SIZE];\n                tempWeight = new double[MAX_UNMERGED_SIZE];\n            }\n            if (tempUsed >= tempMean.length) {\n                initialize();\n            }\n        }\n\n        if (weight != null && tempUsed >= tempWeight.length - activeCentroids - 1) {\n            mergeNewValues();\n        }\n        int where = tempUsed++;\n        tempWeight[where] = w;\n        tempMean[where] = x;\n        unmergedWeight += w;\n        if (x < min) {\n            min = x;\n        }\n        if (x > max) {\n            max = x;\n        }\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "    public void merge(TDigest other)\n    {\n        checkArgument(other != null, \"Cannot merge with a null t-digest\");\n        checkArgument(this.publicCompression == other.getCompressionFactor(), \"TDigests must have the same compression, found (%s, %s)\", this.publicCompression,\n                other.getCompressionFactor());\n        List<Centroid> tmp = new ArrayList<>();\n        for (Centroid centroid : other.centroids()) {\n            tmp.add(centroid);\n        }\n\n        shuffle(tmp, gen);\n        for (Centroid centroid : tmp) {\n            add(centroid.getMean(), centroid.getWeight());\n        }\n    }",
    "replace": "    public void merge(TDigest other)\n    {\n        checkArgument(other != null, \"Cannot merge with a null t-digest\");\n        checkArgument(this.publicCompression == other.getCompressionFactor(), \"TDigests must have the same compression, found (%s, %s)\", this.publicCompression,\n                other.getCompressionFactor());\n\n        if (weight == null) {\n            initialize();\n        }\n\n        List<Centroid> tmp = new ArrayList<>();\n        for (Centroid centroid : other.centroids()) {\n            tmp.add(centroid);\n        }\n\n        shuffle(tmp, gen);\n        for (Centroid centroid : tmp) {\n            add(centroid.getMean(), centroid.getWeight());\n        }\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "    public void compress()\n    {\n        mergeNewValues(true, publicCompression);\n    }",
    "replace": "    public void compress()\n    {\n        if (weight == null) {\n            if (unmergedWeight == 0) {\n                return;\n            }\n            initialize();\n        }\n        mergeNewValues(true, publicCompression);\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "    public int centroidCount()\n    {\n        mergeNewValues();\n        return activeCentroids;\n    }",
    "replace": "    public int centroidCount()\n    {\n        if (weight == null) {\n            if (unmergedWeight == 0) {\n                return 0;\n            }\n            initialize();\n        }\n        mergeNewValues();\n        return activeCentroids;\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "    public long estimatedInMemorySizeInBytes()\n    {\n        return INSTANCE_SIZE + sizeOf(weight) + sizeOf(mean) + sizeOf(tempWeight) + sizeOf(tempMean) + sizeOf(order);\n    }",
    "replace": "    public long estimatedInMemorySizeInBytes()\n    {\n        if (weight == null) {\n            return INSTANCE_SIZE + sizeOf(tempMean) + sizeOf(tempWeight);\n        }\n        return INSTANCE_SIZE + sizeOf(weight) + sizeOf(mean) + sizeOf(tempWeight) + sizeOf(tempMean) + sizeOf(order);\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "    public String toString()\n    {\n        return format(\"TDigest\\nCompression:%s\\nCentroid Count:%s\\nSize:%s\\nMin:%s Median:%s Max:%s\",\n                publicCompression, activeCentroids, totalWeight, min, getQuantile(0.5), max);\n    }",
    "replace": "    private void initialize()\n    {\n        if (weight != null) {\n            return;\n        }\n\n        // having a big buffer is good for speed\n        int bufferSize = 5 * (int) ceil(this.publicCompression + sizeFudge);\n        int size = (int) ceil(this.compression + sizeFudge);\n\n        weight = new double[size];\n        mean = new double[size];\n\n        double[] oldTempMean = tempMean;\n        double[] oldTempWeight = tempWeight;\n\n        tempWeight = new double[bufferSize];\n        tempMean = new double[bufferSize];\n        order = new int[bufferSize];\n\n        if (tempUsed > 0) {\n            arraycopy(oldTempMean, 0, tempMean, 0, tempUsed);\n            arraycopy(oldTempWeight, 0, tempWeight, 0, tempUsed);\n        }\n    }\n\n    public String toString()\n    {\n        return format(\"TDigest\\nCompression:%s\\nCentroid Count:%s\\nSize:%s\\nMin:%s Median:%s Max:%s\",\n                publicCompression, activeCentroids, totalWeight, min, getQuantile(0.5), max);\n    }"
  }
]
```