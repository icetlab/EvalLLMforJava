The primary improvement is optimizing the `TDigest.merge(TDigest)` method. The original implementation was inefficient as it created an `ArrayList` and a `Centroid` object for each centroid in the source digest, leading to significant object allocation and garbage collection overhead. The new version avoids this by directly accessing the internal arrays of the source digest. To maintain the random merge order, which prevents bias, it shuffles an array of indices and then adds the centroids in that random order. This approach eliminates intermediate object creation, substantially improving merge performance.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "    public void merge(TDigest other)\n    {\n        checkArgument(other != null, \"Cannot merge with a null t-digest\");\n        checkArgument(this.publicCompression == other.getCompressionFactor(), \"TDigests must have the same compression, found (%s, %s)\", this.publicCompression,\n                other.getCompressionFactor());\n        List<Centroid> tmp = new ArrayList<>();\n        for (Centroid centroid : other.centroids()) {\n            tmp.add(centroid);\n        }\n\n        shuffle(tmp, gen);\n        for (Centroid centroid : tmp) {\n            add(centroid.getMean(), centroid.getWeight());\n        }\n    }",
    "replace": "    public void merge(TDigest other)\n    {\n        checkArgument(other != null, \"Cannot merge with a null t-digest\");\n        checkArgument(this.publicCompression == other.getCompressionFactor(), \"TDigests must have the same compression, found (%s, %s)\", this.publicCompression,\n                other.getCompressionFactor());\n\n        other.compress();\n\n        if (other.activeCentroids == 0) {\n            return;\n        }\n\n        // To avoid bias, we shuffle the centroids from the other digest before adding them.\n        // This is much more efficient than creating a list of Centroid objects.\n        int[] indices = new int[other.activeCentroids];\n        for (int i = 0; i < other.activeCentroids; i++) {\n            indices[i] = i;\n        }\n\n        // In-place Fisher-Yates shuffle of the indices.\n        for (int i = indices.length - 1; i > 0; i--) {\n            int j = gen.nextInt(i + 1);\n            int temp = indices[j];\n            indices[j] = indices[i];\n            indices[i] = temp;\n        }\n\n        for (int index : indices) {\n            add(other.mean[index], (long) other.weight[index]);\n        }\n    }"
  }
]
```