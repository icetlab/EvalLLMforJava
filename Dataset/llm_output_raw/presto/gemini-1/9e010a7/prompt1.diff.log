The current implementation of `mapCast` has a performance issue when handling maps with a large number of entries. The method uses a `TypedSet` to detect duplicate keys after they have been cast to the target key type. The `TypedSet::add` operation, when called in a loop, can lead to quadratic time complexity (`O(N^2)`) in the number of unique keys, because it may rebuild its internal block storage on each addition.

To improve performance, I will replace this duplicate detection mechanism. The new approach involves the following steps:
1.  Cast all keys from the input map and store them in an intermediate `keyBlock`, similar to the original implementation.
2.  Create an array of indices corresponding to the positions in the `keyBlock`.
3.  Sort these indices based on the values in the `keyBlock`. This step has a time complexity of `O(N log N)`, where N is the number of entries in the map.
4.  Iterate through the sorted indices to both check for duplicates (by comparing adjacent elements) and build the final map. This is an `O(N)` operation.

This change reduces the overall complexity from `O(N^2)` to `O(N log N)`, providing a significant performance improvement for large maps.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java",
    "search": "import com.facebook.presto.metadata.SqlOperator;\nimport com.facebook.presto.operator.aggregation.TypedSet;\nimport com.facebook.presto.spi.PrestoException;\nimport com.facebook.presto.spi.function.JavaScalarFunctionImplementation;\nimport com.google.common.collect.ImmutableList;\nimport io.airlift.slice.Slice;\n\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodHandles;",
    "replace": "import com.facebook.presto.metadata.SqlOperator;\nimport com.facebook.presto.spi.PrestoException;\nimport com.facebook.presto.spi.function.JavaScalarFunctionImplementation;\nimport com.google.common.collect.ImmutableList;\nimport io.airlift.slice.Slice;\n\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodHandles;\nimport java.util.Arrays;"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java",
    "search": "@UsedByGeneratedCode\n    public static Block mapCast(\n            MethodHandle keyProcessFunction,\n            MethodHandle valueProcessFunction,\n            Type toMapType,\n            SqlFunctionProperties properties,\n            Block fromMap)\n    {\n        checkState(toMapType.getTypeParameters().size() == 2, \"Expect two type parameters for toMapType\");\n        Type toKeyType = toMapType.getTypeParameters().get(0);\n        TypedSet typedSet = new TypedSet(toKeyType, fromMap.getPositionCount() / 2, \"map-to-map cast\");\n        BlockBuilder keyBlockBuilder = toKeyType.createBlockBuilder(null, fromMap.getPositionCount() / 2);\n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            try {\n                keyProcessFunction.invokeExact(fromMap, i, properties, keyBlockBuilder);\n            }\n            catch (Throwable t) {\n                throw internalError(t);\n            }\n        }\n        Block keyBlock = keyBlockBuilder.build();\n\n        BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);\n        BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();\n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            if (typedSet.add(keyBlock, i / 2)) {\n                toKeyType.appendTo(keyBlock, i / 2, blockBuilder);\n                if (fromMap.isNull(i + 1)) {\n                    blockBuilder.appendNull();\n                    continue;\n                }\n\n                try {\n                    valueProcessFunction.invokeExact(fromMap, i + 1, properties, blockBuilder);\n                }\n                catch (Throwable t) {\n                    throw internalError(t);\n                }\n            }\n            else {\n                // if there are duplicated keys, fail it!\n                throw new PrestoException(INVALID_CAST_ARGUMENT, \"duplicate keys\");\n            }\n        }\n\n        mapBlockBuilder.closeEntry();\n        return (Block) toMapType.getObject(mapBlockBuilder, mapBlockBuilder.getPositionCount() - 1);\n    }",
    "replace": "@UsedByGeneratedCode\n    public static Block mapCast(\n            MethodHandle keyProcessFunction,\n            MethodHandle valueProcessFunction,\n            Type toMapType,\n            SqlFunctionProperties properties,\n            Block fromMap)\n    {\n        checkState(toMapType.getTypeParameters().size() == 2, \"Expect two type parameters for toMapType\");\n        Type toKeyType = toMapType.getTypeParameters().get(0);\n        int mapSize = fromMap.getPositionCount() / 2;\n\n        BlockBuilder keyBlockBuilder = toKeyType.createBlockBuilder(null, mapSize);\n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            try {\n                keyProcessFunction.invokeExact(fromMap, i, properties, keyBlockBuilder);\n            }\n            catch (Throwable t) {\n                throw internalError(t);\n            }\n        }\n        Block keyBlock = keyBlockBuilder.build();\n\n        BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);\n        BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();\n\n        if (mapSize > 0) {\n            Integer[] positions = new Integer[mapSize];\n            for (int i = 0; i < mapSize; i++) {\n                positions[i] = i;\n            }\n\n            Arrays.sort(positions, (p1, p2) -> (int) toKeyType.compareTo(keyBlock, p1, keyBlock, p2));\n\n            // Check for duplicates and build map\n            int lastPosition = positions[0];\n            toKeyType.appendTo(keyBlock, lastPosition, blockBuilder);\n            if (fromMap.isNull(lastPosition * 2 + 1)) {\n                blockBuilder.appendNull();\n            }\n            else {\n                try {\n                    valueProcessFunction.invokeExact(fromMap, lastPosition * 2 + 1, properties, blockBuilder);\n                }\n                catch (Throwable t) {\n                    throw internalError(t);\n                }\n            }\n\n            for (int i = 1; i < mapSize; i++) {\n                int currentPosition = positions[i];\n                if (toKeyType.equalTo(keyBlock, lastPosition, keyBlock, currentPosition)) {\n                    throw new PrestoException(INVALID_CAST_ARGUMENT, \"duplicate keys\");\n                }\n                toKeyType.appendTo(keyBlock, currentPosition, blockBuilder);\n                if (fromMap.isNull(currentPosition * 2 + 1)) {\n                    blockBuilder.appendNull();\n                }\n                else {\n                    try {\n                        valueProcessFunction.invokeExact(fromMap, currentPosition * 2 + 1, properties, blockBuilder);\n                    }\n                    catch (Throwable t) {\n                        throw internalError(t);\n                    }\n                }\n                lastPosition = currentPosition;\n            }\n        }\n\n        mapBlockBuilder.closeEntry();\n        return (Block) toMapType.getObject(mapBlockBuilder, mapBlockBuilder.getPositionCount() - 1);\n    }"
  }
]
```