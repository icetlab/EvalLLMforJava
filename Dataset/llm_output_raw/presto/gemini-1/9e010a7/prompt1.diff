diff --git a/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java b/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java
index c586b38f12..858fce3b35 100644
--- a/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java
+++ b/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java
@@ -23,7 +23,6 @@ import com.facebook.presto.metadata.BoundVariables;
 import com.facebook.presto.metadata.CastType;
 import com.facebook.presto.metadata.FunctionAndTypeManager;
 import com.facebook.presto.metadata.SqlOperator;
-import com.facebook.presto.operator.aggregation.TypedSet;
 import com.facebook.presto.spi.PrestoException;
 import com.facebook.presto.spi.function.JavaScalarFunctionImplementation;
 import com.google.common.collect.ImmutableList;
@@ -31,6 +30,7 @@ import io.airlift.slice.Slice;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
+import java.util.Arrays;
 
 import static com.facebook.presto.common.block.MethodHandleUtil.compose;
 import static com.facebook.presto.common.block.MethodHandleUtil.nativeValueGetter;
@@ -215,8 +215,9 @@ public final class MapToMapCast
     {
         checkState(toMapType.getTypeParameters().size() == 2, "Expect two type parameters for toMapType");
         Type toKeyType = toMapType.getTypeParameters().get(0);
-        TypedSet typedSet = new TypedSet(toKeyType, fromMap.getPositionCount() / 2, "map-to-map cast");
-        BlockBuilder keyBlockBuilder = toKeyType.createBlockBuilder(null, fromMap.getPositionCount() / 2);
+        int mapSize = fromMap.getPositionCount() / 2;
+
+        BlockBuilder keyBlockBuilder = toKeyType.createBlockBuilder(null, mapSize);
         for (int i = 0; i < fromMap.getPositionCount(); i += 2) {
             try {
                 keyProcessFunction.invokeExact(fromMap, i, properties, keyBlockBuilder);
@@ -229,25 +230,49 @@ public final class MapToMapCast
 
         BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);
         BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();
-        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {
-            if (typedSet.add(keyBlock, i / 2)) {
-                toKeyType.appendTo(keyBlock, i / 2, blockBuilder);
-                if (fromMap.isNull(i + 1)) {
-                    blockBuilder.appendNull();
-                    continue;
+
+        if (mapSize > 0) {
+            Integer[] positions = new Integer[mapSize];
+            for (int i = 0; i < mapSize; i++) {
+                positions[i] = i;
             }
 
+            Arrays.sort(positions, (p1, p2) -> (int) toKeyType.compareTo(keyBlock, p1, keyBlock, p2));
+
+            // Check for duplicates and build map
+            int lastPosition = positions[0];
+            toKeyType.appendTo(keyBlock, lastPosition, blockBuilder);
+            if (fromMap.isNull(lastPosition * 2 + 1)) {
+                blockBuilder.appendNull();
+            }
+            else {
                 try {
-                    valueProcessFunction.invokeExact(fromMap, i + 1, properties, blockBuilder);
+                    valueProcessFunction.invokeExact(fromMap, lastPosition * 2 + 1, properties, blockBuilder);
                 }
                 catch (Throwable t) {
                     throw internalError(t);
                 }
             }
-            else {
-                // if there are duplicated keys, fail it!
+
+            for (int i = 1; i < mapSize; i++) {
+                int currentPosition = positions[i];
+                if (toKeyType.equalTo(keyBlock, lastPosition, keyBlock, currentPosition)) {
                     throw new PrestoException(INVALID_CAST_ARGUMENT, "duplicate keys");
                 }
+                toKeyType.appendTo(keyBlock, currentPosition, blockBuilder);
+                if (fromMap.isNull(currentPosition * 2 + 1)) {
+                    blockBuilder.appendNull();
+                }
+                else {
+                    try {
+                        valueProcessFunction.invokeExact(fromMap, currentPosition * 2 + 1, properties, blockBuilder);
+                    }
+                    catch (Throwable t) {
+                        throw internalError(t);
+                    }
+                }
+                lastPosition = currentPosition;
+            }
         }
 
         mapBlockBuilder.closeEntry();
