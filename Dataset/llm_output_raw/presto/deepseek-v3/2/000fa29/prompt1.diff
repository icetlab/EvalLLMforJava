diff --git a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java
index 30e0088e35..2ce2b79e09 100644
--- a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java
+++ b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java
@@ -434,6 +434,7 @@ public class OptimizedPartitionedOutputOperator
             // Populate positions to copy for each destination partition.
             int positionCount = page.getPositionCount();
 
+            // Reset all partition buffers first
             for (int i = 0; i < partitionBuffers.length; i++) {
                 partitionBuffers[i].resetPositions(positionCount);
             }
@@ -441,15 +442,19 @@ public class OptimizedPartitionedOutputOperator
             Block nullBlock = nullChannel.isPresent() ? page.getBlock(nullChannel.getAsInt()) : null;
             Page partitionFunctionArgs = getPartitionFunctionArguments(page);
 
+            // Pre-calculate replication condition to avoid recomputation in loop
+            boolean shouldReplicateAnyRow = replicatesAnyRow && !hasAnyRowBeenReplicated;
+            
             for (int position = 0; position < positionCount; position++) {
-                boolean shouldReplicate = (replicatesAnyRow && !hasAnyRowBeenReplicated) ||
-                        nullBlock != null && nullBlock.isNull(position);
+                boolean shouldReplicate = shouldReplicateAnyRow ||
+                        (nullBlock != null && nullBlock.isNull(position));
 
                 if (shouldReplicate) {
                     for (int i = 0; i < partitionBuffers.length; i++) {
                         partitionBuffers[i].addPosition(position);
                     }
                     hasAnyRowBeenReplicated = true;
+                    shouldReplicateAnyRow = false; // Update after first replication
                 }
                 else {
                     int partition = partitionFunction.getPartition(partitionFunctionArgs, position);
@@ -587,17 +592,23 @@ public class OptimizedPartitionedOutputOperator
 
             initializeBlockEncodingBuffers(decodedBlocks);
 
+            // Setup all blocks first
             for (int i = 0; i < channelCount; i++) {
                 blockEncodingBuffers[i].setupDecodedBlocksAndPositions(decodedBlocks[i], positions, positionCount);
             }
 
-            populateSerializedRowSizes(fixedWidthRowSize, variableWidthChannels);
+            // Only populate serialized row sizes if we have variable width channels
+            if (!variableWidthChannels.isEmpty()) {
+                populateSerializedRowSizes(fixedWidthRowSize, variableWidthChannels);
+            }
 
             // Due to the limitation of buffer size, we append the data batch by batch
             int offset = 0;
-            do {
-                int batchSize = calculateNextBatchSize(fixedWidthRowSize, variableWidthChannels, offset);
+            int remaining = positionCount;
+            while (remaining > 0) {
+                int batchSize = calculateNextBatchSize(fixedWidthRowSize, variableWidthChannels, offset, remaining);
 
+                // Process all channels for this batch
                 for (int i = 0; i < channelCount; i++) {
                     blockEncodingBuffers[i].setNextBatch(offset, batchSize);
                     blockEncodingBuffers[i].appendDataInBatch();
@@ -605,13 +616,13 @@ public class OptimizedPartitionedOutputOperator
 
                 bufferedRowCount += batchSize;
                 offset += batchSize;
+                remaining -= batchSize;
 
                 if (bufferFull) {
                     flush(outputBuffer);
                     bufferFull = false;
                 }
             }
-            while (offset < positionCount);
         }
 
         private void initializeBlockEncodingBuffers(DecodedBlockNode[] decodedBlocks)
@@ -631,45 +642,55 @@ public class OptimizedPartitionedOutputOperator
          */
         private void populateSerializedRowSizes(int fixedWidthRowSize, List<Integer> variableWidthChannels)
         {
-            if (variableWidthChannels.isEmpty()) {
-                return;
-            }
-
             serializedRowSizes = ensureCapacity(serializedRowSizes, positionCount, SMALL, INITIALIZE);
 
-            for (int i : variableWidthChannels) {
-                blockEncodingBuffers[i].accumulateSerializedRowSizes(serializedRowSizes);
+            // Initialize with fixed width size
+            for (int i = 0; i < positionCount; i++) {
+                serializedRowSizes[i] = fixedWidthRowSize;
             }
 
-            for (int i = 0; i < positionCount; i++) {
-                serializedRowSizes[i] += fixedWidthRowSize;
+            // Accumulate variable width sizes
+            for (int i : variableWidthChannels) {
+                blockEncodingBuffers[i].accumulateSerializedRowSizes(serializedRowSizes);
             }
         }
 
-        private int calculateNextBatchSize(int fixedWidthRowSize, List<Integer> variableWidthChannels, int startPosition)
+        private int calculateNextBatchSize(int fixedWidthRowSize, List<Integer> variableWidthChannels, int startPosition, int remainingPositions)
         {
             int bytesRemaining = capacity - getSerializedBuffersSizeInBytes();
 
             if (variableWidthChannels.isEmpty()) {
-                int maxPositionsFit = max(bytesRemaining / fixedWidthRowSize, 1);
-                if (maxPositionsFit <= positionCount - startPosition) {
+                int maxPositionsFit = bytesRemaining / fixedWidthRowSize;
+                if (maxPositionsFit <= 0) {
+                    bufferFull = true;
+                    return 1;
+                }
+                if (maxPositionsFit < remainingPositions) {
                     bufferFull = true;
                     return maxPositionsFit;
                 }
-                return positionCount - startPosition;
+                return remainingPositions;
             }
 
             verify(serializedRowSizes != null);
-            for (int i = startPosition; i < positionCount; i++) {
-                bytesRemaining -= serializedRowSizes[i];
-
+            int positionsFit = 0;
+            for (int i = 0; i < remainingPositions; i++) {
+                bytesRemaining -= serializedRowSizes[startPosition + i];
                 if (bytesRemaining <= 0) {
                     bufferFull = true;
-                    return max(i - startPosition, 1);
+                    positionsFit = i;
+                    break;
                 }
+                positionsFit++;
             }
-
-            return positionCount - startPosition;
+            
+            // Ensure we always process at least one position
+            if (positionsFit == 0 && remainingPositions > 0) {
+                bufferFull = true;
+                return 1;
+            }
+            
+            return positionsFit > 0 ? positionsFit : remainingPositions;
         }
 
         private void flush(OutputBuffer outputBuffer)
@@ -678,7 +699,8 @@ public class OptimizedPartitionedOutputOperator
                 return;
             }
 
-            SliceOutput output = new DynamicSliceOutput(toIntExact(getSerializedBuffersSizeInBytes()));
+            int estimatedSize = getSerializedBuffersSizeInBytes();
+            SliceOutput output = new DynamicSliceOutput(estimatedSize);
             output.writeInt(channelCount);
 
             for (int i = 0; i < channelCount; i++) {
