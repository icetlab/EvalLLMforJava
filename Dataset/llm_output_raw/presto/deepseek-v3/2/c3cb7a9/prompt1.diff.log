Looking at the error, the search block for `findEndPosition` wasn't found because the original code in the file has slightly different formatting (indentation, line breaks). I need to adjust the search patterns to match the exact code in the file. Let me provide more precise search patterns that match the original code exactly.

The main performance improvements I'll focus on are:
1. Optimizing `findEndPosition` with an early exit for the common case where the group continues to the end
2. Reducing object allocations in `updatePagesIndex` by avoiding repeated channel extraction
3. Adding early exit in `sortPagesIndexIfNecessary` to avoid unnecessary sorting

Here are the corrected changes:

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java",
    "search": "    /**\n     * @param startPosition - inclusive\n     * @param endPosition   - exclusive\n     * @param comparator    - returns true if positions given as parameters are equal\n     * @return the end of the group position exclusive (the position the very next group starts)\n     */\n    @VisibleForTesting\n    static int findEndPosition(int startPosition, int endPosition, BiPredicate<Integer, Integer> comparator)\n    {\n        checkArgument(startPosition >= 0, \"startPosition must be greater or equal than zero: %s\", startPosition);\n        checkArgument(startPosition < endPosition, \"startPosition (%s) must be less than endPosition (%s)\", startPosition, endPosition);\n\n        int left = startPosition;\n        int right = endPosition;\n\n        while (left + 1 < right) {\n            int middle = (left + right) >>> 1;\n\n            if (comparator.test(startPosition, middle)) {\n                left = middle;\n            }\n            else {\n                right = middle;\n            }\n        }\n\n        return right;\n    }",
    "replace": "    /**\n     * @param startPosition - inclusive\n     * @param endPosition   - exclusive\n     * @param comparator    - returns true if positions given as parameters are equal\n     * @return the end of the group position exclusive (the position the very next group starts)\n     */\n    @VisibleForTesting\n    static int findEndPosition(int startPosition, int endPosition, BiPredicate<Integer, Integer> comparator)\n    {\n        checkArgument(startPosition >= 0, \"startPosition must be greater or equal than zero: %s\", startPosition);\n        checkArgument(startPosition < endPosition, \"startPosition (%s) must be less than endPosition (%s)\", startPosition, endPosition);\n\n        // Optimize for common case where group continues to the end\n        if (comparator.test(startPosition, endPosition - 1)) {\n            return endPosition;\n        }\n\n        int left = startPosition;\n        int right = endPosition;\n\n        while (left + 1 < right) {\n            int middle = (left + right) >>> 1;\n\n            if (comparator.test(startPosition, middle)) {\n                left = middle;\n            }\n            else {\n                right = middle;\n            }\n        }\n\n        return right;\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java",
    "search": "    private int updatePagesIndex(PagesIndexWithHashStrategies pagesIndexWithHashStrategies, Page page, int startPosition, Optional<Page> currentSpillGroupRowPage)\n    {\n        checkArgument(page.getPositionCount() > startPosition);\n\n        // TODO: Fix pagesHashStrategy to allow specifying channels for comparison, it currently requires us to rearrange the right side blocks in consecutive channel order\n        Page preGroupedPage = page.extractChannels(pagesIndexWithHashStrategies.preGroupedPartitionChannels);\n\n        PagesIndex pagesIndex = pagesIndexWithHashStrategies.pagesIndex;\n        PagesHashStrategy preGroupedPartitionHashStrategy = pagesIndexWithHashStrategies.preGroupedPartitionHashStrategy;\n        if (currentSpillGroupRowPage.isPresent()) {\n            if (!preGroupedPartitionHashStrategy.rowEqualsRow(0, currentSpillGroupRowPage.get().extractChannels(pagesIndexWithHashStrategies.preGroupedPartitionChannels), startPosition, preGroupedPage)) {\n                return startPosition;\n            }\n        }\n\n        if (pagesIndex.getPositionCount() == 0 || pagesIndex.positionEqualsRow(preGroupedPartitionHashStrategy, 0, startPosition, preGroupedPage)) {\n            // Find the position where the pre-grouped columns change\n            int groupEnd = findGroupEnd(preGroupedPage, preGroupedPartitionHashStrategy, startPosition);\n\n            // Add the section of the page that contains values for the current group\n            pagesIndex.addPage(page.getRegion(startPosition, groupEnd - startPosition));\n\n            if (page.getPositionCount() - groupEnd > 0) {\n                // Save the remaining page, which may contain multiple partitions\n                return groupEnd;\n            }\n            else {\n                // Page fully consumed\n                return page.getPositionCount();\n            }\n        }\n        else {\n            // We had previous results buffered, but the remaining page starts with new group values\n            return startPosition;\n        }\n    }",
    "replace": "    private int updatePagesIndex(PagesIndexWithHashStrategies pagesIndexWithHashStrategies, Page page, int startPosition, Optional<Page> currentSpillGroupRowPage)\n    {\n        checkArgument(page.getPositionCount() > startPosition);\n\n        PagesIndex pagesIndex = pagesIndexWithHashStrategies.pagesIndex;\n        PagesHashStrategy preGroupedPartitionHashStrategy = pagesIndexWithHashStrategies.preGroupedPartitionHashStrategy;\n        \n        if (currentSpillGroupRowPage.isPresent()) {\n            // Cache extracted channels to avoid repeated extraction\n            Page spillGroupChannels = currentSpillGroupRowPage.get().extractChannels(pagesIndexWithHashStrategies.preGroupedPartitionChannels);\n            // TODO: Fix pagesHashStrategy to allow specifying channels for comparison, it currently requires us to rearrange the right side blocks in consecutive channel order\n            Page preGroupedPage = page.extractChannels(pagesIndexWithHashStrategies.preGroupedPartitionChannels);\n            if (!preGroupedPartitionHashStrategy.rowEqualsRow(0, spillGroupChannels, startPosition, preGroupedPage)) {\n                return startPosition;\n            }\n        }\n\n        // TODO: Fix pagesHashStrategy to allow specifying channels for comparison, it currently requires us to rearrange the right side blocks in consecutive channel order\n        Page preGroupedPage = page.extractChannels(pagesIndexWithHashStrategies.preGroupedPartitionChannels);\n        if (pagesIndex.getPositionCount() == 0 || pagesIndex.positionEqualsRow(preGroupedPartitionHashStrategy, 0, startPosition, preGroupedPage)) {\n            // Find the position where the pre-grouped columns change\n            int groupEnd = findGroupEnd(preGroupedPage, preGroupedPartitionHashStrategy, startPosition);\n\n            // Add the section of the page that contains values for the current group\n            pagesIndex.addPage(page.getRegion(startPosition, groupEnd - startPosition));\n\n            if (page.getPositionCount() - groupEnd > 0) {\n                // Save the remaining page, which may contain multiple partitions\n                return groupEnd;\n            }\n            else {\n                // Page fully consumed\n                return page.getPositionCount();\n            }\n        }\n        else {\n            // We had previous results buffered, but the remaining page starts with new group values\n            return startPosition;\n        }\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java",
    "search": "    private void sortPagesIndexIfNecessary(PagesIndexWithHashStrategies pagesIndexWithHashStrategies, List<Integer> orderChannels, List<SortOrder> ordering)\n    {\n        if (pagesIndexWithHashStrategies.pagesIndex.getPositionCount() > 1 && !orderChannels.isEmpty()) {\n            int startPosition = 0;\n            while (startPosition < pagesIndexWithHashStrategies.pagesIndex.getPositionCount()) {\n                int endPosition = findGroupEnd(pagesIndexWithHashStrategies.pagesIndex, pagesIndexWithHashStrategies.preSortedPartitionHashStrategy, startPosition);\n                pagesIndexWithHashStrategies.pagesIndex.sort(orderChannels, ordering, startPosition, endPosition);\n                startPosition = endPosition;\n            }\n        }\n    }",
    "replace": "    private void sortPagesIndexIfNecessary(PagesIndexWithHashStrategies pagesIndexWithHashStrategies, List<Integer> orderChannels, List<SortOrder> ordering)\n    {\n        int positionCount = pagesIndexWithHashStrategies.pagesIndex.getPositionCount();\n        if (positionCount > 1 && !orderChannels.isEmpty()) {\n            int startPosition = 0;\n            while (startPosition < positionCount) {\n                int endPosition = findGroupEnd(pagesIndexWithHashStrategies.pagesIndex, pagesIndexWithHashStrategies.preSortedPartitionHashStrategy, startPosition);\n                if (endPosition - startPosition > 1) {\n                    pagesIndexWithHashStrategies.pagesIndex.sort(orderChannels, ordering, startPosition, endPosition);\n                }\n                startPosition = endPosition;\n            }\n        }\n    }"
  }
]
```