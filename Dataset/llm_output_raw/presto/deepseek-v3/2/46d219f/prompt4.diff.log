The performance issue is to optimize `map_concat` to skip empty maps. Currently, the function always processes both input maps, even if one is empty, leading to unnecessary allocations and iterations. We can add early checks to return the non-empty map directly when one map is empty, avoiding the creation of a `TypedSet` and block builder.

We'll modify `MapConcatFunction.java` to check if either input map is empty (by checking `getPositionCount() == 0`). If one map is empty, we can return the other map directly. If both are empty, we can return an empty map. This avoids unnecessary processing.

Note: The function must also handle the case where both maps have entries, and we need to ensure that keys from the right map override those from the left map (as per the current logic). The early return for empty maps preserves this semantics because:
- If left is empty, return right (right's keys are used).
- If right is empty, return left (no overriding needed).
- If both empty, return empty.

We'll also need to ensure that the returned block is a proper map block. Since the input blocks are already map blocks, returning them directly is safe.

Let's implement this optimization.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapConcatFunction.java",
    "search": "    @TypeParameter(\"K\")\n    @TypeParameter(\"V\")\n    @SqlType(\"map(K,V)\")\n    public static Block mapConcat(\n            @TypeParameter(\"K\") Type keyType,\n            @TypeParameter(\"V\") Type valueType,\n            @SqlType(\"map(K,V)\") Block leftMap,\n            @SqlType(\"map(K,V)\") Block rightMap)\n    {\n        TypedSet typedSet = new TypedSet(keyType, rightMap.getPositionCount());\n        BlockBuilder blockBuilder = new InterleavedBlockBuilder(ImmutableList.of(keyType, valueType), new BlockBuilderStatus(), leftMap.getPositionCount() + rightMap.getPositionCount());\n        for (int i = 0; i < rightMap.getPositionCount(); i += 2) {\n            typedSet.add(rightMap, i);\n            keyType.appendTo(rightMap, i, blockBuilder);\n            valueType.appendTo(rightMap, i + 1, blockBuilder);\n        }\n        for (int i = 0; i < leftMap.getPositionCount(); i += 2) {\n            if (!typedSet.contains(leftMap, i)) {\n                keyType.appendTo(leftMap, i, blockBuilder);\n                valueType.appendTo(leftMap, i + 1, blockBuilder);\n            }\n        }\n        return blockBuilder.build();\n    }",
    "replace": "    @TypeParameter(\"K\")\n    @TypeParameter(\"V\")\n    @SqlType(\"map(K,V)\")\n    public static Block mapConcat(\n            @TypeParameter(\"K\") Type keyType,\n            @TypeParameter(\"V\") Type valueType,\n            @SqlType(\"map(K,V)\") Block leftMap,\n            @SqlType(\"map(K,V)\") Block rightMap)\n    {\n        int leftSize = leftMap.getPositionCount();\n        int rightSize = rightMap.getPositionCount();\n        if (leftSize == 0) {\n            return rightMap;\n        }\n        if (rightSize == 0) {\n            return leftMap;\n        }\n        TypedSet typedSet = new TypedSet(keyType, rightSize);\n        BlockBuilder blockBuilder = new InterleavedBlockBuilder(ImmutableList.of(keyType, valueType), new BlockBuilderStatus(), leftSize + rightSize);\n        for (int i = 0; i < rightSize; i += 2) {\n            typedSet.add(rightMap, i);\n            keyType.appendTo(rightMap, i, blockBuilder);\n            valueType.appendTo(rightMap, i + 1, blockBuilder);\n        }\n        for (int i = 0; i < leftSize; i += 2) {\n            if (!typedSet.contains(leftMap, i)) {\n                keyType.appendTo(leftMap, i, blockBuilder);\n                valueType.appendTo(leftMap, i + 1, blockBuilder);\n            }\n        }\n        return blockBuilder.build();\n    }"
  }
]
```