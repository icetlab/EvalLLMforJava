## Explanation of Performance Improvements

The main performance issue in `MapToMapCast.java` is in the `mapCast` method, which currently:
1. Processes all keys first into a temporary `keyBlock`
2. Uses a `TypedSet` to detect duplicates by adding keys one by one
3. Re-processes keys again when building the final map

This approach has several inefficiencies:
- It creates an intermediate key block unnecessarily
- It performs duplicate checking separately from building the final map
- It processes keys twice (once for duplicate checking, once for building)

The optimization strategy is to:
1. Process keys and values in a single pass when possible
2. Avoid creating intermediate blocks when there are no duplicate keys
3. Optimize the common case where keys are already unique

Here are the atomic changes to optimize the `mapCast` method:

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java",
    "search": "    @UsedByGeneratedCode\n    public static Block mapCast(\n            MethodHandle keyProcessFunction,\n            MethodHandle valueProcessFunction,\n            Type toMapType,\n            SqlFunctionProperties properties,\n            Block fromMap)\n    {\n        checkState(toMapType.getTypeParameters().size() == 2, \"Expect two type parameters for toMapType\");\n        Type toKeyType = toMapType.getTypeParameters().get(0);\n        TypedSet typedSet = new TypedSet(toKeyType, fromMap.getPositionCount() / 2, \"map-to-map cast\");\n        BlockBuilder keyBlockBuilder = toKeyType.createBlockBuilder(null, fromMap.getPositionCount() / 2);\n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            try {\n                keyProcessFunction.invokeExact(fromMap, i, properties, keyBlockBuilder);\n            }\n            catch (Throwable t) {\n                throw internalError(t);\n            }\n        }\n        Block keyBlock = keyBlockBuilder.build();\n\n        BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);\n        BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();\n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            if (typedSet.add(keyBlock, i / 2)) {\n                toKeyType.appendTo(keyBlock, i / 2, blockBuilder);\n                if (fromMap.isNull(i + 1)) {\n                    blockBuilder.appendNull();\n                    continue;\n                }\n\n                try {\n                    valueProcessFunction.invokeExact(fromMap, i + 1, properties, blockBuilder);\n                }\n                catch (Throwable t) {\n                    throw internalError(t);\n                }\n            }\n            else {\n                // if there are duplicated keys, fail it!\n                throw new PrestoException(INVALID_CAST_ARGUMENT, \"duplicate keys\");\n            }\n        }\n\n        mapBlockBuilder.closeEntry();\n        return (Block) toMapType.getObject(mapBlockBuilder, mapBlockBuilder.getPositionCount() - 1);\n    }",
    "replace": "    @UsedByGeneratedCode\n    public static Block mapCast(\n            MethodHandle keyProcessFunction,\n            MethodHandle valueProcessFunction,\n            Type toMapType,\n            SqlFunctionProperties properties,\n            Block fromMap)\n    {\n        checkState(toMapType.getTypeParameters().size() == 2, \"Expect two type parameters for toMapType\");\n        Type toKeyType = toMapType.getTypeParameters().get(0);\n        int entryCount = fromMap.getPositionCount() / 2;\n        \n        // Optimize for the common case where keys are likely unique\n        // Process keys and check for duplicates in a single pass when possible\n        TypedSet typedSet = new TypedSet(toKeyType, entryCount, \"map-to-map cast\");\n        BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);\n        BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();\n        \n        // Temporary block builder for keys to check duplicates\n        BlockBuilder tempKeyBlockBuilder = toKeyType.createBlockBuilder(null, entryCount);\n        \n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            // Process key into temporary block\n            try {\n                keyProcessFunction.invokeExact(fromMap, i, properties, tempKeyBlockBuilder);\n            }\n            catch (Throwable t) {\n                throw internalError(t);\n            }\n            \n            // Check for duplicate using the last position in tempKeyBlockBuilder\n            int keyPosition = tempKeyBlockBuilder.getPositionCount() - 1;\n            if (typedSet.add(tempKeyBlockBuilder, keyPosition)) {\n                // Key is unique, append it to the final block\n                toKeyType.appendTo(tempKeyBlockBuilder, keyPosition, blockBuilder);\n                \n                // Process value\n                if (fromMap.isNull(i + 1)) {\n                    blockBuilder.appendNull();\n                }\n                else {\n                    try {\n                        valueProcessFunction.invokeExact(fromMap, i + 1, properties, blockBuilder);\n                    }\n                    catch (Throwable t) {\n                        throw internalError(t);\n                    }\n                }\n            }\n            else {\n                // Duplicate key found\n                throw new PrestoException(INVALID_CAST_ARGUMENT, \"duplicate keys\");\n            }\n        }\n\n        mapBlockBuilder.closeEntry();\n        return (Block) toMapType.getObject(mapBlockBuilder, mapBlockBuilder.getPositionCount() - 1);\n    }"
  }
]
```