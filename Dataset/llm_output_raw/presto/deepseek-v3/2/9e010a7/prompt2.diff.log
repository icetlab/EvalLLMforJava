Looking at the `MapToMapCast.java` file, I can see that the `mapCast` method currently processes keys and values in a way that could be optimized for common cases. The current implementation:

1. First processes all keys into a temporary `keyBlock`
2. Uses a `TypedSet` to check for duplicates while building the final map
3. Processes values only for unique keys

The performance issue is that we're processing keys twice: once to build the `keyBlock` and once when adding to the `TypedSet`. For common cases where there are no duplicate keys, we can optimize this by processing keys and values together in a single pass.

Here are the optimizations I'll make:

1. **Single-pass processing**: Instead of first processing all keys into a temporary block and then processing values, we can process keys and values together in a single pass when there are no duplicates.

2. **Early duplicate detection**: We can still detect duplicates early without building a separate key block first.

3. **Optimize for the common case**: Most maps don't have duplicate keys, so we should optimize for that case.

Here are the changes:

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java",
    "search": "    @UsedByGeneratedCode\n    public static Block mapCast(\n            MethodHandle keyProcessFunction,\n            MethodHandle valueProcessFunction,\n            Type toMapType,\n            SqlFunctionProperties properties,\n            Block fromMap)\n    {\n        checkState(toMapType.getTypeParameters().size() == 2, \"Expect two type parameters for toMapType\");\n        Type toKeyType = toMapType.getTypeParameters().get(0);\n        TypedSet typedSet = new TypedSet(toKeyType, fromMap.getPositionCount() / 2, \"map-to-map cast\");\n        BlockBuilder keyBlockBuilder = toKeyType.createBlockBuilder(null, fromMap.getPositionCount() / 2);\n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            try {\n                keyProcessFunction.invokeExact(fromMap, i, properties, keyBlockBuilder);\n            }\n            catch (Throwable t) {\n                throw internalError(t);\n            }\n        }\n        Block keyBlock = keyBlockBuilder.build();\n\n        BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);\n        BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();\n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            if (typedSet.add(keyBlock, i / 2)) {\n                toKeyType.appendTo(keyBlock, i / 2, blockBuilder);\n                if (fromMap.isNull(i + 1)) {\n                    blockBuilder.appendNull();\n                    continue;\n                }\n\n                try {\n                    valueProcessFunction.invokeExact(fromMap, i + 1, properties, blockBuilder);\n                }\n                catch (Throwable t) {\n                    throw internalError(t);\n                }\n            }\n            else {\n                // if there are duplicated keys, fail it!\n                throw new PrestoException(INVALID_CAST_ARGUMENT, \"duplicate keys\");\n            }\n        }\n\n        mapBlockBuilder.closeEntry();\n        return (Block) toMapType.getObject(mapBlockBuilder, mapBlockBuilder.getPositionCount() - 1);\n    }",
    "replace": "    @UsedByGeneratedCode\n    public static Block mapCast(\n            MethodHandle keyProcessFunction,\n            MethodHandle valueProcessFunction,\n            Type toMapType,\n            SqlFunctionProperties properties,\n            Block fromMap)\n    {\n        checkState(toMapType.getTypeParameters().size() == 2, \"Expect two type parameters for toMapType\");\n        Type toKeyType = toMapType.getTypeParameters().get(0);\n        int entryCount = fromMap.getPositionCount() / 2;\n        TypedSet typedSet = new TypedSet(toKeyType, entryCount, \"map-to-map cast\");\n        \n        BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);\n        BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();\n        \n        // Temporary block builder for keys to check duplicates\n        BlockBuilder keyBlockBuilder = toKeyType.createBlockBuilder(null, entryCount);\n        \n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            // Process key into temporary block builder\n            try {\n                keyProcessFunction.invokeExact(fromMap, i, properties, keyBlockBuilder);\n            }\n            catch (Throwable t) {\n                throw internalError(t);\n            }\n            \n            // Check if this key is a duplicate\n            if (typedSet.add(keyBlockBuilder, keyBlockBuilder.getPositionCount() - 1)) {\n                // Not a duplicate - append the key to the final block\n                toKeyType.appendTo(keyBlockBuilder, keyBlockBuilder.getPositionCount() - 1, blockBuilder);\n                \n                // Process the value\n                if (fromMap.isNull(i + 1)) {\n                    blockBuilder.appendNull();\n                }\n                else {\n                    try {\n                        valueProcessFunction.invokeExact(fromMap, i + 1, properties, blockBuilder);\n                    }\n                    catch (Throwable t) {\n                        throw internalError(t);\n                    }\n                }\n            }\n            else {\n                // Duplicate key found - fail\n                throw new PrestoException(INVALID_CAST_ARGUMENT, \"duplicate keys\");\n            }\n        }\n\n        mapBlockBuilder.closeEntry();\n        return (Block) toMapType.getObject(mapBlockBuilder, mapBlockBuilder.getPositionCount() - 1);\n    }"
  }
]
```