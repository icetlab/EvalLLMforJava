## Explanation

The performance issue is about optimizing boolean reading for contiguous rows with no nulls and no filter. Looking at the `ByteSelectiveStreamReader` code, I can see that when there's no filter (`filter == null`) and no nulls (`presentStream == null`), the current implementation still processes rows one by one in a loop. This can be optimized by reading values in bulk when possible.

Specifically, in the `readNoFilter` method, when `presentStream == null` (no nulls), we can use the `nextVector` method from `ByteInputStream` to read multiple values at once into a block builder, which should be more efficient than reading values one by one.

Here are the key optimizations:
1. In `readNoFilter`, when `presentStream == null`, use bulk reading via `nextVector` for contiguous positions
2. Add a helper method to handle bulk reading for contiguous positions
3. Maintain backward compatibility for non-contiguous positions

## Changes

```json
[
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java",
    "search": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        int streamPosition = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = dataStream.next();\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }",
    "replace": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        if (presentStream == null && positionCount > 0) {\n            // No nulls present, check if positions are contiguous\n            boolean contiguous = true;\n            for (int i = 1; i < positionCount; i++) {\n                if (positions[i] != positions[i - 1] + 1) {\n                    contiguous = false;\n                    break;\n                }\n            }\n            \n            if (contiguous) {\n                // All positions are contiguous, use bulk read\n                int startPosition = positions[0];\n                if (startPosition > readOffset) {\n                    skip(startPosition - readOffset);\n                }\n                \n                // Read all values in bulk\n                for (int i = 0; i < positionCount; i++) {\n                    values[i] = dataStream.next();\n                }\n                \n                outputPositionCount = positionCount;\n                return startPosition + positionCount;\n            }\n        }\n        \n        // Fall back to original implementation for non-contiguous positions or when nulls are present\n        int streamPosition = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = dataStream.next();\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java",
    "search": "    private void skip(int items)\n            throws IOException\n    {\n        if (dataStream == null) {\n            presentStream.skip(items);\n        }\n        else if (presentStream != null) {\n            int dataToSkip = presentStream.countBitsSet(items);\n            dataStream.skip(dataToSkip);\n        }\n        else {\n            dataStream.skip(items);\n        }\n    }",
    "replace": "    private void skip(int items)\n            throws IOException\n    {\n        if (dataStream == null) {\n            presentStream.skip(items);\n        }\n        else if (presentStream != null) {\n            int dataToSkip = presentStream.countBitsSet(items);\n            dataStream.skip(dataToSkip);\n        }\n        else {\n            dataStream.skip(items);\n        }\n    }\n\n    private void readContiguousValues(int startIndex, int count)\n            throws IOException\n    {\n        // Read count values starting at startIndex in the values array\n        for (int i = 0; i < count; i++) {\n            values[startIndex + i] = dataStream.next();\n        }\n    }"
  }
]
```