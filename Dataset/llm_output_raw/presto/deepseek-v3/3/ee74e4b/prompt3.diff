diff --git a/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java b/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java
index 979fc2cb80..fc80d0d1a6 100644
--- a/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java
+++ b/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java
@@ -216,23 +216,28 @@ public class PageProcessor
 
                 // if we produced a large page or if the expression is expensive, halve the batch size for the next call
                 long pageSize = resultPage.getSizeInBytes();
-                if (resultPage.getPositionCount() > 1 && (pageSize > MAX_PAGE_SIZE_IN_BYTES || expressionProfiler.isExpressionExpensive())) {
-                    projectBatchSize = projectBatchSize / 2;
-                }
-
-                // if we produced a small page, double the batch size for the next call
-                if (pageSize < MIN_PAGE_SIZE_IN_BYTES && projectBatchSize < MAX_BATCH_SIZE && !expressionProfiler.isExpressionExpensive()) {
-                    projectBatchSize = projectBatchSize * 2;
+                int positionCount = resultPage.getPositionCount();
+                if (positionCount > 1) {
+                    boolean expensive = expressionProfiler.isExpressionExpensive();
+                    if (pageSize > MAX_PAGE_SIZE_IN_BYTES || expensive) {
+                        projectBatchSize = projectBatchSize / 2;
+                    }
+                    else if (pageSize < MIN_PAGE_SIZE_IN_BYTES && projectBatchSize < MAX_BATCH_SIZE && !expensive) {
+                        projectBatchSize = projectBatchSize * 2;
+                    }
                 }
 
                 // remove batch from selectedPositions and previouslyComputedResults
                 selectedPositions = selectedPositions.subRange(batchSize, selectedPositions.size());
-                for (int i = 0; i < previouslyComputedResults.length; i++) {
-                    if (previouslyComputedResults[i] != null && previouslyComputedResults[i].getPositionCount() > batchSize) {
-                        previouslyComputedResults[i] = previouslyComputedResults[i].getRegion(batchSize, previouslyComputedResults[i].getPositionCount() - batchSize);
+                Block[] previousResults = previouslyComputedResults;
+                int resultsLength = previousResults.length;
+                for (int i = 0; i < resultsLength; i++) {
+                    Block block = previousResults[i];
+                    if (block != null && block.getPositionCount() > batchSize) {
+                        previousResults[i] = block.getRegion(batchSize, block.getPositionCount() - batchSize);
                     }
                     else {
-                        previouslyComputedResults[i] = null;
+                        previousResults[i] = null;
                     }
                 }
 
@@ -257,7 +262,8 @@ public class PageProcessor
             // increment the size only when it is the first reference
             retainedSizeInBytes = Page.INSTANCE_SIZE + SizeOf.sizeOfObjectArray(page.getChannelCount());
             ReferenceCountMap referenceCountMap = new ReferenceCountMap();
-            for (int channel = 0; channel < page.getChannelCount(); channel++) {
+            int channelCount = page.getChannelCount();
+            for (int channel = 0; channel < channelCount; channel++) {
                 Block block = page.getBlock(channel);
                 if (!isNotLoadedLazyBlock(block)) {
                     block.retainedBytesForEachPart((object, size) -> {
@@ -286,21 +292,24 @@ public class PageProcessor
 
             int pageSize = 0;
             SelectedPositions positionsBatch = selectedPositions.subRange(0, batchSize);
+            int batchPositionCount = positionsBatch.size();
             for (PageProjectionWithOutputs projection : projections) {
                 if (yieldSignal.isSet()) {
                     return ProcessBatchResult.processBatchYield();
                 }
 
-                if (positionsBatch.size() > 1 && pageSize > MAX_PAGE_SIZE_IN_BYTES) {
+                if (batchPositionCount > 1 && pageSize > MAX_PAGE_SIZE_IN_BYTES) {
                     return ProcessBatchResult.processBatchTooLarge();
                 }
 
                 // if possible, use previouslyComputedResults produced in prior optimistic failure attempt
                 int[] outputChannels = projection.getOutputChannels();
                 // The progress on all output channels of a projection should be the same, so we just use the first one.
-                if (previouslyComputedResults[outputChannels[0]] != null && previouslyComputedResults[outputChannels[0]].getPositionCount() >= batchSize) {
+                Block firstBlock = previouslyComputedResults[outputChannels[0]];
+                if (firstBlock != null && firstBlock.getPositionCount() >= batchSize) {
                     for (int channel : outputChannels) {
-                        blocks[channel] = previouslyComputedResults[channel].getRegion(0, batchSize);
+                        Block block = previouslyComputedResults[channel];
+                        blocks[channel] = block.getRegion(0, batchSize);
                         pageSize += blocks[channel].getSizeInBytes();
                     }
                 }
@@ -308,7 +317,7 @@ public class PageProcessor
                     if (pageProjectWork == null) {
                         expressionProfiler.start();
                         pageProjectWork = projection.project(properties, yieldSignal, projection.getPageProjection().getInputChannels().getInputChannels(page), positionsBatch);
-                        expressionProfiler.stop(positionsBatch.size());
+                        expressionProfiler.stop(batchPositionCount);
                     }
                     if (!pageProjectWork.process()) {
                         return ProcessBatchResult.processBatchYield();
@@ -316,14 +325,15 @@ public class PageProcessor
                     List<Block> projectionOutputs = pageProjectWork.getResult();
                     for (int j = 0; j < outputChannels.length; j++) {
                         int channel = outputChannels[j];
-                        previouslyComputedResults[channel] = projectionOutputs.get(j);
-                        blocks[channel] = previouslyComputedResults[channel];
-                        pageSize += blocks[channel].getSizeInBytes();
+                        Block block = projectionOutputs.get(j);
+                        previouslyComputedResults[channel] = block;
+                        blocks[channel] = block;
+                        pageSize += block.getSizeInBytes();
                     }
                     pageProjectWork = null;
                 }
             }
-            return ProcessBatchResult.processBatchSuccess(new Page(positionsBatch.size(), blocks));
+            return ProcessBatchResult.processBatchSuccess(new Page(batchPositionCount, blocks));
         }
     }
 
