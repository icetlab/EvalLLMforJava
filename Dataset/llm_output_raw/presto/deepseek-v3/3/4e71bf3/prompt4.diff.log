## Explanation

The performance issue is to optimize boolean reading when reading contiguous rows with no nulls and no filter. Looking at the `ByteSelectiveStreamReader` code, I can see that in the `readNoFilter` method (which handles the case when there's no filter), there's an opportunity to optimize the reading of contiguous values. Currently, it reads values one by one even when there are no nulls present and no filter applied.

The main optimization opportunity is in the `readNoFilter` method where we can add a fast path for contiguous rows without nulls. When `presentStream` is null (indicating no nulls in the data), we can read values in bulk using the data stream directly into the values array.

Here are the specific changes:

1. **Optimize `readNoFilter` method**: Add a fast path for contiguous rows when there are no nulls (`presentStream == null`). In this case, we can read multiple values at once using a bulk read operation.

2. **Add bulk read method to `ByteInputStream`**: To support the optimization, we need to add a `next` method that can read multiple bytes at once into a byte array.

## Changes

```json
[
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java",
    "search": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        int streamPosition = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = dataStream.next();\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }",
    "replace": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        int streamPosition = 0;\n        \n        // Fast path: contiguous rows with no nulls\n        if (presentStream == null && positions.length > 0) {\n            // Check if positions are contiguous\n            boolean isContiguous = true;\n            for (int i = 0; i < positionCount; i++) {\n                if (positions[i] != streamPosition + i) {\n                    isContiguous = false;\n                    break;\n                }\n            }\n            \n            if (isContiguous) {\n                // Bulk read all values at once\n                dataStream.next(values, 0, positionCount);\n                outputPositionCount = positionCount;\n                return positions[positionCount - 1] + 1;\n            }\n        }\n        \n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = dataStream.next();\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/stream/ByteInputStream.java",
    "search": "    public byte next()\n            throws IOException\n    {\n        if (offset == length) {\n            readNextBlock();\n        }\n        return buffer[offset++];\n    }",
    "replace": "    public byte next()\n            throws IOException\n    {\n        if (offset == length) {\n            readNextBlock();\n        }\n        return buffer[offset++];\n    }\n\n    public void next(byte[] values, int offset, int length)\n            throws IOException\n    {\n        int remaining = length;\n        int destOffset = offset;\n        \n        while (remaining > 0) {\n            if (this.offset == this.length) {\n                readNextBlock();\n            }\n            \n            int chunkSize = Math.min(remaining, this.length - this.offset);\n            System.arraycopy(buffer, this.offset, values, destOffset, chunkSize);\n            \n            this.offset += chunkSize;\n            destOffset += chunkSize;\n            remaining -= chunkSize;\n        }\n    }"
  }
]
```