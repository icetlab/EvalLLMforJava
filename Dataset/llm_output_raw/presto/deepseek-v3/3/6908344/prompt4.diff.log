The performance issue indicates that we should avoid serializing the ESRI Point type that is needed to determine the type of a point (2D, 3D, with ID, etc.) during deserialization. Looking at the code, the current implementation in `GeometrySerde.java` uses `OperatorImportFromESRIShape.local().execute(...)` to deserialize simple geometries, which likely involves parsing the full ESRI shape including the point type metadata. However, for points, we can directly read the coordinates from the serialized bytes without invoking the ESRI shape import, which is more expensive.

Specifically, in `readSimpleGeometry`, we can handle `POINT` type separately by directly reading the coordinates from the buffer (similar to what `getPointEnvelope` does) and constructing an `OGCPoint` or `OGCMultiPoint` accordingly. This avoids the overhead of the ESRI shape import for points.

We also need to update `JtsGeometrySerde.java` similarly because it also deserializes points using the same ESRI shape format.

Let's break down the changes:

1. In `GeometrySerde.java`, modify `readSimpleGeometry` to handle `POINT` type separately by reading the coordinates directly from the buffer.
2. In `JtsGeometrySerde.java`, modify `readPoint` to skip the ESRI type and read coordinates directly (it already does that, but we need to ensure it's used for points in `readSimpleGeometry`? Actually, `JtsGeometrySerde` already has a separate `readPoint` method that reads directly. However, the `readSimpleGeometry` equivalent is `readGeometry` which calls `readPoint` for `POINT` type. That seems fine. But we should also avoid the ESRI shape import for points in `GeometrySerde`.

But note: The benchmark shows that we are also concerned with `MULTI_POINT`. However, the issue specifically mentions "ESRI Point type". For multi-point, we still need to parse multiple points, but we can still avoid the ESRI shape import by reading the coordinates directly.

However, the ESRI shape for multi-point includes an envelope and point count. We can parse that directly as well. But the current `readSimpleGeometry` uses `OperatorImportFromESRIShape` for all simple geometries. We can extend the optimization to `MULTI_POINT` as well.

But note: The `createFromEsriGeometry` method also handles the logic of converting to single vs multi-type. We need to replicate that logic when reading directly.

Given the complexity, let's start with optimizing `POINT` only, as it's the simplest and most frequent case.

We'll change `readSimpleGeometry` to check if the type is `POINT` and then read the coordinates directly, constructing an `OGCPoint` or `OGCMultiPoint` based on the `multiType` flag.

Similarly, for `MULTI_POINT`, we can read the envelope and point count, then read each point coordinate, and construct a `MultiPoint` geometry.

But note: The `multiType` flag passed to `createFromEsriGeometry` is based on the `GeometryType` (i.e., `type.isMultitype()`). For `POINT`, `isMultitype` returns false, so we always create an `OGCPoint`. For `MULTI_POINT`, `isMultitype` returns true, so we create an `OGCMultiPoint`. However, there is also logic in `createFromEsriGeometry` that if the geometry is a `MultiPoint` with a single point, it returns an `OGCPoint`. We need to replicate that.

Alternatively, we can still use `createFromEsriGeometry` but pass a geometry we construct manually. However, constructing an ESRI `Point` or `MultiPoint` directly might still be cheaper than importing from shape.

Let's look at the ESRI shape format for points:
- For a point: shape type (int) + x (double) + y (double)
- For a multi-point: shape type (int) + envelope (4 doubles) + point count (int) + points (x,y for each)

We can read these directly and create ESRI geometry objects.

But note: The `OperatorImportFromESRIShape` is also used for other geometry types. We are only optimizing points.

Let's implement:

In `GeometrySerde.readSimpleGeometry`:
- If type is `POINT`, read the shape type (skip 4 bytes), then read x and y. If coordinates are NaN, return empty point. Otherwise, create a `Point` and then call `createFromEsriGeometry` with `multiType=false`.
- If type is `MULTI_POINT`, read the shape type, envelope (skip 4 doubles), point count, then read each point. Create a `MultiPoint` and call `createFromEsriGeometry` with `multiType=true`.

But note: The `createFromEsriGeometry` method also handles the case where a `MultiPoint` has a single point and returns an `OGCPoint`. So we can rely on that.

However, we are constructing the geometry ourselves, so we can directly call `new OGCPoint` or `new OGCMultiPoint` as appropriate.

But to keep the code consistent and avoid duplication, we can still use `createFromEsriGeometry` with our constructed geometry.

Let's do it step by step.

First, we need to add a helper method to read a point from a ByteBuffer.

But note: The input is a `BasicSliceInput` and we have a `ByteBuffer` slice. We can read from the ByteBuffer directly.

Alternatively, we can read from the `BasicSliceInput` because we already have the current position and length.

We'll change `readSimpleGeometry` to handle `POINT` and `MULTI_POINT` separately, and for other types, fall back to the original ESRI import.

We'll also need to update `getPointEnvelope` and `getSimpleGeometryEnvelope` because they are used for envelope deserialization. However, they already read directly without importing. So no change needed there.

Now, let's write the changes.

We'll create two changes: one for `GeometrySerde.java` and one for `JtsGeometrySerde.java` (though JTS already reads directly, but we should ensure it's consistent).

However, the issue is about avoiding ESRI Point type serialization. The JTS serde already reads points directly (see `readPoint`). So we don't need to change JTS.

But we should also update `JtsGeometrySerde` to handle multi-point directly? It already does in `readMultiPoint`.

So only `GeometrySerde` needs changes.

Let's write the change for `GeometrySerde.java`.

We'll modify `readSimpleGeometry` to handle `POINT` and `MULTI_POINT` separately.

We'll also need to import the `Point` and `MultiPoint` classes from `com.esri.core.geometry`.

Now, let's output the changes in the required JSON format.

```json
[
  {
    "filepath": "../presto/presto-geospatial-toolkit/src/main/java/com/facebook/presto/geospatial/GeometrySerde.java",
    "search": "    private static OGCGeometry readSimpleGeometry(BasicSliceInput input, Slice inputSlice, GeometryType type, int length)\n    {\n        int currentPosition = toIntExact(input.position());\n        ByteBuffer geometryBuffer = inputSlice.toByteBuffer(currentPosition, length).slice();\n        input.setPosition(currentPosition + length);\n        Geometry esriGeometry = OperatorImportFromESRIShape.local().execute(0, Unknown, geometryBuffer);\n        return createFromEsriGeometry(esriGeometry, type.isMultitype());\n    }",
    "replace": "    private static OGCGeometry readSimpleGeometry(BasicSliceInput input, Slice inputSlice, GeometryType type, int length)\n    {\n        if (type == GeometryType.POINT) {\n            // Skip shape type (4 bytes)\n            input.readInt();\n            double x = input.readDouble();\n            double y = input.readDouble();\n            if (isEsriNaN(x) || isEsriNaN(y)) {\n                return new OGCPoint(new Point(), null);\n            }\n            Point point = new Point(x, y);\n            return createFromEsriGeometry(point, false);\n        }\n        if (type == GeometryType.MULTI_POINT) {\n            // Skip shape type (4 bytes)\n            input.readInt();\n            // Skip envelope (4 doubles)\n            input.skip(4 * Double.BYTES);\n            int pointCount = input.readInt();\n            MultiPoint multiPoint = new MultiPoint();\n            for (int i = 0; i < pointCount; i++) {\n                double x = input.readDouble();\n                double y = input.readDouble();\n                if (!isEsriNaN(x) && !isEsriNaN(y)) {\n                    multiPoint.add(x, y);\n                }\n            }\n            return createFromEsriGeometry(multiPoint, true);\n        }\n        int currentPosition = toIntExact(input.position());\n        ByteBuffer geometryBuffer = inputSlice.toByteBuffer(currentPosition, length).slice();\n        input.setPosition(currentPosition + length);\n        Geometry esriGeometry = OperatorImportFromESRIShape.local().execute(0, Unknown, geometryBuffer);\n        return createFromEsriGeometry(esriGeometry, type.isMultitype());\n    }"
  }
]
```

But note: The `createFromEsriGeometry` method expects a `Geometry` and a boolean. For `POINT`, we pass `false` because `type.isMultitype()` is false. For `MULTI_POINT`, we pass `true`. However, the `createFromEsriGeometry` method will still apply the logic to convert a single-point MultiPoint to OGCPoint. That's fine.

Also, we need to handle the case where the point coordinates are NaN. We return an empty point.

For multi-point, we skip points with NaN coordinates? The ESRI shape may include NaN for empty points? Actually, the shape for multi-point might have NaN in the envelope if empty. But the point coordinates themselves might be valid. We'll follow the existing logic: if the point is NaN, we skip adding it? But the ESRI geometry might include NaN points? Let's check the original `createFromEsriGeometry` for MultiPoint: it checks if the geometry is empty. We'll do the same: if the multiPoint is empty after adding, it will be handled by `createFromEsriGeometry`.

Alternatively, we can directly call `new OGCMultiPoint` or `new OGCPoint` based on the point count. But to keep the behavior identical, we use `createFromEsriGeometry`.

Now, we also need to update the envelope deserialization? No, because `getPointEnvelope` and `getSimpleGeometryEnvelope` already read directly.

But note: Our change reads the data from the input, so we must ensure that the input position is advanced correctly. We are reading the data, so we don't need to skip the length because we are reading exactly the length bytes.

However, the original code reads the entire buffer and advances by length. In our new code, we read the point data and leave the input at the correct position. But we are not using the length parameter. We should verify that we read exactly the length bytes.

For point: we read 4 (int) + 8 (double) + 8 (double) = 20 bytes. The length should be 20? Actually, the length includes the type byte? No, the length is the number of bytes for the shape (excluding the type byte). The shape for a point is 20 bytes (4 for shape type + 16 for coordinates). So we are reading 20 bytes.

For multi-point: we read shape type (4) + envelope (32) + point count (4) + points (16 * pointCount). That should match the length.

But we are not checking the length. We assume the shape is valid.

We also need to update the `readSimpleGeometry` for other types to use the length? It already does.

Now, we should also update the `readSimpleGeometry` to handle the case where the point is empty? We already handle NaN.

But what about 3D points? The ESRI shape may include Z and M values. The current code does not support 3D. So we assume 2D points only. That's consistent with the existing code.

Now, let's also consider that the `OperatorImportFromESRIShape` might be more expensive because it parses the shape type and creates the geometry. Our direct reading should be faster.

Now, we need to ensure the unit tests pass. We'll run them to see.

But note: The change is only in `GeometrySerde.java`. We'll output the JSON as above.

We also need to add the import for `Point` and `MultiPoint` if not already present. They are already imported.

Now, let's output the final answer.