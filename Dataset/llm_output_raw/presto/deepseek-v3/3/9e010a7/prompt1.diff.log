Looking at the provided `MapToMapCast.java` file, I can identify several performance improvement opportunities. The main issues are:

1. **Duplicate key detection inefficiency**: The current implementation builds a complete key block first, then uses a `TypedSet` to check for duplicates while building the final map. This requires iterating through the input map twice and building an intermediate key block.

2. **Excessive method handle composition**: The `buildProcessor` method creates complex method handle chains that could be optimized.

3. **Null checking overhead**: The null checker method handles could be simplified or inlined.

Here are the specific improvements I'll make:

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java",
    "search": "    @UsedByGeneratedCode\n    public static Block mapCast(\n            MethodHandle keyProcessFunction,\n            MethodHandle valueProcessFunction,\n            Type toMapType,\n            SqlFunctionProperties properties,\n            Block fromMap)\n    {\n        checkState(toMapType.getTypeParameters().size() == 2, \"Expect two type parameters for toMapType\");\n        Type toKeyType = toMapType.getTypeParameters().get(0);\n        TypedSet typedSet = new TypedSet(toKeyType, fromMap.getPositionCount() / 2, \"map-to-map cast\");\n        BlockBuilder keyBlockBuilder = toKeyType.createBlockBuilder(null, fromMap.getPositionCount() / 2);\n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            try {\n                keyProcessFunction.invokeExact(fromMap, i, properties, keyBlockBuilder);\n            }\n            catch (Throwable t) {\n                throw internalError(t);\n            }\n        }\n        Block keyBlock = keyBlockBuilder.build();\n\n        BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);\n        BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();\n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            if (typedSet.add(keyBlock, i / 2)) {\n                toKeyType.appendTo(keyBlock, i / 2, blockBuilder);\n                if (fromMap.isNull(i + 1)) {\n                    blockBuilder.appendNull();\n                    continue;\n                }\n\n                try {\n                    valueProcessFunction.invokeExact(fromMap, i + 1, properties, blockBuilder);\n                }\n                catch (Throwable t) {\n                    throw internalError(t);\n                }\n            }\n            else {\n                // if there are duplicated keys, fail it!\n                throw new PrestoException(INVALID_CAST_ARGUMENT, \"duplicate keys\");\n            }\n        }\n\n        mapBlockBuilder.closeEntry();\n        return (Block) toMapType.getObject(mapBlockBuilder, mapBlockBuilder.getPositionCount() - 1);\n    }",
    "replace": "    @UsedByGeneratedCode\n    public static Block mapCast(\n            MethodHandle keyProcessFunction,\n            MethodHandle valueProcessFunction,\n            Type toMapType,\n            SqlFunctionProperties properties,\n            Block fromMap)\n    {\n        checkState(toMapType.getTypeParameters().size() == 2, \"Expect two type parameters for toMapType\");\n        Type toKeyType = toMapType.getTypeParameters().get(0);\n        TypedSet typedSet = new TypedSet(toKeyType, fromMap.getPositionCount() / 2, \"map-to-map cast\");\n        \n        BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);\n        BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();\n        \n        // Temporary block builder for key processing\n        BlockBuilder keyBlockBuilder = toKeyType.createBlockBuilder(null, 1);\n        \n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            // Process key and check for duplicates in a single pass\n            keyBlockBuilder = keyBlockBuilder.newBlockBuilderLike(null);\n            try {\n                keyProcessFunction.invokeExact(fromMap, i, properties, keyBlockBuilder);\n            }\n            catch (Throwable t) {\n                throw internalError(t);\n            }\n            \n            Block singleKeyBlock = keyBlockBuilder.build();\n            \n            if (typedSet.add(singleKeyBlock, 0)) {\n                // Append the processed key\n                toKeyType.appendTo(singleKeyBlock, 0, blockBuilder);\n                \n                // Process value\n                if (fromMap.isNull(i + 1)) {\n                    blockBuilder.appendNull();\n                }\n                else {\n                    try {\n                        valueProcessFunction.invokeExact(fromMap, i + 1, properties, blockBuilder);\n                    }\n                    catch (Throwable t) {\n                        throw internalError(t);\n                    }\n                }\n            }\n            else {\n                // if there are duplicated keys, fail it!\n                throw new PrestoException(INVALID_CAST_ARGUMENT, \"duplicate keys\");\n            }\n        }\n\n        mapBlockBuilder.closeEntry();\n        return (Block) toMapType.getObject(mapBlockBuilder, mapBlockBuilder.getPositionCount() - 1);\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java",
    "search": "    private MethodHandle nullChecker(Class<?> javaType)\n    {\n        if (javaType == Long.class) {\n            return CHECK_LONG_IS_NOT_NULL;\n        }\n        else if (javaType == Double.class) {\n            return CHECK_DOUBLE_IS_NOT_NULL;\n        }\n        else if (javaType == Boolean.class) {\n            return CHECK_BOOLEAN_IS_NOT_NULL;\n        }\n        else if (javaType == Slice.class) {\n            return CHECK_SLICE_IS_NOT_NULL;\n        }\n        else if (javaType == Block.class) {\n            return CHECK_BLOCK_IS_NOT_NULL;\n        }\n        else {\n            throw new IllegalArgumentException(\"Unknown java type \" + javaType);\n        }\n    }",
    "replace": "    private MethodHandle nullChecker(Class<?> javaType)\n    {\n        // Use a switch statement for better performance with frequent calls\n        switch (javaType.getName()) {\n            case \"java.lang.Long\":\n                return CHECK_LONG_IS_NOT_NULL;\n            case \"java.lang.Double\":\n                return CHECK_DOUBLE_IS_NOT_NULL;\n            case \"java.lang.Boolean\":\n                return CHECK_BOOLEAN_IS_NOT_NULL;\n            case \"io.airlift.slice.Slice\":\n                return CHECK_SLICE_IS_NOT_NULL;\n            case \"com.facebook.presto.common.block.Block\":\n                return CHECK_BLOCK_IS_NOT_NULL;\n            default:\n                throw new IllegalArgumentException(\"Unknown java type \" + javaType);\n        }\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java",
    "search": "        MethodHandle target = compose(cast, getter);\n\n        // If the key cast function is nullable, check the result is not null.\n        if (isKey && castImplementation.isNullable()) {\n            target = compose(nullChecker(target.type().returnType()), target);\n        }\n\n        MethodHandle writer = nativeValueWriter(toType);\n        writer = permuteArguments(writer, methodType(void.class, writer.type().parameterArray()[1], writer.type().parameterArray()[0]), 1, 0);\n\n        return compose(writer, target.asType(methodType(unwrap(target.type().returnType()), target.type().parameterArray())));",
    "replace": "        MethodHandle target = compose(cast, getter);\n\n        // If the key cast function is nullable, check the result is not null.\n        if (isKey && castImplementation.isNullable()) {\n            target = compose(nullChecker(target.type().returnType()), target);\n        }\n\n        MethodHandle writer = nativeValueWriter(toType);\n        // Optimize: avoid permuteArguments when possible by checking parameter order\n        if (writer.type().parameterArray()[0] == BlockBuilder.class) {\n            // Already in correct order: (BlockBuilder, value)\n            writer = permuteArguments(writer, methodType(void.class, writer.type().parameterArray()[1], writer.type().parameterArray()[0]), 1, 0);\n        }\n        // else: parameter order is already (value, BlockBuilder)\n\n        return compose(writer, target.asType(methodType(unwrap(target.type().returnType()), target.type().parameterArray())));"
  }
]
```