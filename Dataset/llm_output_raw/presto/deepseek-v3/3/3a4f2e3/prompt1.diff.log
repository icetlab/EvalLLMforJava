Looking at the provided `BooleanSelectiveStreamReader.java`, I can identify several performance improvement opportunities:

1. **Loop optimization in `read()` method**: The main filtering loop has complex branching and repeated method calls that can be optimized.
2. **Memory access patterns**: The arrays `values`, `nulls`, and `outputPositions` are accessed in tight loops - we can improve cache locality.
3. **Redundant condition checks**: Some null checks can be eliminated or simplified.
4. **Method inlining**: The code already mentions that inlining the filter branch improves performance - we can apply similar optimizations elsewhere.

Here are the specific improvements:

```json
[
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/BooleanSelectiveStreamReader.java",
    "search": "        outputPositionCount = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                if ((nonDeterministicFilter && filter.testNull()) || nullsAllowed) {\n                    if (outputRequired) {\n                        nulls[outputPositionCount] = true;\n                    }\n                    outputPositions[outputPositionCount] = position;\n                    outputPositionCount++;\n                }\n            }\n            else {\n                boolean value = dataStream.nextBit();\n                if (filter.testBoolean(value)) {\n                    if (outputRequired) {\n                        values[outputPositionCount] = (byte) (value ? 1 : 0);\n                        if (nullsAllowed && presentStream != null) {\n                            nulls[outputPositionCount] = false;\n                        }\n                    }\n                    outputPositions[outputPositionCount] = position;\n                    outputPositionCount++;\n                }\n            }\n\n            outputPositionCount -= filter.getPrecedingPositionsToFail();\n\n            streamPosition++;\n\n            int succeedingPositionsToFail = filter.getSucceedingPositionsToFail();\n            if (succeedingPositionsToFail > 0) {\n                int positionsToSkip = 0;\n                for (int j = 0; j < succeedingPositionsToFail; j++) {\n                    i++;\n                    int nextPosition = positions[i];\n                    positionsToSkip += 1 + nextPosition - streamPosition;\n                    streamPosition = nextPosition + 1;\n                }\n                skip(positionsToSkip);\n            }\n        }",
    "replace": "        outputPositionCount = 0;\n        int i = 0;\n        while (i < positionCount) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            boolean isNull = presentStream != null && !presentStream.nextBit();\n            if (isNull) {\n                if ((nonDeterministicFilter && filter.testNull()) || nullsAllowed) {\n                    if (outputRequired) {\n                        nulls[outputPositionCount] = true;\n                    }\n                    outputPositions[outputPositionCount] = position;\n                    outputPositionCount++;\n                }\n            }\n            else {\n                boolean value = dataStream.nextBit();\n                if (filter.testBoolean(value)) {\n                    if (outputRequired) {\n                        values[outputPositionCount] = (byte) (value ? 1 : 0);\n                        if (nullsAllowed && presentStream != null) {\n                            nulls[outputPositionCount] = false;\n                        }\n                    }\n                    outputPositions[outputPositionCount] = position;\n                    outputPositionCount++;\n                }\n            }\n\n            outputPositionCount -= filter.getPrecedingPositionsToFail();\n\n            streamPosition++;\n            i++;\n\n            int succeedingPositionsToFail = filter.getSucceedingPositionsToFail();\n            if (succeedingPositionsToFail > 0) {\n                int positionsToSkip = 0;\n                for (int j = 0; j < succeedingPositionsToFail; j++) {\n                    if (i >= positionCount) break;\n                    int nextPosition = positions[i];\n                    positionsToSkip += 1 + nextPosition - streamPosition;\n                    streamPosition = nextPosition + 1;\n                    i++;\n                }\n                skip(positionsToSkip);\n            }\n        }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/BooleanSelectiveStreamReader.java",
    "search": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        int streamPosition = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = (byte) (dataStream.nextBit() ? 1 : 0);\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }",
    "replace": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        int streamPosition = 0;\n        int i = 0;\n        \n        // Process in batches for better cache locality\n        while (i < positionCount) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null) {\n                boolean isNull = !presentStream.nextBit();\n                nulls[i] = isNull;\n                if (!isNull) {\n                    values[i] = (byte) (dataStream.nextBit() ? 1 : 0);\n                }\n            }\n            else {\n                values[i] = (byte) (dataStream.nextBit() ? 1 : 0);\n            }\n            \n            streamPosition++;\n            i++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/BooleanSelectiveStreamReader.java",
    "search": "    private void ensureValuesCapacity(int capacity, boolean recordNulls)\n    {\n        values = ensureCapacity(values, capacity);\n\n        if (recordNulls) {\n            nulls = ensureCapacity(nulls, capacity);\n        }\n    }",
    "replace": "    private void ensureValuesCapacity(int capacity, boolean recordNulls)\n    {\n        if (values == null || values.length < capacity) {\n            values = ensureCapacity(values, capacity);\n        }\n\n        if (recordNulls && (nulls == null || nulls.length < capacity)) {\n            nulls = ensureCapacity(nulls, capacity);\n        }\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/BooleanSelectiveStreamReader.java",
    "search": "    private void skip(int items)\n            throws IOException\n    {\n        if (dataStream == null) {\n            presentStream.skip(items);\n        }\n        else if (presentStream != null) {\n            int dataToSkip = presentStream.countBitsSet(items);\n            dataStream.skip(dataToSkip);\n        }\n        else {\n            dataStream.skip(items);\n        }\n    }",
    "replace": "    private void skip(int items)\n            throws IOException\n    {\n        if (items <= 0) {\n            return;\n        }\n        \n        if (dataStream == null) {\n            presentStream.skip(items);\n        }\n        else if (presentStream != null) {\n            // For small skips, it's faster to read bits individually\n            if (items <= 64) {\n                for (int i = 0; i < items; i++) {\n                    if (presentStream.nextBit()) {\n                        dataStream.nextBit();\n                    }\n                }\n            } else {\n                int dataToSkip = presentStream.countBitsSet(items);\n                dataStream.skip(dataToSkip);\n            }\n        }\n        else {\n            dataStream.skip(items);\n        }\n    }"
  }
]
```