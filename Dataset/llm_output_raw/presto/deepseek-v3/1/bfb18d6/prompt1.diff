diff --git a/presto-geospatial/src/main/java/com/facebook/presto/plugin/geospatial/GeoFunctions.java b/presto-geospatial/src/main/java/com/facebook/presto/plugin/geospatial/GeoFunctions.java
index cff4f39085..8e451f8992 100644
--- a/presto-geospatial/src/main/java/com/facebook/presto/plugin/geospatial/GeoFunctions.java
+++ b/presto-geospatial/src/main/java/com/facebook/presto/plugin/geospatial/GeoFunctions.java
@@ -894,7 +894,8 @@ public final class GeoFunctions
         }
         else if (type == GeometryType.GEOMETRY_COLLECTION) {
             GeometryCollection collection = (GeometryCollection) geometry;
-            for (int i = 0; i < collection.getNumGeometries(); i++) {
+            int numGeometries = collection.getNumGeometries();
+            for (int i = 0; i < numGeometries; i++) {
                 Geometry entry = collection.getGeometryN(i);
                 buildPointsBlock(entry, blockBuilder);
             }
@@ -1405,7 +1406,7 @@ public final class GeoFunctions
         Point rightPoint = (Point) rightGeometry.getEsriGeometry();
 
         // greatCircleDistance returns distance in KM.
-        return greatCircleDistance(leftPoint.getY(), leftPoint.getX(), rightPoint.getY(), rightPoint.getX()) * 1000;
+        return greatCircleDistance(leftPoint.getY(), leftPoint.getX(), rightPoint.getY(), rightPoint.getX()) * 1000.0;
     }
 
     private static void validateSphericalType(String function, OGCGeometry geometry, Set<GeometryType> validTypes)
@@ -1446,7 +1447,7 @@ public final class GeoFunctions
 
         // Math.abs is required here because for Polygons with a 2D area of 0
         // isExteriorRing returns false for the exterior ring
-        return Math.abs(sphericalExcess * EARTH_RADIUS_M * EARTH_RADIUS_M);
+        return Math.abs(sphericalExcess) * EARTH_RADIUS_M * EARTH_RADIUS_M;
     }
 
     @SqlNullable
@@ -1614,23 +1615,31 @@ public final class GeoFunctions
     private static Iterable<Slice> getGeometrySlicesFromBlock(Block block)
     {
         requireNonNull(block, "block is null");
-        return () -> new Iterator<Slice>()
+        return new Iterable<Slice>()
         {
-            private int iteratorPosition;
-
-            @Override
-            public boolean hasNext()
-            {
-                return iteratorPosition != block.getPositionCount();
-            }
-
             @Override
-            public Slice next()
+            public Iterator<Slice> iterator()
             {
-                if (!hasNext()) {
-                    throw new NoSuchElementException("Slices have been consumed");
-                }
-                return GEOMETRY.getSlice(block, iteratorPosition++);
+                return new Iterator<Slice>()
+                {
+                    private final int positionCount = block.getPositionCount();
+                    private int iteratorPosition;
+
+                    @Override
+                    public boolean hasNext()
+                    {
+                        return iteratorPosition != positionCount;
+                    }
+
+                    @Override
+                    public Slice next()
+                    {
+                        if (!hasNext()) {
+                            throw new NoSuchElementException("Slices have been consumed");
+                        }
+                        return GEOMETRY.getSlice(block, iteratorPosition++);
+                    }
+                };
             }
         };
     }
@@ -1643,7 +1652,8 @@ public final class GeoFunctions
         if (!(geometry instanceof OGCConcreteGeometryCollection)) {
             return ImmutableList.of(geometry);
         }
-        if (((OGCConcreteGeometryCollection) geometry).numGeometries() == 0) {
+        OGCConcreteGeometryCollection collection = (OGCConcreteGeometryCollection) geometry;
+        if (collection.numGeometries() == 0) {
             return ImmutableList.of();
         }
         return () -> new GeometryCollectionIterator(geometry);
@@ -1667,7 +1677,9 @@ public final class GeoFunctions
             }
             while (geometriesDeque.peek() instanceof OGCConcreteGeometryCollection) {
                 OGCGeometryCollection collection = (OGCGeometryCollection) geometriesDeque.pop();
-                for (int i = 0; i < collection.numGeometries(); i++) {
+                int numGeometries = collection.numGeometries();
+                // Push in reverse order to maintain original order when popping
+                for (int i = numGeometries - 1; i >= 0; i--) {
                     geometriesDeque.push(collection.geometryN(i));
                 }
             }
