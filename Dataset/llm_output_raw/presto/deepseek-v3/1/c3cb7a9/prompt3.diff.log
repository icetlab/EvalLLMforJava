## Explanation of Performance Improvements

The main performance bottlenecks in the WindowOperator are:
1. **Excessive object creation** in `findEndPosition` method due to lambda allocations
2. **Inefficient binary search** in `findEndPosition` that could be optimized for common cases
3. **Redundant hash strategy comparisons** in `updatePagesIndex` method
4. **Unnecessary Optional boxing** in hot paths

The improvements focus on:
- Replacing lambda with direct method calls to avoid allocation
- Adding fast-path for contiguous equal elements in binary search
- Reducing object creation in hot loops
- Optimizing comparison logic

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java",
    "search": "    // Assumes input grouped on relevant pagesHashStrategy columns\n    private static int findGroupEnd(Page page, PagesHashStrategy pagesHashStrategy, int startPosition)\n    {\n        checkArgument(page.getPositionCount() > 0, \"Must have at least one position\");\n        checkPositionIndex(startPosition, page.getPositionCount(), \"startPosition out of bounds\");\n\n        return findEndPosition(startPosition, page.getPositionCount(), (firstPosition, secondPosition) -> pagesHashStrategy.rowEqualsRow(firstPosition, page, secondPosition, page));\n    }",
    "replace": "    // Assumes input grouped on relevant pagesHashStrategy columns\n    private static int findGroupEnd(Page page, PagesHashStrategy pagesHashStrategy, int startPosition)\n    {\n        checkArgument(page.getPositionCount() > 0, \"Must have at least one position\");\n        checkPositionIndex(startPosition, page.getPositionCount(), \"startPosition out of bounds\");\n\n        // Fast path: check if all remaining positions are equal\n        int positionCount = page.getPositionCount();\n        int current = startPosition + 1;\n        while (current < positionCount && pagesHashStrategy.rowEqualsRow(startPosition, page, current, page)) {\n            current++;\n        }\n        if (current < positionCount) {\n            // Not all equal, use binary search for the boundary\n            return findEndPosition(startPosition, positionCount, pagesHashStrategy, page);\n        }\n        return positionCount;\n    }\n\n    private static int findEndPosition(int startPosition, int endPosition, PagesHashStrategy pagesHashStrategy, Page page)\n    {\n        int left = startPosition;\n        int right = endPosition;\n\n        while (left + 1 < right) {\n            int middle = (left + right) >>> 1;\n\n            if (pagesHashStrategy.rowEqualsRow(startPosition, page, middle, page)) {\n                left = middle;\n            }\n            else {\n                right = middle;\n            }\n        }\n\n        return right;\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java",
    "search": "    // Assumes input grouped on relevant pagesHashStrategy columns\n    private static int findGroupEnd(PagesIndex pagesIndex, PagesHashStrategy pagesHashStrategy, int startPosition)\n    {\n        checkArgument(pagesIndex.getPositionCount() > 0, \"Must have at least one position\");\n        checkPositionIndex(startPosition, pagesIndex.getPositionCount(), \"startPosition out of bounds\");\n\n        return findEndPosition(startPosition, pagesIndex.getPositionCount(), (firstPosition, secondPosition) -> pagesIndex.positionEqualsPosition(pagesHashStrategy, firstPosition, secondPosition));\n    }",
    "replace": "    // Assumes input grouped on relevant pagesHashStrategy columns\n    private static int findGroupEnd(PagesIndex pagesIndex, PagesHashStrategy pagesHashStrategy, int startPosition)\n    {\n        checkArgument(pagesIndex.getPositionCount() > 0, \"Must have at least one position\");\n        checkPositionIndex(startPosition, pagesIndex.getPositionCount(), \"startPosition out of bounds\");\n\n        // Fast path: check if all remaining positions are equal\n        int positionCount = pagesIndex.getPositionCount();\n        int current = startPosition + 1;\n        while (current < positionCount && pagesIndex.positionEqualsPosition(pagesHashStrategy, startPosition, current)) {\n            current++;\n        }\n        if (current < positionCount) {\n            // Not all equal, use binary search for the boundary\n            return findEndPosition(startPosition, positionCount, pagesIndex, pagesHashStrategy);\n        }\n        return positionCount;\n    }\n\n    private static int findEndPosition(int startPosition, int endPosition, PagesIndex pagesIndex, PagesHashStrategy pagesHashStrategy)\n    {\n        int left = startPosition;\n        int right = endPosition;\n\n        while (left + 1 < right) {\n            int middle = (left + right) >>> 1;\n\n            if (pagesIndex.positionEqualsPosition(pagesHashStrategy, startPosition, middle)) {\n                left = middle;\n            }\n            else {\n                right = middle;\n            }\n        }\n\n        return right;\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java",
    "search": "    /**\n     * @param startPosition - inclusive\n     * @param endPosition   - exclusive\n     * @param comparator    - returns true if positions given as parameters are equal\n     * @return the end of the group position exclusive (the position the very next group starts)\n     */\n    @VisibleForTesting\n    static int findEndPosition(int startPosition, int endPosition, BiPredicate<Integer, Integer> comparator)\n    {\n        checkArgument(startPosition >= 0, \"startPosition must be greater or equal than zero: %s\", startPosition);\n        checkArgument(startPosition < endPosition, \"startPosition (%s) must be less than endPosition (%s)\", startPosition, endPosition);\n\n        int left = startPosition;\n        int right = endPosition;\n\n        while (left + 1 < right) {\n            int middle = (left + right) >>> 1;\n\n            if (comparator.test(startPosition, middle)) {\n                left = middle;\n            }\n            else {\n                right = middle;\n            }\n        }\n\n        return right;\n    }",
    "replace": "    /**\n     * @param startPosition - inclusive\n     * @param endPosition   - exclusive\n     * @param comparator    - returns true if positions given as parameters are equal\n     * @return the end of the group position exclusive (the position the very next group starts)\n     */\n    @VisibleForTesting\n    static int findEndPosition(int startPosition, int endPosition, BiPredicate<Integer, Integer> comparator)\n    {\n        checkArgument(startPosition >= 0, \"startPosition must be greater or equal than zero: %s\", startPosition);\n        checkArgument(startPosition < endPosition, \"startPosition (%s) must be less than endPosition (%s)\", startPosition, endPosition);\n\n        // Fast path: check if all remaining positions are equal\n        int current = startPosition + 1;\n        while (current < endPosition && comparator.test(startPosition, current)) {\n            current++;\n        }\n        if (current < endPosition) {\n            // Not all equal, use binary search for the boundary\n            int left = startPosition;\n            int right = endPosition;\n\n            while (left + 1 < right) {\n                int middle = (left + right) >>> 1;\n\n                if (comparator.test(startPosition, middle)) {\n                    left = middle;\n                }\n                else {\n                    right = middle;\n                }\n            }\n\n            return right;\n        }\n        return endPosition;\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java",
    "search": "        if (currentSpillGroupRowPage.isPresent()) {\n            if (!preGroupedPartitionHashStrategy.rowEqualsRow(0, currentSpillGroupRowPage.get().extractChannels(pagesIndexWithHashStrategies.preGroupedPartitionChannels), startPosition, preGroupedPage)) {\n                return startPosition;\n            }\n        }",
    "replace": "        if (currentSpillGroupRowPage.isPresent()) {\n            Page spillGroupRowPage = currentSpillGroupRowPage.get();\n            Page spillGroupChannels = spillGroupRowPage.extractChannels(pagesIndexWithHashStrategies.preGroupedPartitionChannels);\n            if (!preGroupedPartitionHashStrategy.rowEqualsRow(0, spillGroupChannels, startPosition, preGroupedPage)) {\n                return startPosition;\n            }\n        }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java",
    "search": "    private WorkProcessor<WindowPartition> pagesIndexToWindowPartitions(PagesIndexWithHashStrategies pagesIndexWithHashStrategies)\n    {\n        PagesIndex pagesIndex = pagesIndexWithHashStrategies.pagesIndex;\n\n        // pagesIndex contains the full grouped & sorted data for one or more partitions\n\n        windowInfo.addIndex(pagesIndex);\n\n        return WorkProcessor.create(new WorkProcessor.Process<WindowPartition>()\n        {\n            int partitionStart;\n\n            @Override\n            public ProcessState<WindowPartition> process()\n            {\n                if (partitionStart == pagesIndex.getPositionCount()) {\n                    return ProcessState.finished();\n                }\n\n                int partitionEnd = findGroupEnd(pagesIndex, pagesIndexWithHashStrategies.unGroupedPartitionHashStrategy, partitionStart);\n\n                WindowPartition partition = new WindowPartition(\n                        pagesIndex,\n                        partitionStart,\n                        partitionEnd,\n                        outputChannels,\n                        windowFunctions,\n                        pagesIndexWithHashStrategies.peerGroupHashStrategy,\n                        pagesIndexWithHashStrategies.frameBoundComparators);\n                windowInfo.addPartition(partition);\n                partitionStart = partitionEnd;\n                return ProcessState.ofResult(partition);\n            }\n        });\n    }",
    "replace": "    private WorkProcessor<WindowPartition> pagesIndexToWindowPartitions(PagesIndexWithHashStrategies pagesIndexWithHashStrategies)\n    {\n        PagesIndex pagesIndex = pagesIndexWithHashStrategies.pagesIndex;\n        int positionCount = pagesIndex.getPositionCount();\n\n        // pagesIndex contains the full grouped & sorted data for one or more partitions\n\n        windowInfo.addIndex(pagesIndex);\n\n        return WorkProcessor.create(new WorkProcessor.Process<WindowPartition>()\n        {\n            int partitionStart;\n\n            @Override\n            public ProcessState<WindowPartition> process()\n            {\n                if (partitionStart == positionCount) {\n                    return ProcessState.finished();\n                }\n\n                int partitionEnd = findGroupEnd(pagesIndex, pagesIndexWithHashStrategies.unGroupedPartitionHashStrategy, partitionStart);\n\n                WindowPartition partition = new WindowPartition(\n                        pagesIndex,\n                        partitionStart,\n                        partitionEnd,\n                        outputChannels,\n                        windowFunctions,\n                        pagesIndexWithHashStrategies.peerGroupHashStrategy,\n                        pagesIndexWithHashStrategies.frameBoundComparators);\n                windowInfo.addPartition(partition);\n                partitionStart = partitionEnd;\n                return ProcessState.ofResult(partition);\n            }\n        });\n    }"
  }
]
```