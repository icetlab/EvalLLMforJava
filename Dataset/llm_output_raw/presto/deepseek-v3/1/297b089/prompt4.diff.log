Looking at the performance issue and the code, I need to improve the reading of `lengthVector` in `SliceDirectSelectiveStreamReader`. The main issues are:

1. The `lengthIndex` field is maintained as a class-level variable, which leads to complex state management across different methods.
2. The skip logic and reading logic need to track this index separately, causing redundant calculations.
3. The code can be optimized by computing positions directly rather than maintaining a mutable index.

The key improvements are:
- Remove the class-level `lengthIndex` field and compute positions locally in each method.
- Simplify the skip logic by passing the current length index as a parameter.
- Improve cache locality by accessing arrays more directly.

Here are the atomic changes:

```json
[
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java",
    "search": "    private int[] lengthVector;         // lengths for all positions up to the last positions requested in read()\n    private int lengthIndex;            // index into lengthVector array",
    "replace": "    private int[] lengthVector;         // lengths for all positions up to the last positions requested in read()"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java",
    "search": "    private int prepareForNextRead(int positionCount, int[] positions)\n            throws IOException\n    {\n        lengthIndex = 0;\n        outputPositionCount = 0;",
    "replace": "    private int prepareForNextRead(int positionCount, int[] positions)\n            throws IOException\n    {\n        outputPositionCount = 0;"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java",
    "search": "        int streamPosition = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skipData(streamPosition, position - streamPosition);\n                streamPosition = position;\n            }\n\n            int offset = offsets[i];\n            if (presentStream != null && isNullVector[position]) {\n                if (offsets != null) {\n                    offsets[i + 1] = offset;\n                }\n                nulls[i] = true;\n            }\n            else {\n                int length = lengthVector[lengthIndex];\n                int truncatedLength = 0;\n                if (length > 0) {\n                    dataStream.next(data, offset, offset + length);\n                    truncatedLength = computeTruncatedLength(dataAsSlice, offset, length, maxCodePointCount, isCharType);\n                }\n                offsets[i + 1] = offset + truncatedLength;\n                lengthIndex++;\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }",
    "replace": "        int streamPosition = 0;\n        int lengthIndex = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skipData(streamPosition, position - streamPosition, lengthIndex);\n                lengthIndex += countNonNulls(streamPosition, position - streamPosition);\n                streamPosition = position;\n            }\n\n            int offset = offsets[i];\n            if (presentStream != null && isNullVector[position]) {\n                if (offsets != null) {\n                    offsets[i + 1] = offset;\n                }\n                nulls[i] = true;\n            }\n            else {\n                int length = lengthVector[lengthIndex];\n                int truncatedLength = 0;\n                if (length > 0) {\n                    dataStream.next(data, offset, offset + length);\n                    truncatedLength = computeTruncatedLength(dataAsSlice, offset, length, maxCodePointCount, isCharType);\n                }\n                offsets[i + 1] = offset + truncatedLength;\n                lengthIndex++;\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java",
    "search": "    private void skipData(int start, int items)\n            throws IOException\n    {\n        int dataToSkip = 0;\n        for (int i = 0; i < items; i++) {\n            if (presentStream == null || !isNullVector[start + i]) {\n                dataToSkip += lengthVector[lengthIndex];\n                lengthIndex++;\n            }\n        }\n        // in case of an empty varbinary both the presentStream and dataStream are null and only lengthStream is present.\n        if (dataStream != null) {\n            dataStream.skip(dataToSkip);\n        }\n    }",
    "replace": "    private void skipData(int start, int items, int currentLengthIndex)\n            throws IOException\n    {\n        int dataToSkip = 0;\n        int lengthIndex = currentLengthIndex;\n        for (int i = 0; i < items; i++) {\n            if (presentStream == null || !isNullVector[start + i]) {\n                dataToSkip += lengthVector[lengthIndex];\n                lengthIndex++;\n            }\n        }\n        // in case of an empty varbinary both the presentStream and dataStream are null and only lengthStream is present.\n        if (dataStream != null) {\n            dataStream.skip(dataToSkip);\n        }\n    }\n\n    private int countNonNulls(int start, int items)\n    {\n        int count = 0;\n        for (int i = 0; i < items; i++) {\n            if (presentStream == null || !isNullVector[start + i]) {\n                count++;\n            }\n        }\n        return count;\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java",
    "search": "        int streamPosition = 0;\n        int dataToSkip = 0;\n\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skipData(streamPosition, position - streamPosition);\n                streamPosition = position;\n            }",
    "replace": "        int streamPosition = 0;\n        int dataToSkip = 0;\n        int lengthIndex = 0;\n\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skipData(streamPosition, position - streamPosition, lengthIndex);\n                lengthIndex += countNonNulls(streamPosition, position - streamPosition);\n                streamPosition = position;\n            }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java",
    "search": "                int length = lengthVector[lengthIndex];\n                int dataOffset = outputRequired ? offset : 0;\n                if (filter.testLength(length)) {\n                    if (dataStream != null) {\n                        dataStream.skip(dataToSkip);\n                        dataToSkip = 0;\n                        dataStream.next(data, dataOffset, dataOffset + length);\n                        if (filter.testBytes(data, dataOffset, length)) {\n                            if (outputRequired) {\n                                int truncatedLength = computeTruncatedLength(dataAsSlice, dataOffset, length, maxCodePointCount, isCharType);\n                                offsets[outputPositionCount + 1] = offset + truncatedLength;\n                                if (nullsAllowed && presentStream != null) {\n                                    nulls[outputPositionCount] = false;\n                                }\n                            }\n                            outputPositions[outputPositionCount] = position;\n                            outputPositionCount++;\n                        }\n                    }\n                    else {\n                        assert length == 0;\n                        if (filter.testBytes(\"\".getBytes(), 0, 0)) {\n                            if (outputRequired) {\n                                offsets[outputPositionCount + 1] = offset;\n                                if (nullsAllowed && presentStream != null) {\n                                    nulls[outputPositionCount] = false;\n                                }\n                            }\n                            outputPositions[outputPositionCount] = position;\n                            outputPositionCount++;\n                        }\n                    }\n                }\n                else {\n                    dataToSkip += length;\n                }\n                lengthIndex++;",
    "replace": "                int length = lengthVector[lengthIndex];\n                int dataOffset = outputRequired ? offset : 0;\n                if (filter.testLength(length)) {\n                    if (dataStream != null) {\n                        dataStream.skip(dataToSkip);\n                        dataToSkip = 0;\n                        dataStream.next(data, dataOffset, dataOffset + length);\n                        if (filter.testBytes(data, dataOffset, length)) {\n                            if (outputRequired) {\n                                int truncatedLength = computeTruncatedLength(dataAsSlice, dataOffset, length, maxCodePointCount, isCharType);\n                                offsets[outputPositionCount + 1] = offset + truncatedLength;\n                                if (nullsAllowed && presentStream != null) {\n                                    nulls[outputPositionCount] = false;\n                                }\n                            }\n                            outputPositions[outputPositionCount] = position;\n                            outputPositionCount++;\n                        }\n                    }\n                    else {\n                        assert length == 0;\n                        if (filter.testBytes(\"\".getBytes(), 0, 0)) {\n                            if (outputRequired) {\n                                offsets[outputPositionCount + 1] = offset;\n                                if (nullsAllowed && presentStream != null) {\n                                    nulls[outputPositionCount] = false;\n                                }\n                            }\n                            outputPositions[outputPositionCount] = position;\n                            outputPositionCount++;\n                        }\n                    }\n                }\n                else {\n                    dataToSkip += length;\n                }\n                lengthIndex++;"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java",
    "search": "                    skipData(streamPosition, positionsToSkip);",
    "replace": "                    skipData(streamPosition, positionsToSkip, lengthIndex);\n                    lengthIndex += countNonNulls(streamPosition, positionsToSkip);"
  }
]
```