The performance issue indicates that `readNoFilter()` is inefficient when reading contiguous rows with no nulls and no filter. The current implementation processes rows one by one, checking positions and reading bits individually. For contiguous rows with no nulls, we can optimize by detecting contiguous positions and reading bits in a tight loop without per-row position checks.

The optimization adds a fast path for the case when `presentStream == null` (no nulls) and positions are contiguous. In this case, we skip to the first position once and then read all bits in a simple loop. This reduces overhead from position comparisons and stream position updates.

Here are the atomic changes:

```json
[
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/BooleanSelectiveStreamReader.java",
    "search": "        allNulls = true;\n        return positions[positionCount - 1] + 1;\n    }\n\n    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {",
    "replace": "        allNulls = true;\n        return positions[positionCount - 1] + 1;\n    }\n\n    private boolean isContiguous(int[] positions, int positionCount)\n    {\n        if (positionCount <= 1) {\n            return true;\n        }\n        for (int i = 1; i < positionCount; i++) {\n            if (positions[i] != positions[i - 1] + 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/BooleanSelectiveStreamReader.java",
    "search": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        int streamPosition = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = (byte) (dataStream.nextBit() ? 1 : 0);\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }",
    "replace": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        int streamPosition = 0;\n\n        // Fast path: no nulls and positions are contiguous\n        if (presentStream == null && isContiguous(positions, positionCount)) {\n            int firstPosition = positions[0];\n            if (firstPosition > streamPosition) {\n                skip(firstPosition - streamPosition);\n                streamPosition = firstPosition;\n            }\n            for (int i = 0; i < positionCount; i++) {\n                values[i] = (byte) (dataStream.nextBit() ? 1 : 0);\n            }\n            streamPosition += positionCount;\n            outputPositionCount = positionCount;\n            return streamPosition;\n        }\n\n        // Original slow path\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = (byte) (dataStream.nextBit() ? 1 : 0);\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }"
  }
]
```