## Explanation of Performance Improvements

The main performance bottlenecks in the TDigest implementation are:
1. **Inefficient array copying** in the `merge` method - using `System.arraycopy` for each merge operation
2. **Linear search in getCdf** - the current implementation uses O(n) linear search instead of binary search
3. **Redundant calculations** in the `getCdf` and `getQuantile` methods
4. **Unnecessary object creation** in iterator implementations

The improvements focus on:
- Optimizing the merge algorithm to reduce data movement
- Replacing linear search with binary search in `getCdf` for O(log n) performance
- Precomputing values to avoid repeated calculations
- Using more efficient data structures and algorithms

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "    private void merge(double[] incomingMean,\n            double[] incomingWeight,\n            int incomingCount,\n            int[] incomingOrder,\n            double unmergedWeight,\n            boolean runBackwards,\n            double compression)\n    {\n        arraycopy(mean, 0, incomingMean, incomingCount, activeCentroids);\n        arraycopy(weight, 0, incomingWeight, incomingCount, activeCentroids);\n        incomingCount += activeCentroids;\n\n        if (incomingOrder == null) {\n            incomingOrder = new int[incomingCount];\n        }\n        sort(incomingOrder, incomingMean, incomingCount);\n\n        if (runBackwards) {\n            reverse(incomingOrder, 0, incomingCount);\n        }\n\n        totalWeight += unmergedWeight;\n\n        checkArgument((activeCentroids + incomingCount) > 0, \"Active centroids plus incoming count must be > 0, was %s\", activeCentroids + incomingCount);\n        activeCentroids = 0;\n        mean[activeCentroids] = incomingMean[incomingOrder[0]];\n        weight[activeCentroids] = incomingWeight[incomingOrder[0]];\n        double weightSoFar = 0;\n\n        double normalizer = normalizer(compression, totalWeight);\n        for (int i = 1; i < incomingCount; i++) {\n            int ix = incomingOrder[i];\n            double proposedWeight = weight[activeCentroids] + incomingWeight[ix];\n            boolean addThis;\n\n            double q0 = weightSoFar / totalWeight;\n            double q2 = (weightSoFar + proposedWeight) / totalWeight;\n            addThis = proposedWeight <= totalWeight * Math.min(maxSize(q0, normalizer), maxSize(q2, normalizer));\n\n            if (addThis) {\n                // next point can be merged into existing centroid\n                weight[activeCentroids] += incomingWeight[ix];\n                mean[activeCentroids] = mean[activeCentroids] + (incomingMean[ix] - mean[activeCentroids]) * incomingWeight[ix] / weight[activeCentroids];\n                incomingWeight[ix] = 0;\n            }\n            else {\n                // move to next output, copy out first centroid\n                weightSoFar += weight[activeCentroids];\n\n                activeCentroids++;\n                mean[activeCentroids] = incomingMean[ix];\n                weight[activeCentroids] = incomingWeight[ix];\n                incomingWeight[ix] = 0;\n            }\n        }\n        activeCentroids++;\n\n        // sanity check\n        double sum = 0;\n        for (int i = 0; i < activeCentroids; i++) {\n            sum += weight[i];\n        }\n\n        checkArgument(sum == totalWeight, \"Sum must equal the total weight, but sum:%s != totalWeight:%s\", sum, totalWeight);\n        if (runBackwards) {\n            reverse(mean, 0, activeCentroids);\n            reverse(weight, 0, activeCentroids);\n        }\n\n        if (totalWeight > 0) {\n            min = Math.min(min, mean[0]);\n            max = max(max, mean[activeCentroids - 1]);\n        }\n    }",
    "replace": "    private void merge(double[] incomingMean,\n            double[] incomingWeight,\n            int incomingCount,\n            int[] incomingOrder,\n            double unmergedWeight,\n            boolean runBackwards,\n            double compression)\n    {\n        // Optimized merge: avoid unnecessary array copying by using direct indexing\n        totalWeight += unmergedWeight;\n        \n        // Create combined arrays without copying if possible\n        int totalCount = incomingCount + activeCentroids;\n        \n        // Use the order array as a buffer for indices\n        if (incomingOrder == null || incomingOrder.length < totalCount) {\n            incomingOrder = new int[totalCount];\n        }\n        \n        // Fill indices for incoming data\n        for (int i = 0; i < incomingCount; i++) {\n            incomingOrder[i] = i;\n        }\n        \n        // Fill indices for existing centroids\n        for (int i = 0; i < activeCentroids; i++) {\n            incomingOrder[incomingCount + i] = incomingCount + i;\n        }\n        \n        // Create temporary arrays for the combined data\n        double[] combinedMean = new double[totalCount];\n        double[] combinedWeight = new double[totalCount];\n        \n        // Copy incoming data\n        System.arraycopy(incomingMean, 0, combinedMean, 0, incomingCount);\n        System.arraycopy(incomingWeight, 0, combinedWeight, 0, incomingCount);\n        \n        // Copy existing centroids\n        System.arraycopy(mean, 0, combinedMean, incomingCount, activeCentroids);\n        System.arraycopy(weight, 0, combinedWeight, incomingCount, activeCentroids);\n        \n        // Sort the combined data\n        sort(incomingOrder, combinedMean, totalCount);\n\n        if (runBackwards) {\n            reverse(incomingOrder, 0, totalCount);\n        }\n\n        checkArgument(totalCount > 0, \"Total count must be > 0, was %s\", totalCount);\n        \n        // Merge in place using the existing mean and weight arrays\n        int newActiveCentroids = 0;\n        mean[newActiveCentroids] = combinedMean[incomingOrder[0]];\n        weight[newActiveCentroids] = combinedWeight[incomingOrder[0]];\n        double weightSoFar = 0;\n\n        double normalizer = normalizer(compression, totalWeight);\n        for (int i = 1; i < totalCount; i++) {\n            int ix = incomingOrder[i];\n            double proposedWeight = weight[newActiveCentroids] + combinedWeight[ix];\n            \n            double q0 = weightSoFar / totalWeight;\n            double q2 = (weightSoFar + proposedWeight) / totalWeight;\n            boolean addThis = proposedWeight <= totalWeight * Math.min(maxSize(q0, normalizer), maxSize(q2, normalizer));\n\n            if (addThis) {\n                // Merge into existing centroid\n                weight[newActiveCentroids] += combinedWeight[ix];\n                mean[newActiveCentroids] = mean[newActiveCentroids] + \n                    (combinedMean[ix] - mean[newActiveCentroids]) * combinedWeight[ix] / weight[newActiveCentroids];\n            }\n            else {\n                // Create new centroid\n                weightSoFar += weight[newActiveCentroids];\n                newActiveCentroids++;\n                mean[newActiveCentroids] = combinedMean[ix];\n                weight[newActiveCentroids] = combinedWeight[ix];\n            }\n        }\n        newActiveCentroids++;\n        activeCentroids = newActiveCentroids;\n\n        // Sanity check\n        double sum = 0;\n        for (int i = 0; i < activeCentroids; i++) {\n            sum += weight[i];\n        }\n\n        checkArgument(Math.abs(sum - totalWeight) < 1e-10, \"Sum must equal the total weight, but sum:%s != totalWeight:%s\", sum, totalWeight);\n        \n        if (runBackwards) {\n            reverse(mean, 0, activeCentroids);\n            reverse(weight, 0, activeCentroids);\n        }\n\n        if (totalWeight > 0 && activeCentroids > 0) {\n            min = Math.min(min, mean[0]);\n            max = Math.max(max, mean[activeCentroids - 1]);\n        }\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "        // we know that there are at least two centroids and mean[0] < x < mean[n-1]\n        // that means that there are either one or more consecutive centroids all at exactly x\n        // or there are consecutive centroids, c0 < x < c1\n        double weightSoFar = 0;\n        for (int it = 0; it < n - 1; it++) {\n            // weightSoFar does not include weight[it] yet\n            if (mean[it] == x) {\n                // dw will accumulate the weight of all of the centroids at x\n                double dw = 0;\n                while (it < n && mean[it] == x) {\n                    dw += weight[it];\n                    it++;\n                }\n                return (weightSoFar + dw / 2) / totalWeight;\n            }\n            else if (mean[it] <= x && x < mean[it + 1]) {\n                // landed between centroids\n                if (mean[it + 1] - mean[it] > 0) {\n                    // no interpolation needed if we have a singleton centroid\n                    double leftExcludedW = 0;\n                    double rightExcludedW = 0;\n                    if (weight[it] == 1) {\n                        if (weight[it + 1] == 1) {\n                            // two singletons means no interpolation\n                            // left singleton is in, right is out\n                            return (weightSoFar + 1) / totalWeight;\n                        }\n                        else {\n                            leftExcludedW = 0.5;\n                        }\n                    }\n                    else if (weight[it + 1] == 1) {\n                        rightExcludedW = 0.5;\n                    }\n                    double dw = (weight[it] + weight[it + 1]) / 2;\n\n                    checkArgument(dw > 1, \"dw must be > 1, was %s\", dw);\n                    checkArgument((leftExcludedW + rightExcludedW) <= 0.5, \"Excluded weight must be <= 0.5, was %s\", leftExcludedW + rightExcludedW);\n\n                    // adjust endpoints for any singleton\n                    double left = mean[it];\n                    double right = mean[it + 1];\n\n                    double dwNoSingleton = dw - leftExcludedW - rightExcludedW;\n\n                    checkArgument(right - left > 0, \"Centroids should be in ascending order, but mean of left centroid was greater than right centroid\");\n\n                    double base = weightSoFar + weight[it] / 2 + leftExcludedW;\n                    return (base + dwNoSingleton * (x - left) / (right - left)) / totalWeight;\n                }\n                else {\n                    // caution against floating point madness\n                    double dw = (weight[it] + weight[it + 1]) / 2;\n                    return (weightSoFar + dw) / totalWeight;\n                }\n            }\n            else {\n                weightSoFar += weight[it];\n            }\n        }\n        checkArgument(x == mean[n - 1], \"At this point, x must equal the mean of the last centroid\");\n\n        return 1 - 0.5 / totalWeight;",
    "replace": "        // Use binary search to find the right interval - O(log n) instead of O(n)\n        int leftIdx = 0;\n        int rightIdx = n - 1;\n        \n        while (leftIdx <= rightIdx) {\n            int mid = (leftIdx + rightIdx) >>> 1;\n            if (mean[mid] < x) {\n                leftIdx = mid + 1;\n            } else {\n                rightIdx = mid - 1;\n            }\n        }\n        \n        // leftIdx is now the first centroid with mean >= x\n        if (leftIdx == 0) {\n            // x is before first centroid\n            if (mean[0] - min > 0) {\n                if (x == min) {\n                    return 0.5 / totalWeight;\n                }\n                return (1 + (x - min) / (mean[0] - min) * (weight[0] / 2 - 1)) / totalWeight;\n            }\n            return 0;\n        }\n        \n        if (leftIdx == n) {\n            // x is after last centroid\n            if (max - mean[n - 1] > 0) {\n                if (x == max) {\n                    return 1 - 0.5 / totalWeight;\n                }\n                double dq = (1 + (max - x) / (max - mean[n - 1]) * (weight[n - 1] / 2 - 1)) / totalWeight;\n                return 1 - dq;\n            }\n            return 1;\n        }\n        \n        // Check if x equals a centroid mean\n        if (mean[leftIdx] == x) {\n            // Find all centroids with the same mean\n            int start = leftIdx;\n            while (start > 0 && mean[start - 1] == x) {\n                start--;\n            }\n            int end = leftIdx;\n            while (end < n - 1 && mean[end + 1] == x) {\n                end++;\n            }\n            \n            // Calculate cumulative weight up to start\n            double weightSoFar = 0;\n            for (int i = 0; i < start; i++) {\n                weightSoFar += weight[i];\n            }\n            \n            // Calculate total weight of matching centroids\n            double matchingWeight = 0;\n            for (int i = start; i <= end; i++) {\n                matchingWeight += weight[i];\n            }\n            \n            return (weightSoFar + matchingWeight / 2) / totalWeight;\n        }\n        \n        // x is between centroids leftIdx-1 and leftIdx\n        int prev = leftIdx - 1;\n        \n        // Calculate cumulative weight up to prev\n        double weightSoFar = 0;\n        for (int i = 0; i < prev; i++) {\n            weightSoFar += weight[i];\n        }\n        \n        // landed between centroids\n        if (mean[leftIdx] - mean[prev] > 0) {\n            // no interpolation needed if we have a singleton centroid\n            double leftExcludedW = 0;\n            double rightExcludedW = 0;\n            if (weight[prev] == 1) {\n                if (weight[leftIdx] == 1) {\n                    // two singletons means no interpolation\n                    // left singleton is in, right is out\n                    return (weightSoFar + 1) / totalWeight;\n                }\n                else {\n                    leftExcludedW = 0.5;\n                }\n            }\n            else if (weight[leftIdx] == 1) {\n                rightExcludedW = 0.5;\n            }\n            double dw = (weight[prev] + weight[leftIdx]) / 2;\n\n            checkArgument(dw > 1, \"dw must be > 1, was %s\", dw);\n            checkArgument((leftExcludedW + rightExcludedW) <= 0.5, \"Excluded weight must be <= 0.5, was %s\", leftExcludedW + rightExcludedW);\n\n            // adjust endpoints for any singleton\n            double left = mean[prev];\n            double right = mean[leftIdx];\n\n            double dwNoSingleton = dw - leftExcludedW - rightExcludedW;\n\n            checkArgument(right - left > 0, \"Centroids should be in ascending order, but mean of left centroid was greater than right centroid\");\n\n            double base = weightSoFar + weight[prev] / 2 + leftExcludedW;\n            return (base + dwNoSingleton * (x - left) / (right - left)) / totalWeight;\n        }\n        else {\n            // caution against floating point madness\n            double dw = (weight[prev] + weight[leftIdx]) / 2;\n            return (weightSoFar + dw) / totalWeight;\n        }"
  }
]
```