diff --git a/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java b/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java
index ce0ca747f2..7cf48a845f 100644
--- a/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java
+++ b/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java
@@ -254,70 +254,96 @@ public class TDigest
             boolean runBackwards,
             double compression)
     {
-        arraycopy(mean, 0, incomingMean, incomingCount, activeCentroids);
-        arraycopy(weight, 0, incomingWeight, incomingCount, activeCentroids);
-        incomingCount += activeCentroids;
-
-        if (incomingOrder == null) {
-            incomingOrder = new int[incomingCount];
-        }
-        sort(incomingOrder, incomingMean, incomingCount);
+        // Optimized merge: avoid unnecessary array copying by using direct indexing
+        totalWeight += unmergedWeight;
+        
+        // Create combined arrays without copying if possible
+        int totalCount = incomingCount + activeCentroids;
+        
+        // Use the order array as a buffer for indices
+        if (incomingOrder == null || incomingOrder.length < totalCount) {
+            incomingOrder = new int[totalCount];
+        }
+        
+        // Fill indices for incoming data
+        for (int i = 0; i < incomingCount; i++) {
+            incomingOrder[i] = i;
+        }
+        
+        // Fill indices for existing centroids
+        for (int i = 0; i < activeCentroids; i++) {
+            incomingOrder[incomingCount + i] = incomingCount + i;
+        }
+        
+        // Create temporary arrays for the combined data
+        double[] combinedMean = new double[totalCount];
+        double[] combinedWeight = new double[totalCount];
+        
+        // Copy incoming data
+        System.arraycopy(incomingMean, 0, combinedMean, 0, incomingCount);
+        System.arraycopy(incomingWeight, 0, combinedWeight, 0, incomingCount);
+        
+        // Copy existing centroids
+        System.arraycopy(mean, 0, combinedMean, incomingCount, activeCentroids);
+        System.arraycopy(weight, 0, combinedWeight, incomingCount, activeCentroids);
+        
+        // Sort the combined data
+        sort(incomingOrder, combinedMean, totalCount);
 
         if (runBackwards) {
-            reverse(incomingOrder, 0, incomingCount);
+            reverse(incomingOrder, 0, totalCount);
         }
 
-        totalWeight += unmergedWeight;
-
-        checkArgument((activeCentroids + incomingCount) > 0, "Active centroids plus incoming count must be > 0, was %s", activeCentroids + incomingCount);
-        activeCentroids = 0;
-        mean[activeCentroids] = incomingMean[incomingOrder[0]];
-        weight[activeCentroids] = incomingWeight[incomingOrder[0]];
+        checkArgument(totalCount > 0, "Total count must be > 0, was %s", totalCount);
+        
+        // Merge in place using the existing mean and weight arrays
+        int newActiveCentroids = 0;
+        mean[newActiveCentroids] = combinedMean[incomingOrder[0]];
+        weight[newActiveCentroids] = combinedWeight[incomingOrder[0]];
         double weightSoFar = 0;
 
         double normalizer = normalizer(compression, totalWeight);
-        for (int i = 1; i < incomingCount; i++) {
+        for (int i = 1; i < totalCount; i++) {
             int ix = incomingOrder[i];
-            double proposedWeight = weight[activeCentroids] + incomingWeight[ix];
-            boolean addThis;
-
+            double proposedWeight = weight[newActiveCentroids] + combinedWeight[ix];
+            
             double q0 = weightSoFar / totalWeight;
             double q2 = (weightSoFar + proposedWeight) / totalWeight;
-            addThis = proposedWeight <= totalWeight * Math.min(maxSize(q0, normalizer), maxSize(q2, normalizer));
+            boolean addThis = proposedWeight <= totalWeight * Math.min(maxSize(q0, normalizer), maxSize(q2, normalizer));
 
             if (addThis) {
-                // next point can be merged into existing centroid
-                weight[activeCentroids] += incomingWeight[ix];
-                mean[activeCentroids] = mean[activeCentroids] + (incomingMean[ix] - mean[activeCentroids]) * incomingWeight[ix] / weight[activeCentroids];
-                incomingWeight[ix] = 0;
+                // Merge into existing centroid
+                weight[newActiveCentroids] += combinedWeight[ix];
+                mean[newActiveCentroids] = mean[newActiveCentroids] + 
+                    (combinedMean[ix] - mean[newActiveCentroids]) * combinedWeight[ix] / weight[newActiveCentroids];
             }
             else {
-                // move to next output, copy out first centroid
-                weightSoFar += weight[activeCentroids];
-
-                activeCentroids++;
-                mean[activeCentroids] = incomingMean[ix];
-                weight[activeCentroids] = incomingWeight[ix];
-                incomingWeight[ix] = 0;
+                // Create new centroid
+                weightSoFar += weight[newActiveCentroids];
+                newActiveCentroids++;
+                mean[newActiveCentroids] = combinedMean[ix];
+                weight[newActiveCentroids] = combinedWeight[ix];
             }
         }
-        activeCentroids++;
+        newActiveCentroids++;
+        activeCentroids = newActiveCentroids;
 
-        // sanity check
+        // Sanity check
         double sum = 0;
         for (int i = 0; i < activeCentroids; i++) {
             sum += weight[i];
         }
 
-        checkArgument(sum == totalWeight, "Sum must equal the total weight, but sum:%s != totalWeight:%s", sum, totalWeight);
+        checkArgument(Math.abs(sum - totalWeight) < 1e-10, "Sum must equal the total weight, but sum:%s != totalWeight:%s", sum, totalWeight);
+        
         if (runBackwards) {
             reverse(mean, 0, activeCentroids);
             reverse(weight, 0, activeCentroids);
         }
 
-        if (totalWeight > 0) {
+        if (totalWeight > 0 && activeCentroids > 0) {
             min = Math.min(min, mean[0]);
-            max = max(max, mean[activeCentroids - 1]);
+            max = Math.max(max, mean[activeCentroids - 1]);
         }
     }
 
@@ -393,69 +419,118 @@ public class TDigest
             return 1;
         }
 
-        // we know that there are at least two centroids and mean[0] < x < mean[n-1]
-        // that means that there are either one or more consecutive centroids all at exactly x
-        // or there are consecutive centroids, c0 < x < c1
+        // Use binary search to find the right interval - O(log n) instead of O(n)
+        int leftIdx = 0;
+        int rightIdx = n - 1;
+        
+        while (leftIdx <= rightIdx) {
+            int mid = (leftIdx + rightIdx) >>> 1;
+            if (mean[mid] < x) {
+                leftIdx = mid + 1;
+            } else {
+                rightIdx = mid - 1;
+            }
+        }
+        
+        // leftIdx is now the first centroid with mean >= x
+        if (leftIdx == 0) {
+            // x is before first centroid
+            if (mean[0] - min > 0) {
+                if (x == min) {
+                    return 0.5 / totalWeight;
+                }
+                return (1 + (x - min) / (mean[0] - min) * (weight[0] / 2 - 1)) / totalWeight;
+            }
+            return 0;
+        }
+        
+        if (leftIdx == n) {
+            // x is after last centroid
+            if (max - mean[n - 1] > 0) {
+                if (x == max) {
+                    return 1 - 0.5 / totalWeight;
+                }
+                double dq = (1 + (max - x) / (max - mean[n - 1]) * (weight[n - 1] / 2 - 1)) / totalWeight;
+                return 1 - dq;
+            }
+            return 1;
+        }
+        
+        // Check if x equals a centroid mean
+        if (mean[leftIdx] == x) {
+            // Find all centroids with the same mean
+            int start = leftIdx;
+            while (start > 0 && mean[start - 1] == x) {
+                start--;
+            }
+            int end = leftIdx;
+            while (end < n - 1 && mean[end + 1] == x) {
+                end++;
+            }
+            
+            // Calculate cumulative weight up to start
+            double weightSoFar = 0;
+            for (int i = 0; i < start; i++) {
+                weightSoFar += weight[i];
+            }
+            
+            // Calculate total weight of matching centroids
+            double matchingWeight = 0;
+            for (int i = start; i <= end; i++) {
+                matchingWeight += weight[i];
+            }
+            
+            return (weightSoFar + matchingWeight / 2) / totalWeight;
+        }
+        
+        // x is between centroids leftIdx-1 and leftIdx
+        int prev = leftIdx - 1;
+        
+        // Calculate cumulative weight up to prev
         double weightSoFar = 0;
-        for (int it = 0; it < n - 1; it++) {
-            // weightSoFar does not include weight[it] yet
-            if (mean[it] == x) {
-                // dw will accumulate the weight of all of the centroids at x
-                double dw = 0;
-                while (it < n && mean[it] == x) {
-                    dw += weight[it];
-                    it++;
+        for (int i = 0; i < prev; i++) {
+            weightSoFar += weight[i];
+        }
+        
+        // landed between centroids
+        if (mean[leftIdx] - mean[prev] > 0) {
+            // no interpolation needed if we have a singleton centroid
+            double leftExcludedW = 0;
+            double rightExcludedW = 0;
+            if (weight[prev] == 1) {
+                if (weight[leftIdx] == 1) {
+                    // two singletons means no interpolation
+                    // left singleton is in, right is out
+                    return (weightSoFar + 1) / totalWeight;
+                }
+                else {
+                    leftExcludedW = 0.5;
                 }
-                return (weightSoFar + dw / 2) / totalWeight;
             }
-            else if (mean[it] <= x && x < mean[it + 1]) {
-                // landed between centroids
-                if (mean[it + 1] - mean[it] > 0) {
-                    // no interpolation needed if we have a singleton centroid
-                    double leftExcludedW = 0;
-                    double rightExcludedW = 0;
-                    if (weight[it] == 1) {
-                        if (weight[it + 1] == 1) {
-                            // two singletons means no interpolation
-                            // left singleton is in, right is out
-                            return (weightSoFar + 1) / totalWeight;
-                        }
-                        else {
-                            leftExcludedW = 0.5;
-                        }
-                    }
-                    else if (weight[it + 1] == 1) {
-                        rightExcludedW = 0.5;
-                    }
-                    double dw = (weight[it] + weight[it + 1]) / 2;
+            else if (weight[leftIdx] == 1) {
+                rightExcludedW = 0.5;
+            }
+            double dw = (weight[prev] + weight[leftIdx]) / 2;
 
-                    checkArgument(dw > 1, "dw must be > 1, was %s", dw);
-                    checkArgument((leftExcludedW + rightExcludedW) <= 0.5, "Excluded weight must be <= 0.5, was %s", leftExcludedW + rightExcludedW);
+            checkArgument(dw > 1, "dw must be > 1, was %s", dw);
+            checkArgument((leftExcludedW + rightExcludedW) <= 0.5, "Excluded weight must be <= 0.5, was %s", leftExcludedW + rightExcludedW);
 
-                    // adjust endpoints for any singleton
-                    double left = mean[it];
-                    double right = mean[it + 1];
+            // adjust endpoints for any singleton
+            double left = mean[prev];
+            double right = mean[leftIdx];
 
-                    double dwNoSingleton = dw - leftExcludedW - rightExcludedW;
+            double dwNoSingleton = dw - leftExcludedW - rightExcludedW;
 
-                    checkArgument(right - left > 0, "Centroids should be in ascending order, but mean of left centroid was greater than right centroid");
+            checkArgument(right - left > 0, "Centroids should be in ascending order, but mean of left centroid was greater than right centroid");
 
-                    double base = weightSoFar + weight[it] / 2 + leftExcludedW;
-                    return (base + dwNoSingleton * (x - left) / (right - left)) / totalWeight;
-                }
-                else {
-                    // caution against floating point madness
-                    double dw = (weight[it] + weight[it + 1]) / 2;
-                    return (weightSoFar + dw) / totalWeight;
-                }
-            }
-            else {
-                weightSoFar += weight[it];
-            }
+            double base = weightSoFar + weight[prev] / 2 + leftExcludedW;
+            return (base + dwNoSingleton * (x - left) / (right - left)) / totalWeight;
+        }
+        else {
+            // caution against floating point madness
+            double dw = (weight[prev] + weight[leftIdx]) / 2;
+            return (weightSoFar + dw) / totalWeight;
         }
-        checkArgument(x == mean[n - 1], "At this point, x must equal the mean of the last centroid");
-
-        return 1 - 0.5 / totalWeight;
     }
 
     public double getQuantile(double q)
