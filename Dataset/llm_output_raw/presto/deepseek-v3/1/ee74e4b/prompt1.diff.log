Looking at the provided `PageProcessor.java` source code and the corresponding unit tests, I can identify several performance improvement opportunities. The main areas for optimization are:

1. **Avoid unnecessary stream operations and object allocations** in the constructor where output channels are validated and processed.
2. **Reduce overhead in the `updateRetainedSize()` method** by caching some calculations or simplifying the reference counting logic.
3. **Optimize the batch processing loop** to reduce branching and improve cache locality.
4. **Improve the `processBatch()` method** to minimize redundant checks and object creations.

Here are the specific changes I'll make:

### 1. Optimize the constructor's output channel validation and processing
The current implementation uses multiple stream operations that can be simplified to reduce overhead.

### 2. Optimize the `updateRetainedSize()` method
The current method creates a new `ReferenceCountMap` each time and iterates through all blocks. We can optimize by:
- Avoiding the creation of a new map each time if possible (though we need to be careful about thread safety since the class is `@NotThreadSafe`)
- Simplifying the logic for calculating retained size

### 3. Optimize the batch processing in `processBatch()`
The current implementation has multiple branches and creates new arrays frequently. We can:
- Pre-allocate arrays when possible
- Reduce redundant checks

### 4. Minor optimizations in the main processing loop
Reduce object allocations and streamline control flow.

Here are the atomic changes:

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java",
    "search": "        List<Integer> outputChannels = projections.stream().map(PageProjectionWithOutputs::getOutputChannels).map(Arrays::stream).map(IntStream::boxed).flatMap(identity()).distinct().collect(toImmutableList());\n        int outputCount = projections.stream().map(PageProjectionWithOutputs::getOutputCount).reduce(Integer::sum).orElse(0);\n        verify(\n                outputChannels.size() == outputCount && (outputCount == 0 || outputChannels.stream().max(Integer::compareTo).orElse(0) == outputChannels.size() - 1),\n                format(\"Invalid outputChannels: outputCount: %d, outputChannels: %s\", outputCount, outputChannels));",
    "replace": "        int outputCount = 0;\n        for (PageProjectionWithOutputs projection : projections) {\n            outputCount += projection.getOutputCount();\n        }\n        \n        // Build and validate output channels\n        int[] outputChannelsArray = new int[outputCount];\n        int index = 0;\n        for (PageProjectionWithOutputs projection : projections) {\n            int[] channels = projection.getOutputChannels();\n            System.arraycopy(channels, 0, outputChannelsArray, index, channels.length);\n            index += channels.length;\n        }\n        \n        // Sort and deduplicate for validation\n        int[] sortedChannels = outputChannelsArray.clone();\n        Arrays.sort(sortedChannels);\n        int uniqueCount = 0;\n        int last = -1;\n        for (int i = 0; i < sortedChannels.length; i++) {\n            if (sortedChannels[i] != last) {\n                uniqueCount++;\n                last = sortedChannels[i];\n            }\n        }\n        verify(\n                uniqueCount == outputCount && (outputCount == 0 || sortedChannels[outputCount - 1] == outputCount - 1),\n                format(\"Invalid outputChannels: outputCount: %d, outputChannels: %s\", outputCount, Arrays.toString(outputChannelsArray)));"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java",
    "search": "    private void updateRetainedSize()\n    {\n        // increment the size only when it is the first reference\n        retainedSizeInBytes = Page.INSTANCE_SIZE + SizeOf.sizeOfObjectArray(page.getChannelCount());\n        ReferenceCountMap referenceCountMap = new ReferenceCountMap();\n        for (int channel = 0; channel < page.getChannelCount(); channel++) {\n            Block block = page.getBlock(channel);\n            if (!isNotLoadedLazyBlock(block)) {\n                block.retainedBytesForEachPart((object, size) -> {\n                    if (referenceCountMap.incrementAndGet(object) == 1) {\n                        retainedSizeInBytes += size;\n                    }\n                });\n            }\n        }\n        for (Block previouslyComputedResult : previouslyComputedResults) {\n            if (previouslyComputedResult != null) {\n                previouslyComputedResult.retainedBytesForEachPart((object, size) -> {\n                    if (referenceCountMap.incrementAndGet(object) == 1) {\n                        retainedSizeInBytes += size;\n                    }\n                });\n            }\n        }\n\n        memoryContext.setBytes(retainedSizeInBytes);\n    }",
    "replace": "    private void updateRetainedSize()\n    {\n        // increment the size only when it is the first reference\n        retainedSizeInBytes = Page.INSTANCE_SIZE + SizeOf.sizeOfObjectArray(page.getChannelCount());\n        ReferenceCountMap referenceCountMap = new ReferenceCountMap();\n        \n        // Process page blocks\n        int channelCount = page.getChannelCount();\n        for (int channel = 0; channel < channelCount; channel++) {\n            Block block = page.getBlock(channel);\n            if (!isNotLoadedLazyBlock(block)) {\n                block.retainedBytesForEachPart((object, size) -> {\n                    if (referenceCountMap.incrementAndGet(object) == 1) {\n                        retainedSizeInBytes += size;\n                    }\n                });\n            }\n        }\n        \n        // Process previously computed results\n        for (int i = 0; i < previouslyComputedResults.length; i++) {\n            Block previouslyComputedResult = previouslyComputedResults[i];\n            if (previouslyComputedResult != null) {\n                previouslyComputedResult.retainedBytesForEachPart((object, size) -> {\n                    if (referenceCountMap.incrementAndGet(object) == 1) {\n                        retainedSizeInBytes += size;\n                    }\n                });\n            }\n        }\n\n        memoryContext.setBytes(retainedSizeInBytes);\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java",
    "search": "        private ProcessBatchResult processBatch(int batchSize)\n        {\n            Block[] blocks = new Block[outputCount];\n\n            int pageSize = 0;\n            SelectedPositions positionsBatch = selectedPositions.subRange(0, batchSize);\n            for (PageProjectionWithOutputs projection : projections) {\n                if (yieldSignal.isSet()) {\n                    return ProcessBatchResult.processBatchYield();\n                }\n\n                if (positionsBatch.size() > 1 && pageSize > MAX_PAGE_SIZE_IN_BYTES) {\n                    return ProcessBatchResult.processBatchTooLarge();\n                }\n\n                // if possible, use previouslyComputedResults produced in prior optimistic failure attempt\n                int[] outputChannels = projection.getOutputChannels();\n                // The progress on all output channels of a projection should be the same, so we just use the first one.\n                if (previouslyComputedResults[outputChannels[0]] != null && previouslyComputedResults[outputChannels[0]].getPositionCount() >= batchSize) {\n                    for (int channel : outputChannels) {\n                        blocks[channel] = previouslyComputedResults[channel].getRegion(0, batchSize);\n                        pageSize += blocks[channel].getSizeInBytes();\n                    }\n                }\n                else {\n                    if (pageProjectWork == null) {\n                        expressionProfiler.start();\n                        pageProjectWork = projection.project(properties, yieldSignal, projection.getPageProjection().getInputChannels().getInputChannels(page), positionsBatch);\n                        expressionProfiler.stop(positionsBatch.size());\n                    }\n                    if (!pageProjectWork.process()) {\n                        return ProcessBatchResult.processBatchYield();\n                    }\n                    List<Block> projectionOutputs = pageProjectWork.getResult();\n                    for (int j = 0; j < outputChannels.length; j++) {\n                        int channel = outputChannels[j];\n                        previouslyComputedResults[channel] = projectionOutputs.get(j);\n                        blocks[channel] = previouslyComputedResults[channel];\n                        pageSize += blocks[channel].getSizeInBytes();\n                    }\n                    pageProjectWork = null;\n                }\n            }\n            return ProcessBatchResult.processBatchSuccess(new Page(positionsBatch.size(), blocks));\n        }",
    "replace": "        private ProcessBatchResult processBatch(int batchSize)\n        {\n            Block[] blocks = new Block[outputCount];\n\n            int pageSize = 0;\n            SelectedPositions positionsBatch = selectedPositions.subRange(0, batchSize);\n            int positionsBatchSize = positionsBatch.size();\n            \n            for (PageProjectionWithOutputs projection : projections) {\n                if (yieldSignal.isSet()) {\n                    return ProcessBatchResult.processBatchYield();\n                }\n\n                if (positionsBatchSize > 1 && pageSize > MAX_PAGE_SIZE_IN_BYTES) {\n                    return ProcessBatchResult.processBatchTooLarge();\n                }\n\n                // if possible, use previouslyComputedResults produced in prior optimistic failure attempt\n                int[] outputChannels = projection.getOutputChannels();\n                int firstChannel = outputChannels[0];\n                // The progress on all output channels of a projection should be the same, so we just use the first one.\n                if (previouslyComputedResults[firstChannel] != null && previouslyComputedResults[firstChannel].getPositionCount() >= batchSize) {\n                    for (int channel : outputChannels) {\n                        Block block = previouslyComputedResults[channel].getRegion(0, batchSize);\n                        blocks[channel] = block;\n                        pageSize += block.getSizeInBytes();\n                    }\n                }\n                else {\n                    if (pageProjectWork == null) {\n                        expressionProfiler.start();\n                        pageProjectWork = projection.project(properties, yieldSignal, projection.getPageProjection().getInputChannels().getInputChannels(page), positionsBatch);\n                        expressionProfiler.stop(positionsBatchSize);\n                    }\n                    if (!pageProjectWork.process()) {\n                        return ProcessBatchResult.processBatchYield();\n                    }\n                    List<Block> projectionOutputs = pageProjectWork.getResult();\n                    for (int j = 0; j < outputChannels.length; j++) {\n                        int channel = outputChannels[j];\n                        Block block = projectionOutputs.get(j);\n                        previouslyComputedResults[channel] = block;\n                        blocks[channel] = block;\n                        pageSize += block.getSizeInBytes();\n                    }\n                    pageProjectWork = null;\n                }\n            }\n            return ProcessBatchResult.processBatchSuccess(new Page(positionsBatchSize, blocks));\n        }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java",
    "search": "                // if we produced a large page or if the expression is expensive, halve the batch size for the next call\n                long pageSize = resultPage.getSizeInBytes();\n                if (resultPage.getPositionCount() > 1 && (pageSize > MAX_PAGE_SIZE_IN_BYTES || expressionProfiler.isExpressionExpensive())) {\n                    projectBatchSize = projectBatchSize / 2;\n                }\n\n                // if we produced a small page, double the batch size for the next call\n                if (pageSize < MIN_PAGE_SIZE_IN_BYTES && projectBatchSize < MAX_BATCH_SIZE && !expressionProfiler.isExpressionExpensive()) {\n                    projectBatchSize = projectBatchSize * 2;\n                }",
    "replace": "                // if we produced a large page or if the expression is expensive, halve the batch size for the next call\n                long pageSize = resultPage.getSizeInBytes();\n                int positionCount = resultPage.getPositionCount();\n                boolean isExpensive = expressionProfiler.isExpressionExpensive();\n                if (positionCount > 1 && (pageSize > MAX_PAGE_SIZE_IN_BYTES || isExpensive)) {\n                    projectBatchSize = projectBatchSize / 2;\n                }\n\n                // if we produced a small page, double the batch size for the next call\n                if (pageSize < MIN_PAGE_SIZE_IN_BYTES && projectBatchSize < MAX_BATCH_SIZE && !isExpensive) {\n                    projectBatchSize = projectBatchSize * 2;\n                }"
  }
]
```