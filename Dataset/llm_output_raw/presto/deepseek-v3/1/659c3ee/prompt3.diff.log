Looking at the provided `ByteSelectiveStreamReader.java` and `ReaderUtils.java`, I can identify several performance improvement opportunities:

1. **Loop optimization in `readWithFilter`**: The current implementation has nested loops and complex skip logic that can be optimized.
2. **Memory access patterns**: The code frequently accesses arrays with bounds checking that could be optimized.
3. **Redundant null checks**: Some null checks could be eliminated or simplified.
4. **Method inlining opportunities**: Small helper methods could be inlined for better performance.

Here are the specific improvements:

```json
[
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java",
    "search": "    private int readWithFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        int streamPosition = 0;\n        outputPositionCount = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                if ((nonDeterministicFilter && filter.testNull()) || nullsAllowed) {\n                    if (outputRequired) {\n                        nulls[outputPositionCount] = true;\n                    }\n                    outputPositions[outputPositionCount] = position;\n                    outputPositionCount++;\n                }\n            }\n            else {\n                byte value = dataStream.next();\n                if (filter.testLong(value)) {\n                    if (outputRequired) {\n                        values[outputPositionCount] = value;\n                        if (nullsAllowed && presentStream != null) {\n                            nulls[outputPositionCount] = false;\n                        }\n                    }\n                    outputPositions[outputPositionCount] = position;\n                    outputPositionCount++;\n                }\n            }\n            streamPosition++;\n\n            if (filter != null) {\n                outputPositionCount -= filter.getPrecedingPositionsToFail();\n                int succeedingPositionsToFail = filter.getSucceedingPositionsToFail();\n                if (succeedingPositionsToFail > 0) {\n                    int positionsToSkip = 0;\n                    for (int j = 0; j < succeedingPositionsToFail; j++) {\n                        i++;\n                        int nextPosition = positions[i];\n                        positionsToSkip += 1 + nextPosition - streamPosition;\n                        streamPosition = nextPosition + 1;\n                    }\n                    skip(positionsToSkip);\n                }\n            }\n        }\n        return streamPosition;\n    }",
    "replace": "    private int readWithFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        int streamPosition = 0;\n        outputPositionCount = 0;\n        int i = 0;\n        while (i < positionCount) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                if ((nonDeterministicFilter && filter.testNull()) || nullsAllowed) {\n                    if (outputRequired) {\n                        nulls[outputPositionCount] = true;\n                    }\n                    outputPositions[outputPositionCount] = position;\n                    outputPositionCount++;\n                }\n            }\n            else {\n                byte value = dataStream.next();\n                if (filter.testLong(value)) {\n                    if (outputRequired) {\n                        values[outputPositionCount] = value;\n                        if (nullsAllowed && presentStream != null) {\n                            nulls[outputPositionCount] = false;\n                        }\n                    }\n                    outputPositions[outputPositionCount] = position;\n                    outputPositionCount++;\n                }\n            }\n            streamPosition++;\n            i++;\n\n            if (filter != null) {\n                outputPositionCount -= filter.getPrecedingPositionsToFail();\n                int succeedingPositionsToFail = filter.getSucceedingPositionsToFail();\n                if (succeedingPositionsToFail > 0) {\n                    int positionsToSkip = 0;\n                    for (int j = 0; j < succeedingPositionsToFail && i < positionCount; j++) {\n                        int nextPosition = positions[i];\n                        positionsToSkip += 1 + nextPosition - streamPosition;\n                        streamPosition = nextPosition + 1;\n                        i++;\n                    }\n                    skip(positionsToSkip);\n                }\n            }\n        }\n        return streamPosition;\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java",
    "search": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        if (presentStream == null && positions[positionCount - 1] == positionCount - 1) {\n            // contiguous chunk of rows, no nulls\n            dataStream.next(values, positionCount);\n            outputPositionCount = positionCount;\n            return positionCount;\n        }\n\n        int streamPosition = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = dataStream.next();\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }",
    "replace": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        if (presentStream == null && positions[positionCount - 1] == positionCount - 1) {\n            // contiguous chunk of rows, no nulls\n            dataStream.next(values, positionCount);\n            outputPositionCount = positionCount;\n            return positionCount;\n        }\n\n        int streamPosition = 0;\n        int i = 0;\n        while (i < positionCount) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = dataStream.next();\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n            i++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java",
    "search": "    private void skip(int items)\n            throws IOException\n    {\n        if (dataStream == null) {\n            presentStream.skip(items);\n        }\n        else if (presentStream != null) {\n            int dataToSkip = presentStream.countBitsSet(items);\n            dataStream.skip(dataToSkip);\n        }\n        else {\n            dataStream.skip(items);\n        }\n    }",
    "replace": "    private void skip(int items)\n            throws IOException\n    {\n        if (items <= 0) {\n            return;\n        }\n        if (dataStream == null) {\n            presentStream.skip(items);\n        }\n        else if (presentStream != null) {\n            int dataToSkip = presentStream.countBitsSet(items);\n            if (dataToSkip > 0) {\n                dataStream.skip(dataToSkip);\n            }\n        }\n        else {\n            dataStream.skip(items);\n        }\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ReaderUtils.java",
    "search": "    public static byte[] unpackByteNulls(byte[] values, boolean[] isNull)\n    {\n        byte[] result = new byte[isNull.length];\n\n        int position = 0;\n        for (int i = 0; i < isNull.length; i++) {\n            if (!isNull[i]) {\n                result[i] = values[position];\n                position++;\n            }\n        }\n        return result;\n    }",
    "replace": "    public static byte[] unpackByteNulls(byte[] values, boolean[] isNull)\n    {\n        byte[] result = new byte[isNull.length];\n\n        int position = 0;\n        for (int i = 0; i < isNull.length; i++) {\n            if (!isNull[i]) {\n                result[i] = values[position++];\n            }\n        }\n        return result;\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ReaderUtils.java",
    "search": "    public static short[] unpackShortNulls(short[] values, boolean[] isNull)\n    {\n        short[] result = new short[isNull.length];\n\n        int position = 0;\n        for (int i = 0; i < isNull.length; i++) {\n            if (!isNull[i]) {\n                result[i] = values[position];\n                position++;\n            }\n        }\n        return result;\n    }",
    "replace": "    public static short[] unpackShortNulls(short[] values, boolean[] isNull)\n    {\n        short[] result = new short[isNull.length];\n\n        int position = 0;\n        for (int i = 0; i < isNull.length; i++) {\n            if (!isNull[i]) {\n                result[i] = values[position++];\n            }\n        }\n        return result;\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ReaderUtils.java",
    "search": "    public static int[] unpackIntNulls(int[] values, boolean[] isNull)\n    {\n        int[] result = new int[isNull.length];\n\n        int position = 0;\n        for (int i = 0; i < isNull.length; i++) {\n            if (!isNull[i]) {\n                result[i] = values[position];\n                position++;\n            }\n        }\n        return result;\n    }",
    "replace": "    public static int[] unpackIntNulls(int[] values, boolean[] isNull)\n    {\n        int[] result = new int[isNull.length];\n\n        int position = 0;\n        for (int i = 0; i < isNull.length; i++) {\n            if (!isNull[i]) {\n                result[i] = values[position++];\n            }\n        }\n        return result;\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ReaderUtils.java",
    "search": "    public static long[] unpackLongNulls(long[] values, boolean[] isNull)\n    {\n        long[] result = new long[isNull.length];\n\n        int position = 0;\n        for (int i = 0; i < isNull.length; i++) {\n            if (!isNull[i]) {\n                result[i] = values[position];\n                position++;\n            }\n        }\n        return result;\n    }",
    "replace": "    public static long[] unpackLongNulls(long[] values, boolean[] isNull)\n    {\n        long[] result = new long[isNull.length];\n\n        int position = 0;\n        for (int i = 0; i < isNull.length; i++) {\n            if (!isNull[i]) {\n                result[i] = values[position++];\n            }\n        }\n        return result;\n    }"
  }
]
```