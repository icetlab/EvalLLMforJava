The current implementation of `GeneratedPageProjection` re-creates a list of `BlockBuilder`s for every page processed. This is done within the `project` method using a stream and collecting to a new `ImmutableList`, which is inefficient due to repeated object allocations (streams, collectors, lists) on a hot path.

My improvement changes this behavior to be more performant.
1.  In the constructor, the `blockBuilders` list is now initialized as a mutable `java.util.ArrayList` instead of an `ImmutableList`. I use fully-qualified class names to avoid modifying the import statements in this part of the change.
2.  In the `project` method, instead of creating a new list, I now reuse the existing `ArrayList`. I iterate through it and replace each `BlockBuilder` with a new one, using the `set` method. This avoids the overhead of creating a new list for every page and eliminates the use of streams in this critical path.

To ensure this change is atomic and self-contained, I've combined the modifications to the constructor and the `project` method into a single search-and-replace operation. This also includes removing an import that becomes unused as a result of these changes. This approach guarantees that the code remains valid after the patch is applied, while delivering a significant performance improvement by reducing object churn.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/project/GeneratedPageProjection.java",
    "search": "import static com.google.common.collect.ImmutableList.toImmutableList;\nimport static java.util.Objects.requireNonNull;\n\npublic class GeneratedPageProjection\n        implements PageProjection\n{\n    private final List<RowExpression> projections;\n    private final boolean isDeterministic;\n    private final InputChannels inputChannels;\n    private final MethodHandle pageProjectionWorkFactory;\n\n    private List<BlockBuilder> blockBuilders;\n\n    public GeneratedPageProjection(List<RowExpression> projections, boolean isDeterministic, InputChannels inputChannels, MethodHandle pageProjectionWorkFactory)\n    {\n        this.projections = ImmutableList.copyOf(requireNonNull(projections, \"projections is null\"));\n        this.isDeterministic = isDeterministic;\n        this.inputChannels = requireNonNull(inputChannels, \"inputChannels is null\");\n        this.pageProjectionWorkFactory = requireNonNull(pageProjectionWorkFactory, \"pageProjectionWorkFactory is null\");\n        this.blockBuilders = projections.stream().map(RowExpression::getType).map(type -> type.createBlockBuilder(null, 1)).collect(toImmutableList());\n    }\n\n    @Override\n    public boolean isDeterministic()\n    {\n        return isDeterministic;\n    }\n\n    @Override\n    public InputChannels getInputChannels()\n    {\n        return inputChannels;\n    }\n\n    @Override\n    public Work<List<Block>> project(SqlFunctionProperties properties, DriverYieldSignal yieldSignal, Page page, SelectedPositions selectedPositions)\n    {\n        blockBuilders = blockBuilders.stream().map(blockBuilder -> blockBuilder.newBlockBuilderLike(null)).collect(toImmutableList());",
    "replace": "import static java.util.Objects.requireNonNull;\n\npublic class GeneratedPageProjection\n        implements PageProjection\n{\n    private final List<RowExpression> projections;\n    private final boolean isDeterministic;\n    private final InputChannels inputChannels;\n    private final MethodHandle pageProjectionWorkFactory;\n\n    private List<BlockBuilder> blockBuilders;\n\n    public GeneratedPageProjection(List<RowExpression> projections, boolean isDeterministic, InputChannels inputChannels, MethodHandle pageProjectionWorkFactory)\n    {\n        this.projections = ImmutableList.copyOf(requireNonNull(projections, \"projections is null\"));\n        this.isDeterministic = isDeterministic;\n        this.inputChannels = requireNonNull(inputChannels, \"inputChannels is null\");\n        this.pageProjectionWorkFactory = requireNonNull(pageProjectionWorkFactory, \"pageProjectionWorkFactory is null\");\n        this.blockBuilders = projections.stream()\n                .map(RowExpression::getType)\n                .map(type -> type.createBlockBuilder(null, 1))\n                .collect(java.util.stream.Collectors.toCollection(() -> new java.util.ArrayList<>(projections.size())));\n    }\n\n    @Override\n    public boolean isDeterministic()\n    {\n        return isDeterministic;\n    }\n\n    @Override\n    public InputChannels getInputChannels()\n    {\n        return inputChannels;\n    }\n\n    @Override\n    public Work<List<Block>> project(SqlFunctionProperties properties, DriverYieldSignal yieldSignal, Page page, SelectedPositions selectedPositions)\n    {\n        for (int i = 0; i < blockBuilders.size(); i++) {\n            blockBuilders.set(i, blockBuilders.get(i).newBlockBuilderLike(null));\n        }"
  }
]
```