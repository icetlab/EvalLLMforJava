diff --git a/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java b/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java
index de6dddea..a8b05224 100644
--- a/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java
+++ b/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java
@@ -13,68 +13,70 @@ public class Node16 extends Node {
   long secondV = 0L;
   Node[] children = new Node[16];
 
+  private static int byteSearchInLong(long v, int length, byte k) {
+    for (int i = 0; i < length; i++) {
+      byte cur = (byte) (v >>> ((7 - i) * 8));
+      if (cur == k) {
+        return i;
+      }
+    }
+    return ILLEGAL_IDX;
+  }
+
+  private static SearchResult byteSearchWithResultInLong(long v, int offset, int length, byte k) {
+    for (int j = 0; j < length; j++) {
+      byte cur = (byte) (v >>> ((7 - j) * 8));
+      if (cur == k) {
+        return SearchResult.found(offset + j);
+      } else if ((cur & 0xFF) > (k & 0xFF)) {
+        int lowPos = (j == 0) ? ILLEGAL_IDX : offset + j - 1;
+        int highPos = offset + j;
+        return SearchResult.notFound(lowPos, highPos);
+      }
+    }
+    int lowPos = (length == 0) ? ILLEGAL_IDX : offset + length - 1;
+    return SearchResult.notFound(lowPos, ILLEGAL_IDX);
+  }
+
   public Node16(int compressionLength) {
     super(NodeType.NODE16, compressionLength);
   }
 
   @Override
   public int getChildPos(byte k) {
-    byte[] firstBytes = LongUtils.toBDBytes(firstV);
     if (count <= 8) {
-      return Node.binarySearch(firstBytes, 0, count, k);
+      return byteSearchInLong(firstV, count, k);
     } else {
-      int pos = Node.binarySearch(firstBytes, 0, 8, k);
+      int pos = byteSearchInLong(firstV, 8, k);
       if (pos != ILLEGAL_IDX) {
         return pos;
       } else {
-        byte[] secondBytes = LongUtils.toBDBytes(secondV);
-        pos = Node.binarySearch(secondBytes, 0, (count - 8), k);
-        if (pos != ILLEGAL_IDX) {
-          return 8 + pos;
-        } else {
-          return ILLEGAL_IDX;
-        }
+        pos = byteSearchInLong(secondV, count - 8, k);
+        return pos != ILLEGAL_IDX ? 8 + pos : ILLEGAL_IDX;
       }
     }
   }
 
   @Override
   public SearchResult getNearestChildPos(byte k) {
-    byte[] firstBytes = LongUtils.toBDBytes(firstV);
     if (count <= 8) {
-      return Node.binarySearchWithResult(firstBytes, 0, count, k);
+      return byteSearchWithResultInLong(firstV, 0, count, k);
     } else {
-      SearchResult firstResult = Node.binarySearchWithResult(
-              firstBytes, 0, 8, k);
-      // given the values are "in order" if we found a match or a value larger than
-      // the target we are done.
-      if (firstResult.outcome == SearchResult.Outcome.FOUND
-              || firstResult.hasNextLargerPos()) {
+      SearchResult firstResult = byteSearchWithResultInLong(firstV, 0, 8, k);
+      if (firstResult.outcome == SearchResult.Outcome.FOUND || firstResult.hasNextLargerPos()) {
         return firstResult;
       } else {
-        byte[] secondBytes = LongUtils.toBDBytes(secondV);
-        SearchResult secondResult = Node.binarySearchWithResult(
-                secondBytes, 0, (count - 8), k);
-
+        SearchResult secondResult = byteSearchWithResultInLong(secondV, 8, count - 8, k);
         switch (secondResult.outcome) {
           case FOUND:
-            return SearchResult.found(8 + secondResult.getKeyPos());
+            return SearchResult.found(secondResult.getKeyPos());
           case NOT_FOUND:
             int lowPos = secondResult.getNextSmallerPos();
             int highPos = secondResult.getNextLargerPos();
-            // don't map -1 into the legal range by adding 8!
-            if (lowPos>=0){ lowPos += 8;}
-            if (highPos>=0){ highPos += 8;}
-
-            if(firstResult.hasNextLargerPos() == false && secondResult.hasNextSmallerPos() == false)
-            {
-              // this happens when the result is in the gap of the two ranges, the correct
-              // "smaller value" is that of first result.
+            if (!firstResult.hasNextLargerPos() && !secondResult.hasNextSmallerPos()) {
               lowPos = firstResult.getNextSmallerPos();
             }
-
             return SearchResult.notFound(lowPos, highPos);
-
           default:
             throw new IllegalStateException("There only two possible search outcomes");
         }
@@ -84,15 +86,11 @@ public class Node16 extends Node {
 
   @Override
   public byte getChildKey(int pos) {
-    int posInLong;
     if (pos <= 7) {
-      posInLong = pos;
-      byte[] firstBytes = LongUtils.toBDBytes(firstV);
-      return firstBytes[posInLong];
+      return (byte) (firstV >>> ((7 - pos) * 8));
     } else {
-      posInLong = pos - 8;
-      byte[] secondBytes = LongUtils.toBDBytes(secondV);
-      return secondBytes[posInLong];
+      int posInLong = pos - 8;
+      return (byte) (secondV >>> ((7 - posInLong) * 8));
     }
   }
 
