I have inlined byte access directly into the long-held key values and removed the per-call byte array allocations, replacing them with small helper methods that extract and search bytes via bit-shifts. This preserves all existing functionality while eliminating the intermediate array overhead.

```json
[
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java",
    "search": "Node[] children = new Node[16];",
    "replace": "Node[] children = new Node[16];\n\n  private static int byteSearchInLong(long v, int length, byte k) {\n    for (int i = 0; i < length; i++) {\n      byte cur = (byte) (v >>> ((7 - i) * 8));\n      if (cur == k) {\n        return i;\n      }\n    }\n    return ILLEGAL_IDX;\n  }\n\n  private static SearchResult byteSearchWithResultInLong(long v, int offset, int length, byte k) {\n    for (int j = 0; j < length; j++) {\n      byte cur = (byte) (v >>> ((7 - j) * 8));\n      if (cur == k) {\n        return SearchResult.found(offset + j);\n      } else if ((cur & 0xFF) > (k & 0xFF)) {\n        int lowPos = (j == 0) ? ILLEGAL_IDX : offset + j - 1;\n        int highPos = offset + j;\n        return SearchResult.notFound(lowPos, highPos);\n      }\n    }\n    int lowPos = (length == 0) ? ILLEGAL_IDX : offset + length - 1;\n    return SearchResult.notFound(lowPos, ILLEGAL_IDX);\n  }"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java",
    "search": "@Override\n  public int getChildPos(byte k) {\n    byte[] firstBytes = LongUtils.toBDBytes(firstV);\n    if (count <= 8) {\n      return Node.binarySearch(firstBytes, 0, count, k);\n    } else {\n      int pos = Node.binarySearch(firstBytes, 0, 8, k);\n      if (pos != ILLEGAL_IDX) {\n        return pos;\n      } else {\n        byte[] secondBytes = LongUtils.toBDBytes(secondV);\n        pos = Node.binarySearch(secondBytes, 0, (count - 8), k);\n        if (pos != ILLEGAL_IDX) {\n          return 8 + pos;\n        } else {\n          return ILLEGAL_IDX;\n        }\n      }\n    }\n  }",
    "replace": "@Override\n  public int getChildPos(byte k) {\n    if (count <= 8) {\n      return byteSearchInLong(firstV, count, k);\n    } else {\n      int pos = byteSearchInLong(firstV, 8, k);\n      if (pos != ILLEGAL_IDX) {\n        return pos;\n      } else {\n        pos = byteSearchInLong(secondV, count - 8, k);\n        return pos != ILLEGAL_IDX ? 8 + pos : ILLEGAL_IDX;\n      }\n    }\n  }"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java",
    "search": "@Override\n  public SearchResult getNearestChildPos(byte k) {\n    byte[] firstBytes = LongUtils.toBDBytes(firstV);\n    if (count <= 8) {\n      return Node.binarySearchWithResult(firstBytes, 0, count, k);\n    } else {\n      SearchResult firstResult = Node.binarySearchWithResult(\n              firstBytes, 0, 8, k);\n      // given the values are \"in order\" if we found a match or a value larger than\n      // the target we are done.\n      if (firstResult.outcome == SearchResult.Outcome.FOUND\n              || firstResult.hasNextLargerPos()) {\n        return firstResult;\n      } else {\n        byte[] secondBytes = LongUtils.toBDBytes(secondV);\n        SearchResult secondResult = Node.binarySearchWithResult(\n                secondBytes, 0, (count - 8), k);\n\n        switch(secondResult.outcome) {\n          case FOUND:\n            return SearchResult.found(8 + secondResult.getKeyPos());\n          case NOT_FOUND:\n            int lowPos = secondResult.getNextSmallerPos();\n            int highPos = secondResult.getNextLargerPos();\n            // don't map -1 into the legal range by adding 8!\n            if (lowPos>=0){ lowPos += 8;}\n            if (highPos>=0){ highPos += 8;}\n\n            if(firstResult.hasNextLargerPos() == false && secondResult.hasNextSmallerPos() == false)\n            {\n              // this happens when the result is in the gap of the two ranges, the correct\n              // \"smaller value\" is that of first result.\n              lowPos = firstResult.getNextSmallerPos();\n            }\n\n            return SearchResult.notFound( lowPos, highPos);\n\n          default:\n            throw new IllegalStateException(\"There only two possible search outcomes\");\n        }\n      }\n    }\n  }",
    "replace": "@Override\n  public SearchResult getNearestChildPos(byte k) {\n    if (count <= 8) {\n      return byteSearchWithResultInLong(firstV, 0, count, k);\n    } else {\n      SearchResult firstResult = byteSearchWithResultInLong(firstV, 0, 8, k);\n      if (firstResult.outcome == SearchResult.Outcome.FOUND || firstResult.hasNextLargerPos()) {\n        return firstResult;\n      } else {\n        SearchResult secondResult = byteSearchWithResultInLong(secondV, 8, count - 8, k);\n        switch (secondResult.outcome) {\n          case FOUND:\n            return SearchResult.found(secondResult.getKeyPos());\n          case NOT_FOUND:\n            int lowPos = secondResult.getNextSmallerPos();\n            int highPos = secondResult.getNextLargerPos();\n            if (!firstResult.hasNextLargerPos() && !secondResult.hasNextSmallerPos()) {\n              lowPos = firstResult.getNextSmallerPos();\n            }\n            return SearchResult.notFound(lowPos, highPos);\n          default:\n            throw new IllegalStateException(\"There only two possible search outcomes\");\n        }\n      }\n    }\n  }"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java",
    "search": "@Override\n  public byte getChildKey(int pos) {\n    int posInLong;\n    if (pos <= 7) {\n      posInLong = pos;\n      byte[] firstBytes = LongUtils.toBDBytes(firstV);\n      return firstBytes[posInLong];\n    } else {\n      posInLong = pos - 8;\n      byte[] secondBytes = LongUtils.toBDBytes(secondV);\n      return secondBytes[posInLong];\n    }\n  }",
    "replace": "@Override\n  public byte getChildKey(int pos) {\n    if (pos <= 7) {\n      return (byte) (firstV >>> ((7 - pos) * 8));\n    } else {\n      int posInLong = pos - 8;\n      return (byte) (secondV >>> ((7 - posInLong) * 8));\n    }\n  }"
  }
]
```