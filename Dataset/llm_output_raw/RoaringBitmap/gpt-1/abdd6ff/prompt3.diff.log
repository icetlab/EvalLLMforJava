Iâ€™ve optimized the `topK` removal logic to use `BatchIterator` for batched removals, reducing per-element overhead, and added the necessary `Arrays` import.

```json
[
  {
    "filepath": "../RoaringBitmap/bsi/src/main/java/org/roaringbitmap/bsi/buffer/BitSliceIndexBase.java",
    "search": "import java.util.stream.IntStream;",
    "replace": "import java.util.stream.IntStream;\nimport java.util.Arrays;"
  },
  {
    "filepath": "../RoaringBitmap/bsi/src/main/java/org/roaringbitmap/bsi/buffer/BitSliceIndexBase.java",
    "search": "if (n > 0) {\n      // TODO: make faster\n      IntIterator i = F.getIntIterator();\n      MutableRoaringBitmap turnoff = new MutableRoaringBitmap();\n      while (i.hasNext() && n > 0) {\n        turnoff.add(i.next());\n        --n;\n      }\n      F.andNot(turnoff);\n    }",
    "replace": "if (n > 0) {\n      MutableRoaringBitmap turnoff = new MutableRoaringBitmap();\n      BatchIterator batchIterator = F.getBatchIterator();\n      long remaining = n;\n      while (batchIterator.hasNext() && remaining > 0) {\n        int batchSize = (int) Math.min(remaining, 1024);\n        int[] buffer = new int[batchSize];\n        int count = batchIterator.nextBatch(buffer);\n        if (count > 0) {\n          if (count < buffer.length) {\n            turnoff.add(Arrays.copyOf(buffer, count));\n          } else {\n            turnoff.add(buffer);\n          }\n          remaining -= count;\n        }\n      }\n      F.andNot(turnoff);\n    }"
  }
]
```