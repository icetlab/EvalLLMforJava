I'll optimize the `shiftLeftFromSpecifiedPosition` method by replacing the array allocation and copying with direct bit manipulation operations. This will eliminate the overhead of creating byte arrays and performing memory copies.

```json
[
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/longlong/IntegerUtil.java",
    "search": "  /**\n   * shift the byte left from the specified position\n   * @param v a integer value\n   * @param pos the position from which to shift byte values left\n   * @param count the shifting numbers\n   * @return a fresh integer value\n   */\n  public static int shiftLeftFromSpecifiedPosition(int v, int pos, int count) {\n    byte[] initialVal = toBDBytes(v);\n    System.arraycopy(initialVal, pos + 1, initialVal, pos, count);\n    return fromBDBytes(initialVal);\n  }",
    "replace": "  /**\n   * shift the byte left from the specified position\n   * @param v a integer value\n   * @param pos the position from which to shift byte values left\n   * @param count the shifting numbers\n   * @return a fresh integer value\n   */\n  public static int shiftLeftFromSpecifiedPosition(int v, int pos, int count) {\n    // Calculate shift amounts for each byte position\n    int shiftMask = 0;\n    for (int i = 0; i < count; i++) {\n      int sourcePos = pos + i + 1;\n      int targetPos = pos + i;\n      if (sourcePos < 4) { // Ensure we don't shift beyond the integer\n        // Extract source byte and place it at target position\n        int sourceByte = (v >> (8 * (3 - sourcePos))) & 0xFF;\n        shiftMask |= sourceByte << (8 * (3 - targetPos));\n      }\n    }\n    // Clear the original bytes in the target range and apply shifted bytes\n    int clearMask = 0;\n    for (int i = 0; i < count; i++) {\n      int targetPos = pos + i;\n      clearMask |= 0xFF << (8 * (3 - targetPos));\n    }\n    return (v & ~clearMask) | shiftMask;\n  }"
  }
]
```