diff --git a/bsi/src/main/java/org/roaringbitmap/bsi/buffer/BitSliceIndexBase.java b/bsi/src/main/java/org/roaringbitmap/bsi/buffer/BitSliceIndexBase.java
index c40c836b..45414298 100644
--- a/bsi/src/main/java/org/roaringbitmap/bsi/buffer/BitSliceIndexBase.java
+++ b/bsi/src/main/java/org/roaringbitmap/bsi/buffer/BitSliceIndexBase.java
@@ -316,16 +316,23 @@ public class BitSliceIndexBase {
     }
 
     MutableRoaringBitmap F = ImmutableRoaringBitmap.or(G, E);
-    long n = F.getLongCardinality() - k;
-    if (n > 0) {
-      // TODO: make faster
-      IntIterator i = F.getIntIterator();
-      MutableRoaringBitmap turnoff = new MutableRoaringBitmap();
-      while (i.hasNext() && n > 0) {
-        turnoff.add(i.next());
-        --n;
+    if (F.getLongCardinality() > k) {
+      // We must remove F.getLongCardinality() - k elements by tie-breaking, choosing from E.
+      // This is equivalent to keeping k - G.getLongCardinality() elements from E.
+      // We keep the ones with largest column IDs from E, which are at the end of the iterator.
+      long to_keep_from_E = k - G.getLongCardinality();
+
+      MutableRoaringBitmap E_kept = new MutableRoaringBitmap();
+      if (to_keep_from_E > 0) {
+        IntIterator reverse_i = E.getReverseIntIterator();
+        for (int i = 0; i < to_keep_from_E; ++i) {
+          if (!reverse_i.hasNext()) {
+            break;
+          }
+          E_kept.add(reverse_i.next());
+        }
       }
-      F.andNot(turnoff);
+      F = MutableRoaringBitmap.or(G, E_kept);
     }
 
     if (F.getCardinality() != k)
@@ -620,14 +627,10 @@ public class BitSliceIndexBase {
 
 
   protected ImmutableRoaringBitmap batchIn(int[] batch, Set<Integer> values) {
-
     MutableRoaringBitmap result = new MutableRoaringBitmap();
-
-    for (int cID : batch) {
-      Pair<Integer, Boolean> value = this.getValue(cID);
-      if (value.getValue() && values.contains(value.getKey())) {
-        result.add(cID);
-      }
+    ImmutableRoaringBitmap batchBitmap = MutableRoaringBitmap.bitmapOf(batch);
+    for (Integer value : values) {
+      result.or(rangeEQ(batchBitmap, value));
     }
     return result;
   }
