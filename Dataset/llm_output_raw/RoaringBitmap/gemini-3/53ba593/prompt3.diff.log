My overall improvement strategy is to enhance performance and correctness across the `RoaringBitmap` and `MutableRoaringBitmap` classes.

First, I will optimize the binary logical operations (`or`, `xor`) in both `RoaringBitmap` and `MutableRoaringBitmap`. The existing implementations iterate through containers one by one, which is inefficient when one bitmap has a long sequence of containers not present in the other. I will replace this with a more efficient approach using `advanceUntil` (a galloping search) to skip multiple containers at once, significantly speeding up these operations on bitmaps with sparse, non-overlapping regions.

Second, I will address a correctness issue in `RoaringBitmap.contains(RoaringBitmap subset)`. The method incorrectly uses the `subset`'s internal array to advance its own position pointer, which can lead to incorrect results. I will fix this to use the correct `this` bitmap's array for advancing the position.

Finally, I will apply a micro-optimization to `RoaringBitmap.checkedAdd(int x)` by simplifying a conditional return statement, which can improve clarity and may offer a minor performance benefit by reducing branching.

These changes collectively improve performance, fix a bug, and enhance code readability without altering the public API or its intended behavior.

```json
[
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java",
    "search": "      Container newCont = c.add(Util.lowbits(x));\n      highLowContainer.setContainerAtIndex(i, newCont);\n      if (newCont.getCardinality() > oldCard) {\n        return true;\n      }\n    } else {\n      final ArrayContainer newac = new ArrayContainer();\n      highLowContainer.insertNewKeyValueAt(-i - 1, hb, newac.add(Util.lowbits(x)));\n      return true;\n    }\n    return false;",
    "replace": "      Container newCont = c.add(Util.lowbits(x));\n      highLowContainer.setContainerAtIndex(i, newCont);\n      return newCont.getCardinality() > oldCard;\n    } else {\n      final ArrayContainer newac = new ArrayContainer();\n      highLowContainer.insertNewKeyValueAt(-i - 1, hb, newac.add(Util.lowbits(x)));\n      return true;\n    }"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java",
    "search": "        if(!c1.contains(c2)) {\n          return false;\n        }\n        ++pos1;\n        ++pos2;\n      } else if (s1 - s2 > 0) {\n        return false;\n      } else {\n        pos1 = subset.highLowContainer.advanceUntil(s2, pos1);\n      }",
    "replace": "        if (!c1.contains(c2)) {\n          return false;\n        }\n        ++pos1;\n        ++pos2;\n      } else if (s1 > s2) {\n        return false;\n      } else {\n        pos1 = this.highLowContainer.advanceUntil(s2, pos1);\n      }"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java",
    "search": "    main: if (pos1 < length1 && pos2 < length2) {\n      char s1 = x1.highLowContainer.getKeyAtIndex(pos1);\n      char s2 = x2.highLowContainer.getKeyAtIndex(pos2);\n\n      while (true) {\n        if (s1 == s2) {\n          answer.highLowContainer.append(s1, x1.highLowContainer.getContainerAtIndex(pos1)\n              .or(x2.highLowContainer.getContainerAtIndex(pos2)));\n          pos1++;\n          pos2++;\n          if ((pos1 == length1) || (pos2 == length2)) {\n            break main;\n          }\n          s1 = x1.highLowContainer.getKeyAtIndex(pos1);\n          s2 = x2.highLowContainer.getKeyAtIndex(pos2);\n        } else if (s1 < s2) { \n          answer.highLowContainer.appendCopy(x1.highLowContainer, pos1);\n          pos1++;\n          if (pos1 == length1) {\n            break main;\n          }\n          s1 = x1.highLowContainer.getKeyAtIndex(pos1);\n        } else { \n          answer.highLowContainer.appendCopy(x2.highLowContainer, pos2);\n          pos2++;\n          if (pos2 == length2) {\n            break main;\n          }\n          s2 = x2.highLowContainer.getKeyAtIndex(pos2);\n        }\n      }\n    }\n    if (pos1 == length1) {\n      answer.highLowContainer.appendCopy(x2.highLowContainer, pos2, length2);\n    } else if (pos2 == length2) {\n      answer.highLowContainer.appendCopy(x1.highLowContainer, pos1, length1);\n    }",
    "replace": "    while (pos1 < length1 && pos2 < length2) {\n      final char s1 = x1.highLowContainer.getKeyAtIndex(pos1);\n      final char s2 = x2.highLowContainer.getKeyAtIndex(pos2);\n      if (s1 == s2) {\n        answer.highLowContainer.append(s1, x1.highLowContainer.getContainerAtIndex(pos1)\n            .or(x2.highLowContainer.getContainerAtIndex(pos2)));\n        pos1++;\n        pos2++;\n      } else if (s1 < s2) {\n        final int nextPos1 = x1.highLowContainer.advanceUntil(s2, pos1);\n        answer.highLowContainer.appendCopy(x1.highLowContainer, pos1, nextPos1);\n        pos1 = nextPos1;\n      } else { // s1 > s2\n        final int nextPos2 = x2.highLowContainer.advanceUntil(s1, pos2);\n        answer.highLowContainer.appendCopy(x2.highLowContainer, pos2, nextPos2);\n        pos2 = nextPos2;\n      }\n    }\n    if (pos1 < length1) {\n      answer.highLowContainer.appendCopy(x1.highLowContainer, pos1, length1);\n    } else if (pos2 < length2) {\n      answer.highLowContainer.appendCopy(x2.highLowContainer, pos2, length2);\n    }"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java",
    "search": "    main: if (pos1 < length1 && pos2 < length2) {\n      char s1 = x1.highLowContainer.getKeyAtIndex(pos1);\n      char s2 = x2.highLowContainer.getKeyAtIndex(pos2);\n\n      while (true) {\n        if (s1 == s2) {\n          final Container c = x1.highLowContainer.getContainerAtIndex(pos1)\n              .xor(x2.highLowContainer.getContainerAtIndex(pos2));\n          if (!c.isEmpty()) {\n            answer.highLowContainer.append(s1, c);\n          }\n          pos1++;\n          pos2++;\n          if ((pos1 == length1) || (pos2 == length2)) {\n            break main;\n          }\n          s1 = x1.highLowContainer.getKeyAtIndex(pos1);\n          s2 = x2.highLowContainer.getKeyAtIndex(pos2);\n        } else if (s1 < s2) { \n          answer.highLowContainer.appendCopy(x1.highLowContainer, pos1);\n          pos1++;\n          if (pos1 == length1) {\n            break main;\n          }\n          s1 = x1.highLowContainer.getKeyAtIndex(pos1);\n        } else { \n          answer.highLowContainer.appendCopy(x2.highLowContainer, pos2);\n          pos2++;\n          if (pos2 == length2) {\n            break main;\n          }\n          s2 = x2.highLowContainer.getKeyAtIndex(pos2);\n        }\n      }\n    }\n    if (pos1 == length1) {\n      answer.highLowContainer.appendCopy(x2.highLowContainer, pos2, length2);\n    } else if (pos2 == length2) {\n      answer.highLowContainer.appendCopy(x1.highLowContainer, pos1, length1);\n    }",
    "replace": "    while (pos1 < length1 && pos2 < length2) {\n      final char s1 = x1.highLowContainer.getKeyAtIndex(pos1);\n      final char s2 = x2.highLowContainer.getKeyAtIndex(pos2);\n      if (s1 == s2) {\n        final Container c = x1.highLowContainer.getContainerAtIndex(pos1)\n            .xor(x2.highLowContainer.getContainerAtIndex(pos2));\n        if (!c.isEmpty()) {\n          answer.highLowContainer.append(s1, c);\n        }\n        pos1++;\n        pos2++;\n      } else if (s1 < s2) {\n        final int nextPos1 = x1.highLowContainer.advanceUntil(s2, pos1);\n        answer.highLowContainer.appendCopy(x1.highLowContainer, pos1, nextPos1);\n        pos1 = nextPos1;\n      } else { // s1 > s2\n        final int nextPos2 = x2.highLowContainer.advanceUntil(s1, pos2);\n        answer.highLowContainer.appendCopy(x2.highLowContainer, pos2, nextPos2);\n        pos2 = nextPos2;\n      }\n    }\n    if (pos1 < length1) {\n      answer.highLowContainer.appendCopy(x1.highLowContainer, pos1, length1);\n    } else if (pos2 < length2) {\n      answer.highLowContainer.appendCopy(x2.highLowContainer, pos2, length2);\n    }"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MutableRoaringBitmap.java",
    "search": "    main: if (pos1 < length1 && pos2 < length2) {\n      char s1 = x1.highLowContainer.getKeyAtIndex(pos1);\n      char s2 = x2.highLowContainer.getKeyAtIndex(pos2);\n\n      while (true) {\n        if (s1 == s2) {\n          answer.getMappeableRoaringArray().append(s1, x1.highLowContainer.getContainerAtIndex(pos1)\n              .or(x2.highLowContainer.getContainerAtIndex(pos2)));\n          pos1++;\n          pos2++;\n          if ((pos1 == length1) || (pos2 == length2)) {\n            break main;\n          }\n          s1 = x1.highLowContainer.getKeyAtIndex(pos1);\n          s2 = x2.highLowContainer.getKeyAtIndex(pos2);\n        } else if (s1 < s2) { \n          answer.getMappeableRoaringArray().appendCopy(x1.highLowContainer.getKeyAtIndex(pos1),\n              x1.highLowContainer.getContainerAtIndex(pos1));\n          pos1++;\n          if (pos1 == length1) {\n            break main;\n          }\n          s1 = x1.highLowContainer.getKeyAtIndex(pos1);\n        } else { // s1 > s2\n          answer.getMappeableRoaringArray().appendCopy(x2.highLowContainer.getKeyAtIndex(pos2),\n              x2.highLowContainer.getContainerAtIndex(pos2));\n          pos2++;\n          if (pos2 == length2) {\n            break main;\n          }\n          s2 = x2.highLowContainer.getKeyAtIndex(pos2);\n        }\n      }\n    }\n    if (pos1 == length1) {\n      answer.getMappeableRoaringArray().appendCopy(x2.highLowContainer, pos2, length2);\n    } else if (pos2 == length2) {\n      answer.getMappeableRoaringArray().appendCopy(x1.highLowContainer, pos1, length1);\n    }",
    "replace": "    while (pos1 < length1 && pos2 < length2) {\n      final char s1 = x1.highLowContainer.getKeyAtIndex(pos1);\n      final char s2 = x2.highLowContainer.getKeyAtIndex(pos2);\n      if (s1 == s2) {\n        answer.getMappeableRoaringArray().append(s1, x1.highLowContainer.getContainerAtIndex(pos1)\n            .or(x2.highLowContainer.getContainerAtIndex(pos2)));\n        pos1++;\n        pos2++;\n      } else if (s1 < s2) {\n        final int nextPos1 = x1.highLowContainer.advanceUntil(s2, pos1);\n        answer.getMappeableRoaringArray().appendCopy(x1.highLowContainer, pos1, nextPos1);\n        pos1 = nextPos1;\n      } else { // s1 > s2\n        final int nextPos2 = x2.highLowContainer.advanceUntil(s1, pos2);\n        answer.getMappeableRoaringArray().appendCopy(x2.highLowContainer, pos2, nextPos2);\n        pos2 = nextPos2;\n      }\n    }\n    if (pos1 < length1) {\n      answer.getMappeableRoaringArray().appendCopy(x1.highLowContainer, pos1, length1);\n    } else if (pos2 < length2) {\n      answer.getMappeableRoaringArray().appendCopy(x2.highLowContainer, pos2, length2);\n    }"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MutableRoaringBitmap.java",
    "search": "    main: if (pos1 < length1 && pos2 < length2) {\n      char s1 = x1.highLowContainer.getKeyAtIndex(pos1);\n      char s2 = x2.highLowContainer.getKeyAtIndex(pos2);\n\n      while (true) {\n        if (s1 == s2) {\n          final MappeableContainer c = x1.highLowContainer.getContainerAtIndex(pos1)\n              .xor(x2.highLowContainer.getContainerAtIndex(pos2));\n          if (!c.isEmpty()) {\n            answer.getMappeableRoaringArray().append(s1, c);\n          }\n          pos1++;\n          pos2++;\n          if ((pos1 == length1) || (pos2 == length2)) {\n            break main;\n          }\n          s1 = x1.highLowContainer.getKeyAtIndex(pos1);\n          s2 = x2.highLowContainer.getKeyAtIndex(pos2);\n        } else if (s1 < s2) { \n          answer.getMappeableRoaringArray().appendCopy(x1.highLowContainer.getKeyAtIndex(pos1),\n              x1.highLowContainer.getContainerAtIndex(pos1));\n          pos1++;\n          if (pos1 == length1) {\n            break main;\n          }\n          s1 = x1.highLowContainer.getKeyAtIndex(pos1);\n        } else if (s1 - s2 > 0) {\n          answer.getMappeableRoaringArray().appendCopy(x2.highLowContainer.getKeyAtIndex(pos2),\n              x2.highLowContainer.getContainerAtIndex(pos2));\n          pos2++;\n          if (pos2 == length2) {\n            break main;\n          }\n          s2 = x2.highLowContainer.getKeyAtIndex(pos2);\n        }\n      }\n    }\n    if (pos1 == length1) {\n      answer.getMappeableRoaringArray().appendCopy(x2.highLowContainer, pos2, length2);\n    } else if (pos2 == length2) {\n      answer.getMappeableRoaringArray().appendCopy(x1.highLowContainer, pos1, length1);\n    }",
    "replace": "    while (pos1 < length1 && pos2 < length2) {\n      final char s1 = x1.highLowContainer.getKeyAtIndex(pos1);\n      final char s2 = x2.highLowContainer.getKeyAtIndex(pos2);\n      if (s1 == s2) {\n        final MappeableContainer c = x1.highLowContainer.getContainerAtIndex(pos1)\n            .xor(x2.highLowContainer.getContainerAtIndex(pos2));\n        if (!c.isEmpty()) {\n          answer.getMappeableRoaringArray().append(s1, c);\n        }\n        pos1++;\n        pos2++;\n      } else if (s1 < s2) {\n        final int nextPos1 = x1.highLowContainer.advanceUntil(s2, pos1);\n        answer.getMappeableRoaringArray().appendCopy(x1.highLowContainer, pos1, nextPos1);\n        pos1 = nextPos1;\n      } else { // s1 > s2\n        final int nextPos2 = x2.highLowContainer.advanceUntil(s1, pos2);\n        answer.getMappeableRoaringArray().appendCopy(x2.highLowContainer, pos2, nextPos2);\n        pos2 = nextPos2;\n      }\n    }\n    if (pos1 < length1) {\n      answer.getMappeableRoaringArray().appendCopy(x1.highLowContainer, pos1, length1);\n    } else if (pos2 < length2) {\n      answer.getMappeableRoaringArray().appendCopy(x2.highLowContainer, pos2, length2);\n    }"
  }
]
```