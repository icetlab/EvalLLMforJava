diff --git a/bsi/src/main/java/org/roaringbitmap/bsi/buffer/BitSliceIndexBase.java b/bsi/src/main/java/org/roaringbitmap/bsi/buffer/BitSliceIndexBase.java
index c40c836b..e87b49ae 100644
--- a/bsi/src/main/java/org/roaringbitmap/bsi/buffer/BitSliceIndexBase.java
+++ b/bsi/src/main/java/org/roaringbitmap/bsi/buffer/BitSliceIndexBase.java
@@ -61,12 +61,12 @@ public class BitSliceIndexBase {
    * GetValue gets the value at the column ID.  Second param will be false for non-existence values.
    */
   public Pair<Integer, Boolean> getValue(int columnId) {
-    boolean exists = this.ebM.contains(columnId);
-    if (!exists) {
+    if (!this.ebM.contains(columnId)) {
       return Pair.newPair(0, false);
     }
     int value = 0;
-    for (int i = 0; i < this.bitCount(); i++) {
+    int bitCount = this.bitCount();
+    for (int i = 0; i < bitCount; i++) {
       if (this.bA[i].contains(columnId)) {
         value |= (1 << i);
       }
@@ -99,36 +99,33 @@ public class BitSliceIndexBase {
                               int parallelism,
                               ImmutableRoaringBitmap foundSet,
                               ExecutorService pool) {
-    int batchSize = foundSet.getCardinality() / parallelism;
-    // fix when batchSize < parallelism
-    batchSize = Math.max(batchSize, parallelism);
-
-    // todo RoaringBitmap's batchIterator return max 2^16
+    long cardinality = foundSet.getLongCardinality();
+    int batchSize = (int) (cardinality / parallelism);
+    // Ensure batchSize is at least 1
+    batchSize = Math.max(batchSize, 1);
+    
+    // RoaringBitmap's batchIterator return max 2^16
     batchSize = Math.min(batchSize, 65536);
 
-
     List<int[]> batches = new ArrayList<>();
-
     final BatchIterator batchIterator = foundSet.getBatchIterator();
     while (batchIterator.hasNext()) {
       int[] buffer = new int[batchSize];
-      int cardinality = batchIterator.nextBatch(buffer);
-      if (cardinality > 0) {
-        if (cardinality == batchSize) {
+      int actualSize = batchIterator.nextBatch(buffer);
+      if (actualSize > 0) {
+        if (actualSize == batchSize) {
           batches.add(buffer);
         } else {
-          int[] buff = new int[cardinality];
-          System.arraycopy(buffer, 0, buff, 0, cardinality);
+          int[] buff = new int[actualSize];
+          System.arraycopy(buffer, 0, buff, 0, actualSize);
           batches.add(buff);
         }
       }
     }
 
-    List<CompletableFuture<R>> futures = new ArrayList<>();
+    List<CompletableFuture<R>> futures = new ArrayList<>(batches.size());
     for (int[] batch : batches) {
-      CompletableFuture<R> future = invokeAsync(() -> {
-        return func.apply(batch);
-      }, null, pool);
+      CompletableFuture<R> future = CompletableFuture.supplyAsync(() -> func.apply(batch), pool);
       futures.add(future);
     }
     return futures;
@@ -293,9 +290,10 @@ public class BitSliceIndexBase {
   //   {turn off n bits from E in F};           -- throw out some ties to return exactly k rows 
   public MutableRoaringBitmap topK(ImmutableRoaringBitmap foundSet, int k) {
     ImmutableRoaringBitmap fixedFoundSet = foundSet == null ? this.ebM : foundSet;
-    if (k > fixedFoundSet.getLongCardinality() || k < 0) {
+    long cardinality = fixedFoundSet.getLongCardinality();
+    if (k > cardinality || k < 0) {
       throw new IllegalArgumentException("TopK param error,cardinality:"
-          + fixedFoundSet.getLongCardinality() + " k:" + k);
+          + cardinality + " k:" + k);
     }
 
     MutableRoaringBitmap G = new MutableRoaringBitmap();
@@ -316,14 +314,19 @@ public class BitSliceIndexBase {
     }
 
     MutableRoaringBitmap F = ImmutableRoaringBitmap.or(G, E);
-    long n = F.getLongCardinality() - k;
-    if (n > 0) {
-      // TODO: make faster
-      IntIterator i = F.getIntIterator();
+    long excess = F.getLongCardinality() - k;
+    if (excess > 0) {
+      // Use batch iterator for better performance
+      BatchIterator batchIterator = F.getBatchIterator();
       MutableRoaringBitmap turnoff = new MutableRoaringBitmap();
-      while (i.hasNext() && n > 0) {
-        turnoff.add(i.next());
-        --n;
+      while (excess > 0 && batchIterator.hasNext()) {
+        int[] buffer = new int[(int) Math.min(excess, 4096)];
+        int count = batchIterator.nextBatch(buffer);
+        int toAdd = (int) Math.min(count, excess);
+        for (int i = 0; i < toAdd; i++) {
+          turnoff.add(buffer[i]);
+        }
+        excess -= toAdd;
       }
       F.andNot(turnoff);
     }
@@ -357,12 +360,11 @@ public class BitSliceIndexBase {
     }
 
     for (int i = this.bA.length - 1; i >= 0; i--) {
-      ImmutableRoaringBitmap slice = this.bA[i];
       int bit = (predicate >> i) & 1;
       if (bit == 1) {
-        eqBitmap = ImmutableRoaringBitmap.and(eqBitmap, slice);
+        eqBitmap = ImmutableRoaringBitmap.and(eqBitmap, this.bA[i]);
       } else {
-        eqBitmap = ImmutableRoaringBitmap.andNot(eqBitmap, slice);
+        eqBitmap = ImmutableRoaringBitmap.andNot(eqBitmap, this.bA[i]);
       }
     }
     return eqBitmap;
