The performance issue is about making the removal of top values faster in the `topK` method. Currently, after computing the top-k bitmap `F`, if there are more than `k` rows (due to ties), the method iterates over `F` with an `IntIterator` and removes the first `n` elements using a temporary bitmap `turnoff`, then does `F.andNot(turnoff)`. This can be slow because it iterates over the bitmap and creates a temporary bitmap. We can improve by directly removing the first `n` elements from `E` (since `F = G OR E` and the extra rows come from `E`) without iterating over the entire `F`. However, note that `E` is an `ImmutableRoaringBitmap` and we need to turn off bits in `F` which is a `MutableRoaringBitmap`. We can instead iterate over `E` and remove from `F` until we have removed `n` bits. But we must ensure we only remove from `E` part of `F`. Since `F = G OR E`, and `G` is already fixed (it has exactly `k - |E|` bits?), we can remove the first `n` bits from `E` and then recompute `F = G OR E'` where `E'` is `E` with `n` bits removed. However, `E` is immutable, so we need to make a mutable copy. Alternatively, we can iterate over `E` and remove from `F` directly, but we must avoid iterating over the entire `E` if `n` is small. The current approach iterates over `F` which may be large (up to `|E| + |G|`). Since `n` is the excess, it's likely small. But we can improve by iterating over `E` instead of `F` because the extra bits are from `E`. Let's examine the algorithm: at the end, `G` has rows that are definitely in the top-k, and `E` has rows that are ties for the last bit. The total `F = G OR E` may have more than `k` rows because `E` may have more rows than needed. So we need to remove `n = |F| - k` rows from `E`. We can iterate over `E` and remove from `F` until we have removed `n` rows. This is similar to the current approach but iterates over `E` which may be smaller than `F`? Actually `E` is a subset of `F`, so iterating over `E` is at most as large as `F`. However, if `E` is large, we still have to iterate over `n` elements only. The current approach iterates over `F` and stops after `n` removals, so it's O(n). That's already optimal in terms of number of iterations. The overhead is creating a temporary bitmap `turnoff` and then doing `andNot`. We can instead remove directly from `F` without the temporary bitmap. We can use `F.remove()` on the iterator's next value. But note that `F` is a `MutableRoaringBitmap` and we are iterating over `F` while modifying it. That is not safe because the iterator may become invalid. The current approach uses a separate `turnoff` bitmap to collect the bits to remove, then does `andNot`. That is safe but requires extra memory and time to build the temporary bitmap. We can instead use `F.getIntIterator()` and call `F.remove()` on each element, but the iterator may not support removal. Actually `IntIterator` from RoaringBitmap does not support removal. So we need to collect the bits to remove. We can collect them in an array or list, but that's similar to the temporary bitmap. However, we can use `F.select(n)` to get the nth element and then remove the first `n` elements by constructing a range? But we need to remove exactly `n` arbitrary bits? Actually the extra bits are from `E` and we want to remove any `n` bits from `E`. Since they are ties, any removal is fine. So we can remove the first `n` bits from `E` by iterating over `E` and removing from `F`. We can get an iterator over `E` and for each bit, remove from `F` until we have removed `n`. This still requires a temporary collection if we cannot remove while iterating. But we can use `E.getIntIterator()` and collect the first `n` integers in a list, then remove them from `F`. That's similar to the current approach but with a list instead of a bitmap. A list of integers may be more efficient than a bitmap for small n. However, the current approach uses a `MutableRoaringBitmap` which may be heavy for small n. Let's change to use an `IntArrayList` or simply an array. But we don't have an `IntArrayList` in the standard library. We can use an `int[]` of size `n`. Since `n` is likely small, we can allocate an array. But we don't know `n` in advance? Actually we know `n = F.getCardinality() - k`. We can allocate an array of size `n`. Then iterate over `E` and fill the array, then remove from `F`. However, iterating over `E` may be more efficient than iterating over `F` because `E` may be smaller? Actually `E` is a subset of `F`, so cardinality of `E` is at most that of `F`. But we only need `n` elements from `E`. So we can iterate over `E` until we have collected `n` elements. That's O(n) as well. The advantage is that we avoid iterating over the entire `F` (which may be large) but we only iterate over `n` elements of `E`. However, we still need to iterate over `E` from the beginning. We can use `E.getIntIterator()` and take the first `n` elements. That's fine.

But note: `E` is an `ImmutableRoaringBitmap`, so we cannot modify it. We are removing from `F`, which is mutable. So we can do:

```java
if (n > 0) {
    IntIterator iter = E.getIntIterator();
    while (iter.hasNext() && n > 0) {
        F.remove(iter.next());
        --n;
    }
}
```

However, we must be careful: `F` is `G OR E`. Removing a bit that is in `E` but also in `G`? Actually `G` and `E` are disjoint? Let's check the algorithm: `G` and `E` are updated such that they are disjoint? In the loop, when `n > k`, we set `E = E AND S^i`, which is a subset of previous `E`. When `n < k`, we set `G = X` and `E = E AND NOT S^i`. Since `X = G OR (E AND S^i)`, the new `G` includes some bits from `E`, and the new `E` excludes those bits. So indeed `G` and `E` are disjoint at each step, and thus at the end `G` and `E` are disjoint. Therefore, removing a bit from `E` will not affect `G`. So we can safely remove from `F` bits that are in `E`. And since `F = G OR E`, after removal, `F` will have `|G| + |E| - n = k`. So we can iterate over `E` and remove from `F`.

But we cannot remove while iterating over `E` because the iterator may be invalidated? Actually the iterator is over `E`, which is immutable, so removing from `F` does not affect `E`'s iterator. That's safe.

Thus we can replace the current removal block with:

```java
if (n > 0) {
    IntIterator iter = E.getIntIterator();
    while (iter.hasNext() && n > 0) {
        F.remove(iter.next());
        --n;
    }
}
```

This avoids creating a temporary bitmap and directly removes from `F`. It also iterates only over `n` elements of `E`, which may be smaller than iterating over `F` (though the original also iterated over `F` but stopped after `n`). However, the original iterated over `F` which includes `G` and `E`. If `G` is large, we might iterate over many bits before reaching `n` bits from `E`? Actually the original iterated over `F` and removed the first `n` bits regardless of whether they are from `G` or `E`. That could remove bits from `G`, which we don't want because `G` is definitely in the top-k. But wait: the algorithm says "turn off n bits from E in F". So we should only remove from `E`. The original code removed the first `n` bits from `F`, which could include bits from `G`. That is a bug! Indeed, the comment says "turn off n bits from E in F". So we must only remove from `E`. Our new approach fixes that bug and improves performance.

Let's verify: In the original code, `F` is `G OR E`. The iterator over `F` will yield bits in sorted order. Since `G` and `E` are disjoint, but we don't know which comes first. If the first `n` bits are from `G`, then we would remove bits from `G`, which is incorrect. So the new approach is both faster and correct.

We must also ensure that after removal, `F` still has exactly `k` bits. Since we remove exactly `n` bits from `E`, and `E` had at least `n` bits (because `n = |F| - k = |G| + |E| - k`, and `|G| <= k`, so `|E| >= n`). So we can remove `n` bits from `E`.

Now, we need to change the code accordingly.

Additionally, we can consider that `E` might be large, but we only need to remove `n` bits. The iterator over `E` is efficient because it's a RoaringBitmap iterator.

Let's make the change.

We'll output a JSON array with one change.

```json
[
  {
    "filepath": "../RoaringBitmap/bsi/src/main/java/org/roaringbitmap/bsi/buffer/BitSliceIndexBase.java",
    "search": "    MutableRoaringBitmap F = ImmutableRoaringBitmap.or(G, E);\n    long n = F.getLongCardinality() - k;\n    if (n > 0) {\n      // TODO: make faster\n      IntIterator i = F.getIntIterator();\n      MutableRoaringBitmap turnoff = new MutableRoaringBitmap();\n      while (i.hasNext() && n > 0) {\n        turnoff.add(i.next());\n        --n;\n      }\n      F.andNot(turnoff);\n    }",
    "replace": "    MutableRoaringBitmap F = ImmutableRoaringBitmap.or(G, E);\n    long n = F.getLongCardinality() - k;\n    if (n > 0) {\n      // Remove exactly n bits from E (ties) to bring total down to k.\n      IntIterator iter = E.getIntIterator();\n      while (iter.hasNext() && n > 0) {\n        F.remove(iter.next());\n        --n;\n      }\n    }"
  }
]
```