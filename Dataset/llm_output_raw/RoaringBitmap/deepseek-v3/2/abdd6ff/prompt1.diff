diff --git a/bsi/src/main/java/org/roaringbitmap/bsi/buffer/BitSliceIndexBase.java b/bsi/src/main/java/org/roaringbitmap/bsi/buffer/BitSliceIndexBase.java
index c40c836b..a26b3a4e 100644
--- a/bsi/src/main/java/org/roaringbitmap/bsi/buffer/BitSliceIndexBase.java
+++ b/bsi/src/main/java/org/roaringbitmap/bsi/buffer/BitSliceIndexBase.java
@@ -61,12 +61,12 @@ public class BitSliceIndexBase {
    * GetValue gets the value at the column ID.  Second param will be false for non-existence values.
    */
   public Pair<Integer, Boolean> getValue(int columnId) {
-    boolean exists = this.ebM.contains(columnId);
-    if (!exists) {
+    if (!this.ebM.contains(columnId)) {
       return Pair.newPair(0, false);
     }
     int value = 0;
-    for (int i = 0; i < this.bitCount(); i++) {
+    int bitCount = this.bitCount();
+    for (int i = 0; i < bitCount; i++) {
       if (this.bA[i].contains(columnId)) {
         value |= (1 << i);
       }
@@ -99,26 +99,26 @@ public class BitSliceIndexBase {
                               int parallelism,
                               ImmutableRoaringBitmap foundSet,
                               ExecutorService pool) {
-    int batchSize = foundSet.getCardinality() / parallelism;
+    int cardinality = foundSet.getCardinality();
+    int batchSize = cardinality / parallelism;
     // fix when batchSize < parallelism
     batchSize = Math.max(batchSize, parallelism);
 
     // todo RoaringBitmap's batchIterator return max 2^16
     batchSize = Math.min(batchSize, 65536);
 
-
-    List<int[]> batches = new ArrayList<>();
+    List<int[]> batches = new ArrayList<>((cardinality + batchSize - 1) / batchSize);
 
     final BatchIterator batchIterator = foundSet.getBatchIterator();
     while (batchIterator.hasNext()) {
       int[] buffer = new int[batchSize];
-      int cardinality = batchIterator.nextBatch(buffer);
-      if (cardinality > 0) {
-        if (cardinality == batchSize) {
+      int batchCardinality = batchIterator.nextBatch(buffer);
+      if (batchCardinality > 0) {
+        if (batchCardinality == batchSize) {
           batches.add(buffer);
         } else {
-          int[] buff = new int[cardinality];
-          System.arraycopy(buffer, 0, buff, 0, cardinality);
+          int[] buff = new int[batchCardinality];
+          System.arraycopy(buffer, 0, buff, 0, batchCardinality);
           batches.add(buff);
         }
       }
@@ -301,7 +301,8 @@ public class BitSliceIndexBase {
     MutableRoaringBitmap G = new MutableRoaringBitmap();
     ImmutableRoaringBitmap E = fixedFoundSet;
 
-    for (int i = this.bitCount() - 1; i >= 0; i--) {
+    int bitCount = this.bitCount();
+    for (int i = bitCount - 1; i >= 0; i--) {
       MutableRoaringBitmap X = ImmutableRoaringBitmap.or(G, ImmutableRoaringBitmap.and(E, this.bA[i]));
       long n = X.getLongCardinality();
       if (n > k) {
@@ -343,26 +344,24 @@ public class BitSliceIndexBase {
    * @return the computed immutable bitmap
    */
   public ImmutableRoaringBitmap rangeEQ(ImmutableRoaringBitmap foundSet, int predicate) {
-    // Start with set of columns with values set.
-    ImmutableRoaringBitmap eqBitmap = this.ebM;
-
-    if (foundSet != null) {
-      eqBitmap = ImmutableRoaringBitmap.and(eqBitmap, foundSet);
-    }
-
     // https://github.com/RoaringBitmap/RoaringBitmap/issues/549
     ImmutableRoaringBitmap result = compareUsingMinMax(BitmapSliceIndex.Operation.EQ, predicate, 0, foundSet);
     if (result != null) {
       return result;
     }
 
+    // Start with set of columns with values set.
+    ImmutableRoaringBitmap eqBitmap = this.ebM;
+    if (foundSet != null) {
+      eqBitmap = ImmutableRoaringBitmap.and(eqBitmap, foundSet);
+    }
+
     for (int i = this.bA.length - 1; i >= 0; i--) {
-      ImmutableRoaringBitmap slice = this.bA[i];
       int bit = (predicate >> i) & 1;
       if (bit == 1) {
-        eqBitmap = ImmutableRoaringBitmap.and(eqBitmap, slice);
+        eqBitmap = ImmutableRoaringBitmap.and(eqBitmap, this.bA[i]);
       } else {
-        eqBitmap = ImmutableRoaringBitmap.andNot(eqBitmap, slice);
+        eqBitmap = ImmutableRoaringBitmap.andNot(eqBitmap, this.bA[i]);
       }
     }
     return eqBitmap;
@@ -517,16 +516,17 @@ public class BitSliceIndexBase {
       return Pair.newPair(0L, 0L);
     }
     long count = foundSet.getLongCardinality();
-
-    Long sum = IntStream.range(0, this.bitCount())
-        .mapToLong(x -> (long) (1 << x) * ImmutableRoaringBitmap.andCardinality(this.bA[x], foundSet))
-        .sum();
-
+    long sum = 0L;
+    int bitCount = this.bitCount();
+    for (int i = 0; i < bitCount; i++) {
+      sum += (long) (1 << i) * ImmutableRoaringBitmap.andCardinality(this.bA[i], foundSet);
+    }
     return Pair.newPair(sum, count);
   }
 
   public List<Pair<Integer, Integer>> toPairList() {
-    List<Pair<Integer, Integer>> pairList = new ArrayList<>();
+    int size = (int) Math.min(this.ebM.getLongCardinality(), Integer.MAX_VALUE);
+    List<Pair<Integer, Integer>> pairList = new ArrayList<>(size);
     this.ebM.forEach((IntConsumer) cid -> {
       pairList.add(Pair.newPair(cid, this.getValue(cid).getKey()));
     });
@@ -534,8 +534,9 @@ public class BitSliceIndexBase {
   }
 
   public List<Pair<Integer, Integer>> toPairList(ImmutableRoaringBitmap foundSet) {
-    List<Pair<Integer, Integer>> pairList = new ArrayList<>();
     ImmutableRoaringBitmap bitmap = ImmutableRoaringBitmap.and(this.ebM, foundSet);
+    int size = (int) Math.min(bitmap.getLongCardinality(), Integer.MAX_VALUE);
+    List<Pair<Integer, Integer>> pairList = new ArrayList<>(size);
     bitmap.forEach((IntConsumer) cid -> {
       pairList.add(Pair.newPair(cid, this.getValue(cid).getKey()));
     });
