diff --git a/RoaringBitmap/src/main/java/org/roaringbitmap/longlong/IntegerUtil.java b/RoaringBitmap/src/main/java/org/roaringbitmap/longlong/IntegerUtil.java
index ed36adf0..07a03497 100644
--- a/RoaringBitmap/src/main/java/org/roaringbitmap/longlong/IntegerUtil.java
+++ b/RoaringBitmap/src/main/java/org/roaringbitmap/longlong/IntegerUtil.java
@@ -50,9 +50,55 @@ public class IntegerUtil {
    * @return a fresh integer value
    */
   public static int shiftLeftFromSpecifiedPosition(int v, int pos, int count) {
-    byte[] initialVal = toBDBytes(v);
-    System.arraycopy(initialVal, pos + 1, initialVal, pos, count);
-    return fromBDBytes(initialVal);
+    if (count == 0) {
+      return v;
+    }
+    // Calculate byte positions in terms of bit shifts
+    // We need to extract and rearrange bytes without array allocation
+    
+    // Extract all 4 bytes
+    int b0 = (v >>> 24) & 0xFF;  // byte at position 0
+    int b1 = (v >>> 16) & 0xFF;  // byte at position 1
+    int b2 = (v >>> 8) & 0xFF;   // byte at position 2
+    int b3 = v & 0xFF;           // byte at position 3
+    
+    // Rearrange bytes based on pos and count
+    int r0, r1, r2, r3;
+    
+    switch (pos) {
+      case 0:
+        r0 = (count >= 1) ? b1 : b0;
+        r1 = (count >= 2) ? b2 : (count >= 1) ? b1 : b1;
+        r2 = (count >= 3) ? b3 : (count >= 2) ? b2 : b2;
+        r3 = (count >= 3) ? b3 : b3;
+        break;
+      case 1:
+        r0 = b0;
+        r1 = (count >= 1) ? b2 : b1;
+        r2 = (count >= 2) ? b3 : (count >= 1) ? b2 : b2;
+        r3 = (count >= 2) ? b3 : b3;
+        break;
+      case 2:
+        r0 = b0;
+        r1 = b1;
+        r2 = (count >= 1) ? b3 : b2;
+        r3 = (count >= 1) ? b3 : b3;
+        break;
+      case 3:
+        r0 = b0;
+        r1 = b1;
+        r2 = b2;
+        r3 = b3;  // No shift possible from position 3
+        break;
+      default:
+        // Should never happen, but fallback to original
+        byte[] initialVal = toBDBytes(v);
+        System.arraycopy(initialVal, pos + 1, initialVal, pos, count);
+        return fromBDBytes(initialVal);
+    }
+    
+    // Reconstruct the integer
+    return (r0 << 24) | (r1 << 16) | (r2 << 8) | r3;
   }
 
   /**
