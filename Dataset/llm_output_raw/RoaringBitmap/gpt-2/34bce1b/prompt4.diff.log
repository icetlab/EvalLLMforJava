Iâ€™ve replaced the byte-array allocation and System.arraycopy in shiftLeftFromSpecifiedPosition with a direct, branch-based byte extraction and recomposition to eliminate temporary arrays and improve performance.

```json
[
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/longlong/IntegerUtil.java",
    "search": "  public static int shiftLeftFromSpecifiedPosition(int v, int pos, int count) {\n    byte[] initialVal = toBDBytes(v);\n    System.arraycopy(initialVal, pos + 1, initialVal, pos, count);\n    return fromBDBytes(initialVal);\n  }",
    "replace": "  public static int shiftLeftFromSpecifiedPosition(int v, int pos, int count) {\n    if (count <= 0) {\n      return v;\n    }\n    int b0 = (v >>> 24) & 0xFF;\n    int b1 = (v >>> 16) & 0xFF;\n    int b2 = (v >>> 8) & 0xFF;\n    int b3 = v & 0xFF;\n    switch (pos) {\n      case 0:\n        if (count >= 3) {\n          b0 = b1;\n          b1 = b2;\n          b2 = b3;\n        } else if (count == 2) {\n          b0 = b1;\n          b1 = b2;\n        } else {\n          // count == 1\n          b0 = b1;\n        }\n        break;\n      case 1:\n        if (count >= 2) {\n          b1 = b2;\n          b2 = b3;\n        } else {\n          // count == 1\n          b1 = b2;\n        }\n        break;\n      case 2:\n        // count == 1\n        b2 = b3;\n        break;\n      case 3:\n      default:\n        return v;\n    }\n    return (b0 << 24) | (b1 << 16) | (b2 << 8) | b3;\n  }"
  }
]
```