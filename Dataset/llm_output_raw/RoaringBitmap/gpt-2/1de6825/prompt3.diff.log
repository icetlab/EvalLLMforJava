I have optimized byte-array allocations and access in key methods to use direct bit shifts, reducing object creation and improving performance.

```json
[
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java",
    "search": "@Override\n  public byte getChildKey(int pos) {\n    int posInLong;\n    if (pos <= 7) {\n      posInLong = pos;\n      byte[] firstBytes = LongUtils.toBDBytes(firstV);\n      return firstBytes[posInLong];\n    } else {\n      posInLong = pos - 8;\n      byte[] secondBytes = LongUtils.toBDBytes(secondV);\n      return secondBytes[posInLong];\n    }\n  }",
    "replace": "@Override\n  public byte getChildKey(int pos) {\n    if (pos <= 7) {\n      return (byte)(firstV >>> ((7 - pos) << 3));\n    } else {\n      int posInLong = pos - 8;\n      return (byte)(secondV >>> ((7 - posInLong) << 3));\n    }\n  }"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java",
    "search": "else if (currentNode16.count < 16) {\n      //second\n      ByteBuffer byteBuffer = ByteBuffer.allocate(16).order(ByteOrder.BIG_ENDIAN);\n      byteBuffer.putLong(currentNode16.firstV);\n      byteBuffer.putLong(currentNode16.secondV);\n      byteBuffer.put(currentNode16.count, key);\n      currentNode16.children[currentNode16.count] = child;\n      sortSmallByteArray(byteBuffer.array(), currentNode16.children, 0, currentNode16.count);\n      currentNode16.count++;\n      currentNode16.firstV = byteBuffer.getLong(0);\n      currentNode16.secondV = byteBuffer.getLong(8);\n      return currentNode16;",
    "replace": "else if (currentNode16.count < 16) {\n      // second: avoid ByteBuffer\n      byte[] bytes = new byte[16];\n      // unpack existing longs\n      for (int i = 0; i < 8; i++) {\n        bytes[i] = (byte)(currentNode16.firstV >>> ((7 - i) << 3));\n      }\n      for (int i = 8; i < 16; i++) {\n        bytes[i] = (byte)(currentNode16.secondV >>> ((15 - i) << 3));\n      }\n      // insert new key and child\n      bytes[currentNode16.count] = key;\n      currentNode16.children[currentNode16.count] = child;\n      // sort and update count\n      sortSmallByteArray(bytes, currentNode16.children, 0, currentNode16.count);\n      currentNode16.count++;\n      // repack into longs\n      long newFirst = 0L, newSecond = 0L;\n      for (int i = 0; i < 8; i++) {\n        newFirst = (newFirst << 8) | (bytes[i] & 0xFFL);\n      }\n      for (int i = 8; i < 16; i++) {\n        newSecond = (newSecond << 8) | (bytes[i] & 0xFFL);\n      }\n      currentNode16.firstV = newFirst;\n      currentNode16.secondV = newSecond;\n      return currentNode16;"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java",
    "search": "children[pos] = null;\n    ByteBuffer byteBuffer = ByteBuffer.allocate(16).order(ByteOrder.BIG_ENDIAN);\n    byte[] bytes = byteBuffer.putLong(firstV).putLong(secondV).array();\n    System.arraycopy(bytes, pos + 1, bytes, pos, (16 - pos - 1));\n    System.arraycopy(children, pos + 1, children, pos, (16 - pos - 1));\n    firstV = byteBuffer.getLong(0);\n    secondV = byteBuffer.getLong(8);\n    count--;",
    "replace": "children[pos] = null;\n    // rebuild byte array directly\n    byte[] bytes = new byte[16];\n    for (int i = 0; i < 8; i++) {\n      bytes[i] = (byte)(firstV >>> ((7 - i) << 3));\n    }\n    for (int i = 8; i < 16; i++) {\n      bytes[i] = (byte)(secondV >>> ((15 - i) << 3));\n    }\n    // shift out the removed slot\n    System.arraycopy(bytes, pos + 1, bytes, pos, 16 - pos - 1);\n    System.arraycopy(children, pos + 1, children, pos, 16 - pos - 1);\n    // repack longs\n    firstV = 0L;\n    secondV = 0L;\n    for (int i = 0; i < 8; i++) {\n      firstV = (firstV << 8) | (bytes[i] & 0xFFL);\n    }\n    for (int i = 8; i < 16; i++) {\n      secondV = (secondV << 8) | (bytes[i] & 0xFFL);\n    }\n    count--;"
  }
]
```