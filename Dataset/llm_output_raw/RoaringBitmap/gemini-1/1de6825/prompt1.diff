diff --git a/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java b/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java
index de6dddea..fab6e002 100644
--- a/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java
+++ b/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java
@@ -19,16 +19,14 @@ public class Node16 extends Node {
 
   @Override
   public int getChildPos(byte k) {
-    byte[] firstBytes = LongUtils.toBDBytes(firstV);
     if (count <= 8) {
-      return Node.binarySearch(firstBytes, 0, count, k);
+      return binarySearch(firstV, 0, count, k);
     } else {
-      int pos = Node.binarySearch(firstBytes, 0, 8, k);
+      int pos = binarySearch(firstV, 0, 8, k);
       if (pos != ILLEGAL_IDX) {
         return pos;
       } else {
-        byte[] secondBytes = LongUtils.toBDBytes(secondV);
-        pos = Node.binarySearch(secondBytes, 0, (count - 8), k);
+        pos = binarySearch(secondV, 0, (count - 8), k);
         if (pos != ILLEGAL_IDX) {
           return 8 + pos;
         } else {
@@ -40,21 +38,19 @@ public class Node16 extends Node {
 
   @Override
   public SearchResult getNearestChildPos(byte k) {
-    byte[] firstBytes = LongUtils.toBDBytes(firstV);
     if (count <= 8) {
-      return Node.binarySearchWithResult(firstBytes, 0, count, k);
+      return binarySearchWithResult(firstV, 0, count, k);
     } else {
-      SearchResult firstResult = Node.binarySearchWithResult(
-              firstBytes, 0, 8, k);
+      SearchResult firstResult = binarySearchWithResult(
+              firstV, 0, 8, k);
       // given the values are "in order" if we found a match or a value larger than
       // the target we are done.
       if (firstResult.outcome == SearchResult.Outcome.FOUND
               || firstResult.hasNextLargerPos()) {
         return firstResult;
       } else {
-        byte[] secondBytes = LongUtils.toBDBytes(secondV);
-        SearchResult secondResult = Node.binarySearchWithResult(
-                secondBytes, 0, (count - 8), k);
+        SearchResult secondResult = binarySearchWithResult(
+                secondV, 0, (count - 8), k);
 
         switch(secondResult.outcome) {
           case FOUND:
@@ -84,15 +80,10 @@ public class Node16 extends Node {
 
   @Override
   public byte getChildKey(int pos) {
-    int posInLong;
     if (pos <= 7) {
-      posInLong = pos;
-      byte[] firstBytes = LongUtils.toBDBytes(firstV);
-      return firstBytes[posInLong];
+      return getByte(firstV, pos);
     } else {
-      posInLong = pos - 8;
-      byte[] secondBytes = LongUtils.toBDBytes(secondV);
-      return secondBytes[posInLong];
+      return getByte(secondV, pos - 8);
     }
   }
 
@@ -147,10 +138,16 @@ public class Node16 extends Node {
     if (currentNode16.count < 8) {
       //first
       byte[] bytes = LongUtils.toBDBytes(currentNode16.firstV);
-      bytes[currentNode16.count] = key;
-      currentNode16.firstV = LongUtils.fromBDBytes(bytes);
-      currentNode16.children[currentNode16.count] = child;
-      sortSmallByteArray(bytes, currentNode16.children, 0, currentNode16.count);
+      int unsignedKey = Byte.toUnsignedInt(key);
+      int pos = 0;
+      while (pos < currentNode16.count && Byte.toUnsignedInt(bytes[pos]) < unsignedKey) {
+        pos++;
+      }
+      int numToMove = currentNode16.count - pos;
+      System.arraycopy(bytes, pos, bytes, pos + 1, numToMove);
+      bytes[pos] = key;
+      System.arraycopy(currentNode16.children, pos, currentNode16.children, pos + 1, numToMove);
+      currentNode16.children[pos] = child;
       currentNode16.count++;
       currentNode16.firstV = LongUtils.fromBDBytes(bytes);
       return currentNode16;
@@ -159,9 +156,17 @@ public class Node16 extends Node {
       ByteBuffer byteBuffer = ByteBuffer.allocate(16).order(ByteOrder.BIG_ENDIAN);
       byteBuffer.putLong(currentNode16.firstV);
       byteBuffer.putLong(currentNode16.secondV);
-      byteBuffer.put(currentNode16.count, key);
-      currentNode16.children[currentNode16.count] = child;
-      sortSmallByteArray(byteBuffer.array(), currentNode16.children, 0, currentNode16.count);
+      byte[] bytes = byteBuffer.array();
+      int unsignedKey = Byte.toUnsignedInt(key);
+      int pos = 0;
+      while (pos < currentNode16.count && Byte.toUnsignedInt(bytes[pos]) < unsignedKey) {
+        pos++;
+      }
+      int numToMove = currentNode16.count - pos;
+      System.arraycopy(bytes, pos, bytes, pos + 1, numToMove);
+      bytes[pos] = key;
+      System.arraycopy(currentNode16.children, pos, currentNode16.children, pos + 1, numToMove);
+      currentNode16.children[pos] = child;
       currentNode16.count++;
       currentNode16.firstV = byteBuffer.getLong(0);
       currentNode16.secondV = byteBuffer.getLong(8);
@@ -193,11 +198,16 @@ public class Node16 extends Node {
 
   @Override
   public Node remove(int pos) {
-    children[pos] = null;
     ByteBuffer byteBuffer = ByteBuffer.allocate(16).order(ByteOrder.BIG_ENDIAN);
     byte[] bytes = byteBuffer.putLong(firstV).putLong(secondV).array();
-    System.arraycopy(bytes, pos + 1, bytes, pos, (16 - pos - 1));
-    System.arraycopy(children, pos + 1, children, pos, (16 - pos - 1));
+    int numToMove = count - 1 - pos;
+    if (numToMove > 0) {
+      System.arraycopy(bytes, pos + 1, bytes, pos, numToMove);
+      System.arraycopy(children, pos + 1, children, pos, numToMove);
+    }
+    bytes[count - 1] = 0;
+    children[count - 1] = null;
+
     firstV = byteBuffer.getLong(0);
     secondV = byteBuffer.getLong(8);
     count--;
@@ -254,4 +264,52 @@ public class Node16 extends Node {
       offset++;
     }
   }
+
+  private static byte getByte(long v, int i) {
+    return (byte) (v >> (8 * (7 - i)));
+  }
+
+  private static int binarySearch(long values, int fromIndex, int toIndex, byte key) {
+    int low = fromIndex;
+    int high = toIndex - 1;
+    int unsignedKey = Byte.toUnsignedInt(key);
+
+    while (low <= high) {
+      int mid = (low + high) >>> 1;
+      int midVal = Byte.toUnsignedInt(getByte(values, mid));
+
+      if (midVal < unsignedKey) {
+        low = mid + 1;
+      } else if (midVal > unsignedKey) {
+        high = mid - 1;
+      } else {
+        return mid; // key found
+      }
+    }
+    return ILLEGAL_IDX;  // key not found.
+  }
+
+  private static SearchResult binarySearchWithResult(long values, int fromIndex, int toIndex,
+      byte key) {
+    int low = fromIndex;
+    int high = toIndex - 1;
+    int unsignedKey = Byte.toUnsignedInt(key);
+
+    while (low <= high) {
+      int mid = (low + high) >>> 1;
+      int midVal = Byte.toUnsignedInt(getByte(values, mid));
+
+      if (midVal < unsignedKey) {
+        low = mid + 1;
+      } else if (midVal > unsignedKey) {
+        high = mid - 1;
+      } else {
+        return SearchResult.found(mid); // key found
+      }
+    }
+    // key not found.
+    int nextLargerPos = low < toIndex ? low : ILLEGAL_IDX;
+    int nextSmallerPos = high >= fromIndex ? high : ILLEGAL_IDX;
+    return SearchResult.notFound(nextSmallerPos, nextLargerPos);
+  }
 }
