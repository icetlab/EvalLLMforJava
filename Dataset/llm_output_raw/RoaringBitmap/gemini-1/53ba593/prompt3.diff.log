My changes aim to improve performance and correctness.
First, I've optimized the `checkedAdd` method in both `RoaringBitmap` and `MutableRoaringBitmap`. The original implementation always updated the container array even if the container itself was modified in-place and no new element was added. My change avoids this redundant memory write when an element already exists in the bitmap, which is particularly beneficial when many duplicate values are added. This is guided by the provided benchmark.
Second, I've fixed a bug in `RoaringBitmap.contains(RoaringBitmap subset)` where it was using the subset's container array for advancing an index into the superset's container array. This has been corrected to use the correct array.

```json
[
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java",
    "search": "  public boolean checkedAdd(final int x) {\n    final char hb = Util.highbits(x);\n    final int i = highLowContainer.getIndex(hb);\n    if (i >= 0) {\n      Container c = highLowContainer.getContainerAtIndex(i);\n      int oldCard = c.getCardinality();\n      // we need to keep the newContainer if a switch between containers type\n      // occur, in order to get the new cardinality\n      Container newCont = c.add(Util.lowbits(x));\n      highLowContainer.setContainerAtIndex(i, newCont);\n      if (newCont.getCardinality() > oldCard) {\n        return true;\n      }\n    } else {\n      final ArrayContainer newac = new ArrayContainer();\n      highLowContainer.insertNewKeyValueAt(-i - 1, hb, newac.add(Util.lowbits(x)));\n      return true;\n    }\n    return false;\n  }",
    "replace": "  public boolean checkedAdd(final int x) {\n    final char hb = Util.highbits(x);\n    final int i = highLowContainer.getIndex(hb);\n    if (i >= 0) {\n      Container c = highLowContainer.getContainerAtIndex(i);\n      int oldCard = c.getCardinality();\n      Container newCont = c.add(Util.lowbits(x));\n      if (newCont == c) {\n        return c.getCardinality() > oldCard;\n      }\n      highLowContainer.setContainerAtIndex(i, newCont);\n      return true;\n    } else {\n      final ArrayContainer newac = new ArrayContainer();\n      highLowContainer.insertNewKeyValueAt(-i - 1, hb, newac.add(Util.lowbits(x)));\n      return true;\n    }\n  }"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java",
    "search": "      } else if (s1 - s2 > 0) {\n        return false;\n      } else {\n        pos1 = subset.highLowContainer.advanceUntil(s2, pos1);\n      }",
    "replace": "      } else if (s1 > s2) {\n        return false;\n      } else {\n        pos1 = this.highLowContainer.advanceUntil(s2, pos1);\n      }"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MutableRoaringBitmap.java",
    "search": "  public boolean checkedAdd(final int x) {\n    final char hb = BufferUtil.highbits(x);\n    final int i = highLowContainer.getIndex(hb);\n    if (i >= 0) {\n      MappeableContainer C = highLowContainer.getContainerAtIndex(i);\n      int oldcard = C.getCardinality();\n      C = C.add(BufferUtil.lowbits(x));\n      getMappeableRoaringArray().setContainerAtIndex(i, C);\n      return C.getCardinality() > oldcard;\n    } else {\n      final MappeableArrayContainer newac = new MappeableArrayContainer();\n      getMappeableRoaringArray().insertNewKeyValueAt(-i - 1, hb, newac.add(BufferUtil.lowbits(x)));\n      return true;\n    }\n  }",
    "replace": "  public boolean checkedAdd(final int x) {\n    final char hb = BufferUtil.highbits(x);\n    final int i = highLowContainer.getIndex(hb);\n    if (i >= 0) {\n      MappeableContainer c = highLowContainer.getContainerAtIndex(i);\n      int oldCard = c.getCardinality();\n      MappeableContainer newCont = c.add(BufferUtil.lowbits(x));\n      if (newCont == c) {\n        return c.getCardinality() > oldCard;\n      }\n      getMappeableRoaringArray().setContainerAtIndex(i, newCont);\n      return true;\n    } else {\n      final MappeableArrayContainer newac = new MappeableArrayContainer();\n      getMappeableRoaringArray().insertNewKeyValueAt(-i - 1, hb, newac.add(BufferUtil.lowbits(x)));\n      return true;\n    }\n  }"
  }
]
```