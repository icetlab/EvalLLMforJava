diff --git a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
index 86f06981ff..2abca67338 100644
--- a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
+++ b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
@@ -262,12 +262,14 @@ class AclAuthorizer extends Authorizer with Logging {
     inReadLock(lock) {
       val aclBindings = new util.ArrayList[AclBinding]()
       unorderedAcls.foreach { case (resource, versionedAcls) =>
+        if (filter.patternFilter.matches(resource)) {
           versionedAcls.acls.foreach { acl =>
             val binding = new AclBinding(resource, acl.ace)
-          if (filter.matches(binding))
+            if (filter.entryFilter.matches(binding.entry))
               aclBindings.add(binding)
           }
         }
+      }
       aclBindings
     }
   }
@@ -351,10 +353,14 @@ class AclAuthorizer extends Authorizer with Logging {
 
       val prefixed = aclCache
         .from(new ResourcePattern(resourceType, resourceName, PatternType.PREFIXED))
-        .to(new ResourcePattern(resourceType, resourceName.take(1), PatternType.PREFIXED))
-        .filterKeys(resource => resourceName.startsWith(resource.name))
+        .takeWhile { case (resource, _) =>
+          resource.resourceType == resourceType && resource.patternType == PatternType.PREFIXED
+        }
+        .filter { case (resource, _) =>
+          resourceName.startsWith(resource.name)
+        }
         .values
-        .flatMap { _.acls }
+        .flatMap(_.acls)
         .toSet
 
       prefixed ++ wildcard ++ literal
