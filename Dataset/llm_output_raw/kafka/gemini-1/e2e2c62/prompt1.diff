diff --git a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
index 5f2be90535..0b9a57d8fd 100644
--- a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
+++ b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
@@ -264,10 +264,18 @@ class AclAuthorizer extends Authorizer with Logging {
     }.map(CompletableFuture.completedFuture[AclDeleteResult]).asJava
   }
 
-  @nowarn("cat=optimizer")
     override def acls(filter: AclBindingFilter): lang.Iterable[AclBinding] = {
     val aclBindings = new util.ArrayList[AclBinding]()
-      aclCache.foreach { case (resource, versionedAcls) =>
+    val patternFilter = filter.patternFilter
+
+    val resourcesToScan: Iterable[(ResourcePattern, VersionedAcls)] = if (patternFilter.matchesAtMostOne) {
+      val resource = new ResourcePattern(patternFilter.resourceType, patternFilter.name, patternFilter.patternType)
+      aclCache.get(resource).map(va => List(resource -> va)).getOrElse(List.empty)
+    } else {
+      aclCache
+    }
+
+    resourcesToScan.foreach { case (resource, versionedAcls) =>
       versionedAcls.acls.foreach { acl =>
         val binding = new AclBinding(resource, acl.ace)
         if (filter.matches(binding))
@@ -315,12 +323,17 @@ class AclAuthorizer extends Authorizer with Logging {
       // Check if there are any Allow ACLs which would allow this operation.
       // Allowing read, write, delete, or alter implies allowing describe.
       // See #{org.apache.kafka.common.acl.AclOperation} for more details about ACL inheritance.
-      val allowOps = operation match {
-        case DESCRIBE => Set[AclOperation](DESCRIBE, READ, WRITE, DELETE, ALTER)
-        case DESCRIBE_CONFIGS => Set[AclOperation](DESCRIBE_CONFIGS, ALTER_CONFIGS)
-        case _ => Set[AclOperation](operation)
-      }
-      allowOps.exists(operation => matchingAclExists(operation, resource, principal, host, ALLOW, acls))
+      matchingAclExists(operation, resource, principal, host, ALLOW, acls) || (operation match {
+        case DESCRIBE =>
+          matchingAclExists(READ, resource, principal, host, ALLOW, acls) ||
+          matchingAclExists(WRITE, resource, principal, host, ALLOW, acls) ||
+          matchingAclExists(DELETE, resource, principal, host, ALLOW, acls) ||
+          matchingAclExists(ALTER, resource, principal, host, ALLOW, acls)
+        case DESCRIBE_CONFIGS =>
+          matchingAclExists(ALTER_CONFIGS, resource, principal, host, ALLOW, acls)
+        case _ =>
+          false
+      })
     }
 
     def aclsAllowAccess = {
@@ -356,11 +369,17 @@ class AclAuthorizer extends Authorizer with Logging {
       .map(_.acls.toBuffer)
       .getOrElse(mutable.Buffer.empty)
 
-    val prefixed = aclCacheSnapshot
+    val prefixed = mutable.Buffer.empty[AclEntry]
+    if (resourceName.nonEmpty) {
+      aclCacheSnapshot
         .from(new ResourcePattern(resourceType, resourceName, PatternType.PREFIXED))
         .to(new ResourcePattern(resourceType, resourceName.take(1), PatternType.PREFIXED))
-      .flatMap { case (resource, acls) => if (resourceName.startsWith(resource.name)) acls.acls else Seq.empty }
-      .toBuffer
+        .iterator
+        .foreach { case (resource, acls) =>
+          if (resourceName.startsWith(resource.name))
+            prefixed ++= acls.acls
+        }
+    }
 
     new AclSeqs(prefixed, wildcard, literal)
   }
