The performance of `Checksums.update` for `ByteBuffer` can be significantly improved, especially for direct or read-only buffers. The original implementation iterates byte-by-byte using `buffer.get(i)`, which is inefficient for these buffer types.

My improvement replaces this byte-by-byte iteration with a chunk-based approach. It creates a temporary byte array on the heap and reads data from the `ByteBuffer` into this array in chunks. Then, it updates the checksum from this temporary array. This bulk processing is much faster than individual byte processing.

To ensure the original `ByteBuffer`'s state (its position, limit, and mark) remains unchanged, I use `buffer.duplicate()`. This creates a new `ByteBuffer` instance that shares the same data but has its own independent state, making the change safe and preserving the method's contract.

```json
[
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java",
    "search": "    public static void update(Checksum checksum, ByteBuffer buffer, int offset, int length) {\n        if (buffer.hasArray()) {\n            checksum.update(buffer.array(), buffer.position() + buffer.arrayOffset() + offset, length);\n        } else {\n            int start = buffer.position() + offset;\n            for (int i = start; i < start + length; i++)\n                checksum.update(buffer.get(i));\n        }\n    }",
    "replace": "    public static void update(Checksum checksum, ByteBuffer buffer, int offset, int length) {\n        if (buffer.hasArray()) {\n            checksum.update(buffer.array(), buffer.position() + buffer.arrayOffset() + offset, length);\n        } else {\n            ByteBuffer toChecksum = buffer.duplicate();\n            toChecksum.position(buffer.position() + offset);\n            toChecksum.limit(buffer.position() + offset + length);\n\n            byte[] b = new byte[Math.min(toChecksum.remaining(), 8192)];\n            while (toChecksum.hasRemaining()) {\n                int chunk = Math.min(toChecksum.remaining(), b.length);\n                toChecksum.get(b, 0, chunk);\n                checksum.update(b, 0, chunk);\n            }\n        }\n    }"
  }
]
```