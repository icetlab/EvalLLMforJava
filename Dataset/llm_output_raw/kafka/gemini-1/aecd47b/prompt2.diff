diff --git a/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java b/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java
index 679b59249d..d602238067 100644
--- a/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java
+++ b/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java
@@ -16,6 +16,9 @@
  */
 package org.apache.kafka.common.utils;
 
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
 import java.nio.ByteBuffer;
 import java.util.zip.Checksum;
 
@@ -30,6 +33,21 @@ import java.util.zip.Checksum;
  */
 public final class Checksums {
 
+    private static final MethodHandle UPDATE_BYTE_BUFFER_METHOD_HANDLE;
+
+    static {
+        MethodHandle handle = null;
+        // Checksum#update(ByteBuffer) is only available in Java 9+, so we use method handles to
+        // call it conditionally.
+        try {
+            handle = MethodHandles.lookup().findVirtual(Checksum.class, "update",
+                MethodType.methodType(void.class, ByteBuffer.class));
+        } catch (NoSuchMethodException | IllegalAccessException e) {
+            // ignore, we are on a platform that does not have the method.
+        }
+        UPDATE_BYTE_BUFFER_METHOD_HANDLE = handle;
+    }
+
     private Checksums() {
     }
 
@@ -40,12 +58,27 @@ public final class Checksums {
     public static void update(Checksum checksum, ByteBuffer buffer, int offset, int length) {
         if (buffer.hasArray()) {
             checksum.update(buffer.array(), buffer.position() + buffer.arrayOffset() + offset, length);
+        } else {
+            if (UPDATE_BYTE_BUFFER_METHOD_HANDLE != null) {
+                try {
+                    // JDK9+ has a method to compute checksum for a ByteBuffer.
+                    int pos = buffer.position();
+                    buffer.position(pos + offset);
+                    ByteBuffer slice = buffer.slice();
+                    slice.limit(length);
+                    UPDATE_BYTE_BUFFER_METHOD_HANDLE.invoke(checksum, slice);
+                    buffer.position(pos);
+                } catch (Throwable t) {
+                    // Should not happen
+                    throw new RuntimeException("Could not invoke Checksum.update(ByteBuffer)", t);
+                }
             } else {
                 int start = buffer.position() + offset;
                 for (int i = start; i < start + length; i++)
                     checksum.update(buffer.get(i));
             }
         }
+    }
     
     public static void updateInt(Checksum checksum, int input) {
         checksum.update((byte) (input >> 24));
