diff --git a/core/src/main/scala/kafka/cluster/Partition.scala b/core/src/main/scala/kafka/cluster/Partition.scala
index 9cfd99e8e5..3f44d9305f 100755
--- a/core/src/main/scala/kafka/cluster/Partition.scala
+++ b/core/src/main/scala/kafka/cluster/Partition.scala
@@ -203,6 +203,7 @@ class Partition(val topicPartition: TopicPartition,
   private val remoteReplicasMap = new Pool[Int, Replica]
   // The read lock is only required when multiple reads are executed and needs to be in a consistent manner
   private val leaderIsrUpdateLock = new ReentrantReadWriteLock
+  private val futureLogLock = new ReentrantReadWriteLock
   private var zkVersion: Int = LeaderAndIsr.initialZKVersion
   @volatile private var leaderEpoch: Int = LeaderAndIsr.initialLeaderEpoch - 1
   // start offset for 'leaderEpoch' above (leader epoch of the current leader for this partition),
@@ -428,6 +429,7 @@ class Partition(val topicPartition: TopicPartition,
       // The write lock is needed to make sure that while ReplicaAlterDirThread checks the LEO of the
       // current replica, no other thread can update LEO of the current replica via log truncation or log append operation.
       inWriteLock(leaderIsrUpdateLock) {
+        inWriteLock(futureLogLock) {
           futureLog match {
             case Some(futurePartitionLog) =>
               if (log.exists(_.logEndOffset == futurePartitionLog.logEndOffset)) {
@@ -444,6 +446,7 @@ class Partition(val topicPartition: TopicPartition,
               false
           }
         }
+      }
     } else false
   }
 
@@ -913,14 +916,16 @@ class Partition(val topicPartition: TopicPartition,
   private def doAppendRecordsToFollowerOrFutureReplica(records: MemoryRecords, isFuture: Boolean): Option[LogAppendInfo] = {
     // The read lock is needed to handle race condition if request handler thread tries to
     // remove future replica after receiving AlterReplicaLogDirsRequest.
-    inReadLock(leaderIsrUpdateLock) {
     if (isFuture) {
+      inReadLock(leaderIsrUpdateLock) {
         // Note the replica may be undefined if it is removed by a non-ReplicaAlterLogDirsThread before
         // this method is called
         futureLog.map { _.appendAsFollower(records) }
+      }
     } else {
       // The read lock is needed to prevent the follower replica from being updated while ReplicaAlterDirThread
       // is executing maybeDeleteAndSwapFutureReplica() to replace follower replica with the future replica.
+      inReadLock(futureLogLock) {
         Some(localLogOrException.appendAsFollower(records))
       }
     }
@@ -1128,8 +1133,12 @@ class Partition(val topicPartition: TopicPartition,
   def truncateTo(offset: Long, isFuture: Boolean): Unit = {
     // The read lock is needed to prevent the follower replica from being truncated while ReplicaAlterDirThread
     // is executing maybeDeleteAndSwapFutureReplica() to replace follower replica with the future replica.
-    inReadLock(leaderIsrUpdateLock) {
+    val lock = if (isFuture) leaderIsrUpdateLock.readLock() else futureLogLock.readLock()
+    lock.lock()
+    try {
       logManager.truncateTo(Map(topicPartition -> offset), isFuture = isFuture)
+    } finally {
+      lock.unlock()
     }
   }
 
@@ -1142,8 +1151,12 @@ class Partition(val topicPartition: TopicPartition,
   def truncateFullyAndStartAt(newOffset: Long, isFuture: Boolean): Unit = {
     // The read lock is needed to prevent the follower replica from being truncated while ReplicaAlterDirThread
     // is executing maybeDeleteAndSwapFutureReplica() to replace follower replica with the future replica.
-    inReadLock(leaderIsrUpdateLock) {
+    val lock = if (isFuture) leaderIsrUpdateLock.readLock() else futureLogLock.readLock()
+    lock.lock()
+    try {
       logManager.truncateFullyAndStartAt(topicPartition, newOffset, isFuture = isFuture)
+    } finally {
+      lock.unlock()
     }
   }
 
