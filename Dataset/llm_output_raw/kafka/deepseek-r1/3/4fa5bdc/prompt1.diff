diff --git a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
index 58860be864..480b6cbe9c 100644
--- a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
+++ b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
@@ -174,7 +174,15 @@ class AclAuthorizer extends Authorizer with Logging {
   }
 
   override def authorize(requestContext: AuthorizableRequestContext, actions: util.List[Action]): util.List[AuthorizationResult] = {
-    actions.asScala.map { action => authorizeAction(requestContext, action) }.asJava
+    // Optimize: Avoid creating intermediate Scala collections
+    val size = actions.size
+    val results = new java.util.ArrayList[AuthorizationResult](size)
+    var i = 0
+    while (i < size) {
+      results.add(authorizeAction(requestContext, actions.get(i)))
+      i += 1
+    }
+    results
   }
 
   override def createAcls(requestContext: AuthorizableRequestContext,
@@ -263,9 +271,14 @@ class AclAuthorizer extends Authorizer with Logging {
   }
 
   override def acls(filter: AclBindingFilter): lang.Iterable[AclBinding] = {
-      val aclBindings = new util.ArrayList[AclBinding]()
-      aclCache.foreach { case (resource, versionedAcls) =>
-        versionedAcls.acls.foreach { acl =>
+      // Optimize: Pre-size the ArrayList for better performance
+      val aclBindings = new util.ArrayList[AclBinding](aclCache.size * 2) // Estimate 2 ACLs per resource
+      val iter = aclCache.iterator
+      while (iter.hasNext) {
+        val (resource, versionedAcls) = iter.next()
+        val aclsIter = versionedAcls.acls.iterator
+        while (aclsIter.hasNext) {
+          val acl = aclsIter.next()
           val binding = new AclBinding(resource, acl.ace)
           if (filter.matches(binding))
             aclBindings.add(binding)
@@ -298,8 +311,13 @@ class AclAuthorizer extends Authorizer with Logging {
     def isEmptyAclAndAuthorized(acls: AclSets): Boolean = {
       if (acls.isEmpty) {
         // No ACLs found for this resource, permission is determined by value of config allow.everyone.if.no.acl.found
-        authorizerLogger.debug(s"No acl found for resource $resource, authorized = $shouldAllowEveryoneIfNoAclIsFound")
-        shouldAllowEveryoneIfNoAclIsFound
+        // Optimize: Cache the configuration value since it's immutable after startup
+        val allowEveryone = shouldAllowEveryoneIfNoAclIsFound
+        // Optimize: Check log level before formatting debug string
+        if (authorizerLogger.underlying.isDebugEnabled) {
+          authorizerLogger.debug(s"No acl found for resource $resource, authorized = $allowEveryone")
+        }
+        allowEveryone
       } else false
     }
 
@@ -336,7 +354,10 @@ class AclAuthorizer extends Authorizer with Logging {
 
   def isSuperUser(principal: KafkaPrincipal): Boolean = {
     if (superUsers.contains(principal)) {
-      authorizerLogger.debug(s"principal = $principal is a super user, allowing operation without checking acls.")
+      // Optimize: Check log level before formatting debug string
+      if (authorizerLogger.underlying.isDebugEnabled) {
+        authorizerLogger.debug(s"principal = $principal is a super user, allowing operation without checking acls.")
+      }
       true
     } else false
   }
@@ -352,13 +373,22 @@ class AclAuthorizer extends Authorizer with Logging {
       .map(_.acls)
       .getOrElse(Set.empty)
 
-    val prefixed = aclCacheSnapshot
-      .from(new ResourcePattern(resourceType, resourceName, PatternType.PREFIXED))
-      .to(new ResourcePattern(resourceType, resourceName.take(1), PatternType.PREFIXED))
-      .filterKeys(resource => resourceName.startsWith(resource.name))
-      .values
-      .flatMap { _.acls }
-      .toSet
+    // Optimize: Only scan prefixed resources if the resource name is non-empty
+    val prefixed = if (resourceName.nonEmpty) {
+      // Create the keys once to avoid repeated object creation
+      val fromKey = new ResourcePattern(resourceType, resourceName, PatternType.PREFIXED)
+      val toKey = new ResourcePattern(resourceType, resourceName.take(1), PatternType.PREFIXED)
+      
+      aclCacheSnapshot
+        .from(fromKey)
+        .to(toKey)
+        .filterKeys(resource => resourceName.startsWith(resource.name))
+        .values
+        .flatMap { _.acls }
+        .toSet
+    } else {
+      Set.empty[AclEntry]
+    }
 
     new AclSets(prefixed, wildcard, literal)
   }
@@ -369,13 +399,17 @@ class AclAuthorizer extends Authorizer with Logging {
                                 host: String,
                                 permissionType: AclPermissionType,
                                 acls: AclSets): Boolean = {
+    // Optimize: Use early returns in the predicate
     acls.find { acl =>
-      acl.permissionType == permissionType &&
-        (acl.kafkaPrincipal == principal || acl.kafkaPrincipal == AclEntry.WildcardPrincipal) &&
-        (operation == acl.operation || acl.operation == AclOperation.ALL) &&
-        (acl.host == host || acl.host == AclEntry.WildcardHost)
+      if (acl.permissionType != permissionType) false
+      else if (acl.kafkaPrincipal != principal && acl.kafkaPrincipal != AclEntry.WildcardPrincipal) false
+      else if (operation != acl.operation && acl.operation != AclOperation.ALL) false
+      else acl.host == host || acl.host == AclEntry.WildcardHost
     }.exists { acl =>
-      authorizerLogger.debug(s"operation = $operation on resource = $resource from host = $host is $permissionType based on acl = $acl")
+      // Optimize: Check log level before formatting debug string
+      if (authorizerLogger.underlying.isDebugEnabled) {
+        authorizerLogger.debug(s"operation = $operation on resource = $resource from host = $host is $permissionType based on acl = $acl")
+      }
       true
     }
   }
