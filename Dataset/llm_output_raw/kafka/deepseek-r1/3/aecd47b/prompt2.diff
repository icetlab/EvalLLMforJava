diff --git a/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java b/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java
index 679b59249d..563afeff8a 100644
--- a/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java
+++ b/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java
@@ -18,6 +18,9 @@ package org.apache.kafka.common.utils;
 
 import java.nio.ByteBuffer;
 import java.util.zip.Checksum;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
 
 /**
  * Utility methods for `Checksum` instances.
@@ -33,11 +36,35 @@ public final class Checksums {
     private Checksums() {
     }
 
+    private static final MethodHandle UPDATE_BYTE_BUFFER_METHOD;
+
+    static {
+        MethodHandle method = null;
+        try {
+            method = MethodHandles.lookup()
+                .findVirtual(Checksum.class, "update", MethodType.methodType(void.class, ByteBuffer.class));
+        } catch (ReflectiveOperationException e) {
+            // ignore, method not found
+        }
+        UPDATE_BYTE_BUFFER_METHOD = method;
+    }
+
     public static void update(Checksum checksum, ByteBuffer buffer, int length) {
         update(checksum, buffer, 0, length);
     }
 
     public static void update(Checksum checksum, ByteBuffer buffer, int offset, int length) {
+        if (UPDATE_BYTE_BUFFER_METHOD != null) {
+            try {
+                ByteBuffer dup = buffer.duplicate();
+                dup.position(buffer.position() + offset);
+                dup.limit(buffer.position() + offset + length);
+                UPDATE_BYTE_BUFFER_METHOD.invokeExact(checksum, dup);
+                return;
+            } catch (Throwable e) {
+                // fall through to the legacy implementation
+            }
+        }
         if (buffer.hasArray()) {
             checksum.update(buffer.array(), buffer.position() + buffer.arrayOffset() + offset, length);
         } else {
