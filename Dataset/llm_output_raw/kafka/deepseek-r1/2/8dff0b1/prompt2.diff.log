The performance issue indicates that the `acls()` method creates unnecessary intermediate collections, specifically through the use of `flatMap` and multiple traversals. The current implementation iterates over all ACL entries, creates `AclBinding` objects for each, and then filters them, resulting in unnecessary object allocations and collection operations.

To improve performance, we can:
1. Use direct iteration over the ACL cache with early filtering to avoid creating intermediate collections
2. Filter by resource pattern first before checking individual ACL entries
3. Use a mutable collection builder for results to avoid multiple traversals

The changes focus on the `acls()` method to reduce object creation and improve iteration efficiency.

```json
[
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "  override def acls(filter: AclBindingFilter): lang.Iterable[AclBinding] = {\n    inReadLock(lock) {\n      unorderedAcls.flatMap { case (resource, versionedAcls) =>\n        versionedAcls.acls.map(acl => new AclBinding(resource, acl.ace))\n            .filter(filter.matches)\n      }.asJava\n    }\n  }",
    "replace": "  override def acls(filter: AclBindingFilter): lang.Iterable[AclBinding] = {\n    inReadLock(lock) {\n      val resourceFilter = filter.patternFilter\n      val entryFilter = filter.entryFilter\n      val result = new java.util.ArrayList[AclBinding]\n      aclCache.foreach { case (resource, versionedAcls) =>\n        if (resourceFilter.matches(resource)) {\n          versionedAcls.acls.foreach { acl =>\n            if (entryFilter.matches(acl.ace)) {\n              result.add(new AclBinding(resource, acl.ace))\n            }\n          }\n        }\n      }\n      result\n    }\n  }"
  }
]
```