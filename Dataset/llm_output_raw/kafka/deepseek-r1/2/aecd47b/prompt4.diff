diff --git a/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java b/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java
index 679b59249d..abd2ee2fb8 100644
--- a/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java
+++ b/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java
@@ -16,6 +16,7 @@
  */
 package org.apache.kafka.common.utils;
 
+import java.lang.reflect.Method;
 import java.nio.ByteBuffer;
 import java.util.zip.Checksum;
 
@@ -29,6 +30,17 @@ import java.util.zip.Checksum;
  * NOTE: This class is intended for INTERNAL usage only within Kafka.
  */
 public final class Checksums {
+    private static final Method UPDATE_BYTE_BUFFER_METHOD;
+    
+    static {
+        Method method = null;
+        try {
+            method = Checksum.class.getMethod("update", ByteBuffer.class);
+        } catch (NoSuchMethodException e) {
+            // Java 8 or earlier, method not available
+        }
+        UPDATE_BYTE_BUFFER_METHOD = method;
+    }
 
     private Checksums() {
     }
@@ -40,12 +52,29 @@ public final class Checksums {
     public static void update(Checksum checksum, ByteBuffer buffer, int offset, int length) {
         if (buffer.hasArray()) {
             checksum.update(buffer.array(), buffer.position() + buffer.arrayOffset() + offset, length);
-        } else {
+        } else if (UPDATE_BYTE_BUFFER_METHOD != null) {
+            // Use Java 9+ optimized ByteBuffer method if available
             int start = buffer.position() + offset;
-            for (int i = start; i < start + length; i++)
-                checksum.update(buffer.get(i));
+            int end = start + length;
+            ByteBuffer slice = buffer.duplicate();
+            slice.position(start).limit(end);
+            try {
+                UPDATE_BYTE_BUFFER_METHOD.invoke(checksum, slice);
+            } catch (ReflectiveOperationException e) {
+                // Fallback to byte-by-byte for compatibility
+                fallbackUpdate(checksum, buffer, offset, length);
+            }
+        } else {
+            // Java 8 or earlier fallback
+            fallbackUpdate(checksum, buffer, offset, length);
         }
     }
+
+    private static void fallbackUpdate(Checksum checksum, ByteBuffer buffer, int offset, int length) {
+        int start = buffer.position() + offset;
+        for (int i = start; i < start + length; i++)
+            checksum.update(buffer.get(i));
+    }
     
     public static void updateInt(Checksum checksum, int input) {
         checksum.update((byte) (input >> 24));
