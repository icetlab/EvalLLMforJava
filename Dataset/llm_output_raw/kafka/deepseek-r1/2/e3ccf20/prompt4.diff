diff --git a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
index 86f06981ff..2dd4bb9a0d 100644
--- a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
+++ b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
@@ -341,23 +341,26 @@ class AclAuthorizer extends Authorizer with Logging {
 
   private def matchingAcls(resourceType: ResourceType, resourceName: String): Set[AclEntry] = {
     inReadLock(lock) {
-      val wildcard = aclCache.get(new ResourcePattern(resourceType, ResourcePattern.WILDCARD_RESOURCE, PatternType.LITERAL))
-        .map(_.acls)
-        .getOrElse(Set.empty)
-
-      val literal = aclCache.get(new ResourcePattern(resourceType, resourceName, PatternType.LITERAL))
-        .map(_.acls)
-        .getOrElse(Set.empty)
-
-      val prefixed = aclCache
+      // Use mutable builder for efficient set accumulation
+      val builder = Set.newBuilder[AclEntry]
+      
+      // Add wildcard ACLs
+      aclCache.get(new ResourcePattern(resourceType, ResourcePattern.WILDCARD_RESOURCE, PatternType.LITERAL))
+        .foreach { versionedAcls => builder ++= versionedAcls.acls }
+      
+      // Add literal ACLs
+      aclCache.get(new ResourcePattern(resourceType, resourceName, PatternType.LITERAL))
+        .foreach { versionedAcls => builder ++= versionedAcls.acls }
+      
+      // Add prefixed ACLs directly without creating intermediate Set
+      aclCache
         .from(new ResourcePattern(resourceType, resourceName, PatternType.PREFIXED))
         .to(new ResourcePattern(resourceType, resourceName.take(1), PatternType.PREFIXED))
         .filterKeys(resource => resourceName.startsWith(resource.name))
         .values
-        .flatMap { _.acls }
-        .toSet
-
-      prefixed ++ wildcard ++ literal
+        .foreach { versionedAcls => builder ++= versionedAcls.acls }
+      
+      builder.result()
     }
   }
 
