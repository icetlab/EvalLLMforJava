The performance issue is centered around the `acls()` method in `AclAuthorizer.scala`, which currently creates unnecessary intermediate sets when flattening ACLs and filtering them. This can cause performance degradation, especially with large numbers of ACLs. The fix optimizes by using iterators and avoiding intermediate collections.

```json
[
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "  override def acls(filter: AclBindingFilter): lang.Iterable[AclBinding] = {\n    inReadLock(lock) {\n      unorderedAcls.flatMap { case (resource, versionedAcls) =>\n        versionedAcls.acls.map(acl => new AclBinding(resource, acl.ace))\n            .filter(filter.matches)\n      }.asJava\n    }\n  }",
    "replace": "  override def acls(filter: AclBindingFilter): lang.Iterable[AclBinding] = {\n    inReadLock(lock) {\n      unorderedAcls.iterator.flatMap { case (resource, versionedAcls) =>\n        versionedAcls.acls.iterator.map(acl => new AclBinding(resource, acl.ace))\n            .filter(filter.matches)\n      }.toSeq.asJava\n    }\n  }"
  }
]
```