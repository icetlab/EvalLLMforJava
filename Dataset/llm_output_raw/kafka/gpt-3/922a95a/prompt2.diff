diff --git a/core/src/main/scala/kafka/cluster/Partition.scala b/core/src/main/scala/kafka/cluster/Partition.scala
index 9cfd99e8e5..2328deda47 100755
--- a/core/src/main/scala/kafka/cluster/Partition.scala
+++ b/core/src/main/scala/kafka/cluster/Partition.scala
@@ -203,6 +203,7 @@ class Partition(val topicPartition: TopicPartition,
   private val remoteReplicasMap = new Pool[Int, Replica]
   // The read lock is only required when multiple reads are executed and needs to be in a consistent manner
   private val leaderIsrUpdateLock = new ReentrantReadWriteLock
+  private val futureReplicaLock = new ReentrantReadWriteLock
   private var zkVersion: Int = LeaderAndIsr.initialZKVersion
   @volatile private var leaderEpoch: Int = LeaderAndIsr.initialLeaderEpoch - 1
   // start offset for 'leaderEpoch' above (leader epoch of the current leader for this partition),
@@ -258,10 +259,8 @@ class Partition(val topicPartition: TopicPartition,
     * @return true iff the future replica is created
     */
   def maybeCreateFutureReplica(logDir: String, highWatermarkCheckpoints: OffsetCheckpoints): Boolean = {
-    // The writeLock is needed to make sure that while the caller checks the log directory of the
-    // current replica and the existence of the future replica, no other thread can update the log directory of the
-    // current replica or remove the future replica.
-    inWriteLock(leaderIsrUpdateLock) {
+    // Guard future-log creation/removal separately
+    inWriteLock(futureReplicaLock) {
       val currentLogDir = localLogOrException.dir.getParent
       if (currentLogDir == logDir) {
         info(s"Current log directory $currentLogDir is same as requested log dir $logDir. " +
@@ -405,13 +404,13 @@ class Partition(val topicPartition: TopicPartition,
     remoteReplicasMap.values
 
   def futureReplicaDirChanged(newDestinationDir: String): Boolean = {
-    inReadLock(leaderIsrUpdateLock) {
+    inReadLock(futureReplicaLock) {
       futureLog.exists(_.dir.getParent != newDestinationDir)
     }
   }
 
   def removeFutureLocalReplica(deleteFromLogDir: Boolean = true): Unit = {
-    inWriteLock(leaderIsrUpdateLock) {
+    inWriteLock(futureReplicaLock) {
       futureLog = None
       if (deleteFromLogDir)
         logManager.asyncDelete(topicPartition, isFuture = true)
@@ -425,9 +424,8 @@ class Partition(val topicPartition: TopicPartition,
     val localReplicaLEO = localLogOrException.logEndOffset
     val futureReplicaLEO = futureLog.map(_.logEndOffset)
     if (futureReplicaLEO.contains(localReplicaLEO)) {
-      // The write lock is needed to make sure that while ReplicaAlterDirThread checks the LEO of the
-      // current replica, no other thread can update LEO of the current replica via log truncation or log append operation.
-      inWriteLock(leaderIsrUpdateLock) {
+      // Guard replacement of current with future replica separately
+      inWriteLock(futureReplicaLock) {
         futureLog match {
           case Some(futurePartitionLog) =>
             if (log.exists(_.logEndOffset == futurePartitionLog.logEndOffset)) {
@@ -911,9 +909,8 @@ class Partition(val topicPartition: TopicPartition,
   }
 
   private def doAppendRecordsToFollowerOrFutureReplica(records: MemoryRecords, isFuture: Boolean): Option[LogAppendInfo] = {
-    // The read lock is needed to handle race condition if request handler thread tries to
-    // remove future replica after receiving AlterReplicaLogDirsRequest.
-    inReadLock(leaderIsrUpdateLock) {
+    // Guard follower/future append separately
+    inReadLock(futureReplicaLock) {
       if (isFuture) {
         // Note the replica may be undefined if it is removed by a non-ReplicaAlterLogDirsThread before
         // this method is called
@@ -1126,9 +1123,8 @@ class Partition(val topicPartition: TopicPartition,
     * @param isFuture True iff the truncation should be performed on the future log of this partition
     */
   def truncateTo(offset: Long, isFuture: Boolean): Unit = {
-    // The read lock is needed to prevent the follower replica from being truncated while ReplicaAlterDirThread
-    // is executing maybeDeleteAndSwapFutureReplica() to replace follower replica with the future replica.
-    inReadLock(leaderIsrUpdateLock) {
+    // Guard truncation separately
+    inReadLock(futureReplicaLock) {
       logManager.truncateTo(Map(topicPartition -> offset), isFuture = isFuture)
     }
   }
@@ -1140,9 +1136,8 @@ class Partition(val topicPartition: TopicPartition,
     * @param isFuture True iff the truncation should be performed on the future log of this partition
     */
   def truncateFullyAndStartAt(newOffset: Long, isFuture: Boolean): Unit = {
-    // The read lock is needed to prevent the follower replica from being truncated while ReplicaAlterDirThread
-    // is executing maybeDeleteAndSwapFutureReplica() to replace follower replica with the future replica.
-    inReadLock(leaderIsrUpdateLock) {
+    // Guard full-truncate separately
+    inReadLock(futureReplicaLock) {
       logManager.truncateFullyAndStartAt(topicPartition, newOffset, isFuture = isFuture)
     }
   }
