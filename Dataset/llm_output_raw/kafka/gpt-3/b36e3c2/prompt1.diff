diff --git a/core/src/main/scala/kafka/log/LogValidator.scala b/core/src/main/scala/kafka/log/LogValidator.scala
index 48b9f57d9a..3ee6463e19 100644
--- a/core/src/main/scala/kafka/log/LogValidator.scala
+++ b/core/src/main/scala/kafka/log/LogValidator.scala
@@ -132,9 +132,10 @@ private[log] object LogValidator extends Logging {
                             origin: AppendOrigin,
                             toMagic: Byte,
                             brokerTopicStats: BrokerTopicStats): Unit = {
+    val stats = brokerTopicStats.allTopicsStats
     // batch magic byte should have the same magic as the first batch
     if (firstBatch.magic() != batch.magic()) {
-      brokerTopicStats.allTopicsStats.invalidMagicNumberRecordsPerSec.mark()
+      stats.invalidMagicNumberRecordsPerSec.mark()
       throw new InvalidRecordException(s"Batch magic ${batch.magic()} is not the same as the first batch'es magic byte ${firstBatch.magic()} in topic partition $topicPartition.")
     }
 
@@ -142,31 +143,31 @@ private[log] object LogValidator extends Logging {
       if (batch.magic >= RecordBatch.MAGIC_VALUE_V2) {
         val countFromOffsets = batch.lastOffset - batch.baseOffset + 1
         if (countFromOffsets <= 0) {
-          brokerTopicStats.allTopicsStats.invalidOffsetOrSequenceRecordsPerSec.mark()
+          stats.invalidOffsetOrSequenceRecordsPerSec.mark()
           throw new InvalidRecordException(s"Batch has an invalid offset range: [${batch.baseOffset}, ${batch.lastOffset}] in topic partition $topicPartition.")
         }
 
         // v2 and above messages always have a non-null count
         val count = batch.countOrNull
         if (count <= 0) {
-          brokerTopicStats.allTopicsStats.invalidOffsetOrSequenceRecordsPerSec.mark()
+          stats.invalidOffsetOrSequenceRecordsPerSec.mark()
           throw new InvalidRecordException(s"Invalid reported count for record batch: $count in topic partition $topicPartition.")
         }
 
         if (countFromOffsets != batch.countOrNull) {
-          brokerTopicStats.allTopicsStats.invalidOffsetOrSequenceRecordsPerSec.mark()
+          stats.invalidOffsetOrSequenceRecordsPerSec.mark()
           throw new InvalidRecordException(s"Inconsistent batch offset range [${batch.baseOffset}, ${batch.lastOffset}] " +
             s"and count of records $count in topic partition $topicPartition.")
         }
       }
 
       if (batch.isControlBatch) {
-        brokerTopicStats.allTopicsStats.invalidOffsetOrSequenceRecordsPerSec.mark()
+        stats.invalidOffsetOrSequenceRecordsPerSec.mark()
         throw new InvalidRecordException(s"Clients are not allowed to write control records in topic partition $topicPartition.")
       }
 
       if (batch.hasProducerId && batch.baseSequence < 0) {
-        brokerTopicStats.allTopicsStats.invalidOffsetOrSequenceRecordsPerSec.mark()
+        stats.invalidOffsetOrSequenceRecordsPerSec.mark()
         throw new InvalidRecordException(s"Invalid sequence number ${batch.baseSequence} in record batch " +
           s"with producerId ${batch.producerId} in topic partition $topicPartition.")
       }
@@ -182,8 +183,9 @@ private[log] object LogValidator extends Logging {
   private def validateRecord(batch: RecordBatch, topicPartition: TopicPartition, record: Record, batchIndex: Int, now: Long,
                              timestampType: TimestampType, timestampDiffMaxMs: Long, compactedTopic: Boolean,
                              brokerTopicStats: BrokerTopicStats): Option[ApiRecordError] = {
+    val stats = brokerTopicStats.allTopicsStats
     if (!record.hasMagic(batch.magic)) {
-      brokerTopicStats.allTopicsStats.invalidMagicNumberRecordsPerSec.mark()
+      stats.invalidMagicNumberRecordsPerSec.mark()
       return Some(ApiRecordError(Errors.INVALID_RECORD, new RecordError(batchIndex,
         s"Record $record's magic does not match outer magic ${batch.magic} in topic partition $topicPartition.")))
     }
@@ -197,7 +199,7 @@ private[log] object LogValidator extends Logging {
         record.ensureValid()
       } catch {
         case e: InvalidRecordException =>
-          brokerTopicStats.allTopicsStats.invalidMessageCrcRecordsPerSec.mark()
+          stats.invalidMessageCrcRecordsPerSec.mark()
           throw new CorruptRecordException(e.getMessage + s" in topic partition $topicPartition.")
       }
     }
