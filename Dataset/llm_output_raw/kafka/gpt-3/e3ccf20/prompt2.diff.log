I have refactored the core authorization path to avoid eager merging of large ACL Sets with `++`. Instead, the wildcard, literal, and prefixed ACL collections are fetched separately under the read lock and then checked individually for deny/allow semantics, eliminating the costly set concatenation and hash-code computation.

```json
[
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "    def aclsAllowAccess = {\n      //we allow an operation if no acls are found and user has configured to allow all users\n      //when no acls are found or if no deny acls are found and at least one allow acls matches.\n      val acls = matchingAcls(resource.resourceType, resource.name)\n      isEmptyAclAndAuthorized(acls) || (!denyAclExists(acls) && allowAclExists(acls))\n    }",
    "replace": "    def aclsAllowAccess = {\n      // Separate retrieval of wildcard, literal, and prefixed ACL sets to avoid merging sets\n      val (wildcardAcls, literalAcls, prefixedAcls) = inReadLock(lock) {\n        val wildcard = aclCache.get(new ResourcePattern(resource.resourceType, ResourcePattern.WILDCARD_RESOURCE, PatternType.LITERAL)).map(_.acls).getOrElse(Set.empty[AclEntry])\n        val literal = aclCache.get(new ResourcePattern(resource.resourceType, resource.name, PatternType.LITERAL)).map(_.acls).getOrElse(Set.empty[AclEntry])\n        val prefixed = aclCache\n          .from(new ResourcePattern(resource.resourceType, resource.name, PatternType.PREFIXED))\n          .to(new ResourcePattern(resource.resourceType, resource.name.take(1), PatternType.PREFIXED))\n          .filterKeys(r => resource.name.startsWith(r.name))\n          .values\n          .flatMap(_.acls)\n        (wildcard, literal, prefixed)\n      }\n\n      // No merging of sets; apply logic directly on individual collections\n      val emptyAcls = wildcardAcls.isEmpty && literalAcls.isEmpty && !prefixedAcls.iterator.hasNext\n      if (emptyAcls) {\n        authorizerLogger.debug(s\"No acl found for resource $resource, authorized = $shouldAllowEveryoneIfNoAclIsFound\")\n        shouldAllowEveryoneIfNoAclIsFound\n      } else {\n        // Deny takes precedence\n        val denyInWildcard = matchingAclExists(operation, resource, principal, host, DENY, wildcardAcls)\n        val denyInLiteral  = matchingAclExists(operation, resource, principal, host, DENY, literalAcls)\n        val denyInPrefixed = prefixedAcls.exists(acl =>\n          acl.permissionType    == DENY &&\n          (acl.kafkaPrincipal  == principal || acl.kafkaPrincipal == AclEntry.WildcardPrincipal) &&\n          (acl.host            == host      || acl.host            == AclEntry.WildcardHost) &&\n          (operation           == acl.operation || acl.operation == AclOperation.ALL)\n        )\n        if (denyInWildcard || denyInLiteral || denyInPrefixed) {\n          false\n        } else {\n          // Check allow operations\n          val allowOps = operation match {\n            case DESCRIBE         => Set(DESCRIBE, READ, WRITE, DELETE, ALTER)\n            case DESCRIBE_CONFIGS => Set(DESCRIBE_CONFIGS, ALTER_CONFIGS)\n            case _                => Set(operation)\n          }\n          allowOps.exists { op =>\n            matchingAclExists(op, resource, principal, host, ALLOW, wildcardAcls)  ||\n            matchingAclExists(op, resource, principal, host, ALLOW, literalAcls)   ||\n            prefixedAcls.exists(acl =>\n              acl.permissionType    == ALLOW &&\n              (acl.kafkaPrincipal  == principal || acl.kafkaPrincipal == AclEntry.WildcardPrincipal) &&\n              (acl.host            == host      || acl.host            == AclEntry.WildcardHost) &&\n              (op                   == acl.operation || acl.operation == AclOperation.ALL)\n            )\n          }\n        }\n      }\n    }"
  }
]
```