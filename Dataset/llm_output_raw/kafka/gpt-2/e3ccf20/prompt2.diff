diff --git a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
index 86f06981ff..7fc5099afa 100644
--- a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
+++ b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
@@ -319,10 +319,36 @@ class AclAuthorizer extends Authorizer with Logging {
     }
 
     def aclsAllowAccess = {
-      //we allow an operation if no acls are found and user has configured to allow all users
-      //when no acls are found or if no deny acls are found and at least one allow acls matches.
-      val acls = matchingAcls(resource.resourceType, resource.name)
-      isEmptyAclAndAuthorized(acls) || (!denyAclExists(acls) && allowAclExists(acls))
+      val (wildcardAcls, literalAcls, prefixedAcls) = inReadLock(lock) {
+        val wildcardSet = aclCache.get(new ResourcePattern(resource.resourceType, ResourcePattern.WILDCARD_RESOURCE, PatternType.LITERAL))
+          .map(_.acls).getOrElse(Set.empty)
+        val literalSet = aclCache.get(new ResourcePattern(resource.resourceType, resource.name, PatternType.LITERAL))
+          .map(_.acls).getOrElse(Set.empty)
+        val prefixedSet = aclCache
+          .from(new ResourcePattern(resource.resourceType, resource.name, PatternType.PREFIXED))
+          .to(new ResourcePattern(resource.resourceType, resource.name.take(1), PatternType.PREFIXED))
+          .filterKeys(rp => resource.name.startsWith(rp.name))
+          .values.flatMap(_.acls).toSet
+        (wildcardSet, literalSet, prefixedSet)
+      }
+      val emptyAcls = wildcardAcls.isEmpty && literalAcls.isEmpty && prefixedAcls.isEmpty
+      if (emptyAcls) {
+        authorizerLogger.debug(s"No acl found for resource $resource, authorized = $shouldAllowEveryoneIfNoAclIsFound")
+        shouldAllowEveryoneIfNoAclIsFound
+      } else {
+        val denyExists = Seq(literalAcls, wildcardAcls, prefixedAcls)
+          .exists(set => matchingAclExists(operation, resource, principal, host, DENY, set))
+        if (denyExists) false
+        else {
+          val allowOps = operation match {
+            case DESCRIBE => Set(DESCRIBE, READ, WRITE, DELETE, ALTER)
+            case DESCRIBE_CONFIGS => Set(DESCRIBE_CONFIGS, ALTER_CONFIGS)
+            case _ => Set(operation)
+          }
+          allowOps.exists(op => Seq(literalAcls, wildcardAcls, prefixedAcls)
+            .exists(set => matchingAclExists(op, resource, principal, host, ALLOW, set)))
+        }
+      }
     }
 
     // Evaluate if operation is allowed
