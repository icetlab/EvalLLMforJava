I’ve replaced the iterative byte-count loops in sizeOfUnsignedVarint and sizeOfVarlong with O(1) bit‐twiddling using leading zero counts to compute the number of bytes directly, preserving exact behavior (including handling negatives) and improving performance.

```json
[
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/utils/ByteUtils.java",
    "search": "public static int sizeOfUnsignedVarint(int value) {\n        int bytes = 1;\n        while ((value & 0xffffff80) != 0L) {\n            bytes += 1;\n            value >>>= 7;\n        }\n        return bytes;\n    }",
    "replace": "public static int sizeOfUnsignedVarint(int value) {\n        // Negative values always take 5 bytes in varint encoding\n        if (value < 0) {\n            return 5;\n        }\n        // Determine highest set bit position and compute bytes = floor(highestBit/7) + 1\n        int highestBit = value == 0 ? 0 : 31 - Integer.numberOfLeadingZeros(value);\n        return (highestBit / 7) + 1;\n    }"
  },
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/utils/ByteUtils.java",
    "search": "public static int sizeOfVarlong(long value) {\n        long v = (value << 1) ^ (value >> 63);\n        int bytes = 1;\n        while ((v & 0xffffffffffffff80L) != 0L) {\n            bytes += 1;\n            v >>>= 7;\n        }\n        return bytes;\n    }",
    "replace": "public static int sizeOfVarlong(long value) {\n        long v = (value << 1) ^ (value >> 63);\n        // Determine highest set bit in zig-zag value and compute bytes = floor(highestBit/7) + 1\n        int highestBit = v == 0L ? 0 : 63 - Long.numberOfLeadingZeros(v);\n        return (highestBit / 7) + 1;\n    }"
  }
]
```