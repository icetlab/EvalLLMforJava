We add a per‐thread scratch buffer and switch the non‐array ByteBuffer path from per‐byte updates to bulk chunked updates, cutting down on method call overhead and improving throughput without changing semantics or buffer position.

```json
[
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java",
    "search": "    private Checksums() {\n    }",
    "replace": "    private Checksums() {\n    }\n\n    // Scratch buffer for bulk updates on non-array ByteBuffers\n    private static final int DEFAULT_CHUNK_SIZE = 4096;\n    private static final ThreadLocal<byte[]> BUFFER =\n        ThreadLocal.withInitial(() -> new byte[DEFAULT_CHUNK_SIZE]);"
  },
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java",
    "search": "        } else {\n            int start = buffer.position() + offset;\n            for (int i = start; i < start + length; i++)\n                checksum.update(buffer.get(i));\n        }",
    "replace": "        } else {\n            int start = buffer.position() + offset;\n            // Bulk copy via a duplicate so original position is untouched\n            ByteBuffer dup = buffer.duplicate();\n            dup.position(start).limit(start + length);\n            byte[] tmp = BUFFER.get();\n            while (dup.hasRemaining()) {\n                int chunk = Math.min(dup.remaining(), tmp.length);\n                dup.get(tmp, 0, chunk);\n                checksum.update(tmp, 0, chunk);\n            }\n        }"
  }
]
```