diff --git a/core/src/main/scala/kafka/log/LogValidator.scala b/core/src/main/scala/kafka/log/LogValidator.scala
index 48b9f57d9a..854e231448 100644
--- a/core/src/main/scala/kafka/log/LogValidator.scala
+++ b/core/src/main/scala/kafka/log/LogValidator.scala
@@ -237,16 +237,24 @@ private[log] object LogValidator extends Logging {
     for (batch <- records.batches.asScala) {
       validateBatch(topicPartition, firstBatch, batch, origin, toMagicValue, brokerTopicStats)
 
-      val recordErrors = new ArrayBuffer[ApiRecordError](0)
-      for ((record, batchIndex) <- batch.asScala.view.zipWithIndex) {
-        validateRecord(batch, topicPartition, record, batchIndex, now, timestampType,
-          timestampDiffMaxMs, compactedTopic, brokerTopicStats).foreach(recordError => recordErrors += recordError)
+      var recordErrors: ArrayBuffer[ApiRecordError] = null
+      val iter = batch.asScala.iterator
+      var batchIndex = 0
+      while (iter.hasNext) {
+        val record = iter.next()
+        val error = validateRecord(batch, topicPartition, record, batchIndex, now, timestampType,
+          timestampDiffMaxMs, compactedTopic, brokerTopicStats)
+        if (error.isDefined) {
+          if (recordErrors == null) recordErrors = new ArrayBuffer[ApiRecordError](4)
+          recordErrors += error.get
+        }
         // we fail the batch if any record fails, so we stop appending if any record fails
-        if (recordErrors.isEmpty)
+        if (recordErrors == null)
           builder.appendWithOffset(offsetCounter.getAndIncrement(), record)
+        batchIndex += 1
       }
 
-      processRecordErrors(recordErrors)
+      if (recordErrors != null) processRecordErrors(recordErrors)
     }
 
     val convertedRecords = builder.build()
@@ -285,19 +293,26 @@ private[log] object LogValidator extends Logging {
       var maxBatchTimestamp = RecordBatch.NO_TIMESTAMP
       var offsetOfMaxBatchTimestamp = -1L
 
-      val recordErrors = new ArrayBuffer[ApiRecordError](0)
-      for ((record, batchIndex) <- batch.asScala.view.zipWithIndex) {
-        validateRecord(batch, topicPartition, record, batchIndex, now, timestampType,
-          timestampDiffMaxMs, compactedTopic, brokerTopicStats).foreach(recordError => recordErrors += recordError)
-
+      var recordErrors: ArrayBuffer[ApiRecordError] = null
+      val iter = batch.asScala.iterator
+      var batchIndex = 0
+      while (iter.hasNext) {
+        val record = iter.next()
+        val error = validateRecord(batch, topicPartition, record, batchIndex, now, timestampType,
+          timestampDiffMaxMs, compactedTopic, brokerTopicStats)
+        if (error.isDefined) {
+          if (recordErrors == null) recordErrors = new ArrayBuffer[ApiRecordError](4)
+          recordErrors += error.get
+        }
         val offset = offsetCounter.getAndIncrement()
         if (batch.magic > RecordBatch.MAGIC_VALUE_V0 && record.timestamp > maxBatchTimestamp) {
           maxBatchTimestamp = record.timestamp
           offsetOfMaxBatchTimestamp = offset
         }
+        batchIndex += 1
       }
 
-      processRecordErrors(recordErrors)
+      if (recordErrors != null) processRecordErrors(recordErrors)
 
       if (batch.magic > RecordBatch.MAGIC_VALUE_V0 && maxBatchTimestamp > maxTimestamp) {
         maxTimestamp = maxBatchTimestamp
@@ -552,10 +567,15 @@ private[log] object LogValidator extends Logging {
     else None
   }
 
-  private def processRecordErrors(recordErrors: Seq[ApiRecordError]): Unit = {
-    if (recordErrors.nonEmpty) {
+  private def processRecordErrors(recordErrors: ArrayBuffer[ApiRecordError]): Unit = {
+    if (recordErrors != null && recordErrors.nonEmpty) {
       val errors = recordErrors.map(_.recordError)
-      if (recordErrors.exists(_.apiError == Errors.INVALID_TIMESTAMP)) {
+      var hasInvalidTimestamp = false
+      val iter = recordErrors.iterator
+      while (iter.hasNext && !hasInvalidTimestamp) {
+        if (iter.next().apiError == Errors.INVALID_TIMESTAMP) hasInvalidTimestamp = true
+      }
+      if (hasInvalidTimestamp) {
         throw new RecordValidationException(new InvalidTimestampException(
           "One or more records have been rejected due to invalid timestamp"), errors)
       } else {
