## Explanation
The performance issue is that the current `Checksums.update(Checksum, ByteBuffer, int, int)` method processes direct ByteBuffers byte-by-byte, which is inefficient. Java 9 introduced optimized `Checksum.update(ByteBuffer)` methods that can leverage hardware acceleration for direct buffers. We should use this optimized path when available (Java 9+) while maintaining backward compatibility.

The solution involves:
1. Detecting if the Checksum instance supports the Java 9+ ByteBuffer update method via reflection
2. Using the optimized path when available
3. Falling back to the existing implementation for compatibility

Here are the atomic changes:

```json
[
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java",
    "search": "import java.nio.ByteBuffer;\nimport java.util.zip.Checksum;",
    "replace": "import java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.invoke.MethodType;\nimport java.nio.ByteBuffer;\nimport java.util.zip.Checksum;"
  },
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java",
    "search": "public final class Checksums {\n\n    private Checksums() {\n    }",
    "replace": "public final class Checksums {\n\n    private static final MethodHandle UPDATE_BYTEBUFFER_HANDLE;\n\n    static {\n        MethodHandle handle = null;\n        try {\n            // Java 9+ provides Checksum.update(ByteBuffer)\n            handle = MethodHandles.lookup().findVirtual(Checksum.class, \"update\",\n                    MethodType.methodType(void.class, ByteBuffer.class));\n        } catch (ReflectiveOperationException e) {\n            // Java 8 or earlier, or method not found\n            handle = null;\n        }\n        UPDATE_BYTEBUFFER_HANDLE = handle;\n    }\n\n    private Checksums() {\n    }"
  },
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java",
    "search": "    public static void update(Checksum checksum, ByteBuffer buffer, int offset, int length) {\n        if (buffer.hasArray()) {\n            checksum.update(buffer.array(), buffer.position() + buffer.arrayOffset() + offset, length);\n        } else {\n            int start = buffer.position() + offset;\n            for (int i = start; i < start + length; i++)\n                checksum.update(buffer.get(i));\n        }\n    }",
    "replace": "    public static void update(Checksum checksum, ByteBuffer buffer, int offset, int length) {\n        if (buffer.hasArray()) {\n            checksum.update(buffer.array(), buffer.position() + buffer.arrayOffset() + offset, length);\n        } else if (UPDATE_BYTEBUFFER_HANDLE != null) {\n            // Use Java 9+ optimized ByteBuffer update if available\n            try {\n                ByteBuffer slice = buffer.slice();\n                slice.position(buffer.position() + offset);\n                slice.limit(buffer.position() + offset + length);\n                UPDATE_BYTEBUFFER_HANDLE.invokeExact(checksum, slice);\n            } catch (Throwable e) {\n                // Fall back to byte-by-byte processing\n                fallbackUpdate(checksum, buffer, offset, length);\n            }\n        } else {\n            // Java 8 or earlier\n            fallbackUpdate(checksum, buffer, offset, length);\n        }\n    }\n\n    private static void fallbackUpdate(Checksum checksum, ByteBuffer buffer, int offset, int length) {\n        int start = buffer.position() + offset;\n        for (int i = start; i < start + length; i++)\n            checksum.update(buffer.get(i));\n    }"
  }
]
```