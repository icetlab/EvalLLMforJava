Looking at the build error, the issue is that I changed the lock type from `ReentrantReadWriteLock` to `StampedLock`, but the `inWriteLock` and `inReadLock` utility methods from `kafka.utils.CoreUtils` expect a `ReadWriteLock`, not a `StampedLock`. The compilation errors show type mismatches at lines 196 and 219 where `inWriteLock(lock)` is called.

I need to:
1. Revert the lock type back to `ReentrantReadWriteLock` since the utility methods depend on it
2. Keep the performance improvements but adapt them to work with the existing lock type
3. Remove the unused imports that are now causing warnings

Here are the fixes:

```json
[
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "import java.{lang, util}\nimport java.util.concurrent.{CompletableFuture, CompletionStage}\nimport java.util.concurrent.locks.ReentrantReadWriteLock\n\nimport com.typesafe.scalalogging.Logger\nimport kafka.api.KAFKA_2_0_IV1\nimport kafka.security.authorizer.AclAuthorizer.{ResourceOrdering, VersionedAcls}\nimport kafka.security.authorizer.AclEntry.ResourceSeparator\nimport kafka.server.{KafkaConfig, KafkaServer}\nimport kafka.utils.CoreUtils.{inReadLock, inWriteLock}\nimport kafka.utils._",
    "replace": "import java.{lang, util}\nimport java.util.concurrent.{CompletableFuture, CompletionStage}\nimport java.util.concurrent.locks.ReentrantReadWriteLock\n\nimport com.typesafe.scalalogging.Logger\nimport kafka.api.KAFKA_2_0_IV1\nimport kafka.security.authorizer.AclAuthorizer.{ResourceOrdering, VersionedAcls}\nimport kafka.security.authorizer.AclEntry.ResourceSeparator\nimport kafka.server.{KafkaConfig, KafkaServer}\nimport kafka.utils.CoreUtils.{inReadLock, inWriteLock}\nimport kafka.utils._"
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "  @volatile\n  private var aclCache = new scala.collection.immutable.TreeMap[ResourcePattern, VersionedAcls]()(new ResourceOrdering)\n  private val lock = new ReentrantReadWriteLock()",
    "replace": "  @volatile\n  private var aclCache = new scala.collection.immutable.TreeMap[ResourcePattern, VersionedAcls]()(new ResourceOrdering)\n  private val lock = new ReentrantReadWriteLock()"
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "  override def acls(filter: AclBindingFilter): lang.Iterable[AclBinding] = {\n    inReadLock(lock) {\n      val aclBindings = new util.ArrayList[AclBinding]()\n      unorderedAcls.foreach { case (resource, versionedAcls) =>\n        versionedAcls.acls.foreach { acl =>\n          val binding = new AclBinding(resource, acl.ace)\n          if (filter.matches(binding))\n            aclBindings.add(binding)\n        }\n      }\n      aclBindings\n    }\n  }",
    "replace": "  override def acls(filter: AclBindingFilter): lang.Iterable[AclBinding] = {\n    inReadLock(lock) {\n      val aclBindings = new util.ArrayList[AclBinding]()\n      val iter = aclCache.iterator\n      while (iter.hasNext) {\n        val (resource, versionedAcls) = iter.next()\n        val aclsIter = versionedAcls.acls.iterator\n        while (aclsIter.hasNext) {\n          val acl = aclsIter.next()\n          val binding = new AclBinding(resource, acl.ace)\n          if (filter.matches(binding))\n            aclBindings.add(binding)\n        }\n      }\n      aclBindings\n    }\n  }"
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "  private def matchingAclExists(operation: AclOperation,\n                                resource: ResourcePattern,\n                                principal: KafkaPrincipal,\n                                host: String,\n                                permissionType: AclPermissionType,\n                                acls: Set[AclEntry]): Boolean = {\n    acls.find { acl =>\n      acl.permissionType == permissionType &&\n        (acl.kafkaPrincipal == principal || acl.kafkaPrincipal == AclEntry.WildcardPrincipal) &&\n        (operation == acl.operation || acl.operation == AclOperation.ALL) &&\n        (acl.host == host || acl.host == AclEntry.WildcardHost)\n    }.exists { acl =>\n      authorizerLogger.debug(s\"operation = $operation on resource = $resource from host = $host is $permissionType based on acl = $acl\")\n      true\n    }\n  }",
    "replace": "  private def matchingAclExists(operation: AclOperation,\n                                resource: ResourcePattern,\n                                principal: KafkaPrincipal,\n                                host: String,\n                                permissionType: AclPermissionType,\n                                acls: Set[AclEntry]): Boolean = {\n    val iter = acls.iterator\n    while (iter.hasNext) {\n      val acl = iter.next()\n      if (acl.permissionType == permissionType &&\n          (acl.kafkaPrincipal == principal || acl.kafkaPrincipal == AclEntry.WildcardPrincipal) &&\n          (operation == acl.operation || acl.operation == AclOperation.ALL) &&\n          (acl.host == host || acl.host == AclEntry.WildcardHost)) {\n        authorizerLogger.debug(s\"operation = $operation on resource = $resource from host = $host is $permissionType based on acl = $acl\")\n        return true\n      }\n    }\n    false\n  }"
  }
]
```

The key changes are:
1. Kept the lock type as `ReentrantReadWriteLock` to maintain compatibility with the `inReadLock` and `inWriteLock` utility methods
2. Improved the `acls` method to use explicit iterators instead of `foreach` for better performance
3. Improved the `matchingAclExists` method to use explicit iterator loops instead of `find` and `exists` for better performance
4. All other methods continue to use the original `inReadLock`/`inWriteLock` pattern which is compatible with `ReentrantReadWriteLock`

The performance improvements focus on:
- Using explicit iterators in hot paths to avoid functional programming overhead
- Maintaining the existing locking strategy for thread safety
- Keeping the code compatible with the existing test suite