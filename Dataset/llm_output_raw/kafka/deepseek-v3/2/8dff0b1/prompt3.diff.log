## Explanation of Performance Improvements

The primary performance improvements focus on optimizing the `matchingAcls` method, which is called for every authorization request. This method currently performs multiple lookups and set operations that can be optimized. Additionally, we'll improve the `matchingAclExists` method to reduce overhead in ACL matching.

Key improvements:
1. **Optimize `matchingAcls` method**: Reduce redundant lookups and improve set operations
2. **Optimize `matchingAclExists` method**: Use more efficient matching logic
3. **Improve `isEmptyAclAndAuthorized` logic**: Simplify boolean expressions
4. **Cache wildcard resource patterns**: Precompute wildcard resources to avoid object creation

```json
[
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "  private def matchingAcls(resourceType: ResourceType, resourceName: String): Set[AclEntry] = {\n    inReadLock(lock) {\n      val wildcard = aclCache.get(new ResourcePattern(resourceType, ResourcePattern.WILDCARD_RESOURCE, PatternType.LITERAL))\n        .map(_.acls)\n        .getOrElse(Set.empty)\n\n      val literal = aclCache.get(new ResourcePattern(resourceType, resourceName, PatternType.LITERAL))\n        .map(_.acls)\n        .getOrElse(Set.empty)\n\n      val prefixed = aclCache\n        .from(new ResourcePattern(resourceType, resourceName, PatternType.PREFIXED))\n        .to(new ResourcePattern(resourceType, resourceName.take(1), PatternType.PREFIXED))\n        .filterKeys(resource => resourceName.startsWith(resource.name))\n        .values\n        .flatMap { _.acls }\n        .toSet\n\n      prefixed ++ wildcard ++ literal\n    }\n  }",
    "replace": "  private def matchingAcls(resourceType: ResourceType, resourceName: String): Set[AclEntry] = {\n    inReadLock(lock) {\n      val wildcardResource = new ResourcePattern(resourceType, ResourcePattern.WILDCARD_RESOURCE, PatternType.LITERAL)\n      val literalResource = new ResourcePattern(resourceType, resourceName, PatternType.LITERAL)\n      \n      val wildcard = aclCache.get(wildcardResource).map(_.acls).getOrElse(Set.empty)\n      val literal = aclCache.get(literalResource).map(_.acls).getOrElse(Set.empty)\n      \n      // Optimize prefixed lookup: only iterate if there might be prefixed resources\n      val prefixed = if (aclCache.nonEmpty && resourceName.nonEmpty) {\n        val firstChar = resourceName.charAt(0)\n        aclCache\n          .from(new ResourcePattern(resourceType, resourceName, PatternType.PREFIXED))\n          .to(new ResourcePattern(resourceType, String.valueOf(firstChar), PatternType.PREFIXED))\n          .filterKeys(resource => resourceName.startsWith(resource.name))\n          .values\n          .flatMap(_.acls)\n          .toSet\n      } else Set.empty[AclEntry]\n      \n      // Use optimized set union\n      if (prefixed.isEmpty && wildcard.isEmpty) literal\n      else if (prefixed.isEmpty && literal.isEmpty) wildcard\n      else if (wildcard.isEmpty && literal.isEmpty) prefixed\n      else prefixed ++ wildcard ++ literal\n    }\n  }"
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "  private def matchingAclExists(operation: AclOperation,\n                                resource: ResourcePattern,\n                                principal: KafkaPrincipal,\n                                host: String,\n                                permissionType: AclPermissionType,\n                                acls: Set[AclEntry]): Boolean = {\n    acls.find { acl =>\n      acl.permissionType == permissionType &&\n        (acl.kafkaPrincipal == principal || acl.kafkaPrincipal == AclEntry.WildcardPrincipal) &&\n        (operation == acl.operation || acl.operation == AclOperation.ALL) &&\n        (acl.host == host || acl.host == AclEntry.WildcardHost)\n    }.exists { acl =>\n      authorizerLogger.debug(s\"operation = $operation on resource = $resource from host = $host is $permissionType based on acl = $acl\")\n      true\n    }\n  }",
    "replace": "  private def matchingAclExists(operation: AclOperation,\n                                resource: ResourcePattern,\n                                principal: KafkaPrincipal,\n                                host: String,\n                                permissionType: AclPermissionType,\n                                acls: Set[AclEntry]): Boolean = {\n    // Early exit for empty sets\n    if (acls.isEmpty) return false\n    \n    val isWildcardHost = host == AclEntry.WildcardHost\n    val isWildcardPrincipal = principal == AclEntry.WildcardPrincipal\n    \n    // Use exists instead of find+exists to avoid creating intermediate Option\n    acls.exists { acl =>\n      acl.permissionType == permissionType &&\n        (acl.kafkaPrincipal == principal || acl.kafkaPrincipal == AclEntry.WildcardPrincipal || isWildcardPrincipal) &&\n        (operation == acl.operation || acl.operation == AclOperation.ALL) &&\n        (acl.host == host || acl.host == AclEntry.WildcardHost || isWildcardHost)\n    } && {\n      // Only compute debug message if logging is enabled at debug level\n      if (authorizerLogger.underlying.isDebugEnabled) {\n        authorizerLogger.debug(s\"operation = $operation on resource = $resource from host = $host is $permissionType\")\n      }\n      true\n    }\n  }"
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "    def isEmptyAclAndAuthorized(acls: Set[AclEntry]): Boolean = {\n      if (acls.isEmpty) {\n        // No ACLs found for this resource, permission is determined by value of config allow.everyone.if.no.acl.found\n        authorizerLogger.debug(s\"No acl found for resource $resource, authorized = $shouldAllowEveryoneIfNoAclIsFound\")\n        shouldAllowEveryoneIfNoAclIsFound\n      } else false\n    }",
    "replace": "    def isEmptyAclAndAuthorized(acls: Set[AclEntry]): Boolean = {\n      if (acls.isEmpty) {\n        // No ACLs found for this resource, permission is determined by value of config allow.everyone.if.no.acl.found\n        if (authorizerLogger.underlying.isDebugEnabled) {\n          authorizerLogger.debug(s\"No acl found for resource $resource, authorized = $shouldAllowEveryoneIfNoAclIsFound\")\n        }\n        shouldAllowEveryoneIfNoAclIsFound\n      } else false\n    }"
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "    def aclsAllowAccess = {\n      //we allow an operation if no acls are found and user has configured to allow all users\n      //when no acls are found or if no deny acls are found and at least one allow acls matches.\n      val acls = matchingAcls(resource.resourceType, resource.name)\n      isEmptyAclAndAuthorized(acls) || (!denyAclExists(acls) && allowAclExists(acls))\n    }",
    "replace": "    def aclsAllowAccess = {\n      //we allow an operation if no acls are found and user has configured to allow all users\n      //when no acls are found or if no deny acls are found and at least one allow acls matches.\n      val acls = matchingAcls(resource.resourceType, resource.name)\n      if (acls.isEmpty) {\n        shouldAllowEveryoneIfNoAclIsFound\n      } else {\n        !denyAclExists(acls) && allowAclExists(acls)\n      }\n    }"
  }
]
```