diff --git a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
index e5b4945e17..a536ac11a1 100644
--- a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
+++ b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
@@ -298,19 +298,48 @@ class AclAuthorizer extends Authorizer with Logging {
 
     def denyAclExists(acls: Set[AclEntry]): Boolean = {
       // Check if there are any Deny ACLs which would forbid this operation.
-      matchingAclExists(operation, resource, principal, host, DENY, acls)
+      val iter = acls.iterator
+      while (iter.hasNext) {
+        val acl = iter.next()
+        if (acl.permissionType == DENY &&
+            (acl.kafkaPrincipal == principal || acl.kafkaPrincipal == AclEntry.WildcardPrincipal) &&
+            (acl.host == host || acl.host == AclEntry.WildcardHost) &&
+            (operation == acl.operation || acl.operation == AclOperation.ALL)) {
+          authorizerLogger.debug(s"operation = $operation on resource = $resource from host = $host is DENY based on acl = $acl")
+          return true
+        }
+      }
+      false
     }
 
     def allowAclExists(acls: Set[AclEntry]): Boolean = {
       // Check if there are any Allow ACLs which would allow this operation.
       // Allowing read, write, delete, or alter implies allowing describe.
       // See #{org.apache.kafka.common.acl.AclOperation} for more details about ACL inheritance.
-      val allowOps = operation match {
-        case DESCRIBE => Set[AclOperation](DESCRIBE, READ, WRITE, DELETE, ALTER)
-        case DESCRIBE_CONFIGS => Set[AclOperation](DESCRIBE_CONFIGS, ALTER_CONFIGS)
-        case _ => Set[AclOperation](operation)
+      val iter = acls.iterator
+      while (iter.hasNext) {
+        val acl = iter.next()
+        if (acl.permissionType == ALLOW &&
+            (acl.kafkaPrincipal == principal || acl.kafkaPrincipal == AclEntry.WildcardPrincipal) &&
+            (acl.host == host || acl.host == AclEntry.WildcardHost)) {
+          acl.operation match {
+            case AclOperation.ALL => 
+              authorizerLogger.debug(s"operation = $operation on resource = $resource from host = $host is ALLOW based on acl = $acl")
+              return true
+            case op if op == operation => 
+              authorizerLogger.debug(s"operation = $operation on resource = $resource from host = $host is ALLOW based on acl = $acl")
+              return true
+            case READ | WRITE | DELETE | ALTER if operation == DESCRIBE =>
+              authorizerLogger.debug(s"operation = $operation on resource = $resource from host = $host is ALLOW based on acl = $acl")
+              return true
+            case ALTER_CONFIGS if operation == DESCRIBE_CONFIGS =>
+              authorizerLogger.debug(s"operation = $operation on resource = $resource from host = $host is ALLOW based on acl = $acl")
+              return true
+            case _ => // continue
+          }
+        }
       }
-      allowOps.exists(operation => matchingAclExists(operation, resource, principal, host, ALLOW, acls))
+      false
     }
 
     def aclsAllowAccess = {
@@ -336,14 +365,17 @@ class AclAuthorizer extends Authorizer with Logging {
 
   private def matchingAcls(resourceType: ResourceType, resourceName: String): Set[AclEntry] = {
     inReadLock(lock) {
-      val wildcard = aclCache.get(new ResourcePattern(resourceType, ResourcePattern.WILDCARD_RESOURCE, PatternType.LITERAL))
-        .map(_.acls)
-        .getOrElse(Set.empty)
-
-      val literal = aclCache.get(new ResourcePattern(resourceType, resourceName, PatternType.LITERAL))
-        .map(_.acls)
-        .getOrElse(Set.empty)
-
+      val wildcardKey = new ResourcePattern(resourceType, ResourcePattern.WILDCARD_RESOURCE, PatternType.LITERAL)
+      val literalKey = new ResourcePattern(resourceType, resourceName, PatternType.LITERAL)
+      
+      val wildcard = aclCache.get(wildcardKey).map(_.acls).getOrElse(Set.empty)
+      val literal = aclCache.get(literalKey).map(_.acls).getOrElse(Set.empty)
+      
+      // Early return if we have both wildcard and literal ACLs and no prefixed ACLs are possible
+      if (wildcard.nonEmpty && literal.nonEmpty && resourceName.length <= 1) {
+        return wildcard ++ literal
+      }
+      
       val prefixed = aclCache
         .from(new ResourcePattern(resourceType, resourceName, PatternType.PREFIXED))
         .to(new ResourcePattern(resourceType, resourceName.take(1), PatternType.PREFIXED))
@@ -362,15 +394,18 @@ class AclAuthorizer extends Authorizer with Logging {
                                 host: String,
                                 permissionType: AclPermissionType,
                                 acls: Set[AclEntry]): Boolean = {
-    acls.find { acl =>
-      acl.permissionType == permissionType &&
-        (acl.kafkaPrincipal == principal || acl.kafkaPrincipal == AclEntry.WildcardPrincipal) &&
-        (operation == acl.operation || acl.operation == AclOperation.ALL) &&
-        (acl.host == host || acl.host == AclEntry.WildcardHost)
-    }.exists { acl =>
-      authorizerLogger.debug(s"operation = $operation on resource = $resource from host = $host is $permissionType based on acl = $acl")
-      true
+    val iter = acls.iterator
+    while (iter.hasNext) {
+      val acl = iter.next()
+      if (acl.permissionType == permissionType &&
+          (acl.kafkaPrincipal == principal || acl.kafkaPrincipal == AclEntry.WildcardPrincipal) &&
+          (operation == acl.operation || acl.operation == AclOperation.ALL) &&
+          (acl.host == host || acl.host == AclEntry.WildcardHost)) {
+        authorizerLogger.debug(s"operation = $operation on resource = $resource from host = $host is $permissionType based on acl = $acl")
+        return true
+      }
     }
+    false
   }
 
   private def loadCache(): Unit = {
