diff --git a/connect/transforms/src/main/java/org/apache/kafka/connect/transforms/ReplaceField.java b/connect/transforms/src/main/java/org/apache/kafka/connect/transforms/ReplaceField.java
index fb02577e99..3fce7f56e8 100644
--- a/connect/transforms/src/main/java/org/apache/kafka/connect/transforms/ReplaceField.java
+++ b/connect/transforms/src/main/java/org/apache/kafka/connect/transforms/ReplaceField.java
@@ -33,8 +33,10 @@ import org.apache.kafka.connect.transforms.util.SimpleConfig;
 
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 import static org.apache.kafka.connect.transforms.util.Requirements.requireMap;
 import static org.apache.kafka.connect.transforms.util.Requirements.requireStruct;
@@ -80,8 +82,8 @@ public abstract class ReplaceField<R extends ConnectRecord<R>> implements Transf
 
     private static final String PURPOSE = "field replacement";
 
-    private List<String> exclude;
-    private List<String> include;
+    private Set<String> exclude;
+    private Set<String> include;
     private Map<String, String> renames;
     private Map<String, String> reverseRenames;
 
@@ -94,8 +96,8 @@ public abstract class ReplaceField<R extends ConnectRecord<R>> implements Transf
             {ConfigName.EXCLUDE, "blacklist"},
         }));
 
-        exclude = config.getList(ConfigName.EXCLUDE);
-        include = config.getList(ConfigName.INCLUDE);
+        exclude = new HashSet<>(config.getList(ConfigName.EXCLUDE));
+        include = new HashSet<>(config.getList(ConfigName.INCLUDE));
         renames = parseRenameMappings(config.getList(ConfigName.RENAME));
         reverseRenames = invert(renames);
 
@@ -103,19 +105,25 @@ public abstract class ReplaceField<R extends ConnectRecord<R>> implements Transf
     }
 
     static Map<String, String> parseRenameMappings(List<String> mappings) {
-        final Map<String, String> m = new HashMap<>();
+        if (mappings.isEmpty()) {
+            return Collections.emptyMap();
+        }
+        final Map<String, String> m = new HashMap<>(mappings.size());
         for (String mapping : mappings) {
-            final String[] parts = mapping.split(":");
-            if (parts.length != 2) {
+            final int colonIndex = mapping.indexOf(':');
+            if (colonIndex <= 0 || colonIndex == mapping.length() - 1) {
                 throw new ConfigException(ConfigName.RENAME, mappings, "Invalid rename mapping: " + mapping);
             }
-            m.put(parts[0], parts[1]);
+            m.put(mapping.substring(0, colonIndex), mapping.substring(colonIndex + 1));
         }
         return m;
     }
 
     static Map<String, String> invert(Map<String, String> source) {
-        final Map<String, String> m = new HashMap<>();
+        if (source.isEmpty()) {
+            return Collections.emptyMap();
+        }
+        final Map<String, String> m = new HashMap<>(source.size());
         for (Map.Entry<String, String> e : source.entrySet()) {
             m.put(e.getValue(), e.getKey());
         }
