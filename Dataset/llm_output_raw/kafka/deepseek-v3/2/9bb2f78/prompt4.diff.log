The performance issue is that the `ReplaceField` SMT uses `ArrayList.contains()` for filtering fields, which has O(N) complexity. When configured with a large number of include/exclude fields, this leads to poor performance. We can improve this by converting the `exclude` and `include` lists to `HashSet` for O(1) lookups.

```json
[
  {
    "filepath": "../kafka/connect/transforms/src/main/java/org/apache/kafka/connect/transforms/ReplaceField.java",
    "search": "import java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;",
    "replace": "import java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;"
  },
  {
    "filepath": "../kafka/connect/transforms/src/main/java/org/apache/kafka/connect/transforms/ReplaceField.java",
    "search": "  private List<String> exclude;\n  private List<String> include;\n  private Map<String, String> renames;\n  private Map<String, String> reverseRenames;",
    "replace": "  private Set<String> exclude;\n  private Set<String> include;\n  private Map<String, String> renames;\n  private Map<String, String> reverseRenames;"
  },
  {
    "filepath": "../kafka/connect/transforms/src/main/java/org/apache/kafka/connect/transforms/ReplaceField.java",
    "search": "    exclude = config.getList(ConfigName.EXCLUDE);\n    include = config.getList(ConfigName.INCLUDE);\n    renames = parseRenameMappings(config.getList(ConfigName.RENAME));\n    reverseRenames = invert(renames);",
    "replace": "    exclude = new HashSet<>(config.getList(ConfigName.EXCLUDE));\n    include = new HashSet<>(config.getList(ConfigName.INCLUDE));\n    renames = parseRenameMappings(config.getList(ConfigName.RENAME));\n    reverseRenames = invert(renames);"
  },
  {
    "filepath": "../kafka/connect/transforms/src/main/java/org/apache/kafka/connect/transforms/ReplaceField.java",
    "search": "  boolean filter(String fieldName) {\n    return !exclude.contains(fieldName) && (include.isEmpty() || include.contains(fieldName));\n  }",
    "replace": "  boolean filter(String fieldName) {\n    return !exclude.contains(fieldName) && (include.isEmpty() || include.contains(fieldName));\n  }"
  }
]
```