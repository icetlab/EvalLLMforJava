The performance issue is caused by the repeated use of Scala's `Set.++` operation to merge ACL sets for wildcard, prefixed, and literal resources. This operation can be slow, especially with large sets, as it involves iterating and calculating hash codes for each element.

To improve performance, I will refactor the `authorizeAction` method to avoid merging these sets. Instead of creating a single large set of ACLs, the new implementation will:
1.  Fetch the ACLs for wildcard, prefixed, and literal resources into separate sets.
2.  Check for `DENY` rules across these sets individually, short-circuiting if a deny rule is found.
3.  If no deny rules match, it will then check for `ALLOW` rules across the sets, again short-circuiting upon finding a match.
4.  The now-unused helper method `matchingAcls` will be removed.

This approach avoids the costly set-merging operation, improving the performance of each authorization check by iterating over smaller, separate collections and stopping as soon as a definitive rule is found.

```json
[
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "  private def authorizeAction(requestContext: AuthorizableRequestContext, action: Action): AuthorizationResult = {\n    val resource = action.resourcePattern\n    if (resource.patternType != PatternType.LITERAL) {\n      throw new IllegalArgumentException(\"Only literal resources are supported. Got: \" + resource.patternType)\n    }\n\n    // ensure we compare identical classes\n    val sessionPrincipal = requestContext.principal\n    val principal = if (classOf[KafkaPrincipal] != sessionPrincipal.getClass)\n      new KafkaPrincipal(sessionPrincipal.getPrincipalType, sessionPrincipal.getName)\n    else\n      sessionPrincipal\n\n    val host = requestContext.clientAddress.getHostAddress\n    val operation = action.operation\n\n    def isEmptyAclAndAuthorized(acls: Set[AclEntry]): Boolean = {\n      if (acls.isEmpty) {\n        // No ACLs found for this resource, permission is determined by value of config allow.everyone.if.no.acl.found\n        authorizerLogger.debug(s\"No acl found for resource $resource, authorized = $shouldAllowEveryoneIfNoAclIsFound\")\n        shouldAllowEveryoneIfNoAclIsFound\n      } else false\n    }\n\n    def denyAclExists(acls: Set[AclEntry]): Boolean = {\n      // Check if there are any Deny ACLs which would forbid this operation.\n      matchingAclExists(operation, resource, principal, host, DENY, acls)\n    }\n\n    def allowAclExists(acls: Set[AclEntry]): Boolean = {\n      // Check if there are any Allow ACLs which would allow this operation.\n      // Allowing read, write, delete, or alter implies allowing describe.\n      // See #{org.apache.kafka.common.acl.AclOperation} for more details about ACL inheritance.\n      val allowOps = operation match {\n        case DESCRIBE => Set[AclOperation](DESCRIBE, READ, WRITE, DELETE, ALTER)\n        case DESCRIBE_CONFIGS => Set[AclOperation](DESCRIBE_CONFIGS, ALTER_CONFIGS)\n        case _ => Set[AclOperation](operation)\n      }\n      allowOps.exists(operation => matchingAclExists(operation, resource, principal, host, ALLOW, acls))\n    }\n\n    def aclsAllowAccess = {\n      //we allow an operation if no acls are found and user has configured to allow all users\n      //when no acls are found or if no deny acls are found and at least one allow acls matches.\n      val acls = matchingAcls(resource.resourceType, resource.name)\n      isEmptyAclAndAuthorized(acls) || (!denyAclExists(acls) && allowAclExists(acls))\n    }\n\n    // Evaluate if operation is allowed\n    val authorized = isSuperUser(principal) || aclsAllowAccess\n\n    logAuditMessage(requestContext, action, authorized)\n    if (authorized) AuthorizationResult.ALLOWED else AuthorizationResult.DENIED\n  }\n\n  def isSuperUser(principal: KafkaPrincipal): Boolean = {\n    if (superUsers.contains(principal)) {\n      authorizerLogger.debug(s\"principal = $principal is a super user, allowing operation without checking acls.\")\n      true\n    } else false\n  }\n\n  private def matchingAcls(resourceType: ResourceType, resourceName: String): Set[AclEntry] = {\n    inReadLock(lock) {\n      val wildcard = aclCache.get(new ResourcePattern(resourceType, ResourcePattern.WILDCARD_RESOURCE, PatternType.LITERAL))\n        .map(_.acls)\n        .getOrElse(Set.empty)\n\n      val literal = aclCache.get(new ResourcePattern(resourceType, resourceName, PatternType.LITERAL))\n        .map(_.acls)\n        .getOrElse(Set.empty)\n\n      val prefixed = aclCache\n        .from(new ResourcePattern(resourceType, resourceName, PatternType.PREFIXED))\n        .to(new ResourcePattern(resourceType, resourceName.take(1), PatternType.PREFIXED))\n        .filterKeys(resource => resourceName.startsWith(resource.name))\n        .values\n        .flatMap { _.acls }\n        .toSet\n\n      prefixed ++ wildcard ++ literal\n    }\n  }",
    "replace": "  private def authorizeAction(requestContext: AuthorizableRequestContext, action: Action): AuthorizationResult = {\n    val resource = action.resourcePattern\n    if (resource.patternType != PatternType.LITERAL) {\n      throw new IllegalArgumentException(\"Only literal resources are supported. Got: \" + resource.patternType)\n    }\n\n    // ensure we compare identical classes\n    val sessionPrincipal = requestContext.principal\n    val principal = if (classOf[KafkaPrincipal] != sessionPrincipal.getClass)\n      new KafkaPrincipal(sessionPrincipal.getPrincipalType, sessionPrincipal.getName)\n    else\n      sessionPrincipal\n\n    val host = requestContext.clientAddress.getHostAddress\n    val operation = action.operation\n\n    def aclsAllowAccess: Boolean = {\n      val (wildcardAcls, prefixedAcls, literalAcls) = inReadLock(lock) {\n        val wildcard = aclCache.get(new ResourcePattern(resource.resourceType, ResourcePattern.WILDCARD_RESOURCE, PatternType.LITERAL))\n          .map(_.acls)\n          .getOrElse(Set.empty)\n\n        val literal = aclCache.get(new ResourcePattern(resource.resourceType, resource.name, PatternType.LITERAL))\n          .map(_.acls)\n          .getOrElse(Set.empty)\n\n        val prefixed = aclCache\n          .from(new ResourcePattern(resource.resourceType, resource.name, PatternType.PREFIXED))\n          .to(new ResourcePattern(resource.resourceType, resource.name.take(1), PatternType.PREFIXED))\n          .filterKeys(resourcePattern => resource.name.startsWith(resourcePattern.name))\n          .values\n          .flatMap { _.acls }\n          .toSet\n        (wildcard, prefixed, literal)\n      }\n\n      //we allow an operation if no acls are found and user has configured to allow all users\n      //when no acls are found or if no deny acls are found and at least one allow acls matches.\n      if (literalAcls.isEmpty && prefixedAcls.isEmpty && wildcardAcls.isEmpty) {\n        authorizerLogger.debug(s\"No acl found for resource $resource, authorized = $shouldAllowEveryoneIfNoAclIsFound\")\n        shouldAllowEveryoneIfNoAclIsFound\n      } else {\n        // Check if there are any Deny ACLs which would forbid this operation.\n        // The order of checks is important here for performance. Literal is most specific, so we check it first.\n        val denyAclExists =\n          matchingAclExists(operation, resource, principal, host, DENY, literalAcls) ||\n          matchingAclExists(operation, resource, principal, host, DENY, prefixedAcls) ||\n          matchingAclExists(operation, resource, principal, host, DENY, wildcardAcls)\n\n        if (denyAclExists) {\n          false\n        } else {\n          // Check if there are any Allow ACLs which would allow this operation.\n          // Allowing read, write, delete, or alter implies allowing describe.\n          // See #{org.apache.kafka.common.acl.AclOperation} for more details about ACL inheritance.\n          val allowOps = operation match {\n            case DESCRIBE => Set[AclOperation](DESCRIBE, READ, WRITE, DELETE, ALTER)\n            case DESCRIBE_CONFIGS => Set[AclOperation](DESCRIBE_CONFIGS, ALTER_CONFIGS)\n            case _ => Set[AclOperation](operation)\n          }\n          val allowAclExists = allowOps.exists { op =>\n            matchingAclExists(op, resource, principal, host, ALLOW, literalAcls) ||\n            matchingAclExists(op, resource, principal, host, ALLOW, prefixedAcls) ||\n            matchingAclExists(op, resource, principal, host, ALLOW, wildcardAcls)\n          }\n          allowAclExists\n        }\n      }\n    }\n\n    // Evaluate if operation is allowed\n    val authorized = isSuperUser(principal) || aclsAllowAccess\n\n    logAuditMessage(requestContext, action, authorized)\n    if (authorized) AuthorizationResult.ALLOWED else AuthorizationResult.DENIED\n  }\n\n  def isSuperUser(principal: KafkaPrincipal): Boolean = {\n    if (superUsers.contains(principal)) {\n      authorizerLogger.debug(s\"principal = $principal is a super user, allowing operation without checking acls.\")\n      true\n    } else false\n  }"
  }
]
```