The primary performance bottleneck is the creation of a temporary `Set` for prefixed ACLs in the `matchingAcls` method during authorization checks. This change avoids this by using a lazy `Iterable` instead. To support this, the `AclSets` helper class is updated to accept `Iterable[AclEntry]` instead of `Set[AclEntry]`. Additionally, the `find` method in `AclSets` is optimized to use a lazy `view`, preventing intermediate collection allocation.

```json
[
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "  class AclSets(sets: Set[AclEntry]*) {\n    def find(p: AclEntry => Boolean): Option[AclEntry] = sets.flatMap(_.find(p)).headOption\n    def isEmpty: Boolean = !sets.exists(_.nonEmpty)\n  }",
    "replace": "  class AclSets(sets: Iterable[AclEntry]*) {\n    def find(p: AclEntry => Boolean): Option[AclEntry] = sets.view.flatMap(_.find(p)).headOption\n    def isEmpty: Boolean = !sets.exists(_.nonEmpty)\n  }"
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "      .filterKeys(resource => resourceName.startsWith(resource.name))\n      .values\n      .flatMap { _.acls }\n      .toSet\n\n    new AclSets(prefixed, wildcard, literal)",
    "replace": "      .filterKeys(resource => resourceName.startsWith(resource.name))\n      .values\n      .flatMap { _.acls }\n\n    new AclSets(prefixed, wildcard, literal)"
  }
]
```