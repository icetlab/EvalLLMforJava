diff --git a/storage/src/main/java/org/apache/kafka/storage/internals/log/ProducerStateManager.java b/storage/src/main/java/org/apache/kafka/storage/internals/log/ProducerStateManager.java
index da56ddaccc..3185146c9c 100644
--- a/storage/src/main/java/org/apache/kafka/storage/internals/log/ProducerStateManager.java
+++ b/storage/src/main/java/org/apache/kafka/storage/internals/log/ProducerStateManager.java
@@ -233,36 +233,31 @@ public class ProducerStateManager {
      * largest stray snapshot file which was emitted during clean shutdown.
      */
     public void removeStraySnapshots(Collection<Long> segmentBaseOffsets) throws IOException {
-        OptionalLong maxSegmentBaseOffset = segmentBaseOffsets.isEmpty() ? OptionalLong.empty() : OptionalLong.of(segmentBaseOffsets.stream().max(Long::compare).get());
+        OptionalLong maxSegmentBaseOffset = segmentBaseOffsets.stream().mapToLong(l -> l).max();
 
         HashSet<Long> baseOffsets = new HashSet<>(segmentBaseOffsets);
-        Optional<SnapshotFile> latestStraySnapshot = Optional.empty();
-
         ConcurrentSkipListMap<Long, SnapshotFile> snapshots = loadSnapshots();
-        for (SnapshotFile snapshot : snapshots.values()) {
-            long key = snapshot.offset;
-            if (latestStraySnapshot.isPresent()) {
-                SnapshotFile prev = latestStraySnapshot.get();
-                if (!baseOffsets.contains(key)) {
-                    // this snapshot is now the largest stray snapshot.
-                    prev.deleteIfExists();
-                    snapshots.remove(prev.offset);
-                    latestStraySnapshot = Optional.of(snapshot);
-                }
-            } else {
-                if (!baseOffsets.contains(key)) {
-                    latestStraySnapshot = Optional.of(snapshot);
-                }
+
+        List<SnapshotFile> straySnapshots = snapshots.values().stream()
+            .filter(snapshot -> !baseOffsets.contains(snapshot.offset))
+            .collect(Collectors.toList());
+
+        if (!straySnapshots.isEmpty()) {
+            // The last element is the one with the highest offset since snapshots are sorted.
+            SnapshotFile latestStraySnapshot = straySnapshots.get(straySnapshots.size() - 1);
+
+            for (SnapshotFile snapshot : straySnapshots) {
+                if (snapshot.offset != latestStraySnapshot.offset) {
+                    // This is not the latest stray snapshot, so we can remove it.
+                    snapshots.remove(snapshot.offset);
+                    snapshot.deleteIfExists();
                 }
             }
 
             // Check to see if the latestStraySnapshot is larger than the largest segment base offset, if it is not,
             // delete the largestStraySnapshot.
-        if (latestStraySnapshot.isPresent() && maxSegmentBaseOffset.isPresent()) {
-            long strayOffset = latestStraySnapshot.get().offset;
-            long maxOffset = maxSegmentBaseOffset.getAsLong();
-            if (strayOffset < maxOffset) {
-                SnapshotFile removedSnapshot = snapshots.remove(strayOffset);
+            if (maxSegmentBaseOffset.isPresent() && latestStraySnapshot.offset < maxSegmentBaseOffset.getAsLong()) {
+                SnapshotFile removedSnapshot = snapshots.remove(latestStraySnapshot.offset);
                 if (removedSnapshot != null) {
                     removedSnapshot.deleteIfExists();
                 }
@@ -369,17 +364,12 @@ public class ProducerStateManager {
      * Also expire any verification state entries that are lingering as unverified.
      */
     public void removeExpiredProducers(long currentTimeMs) {
-        List<Long> keys = producers.entrySet().stream()
-                .filter(entry -> isProducerExpired(currentTimeMs, entry.getValue()))
-                .map(Map.Entry::getKey)
-                .collect(Collectors.toList());
-        removeProducerIds(keys);
+        if (producers.entrySet().removeIf(entry -> isProducerExpired(currentTimeMs, entry.getValue()))) {
+            producerIdCount = producers.size();
+        }
 
-        List<Long> verificationKeys = verificationStates.entrySet().stream()
-                .filter(entry -> currentTimeMs - entry.getValue().timestamp() >= producerStateManagerConfig.producerIdExpirationMs())
-                .map(Map.Entry::getKey)
-                .collect(Collectors.toList());
-        verificationKeys.forEach(verificationStates::remove);
+        verificationStates.entrySet().removeIf(entry ->
+            currentTimeMs - entry.getValue().timestamp() >= producerStateManagerConfig.producerIdExpirationMs());
     }
 
     /**
