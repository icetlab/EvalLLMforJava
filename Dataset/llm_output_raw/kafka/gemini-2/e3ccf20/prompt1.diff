diff --git a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
index 86f06981ff..554685e8a2 100644
--- a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
+++ b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
@@ -315,7 +315,16 @@ class AclAuthorizer extends Authorizer with Logging {
         case DESCRIBE_CONFIGS => Set[AclOperation](DESCRIBE_CONFIGS, ALTER_CONFIGS)
         case _ => Set[AclOperation](operation)
       }
-      allowOps.exists(operation => matchingAclExists(operation, resource, principal, host, ALLOW, acls))
+      acls.find { acl =>
+        acl.permissionType == ALLOW &&
+          (acl.kafkaPrincipal == principal || acl.kafkaPrincipal == AclEntry.WildcardPrincipal) &&
+          (acl.host == host || acl.host == AclEntry.WildcardHost) &&
+          (allowOps.contains(acl.operation) || acl.operation == AclOperation.ALL)
+      }.exists { acl =>
+        val satisfiedOp = if (acl.operation == AclOperation.ALL) operation else acl.operation
+        authorizerLogger.debug(s"operation = $satisfiedOp on resource = $resource from host = $host is ALLOW based on acl = $acl")
+        true
+      }
     }
 
     def aclsAllowAccess = {
@@ -352,9 +361,9 @@ class AclAuthorizer extends Authorizer with Logging {
       val prefixed = aclCache
         .from(new ResourcePattern(resourceType, resourceName, PatternType.PREFIXED))
         .to(new ResourcePattern(resourceType, resourceName.take(1), PatternType.PREFIXED))
-        .filterKeys(resource => resourceName.startsWith(resource.name))
-        .values
-        .flatMap { _.acls }
+        .iterator
+        .filter { case (resource, _) => resourceName.startsWith(resource.name) }
+        .flatMap { case (_, versionedAcls) => versionedAcls.acls }
         .toSet
 
       prefixed ++ wildcard ++ literal
