diff --git a/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java b/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java
index 6813ba04fa..e9df5ef133 100644
--- a/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java
+++ b/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java
@@ -240,16 +240,28 @@ public class WindowOperator
                 .map(functionDefinition -> new FramedWindowFunction(functionDefinition.createWindowFunction(), functionDefinition.getFrameInfo()))
                 .collect(toImmutableList());
 
-        this.outputTypes = Stream.concat(
-                outputChannels.stream()
-                        .map(sourceTypes::get),
-                windowFunctionDefinitions.stream()
-                        .map(WindowFunctionDefinition::getType))
-                .collect(toImmutableList());
-
-        List<Integer> unGroupedPartitionChannels = partitionChannels.stream()
-                .filter(channel -> !preGroupedChannels.contains(channel))
-                .collect(toImmutableList());
+        ImmutableList.Builder<Type> outputTypesBuilder = ImmutableList.builderWithExpectedSize(
+            outputChannels.size() + windowFunctionDefinitions.size());
+        for (int channel : outputChannels) {
+            outputTypesBuilder.add(sourceTypes.get(channel));
+        }
+        for (WindowFunctionDefinition definition : windowFunctionDefinitions) {
+            outputTypesBuilder.add(definition.getType());
+        }
+        this.outputTypes = outputTypesBuilder.build();
+
+        List<Integer> unGroupedPartitionChannels;
+        if (preGroupedChannels.isEmpty()) {
+            unGroupedPartitionChannels = ImmutableList.copyOf(partitionChannels);
+        } else {
+            ImmutableList.Builder<Integer> builder = ImmutableList.builder();
+            for (Integer channel : partitionChannels) {
+                if (!preGroupedChannels.contains(channel)) {
+                    builder.add(channel);
+                }
+            }
+            unGroupedPartitionChannels = builder.build();
+        }
         List<Integer> preSortedChannels = sortChannels.stream()
                 .limit(preSortedChannelPrefix)
                 .collect(toImmutableList());
@@ -570,6 +582,7 @@ public class WindowOperator
     private WorkProcessor<WindowPartition> pagesIndexToWindowPartitions(PagesIndexWithHashStrategies pagesIndexWithHashStrategies)
     {
         PagesIndex pagesIndex = pagesIndexWithHashStrategies.pagesIndex;
+        int positionCount = pagesIndex.getPositionCount();
 
         // pagesIndex contains the full grouped & sorted data for one or more partitions
 
@@ -582,7 +595,7 @@ public class WindowOperator
             @Override
             public ProcessState<WindowPartition> process()
             {
-                if (partitionStart == pagesIndex.getPositionCount()) {
+                if (partitionStart == positionCount) {
                     return ProcessState.finished();
                 }
 
@@ -899,7 +912,13 @@ public class WindowOperator
         checkArgument(page.getPositionCount() > 0, "Must have at least one position");
         checkPositionIndex(startPosition, page.getPositionCount(), "startPosition out of bounds");
 
-        return findEndPosition(startPosition, page.getPositionCount(), (firstPosition, secondPosition) -> pagesHashStrategy.rowEqualsRow(firstPosition, page, secondPosition, page));
+        int endPosition = page.getPositionCount();
+        // Fast path for common case: if the next position is different, return immediately
+        if (startPosition + 1 < endPosition && !pagesHashStrategy.rowEqualsRow(startPosition, page, startPosition + 1, page)) {
+            return startPosition + 1;
+        }
+        
+        return findEndPosition(startPosition, endPosition, (firstPosition, secondPosition) -> pagesHashStrategy.rowEqualsRow(firstPosition, page, secondPosition, page));
     }
 
     // Assumes input grouped on relevant pagesHashStrategy columns
@@ -908,7 +927,13 @@ public class WindowOperator
         checkArgument(pagesIndex.getPositionCount() > 0, "Must have at least one position");
         checkPositionIndex(startPosition, pagesIndex.getPositionCount(), "startPosition out of bounds");
 
-        return findEndPosition(startPosition, pagesIndex.getPositionCount(), (firstPosition, secondPosition) -> pagesIndex.positionEqualsPosition(pagesHashStrategy, firstPosition, secondPosition));
+        int endPosition = pagesIndex.getPositionCount();
+        // Fast path for common case: if the next position is different, return immediately
+        if (startPosition + 1 < endPosition && !pagesIndex.positionEqualsPosition(pagesHashStrategy, startPosition, startPosition + 1)) {
+            return startPosition + 1;
+        }
+        
+        return findEndPosition(startPosition, endPosition, (firstPosition, secondPosition) -> pagesIndex.positionEqualsPosition(pagesHashStrategy, firstPosition, secondPosition));
     }
 
     /**
@@ -926,7 +951,8 @@ public class WindowOperator
         int left = startPosition;
         int right = endPosition;
 
-        while (left + 1 < right) {
+        // Unroll first few iterations for common small group sizes
+        while (left + 4 < right) {
             int middle = (left + right) >>> 1;
 
             if (comparator.test(startPosition, middle)) {
@@ -936,6 +962,13 @@ public class WindowOperator
                 right = middle;
             }
         }
+        
+        // Linear search for the remaining small range (typically <= 3 elements)
+        for (int i = left + 1; i < right; i++) {
+            if (!comparator.test(startPosition, i)) {
+                return i;
+            }
+        }
 
         return right;
     }
