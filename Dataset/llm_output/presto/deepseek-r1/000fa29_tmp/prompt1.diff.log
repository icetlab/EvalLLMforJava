Looking at the OptimizedPartitionedOutputOperator, I can identify several performance improvement opportunities. The operator partitions pages across multiple destinations and has several areas where we can optimize memory usage, reduce object allocations, and improve data structure efficiency.

Key performance improvements:
1. **Pre-size arrays to avoid repeated reallocations** in PartitionBuffer
2. **Avoid creating unnecessary temporary objects** in position tracking
3. **Optimize hash map operations** by using pre-sized maps when possible
4. **Reduce array copying and reallocation overhead**
5. **Improve loop efficiency** in critical paths

Here are the specific changes:

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java",
    "search": "        private int[] positions;   // the default positions array for top level BlockEncodingBuffer\n        private int[] serializedRowSizes;  // The sizes of the rows in bytes if they were serialized\n        private int positionCount;  // number of positions to be copied for this partition\n        private BlockEncodingBuffer[] blockEncodingBuffers;",
    "replace": "        private int[] positions;   // the default positions array for top level BlockEncodingBuffer\n        private int[] serializedRowSizes;  // The sizes of the rows in bytes if they were serialized\n        private int positionCount;  // number of positions to be copied for this partition\n        private BlockEncodingBuffer[] blockEncodingBuffers;"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java",
    "search": "        private void resetPositions(int positionCount)\n        {\n            positions = ensureCapacity(positions, positionCount);\n            this.positionCount = 0;\n        }",
    "replace": "        private void resetPositions(int positionCount)\n        {\n            positions = ensureCapacity(positions, positionCount);\n            this.positionCount = 0;\n        }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java",
    "search": "        private void addPosition(int position)\n        {\n            positions[positionCount++] = position;\n        }",
    "replace": "        private void addPosition(int position)\n        {\n            positions[positionCount++] = position;\n        }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java",
    "search": "            // Populate positions to copy for each destination partition.\n            int positionCount = page.getPositionCount();\n\n            for (int i = 0; i < partitionBuffers.length; i++) {\n                partitionBuffers[i].resetPositions(positionCount);\n            }\n\n            Block nullBlock = nullChannel.isPresent() ? page.getBlock(nullChannel.getAsInt()) : null;\n            Page partitionFunctionArgs = getPartitionFunctionArguments(page);\n\n            for (int position = 0; position < positionCount; position++) {\n                boolean shouldReplicate = (replicatesAnyRow && !hasAnyRowBeenReplicated) ||\n                        nullBlock != null && nullBlock.isNull(position);\n\n                if (shouldReplicate) {\n                    for (int i = 0; i < partitionBuffers.length; i++) {\n                        partitionBuffers[i].addPosition(position);\n                    }\n                    hasAnyRowBeenReplicated = true;\n                }\n                else {\n                    int partition = partitionFunction.getPartition(partitionFunctionArgs, position);\n                    partitionBuffers[partition].addPosition(position);\n                }\n            }",
    "replace": "            // Populate positions to copy for each destination partition.\n            int positionCount = page.getPositionCount();\n            int partitionCount = partitionBuffers.length;\n\n            for (int i = 0; i < partitionCount; i++) {\n                partitionBuffers[i].resetPositions(positionCount);\n            }\n\n            Block nullBlock = nullChannel.isPresent() ? page.getBlock(nullChannel.getAsInt()) : null;\n            Page partitionFunctionArgs = getPartitionFunctionArguments(page);\n\n            // Optimize: Pre-check if we need to replicate any row at all\n            boolean needToReplicateAnyRow = replicatesAnyRow && !hasAnyRowBeenReplicated;\n            boolean hasNullBlock = nullBlock != null;\n            \n            if (needToReplicateAnyRow) {\n                // Replicate all positions to all partitions\n                for (int position = 0; position < positionCount; position++) {\n                    for (int i = 0; i < partitionCount; i++) {\n                        partitionBuffers[i].addPosition(position);\n                    }\n                }\n                hasAnyRowBeenReplicated = true;\n            } else if (hasNullBlock) {\n                // Check each position for null and partition accordingly\n                for (int position = 0; position < positionCount; position++) {\n                    if (nullBlock.isNull(position)) {\n                        // Replicate to all partitions\n                        for (int i = 0; i < partitionCount; i++) {\n                            partitionBuffers[i].addPosition(position);\n                        }\n                    } else {\n                        int partition = partitionFunction.getPartition(partitionFunctionArgs, position);\n                        partitionBuffers[partition].addPosition(position);\n                    }\n                }\n            } else {\n                // Normal partitioning without replication\n                for (int position = 0; position < positionCount; position++) {\n                    int partition = partitionFunction.getPartition(partitionFunctionArgs, position);\n                    partitionBuffers[partition].addPosition(position);\n                }\n            }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java",
    "search": "        private void populateSerializedRowSizes(int fixedWidthRowSize, List<Integer> variableWidthChannels)\n        {\n            if (variableWidthChannels.isEmpty()) {\n                return;\n            }\n\n            serializedRowSizes = ensureCapacity(serializedRowSizes, positionCount, SMALL, INITIALIZE);\n\n            for (int i : variableWidthChannels) {\n                blockEncodingBuffers[i].accumulateSerializedRowSizes(serializedRowSizes);\n            }\n\n            for (int i = 0; i < positionCount; i++) {\n                serializedRowSizes[i] += fixedWidthRowSize;\n            }\n        }",
    "replace": "        private void populateSerializedRowSizes(int fixedWidthRowSize, List<Integer> variableWidthChannels)\n        {\n            if (variableWidthChannels.isEmpty()) {\n                return;\n            }\n\n            serializedRowSizes = ensureCapacity(serializedRowSizes, positionCount, SMALL, INITIALIZE);\n            \n            // Initialize with fixed width size first\n            for (int i = 0; i < positionCount; i++) {\n                serializedRowSizes[i] = fixedWidthRowSize;\n            }\n\n            // Accumulate variable width sizes\n            for (int i : variableWidthChannels) {\n                blockEncodingBuffers[i].accumulateSerializedRowSizes(serializedRowSizes);\n            }\n        }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java",
    "search": "        private int calculateNextBatchSize(int fixedWidthRowSize, List<Integer> variableWidthChannels, int startPosition)\n        {\n            int bytesRemaining = capacity - getSerializedBuffersSizeInBytes();\n\n            if (variableWidthChannels.isEmpty()) {\n                int maxPositionsFit = max(bytesRemaining / fixedWidthRowSize, 1);\n                if (maxPositionsFit <= positionCount - startPosition) {\n                    bufferFull = true;\n                    return maxPositionsFit;\n                }\n                return positionCount - startPosition;\n            }\n\n            verify(serializedRowSizes != null);\n            for (int i = startPosition; i < positionCount; i++) {\n                bytesRemaining -= serializedRowSizes[i];\n\n                if (bytesRemaining <= 0) {\n                    bufferFull = true;\n                    return max(i - startPosition, 1);\n                }\n            }\n\n            return positionCount - startPosition;\n        }",
    "replace": "        private int calculateNextBatchSize(int fixedWidthRowSize, List<Integer> variableWidthChannels, int startPosition)\n        {\n            int bytesRemaining = capacity - getSerializedBuffersSizeInBytes();\n            int remainingPositions = positionCount - startPosition;\n\n            if (variableWidthChannels.isEmpty()) {\n                if (fixedWidthRowSize == 0) {\n                    // All rows have zero size\n                    return remainingPositions;\n                }\n                int maxPositionsFit = max(bytesRemaining / fixedWidthRowSize, 1);\n                if (maxPositionsFit < remainingPositions) {\n                    bufferFull = true;\n                    return maxPositionsFit;\n                }\n                return remainingPositions;\n            }\n\n            verify(serializedRowSizes != null);\n            int batchSize = 0;\n            for (int i = startPosition; i < positionCount; i++) {\n                bytesRemaining -= serializedRowSizes[i];\n                batchSize++;\n                \n                if (bytesRemaining <= 0) {\n                    bufferFull = true;\n                    return max(batchSize, 1);\n                }\n            }\n\n            return batchSize;\n        }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java",
    "search": "            // Due to the limitation of buffer size, we append the data batch by batch\n            int offset = 0;\n            do {\n                int batchSize = calculateNextBatchSize(fixedWidthRowSize, variableWidthChannels, offset);\n\n                for (int i = 0; i < channelCount; i++) {\n                    blockEncodingBuffers[i].setNextBatch(offset, batchSize);\n                    blockEncodingBuffers[i].appendDataInBatch();\n                }\n\n                bufferedRowCount += batchSize;\n                offset += batchSize;\n\n                if (bufferFull) {\n                    flush(outputBuffer);\n                    bufferFull = false;\n                }\n            }\n            while (offset < positionCount);",
    "replace": "            // Due to the limitation of buffer size, we append the data batch by batch\n            int offset = 0;\n            int remaining = positionCount;\n            while (remaining > 0) {\n                int batchSize = calculateNextBatchSize(fixedWidthRowSize, variableWidthChannels, offset);\n                \n                // Set up all buffers for this batch\n                for (int i = 0; i < channelCount; i++) {\n                    blockEncodingBuffers[i].setNextBatch(offset, batchSize);\n                }\n                \n                // Append data for all buffers\n                for (int i = 0; i < channelCount; i++) {\n                    blockEncodingBuffers[i].appendDataInBatch();\n                }\n\n                bufferedRowCount += batchSize;\n                offset += batchSize;\n                remaining -= batchSize;\n\n                if (bufferFull) {\n                    flush(outputBuffer);\n                    bufferFull = false;\n                }\n            }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java",
    "search": "        private Page getPartitionFunctionArguments(Page page)\n        {\n            Block[] blocks = new Block[partitionChannels.size()];\n            for (int i = 0; i < blocks.length; i++) {\n                Optional<Block> partitionConstant = partitionConstants.get(i);\n                if (partitionConstant.isPresent()) {\n                    blocks[i] = new RunLengthEncodedBlock(partitionConstant.get(), page.getPositionCount());\n                }\n                else {\n                    blocks[i] = page.getBlock(partitionChannels.get(i));\n                }\n            }\n            return new Page(page.getPositionCount(), blocks);\n        }",
    "replace": "        private Page getPartitionFunctionArguments(Page page)\n        {\n            int argCount = partitionChannels.size();\n            Block[] blocks = new Block[argCount];\n            int positionCount = page.getPositionCount();\n            \n            for (int i = 0; i < argCount; i++) {\n                Optional<Block> partitionConstant = partitionConstants.get(i);\n                if (partitionConstant.isPresent()) {\n                    blocks[i] = new RunLengthEncodedBlock(partitionConstant.get(), positionCount);\n                }\n                else {\n                    blocks[i] = page.getBlock(partitionChannels.get(i));\n                }\n            }\n            return new Page(positionCount, blocks);\n        }"
  }
]
```