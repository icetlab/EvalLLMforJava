## Improvement Intent

The performance issue is that each PartitionBuffer's `positions` array was initialized to the full page size (`positionCount`), wasting memory when partitions receive only a small subset of rows. The solution uses a two-pass approach: first counting positions per partition, then allocating exact-sized arrays, and finally populating them. This reduces memory waste while maintaining functionality.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java",
    "search": "        public void partitionPage(Page page)\n        {\n            // Populate positions to copy for each destination partition.\n            int positionCount = page.getPositionCount();\n\n            for (int i = 0; i < partitionBuffers.length; i++) {\n                partitionBuffers[i].resetPositions(positionCount);\n            }\n\n            Block nullBlock = nullChannel.isPresent() ? page.getBlock(nullChannel.getAsInt()) : null;\n            Page partitionFunctionArgs = getPartitionFunctionArguments(page);\n\n            for (int position = 0; position < positionCount; position++) {\n                boolean shouldReplicate = (replicatesAnyRow && !hasAnyRowBeenReplicated) ||\n                        nullBlock != null && nullBlock.isNull(position);\n\n                if (shouldReplicate) {\n                    for (int i = 0; i < partitionBuffers.length; i++) {\n                        partitionBuffers[i].addPosition(position);\n                    }\n                    hasAnyRowBeenReplicated = true;\n                }\n                else {\n                    int partition = partitionFunction.getPartition(partitionFunctionArgs, position);\n                    partitionBuffers[partition].addPosition(position);\n                }\n            }\n\n            // Decode the page just once. The decoded blocks will be fed to each PartitionBuffer object to set up AbstractBlockEncodingBuffer.\n            for (int i = 0; i < decodedBlocks.length; i++) {\n                decodedBlocks[i] = decodeBlock(flattener, blockLeaseCloser, page.getBlock(i));\n            }\n\n            // Copy the data to their destination partitions and flush when the buffer is full.\n            for (int i = 0; i < partitionBuffers.length; i++) {\n                partitionBuffers[i].appendData(decodedBlocks, fixedWidthRowSize, variableWidthChannels, outputBuffer);\n            }\n\n            // Return all borrowed arrays\n            try {\n                blockLeaseCloser.close();\n            }\n            catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }",
    "replace": "        public void partitionPage(Page page)\n        {\n            // First, count the number of positions for each partition.\n            int positionCount = page.getPositionCount();\n            int[] partitionAssignments = new int[positionCount];\n            int[] partitionCounts = new int[partitionBuffers.length];\n\n            Block nullBlock = nullChannel.isPresent() ? page.getBlock(nullChannel.getAsInt()) : null;\n            Page partitionFunctionArgs = getPartitionFunctionArguments(page);\n\n            for (int position = 0; position < positionCount; position++) {\n                boolean shouldReplicate = (replicatesAnyRow && !hasAnyRowBeenReplicated) ||\n                        nullBlock != null && nullBlock.isNull(position);\n\n                if (shouldReplicate) {\n                    partitionAssignments[position] = -1;\n                    for (int i = 0; i < partitionBuffers.length; i++) {\n                        partitionCounts[i]++;\n                    }\n                    if (replicatesAnyRow && !hasAnyRowBeenReplicated) {\n                        hasAnyRowBeenReplicated = true;\n                    }\n                }\n                else {\n                    int partition = partitionFunction.getPartition(partitionFunctionArgs, position);\n                    partitionAssignments[position] = partition;\n                    partitionCounts[partition]++;\n                }\n            }\n\n            // Then, reset the positions array for each partition with the exact count.\n            for (int i = 0; i < partitionBuffers.length; i++) {\n                partitionBuffers[i].resetPositions(partitionCounts[i]);\n            }\n\n            // Then, second pass to add positions.\n            for (int position = 0; position < positionCount; position++) {\n                if (partitionAssignments[position] == -1) {\n                    for (int i = 0; i < partitionBuffers.length; i++) {\n                        partitionBuffers[i].addPosition(position);\n                    }\n                }\n                else {\n                    partitionBuffers[partitionAssignments[position]].addPosition(position);\n                }\n            }\n\n            // Decode the page just once. The decoded blocks will be fed to each PartitionBuffer object to set up AbstractBlockEncodingBuffer.\n            for (int i = 0; i < decodedBlocks.length; i++) {\n                decodedBlocks[i] = decodeBlock(flattener, blockLeaseCloser, page.getBlock(i));\n            }\n\n            // Copy the data to their destination partitions and flush when the buffer is full.\n            for (int i = 0; i < partitionBuffers.length; i++) {\n                partitionBuffers[i].appendData(decodedBlocks, fixedWidthRowSize, variableWidthChannels, outputBuffer);\n            }\n\n            // Return all borrowed arrays\n            try {\n                blockLeaseCloser.close();\n            }\n            catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }"
  }
]
```