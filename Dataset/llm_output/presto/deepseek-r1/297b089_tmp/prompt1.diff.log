Looking at the `SliceDirectSelectiveStreamReader` class, I can identify several performance optimization opportunities:

1. **Simplify batch mode decision logic**: The `useBatchMode` method currently returns `true` unconditionally, but there's commented-out logic that suggests it should be conditional. We should enable the optimized batch mode logic for better performance.

2. **Avoid unnecessary System.arraycopy operations**: In the batch processing paths, we can optimize by avoiding redundant array copies when not needed.

3. **Reduce redundant condition checks**: Several methods have repeated null checks that can be optimized.

Here are the performance improvements I'll implement:

```json
[
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java",
    "search": "    private boolean useBatchMode(int positionCount, int totalPositionCount)\n    {\n        return true;\n        // maxCodePointCount < 0 means it's unbounded varchar VARCHAR.\n        // If the types are VARCHAR(N) or CHAR(N), the length of the string need to be calculated and truncated.\n//        if (lengthStream == null || maxCodePointCount >= 0) {\n//            return false;\n//        }\n//\n//        double inputFilterRate = (double) (totalPositionCount - positionCount) / totalPositionCount;\n//        if (filter == null) {  // readNoFilter\n//            // When there is no filter, batch mode performs better for almost all inputFilterRate.\n//            // But to limit data buffer size, we enable it for the range of [0.0f, 0.5f]\n//            if (inputFilterRate >= 0.0f && inputFilterRate <= 0.5f) {\n//                return true;\n//            }\n//\n//            return false;\n//        }\n//        else { // readWithFilter\n//            // When there is filter, batch mode performs better for almost all inputFilterRate except when inputFilterRate is around 0.1f.\n//            // To limit data buffer size, we enable it for the range of [0.0f, 0.05f] and [0.15f, 0.5f]\n//            if (inputFilterRate >= 0.0f && inputFilterRate <= 0.05f || inputFilterRate >= 0.15f && inputFilterRate <= 0.5f) {\n//                return true;\n//            }\n//\n//            return false;\n//        }\n    }",
    "replace": "    private boolean useBatchMode(int positionCount, int totalPositionCount)\n    {\n        // maxCodePointCount < 0 means it's unbounded varchar VARCHAR.\n        // If the types are VARCHAR(N) or CHAR(N), the length of the string need to be calculated and truncated.\n        if (lengthStream == null || maxCodePointCount >= 0) {\n            return false;\n        }\n\n        double inputFilterRate = (double) (totalPositionCount - positionCount) / totalPositionCount;\n        if (filter == null) {  // readNoFilter\n            // When there is no filter, batch mode performs better for almost all inputFilterRate.\n            // But to limit data buffer size, we enable it for the range of [0.0f, 0.5f]\n            if (inputFilterRate >= 0.0f && inputFilterRate <= 0.5f) {\n                return true;\n            }\n\n            return false;\n        }\n        else { // readWithFilter\n            // When there is filter, batch mode performs better for almost all inputFilterRate except when inputFilterRate is around 0.1f.\n            // To limit data buffer size, we enable it for the range of [0.0f, 0.05f] and [0.15f, 0.5f]\n            if (inputFilterRate >= 0.0f && inputFilterRate <= 0.05f || inputFilterRate >= 0.15f && inputFilterRate <= 0.5f) {\n                return true;\n            }\n\n            return false;\n        }\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java",
    "search": "            if (presentStream == null) {\n                filteredPositionCount = evaluateFilter(positions, positionCount);\n\n                if (outputRequired && totalPositionCount > filteredPositionCount && filteredPositionCount > 0 && dataStream != null) {\n                    packByteArrayAndOffsets(data, offsets, outputPositions, filteredPositionCount);\n                }\n            }\n            else {\n                filteredPositionCount = evaluateFilterWithNull(positions, positionCount);\n\n                if (outputRequired) {\n                    if (filteredPositionCount > 0) {\n                        if (outputRequired && totalPositionCount > filteredPositionCount) {\n                            packByteArrayOffsetsAndNulls(data, offsets, isNullVector, outputPositions, filteredPositionCount);\n                        }\n\n                        if (nullsAllowed) {\n                            System.arraycopy(isNullVector, 0, nulls, 0, filteredPositionCount);\n                        }\n                    }\n                }\n            }",
    "replace": "            if (presentStream == null) {\n                filteredPositionCount = evaluateFilter(positions, positionCount);\n\n                if (outputRequired && totalPositionCount > filteredPositionCount && filteredPositionCount > 0 && dataStream != null) {\n                    packByteArrayAndOffsets(data, offsets, outputPositions, filteredPositionCount);\n                }\n            }\n            else {\n                filteredPositionCount = evaluateFilterWithNull(positions, positionCount);\n\n                if (outputRequired && filteredPositionCount > 0) {\n                    if (totalPositionCount > filteredPositionCount) {\n                        packByteArrayOffsetsAndNulls(data, offsets, isNullVector, outputPositions, filteredPositionCount);\n                    }\n\n                    if (nullsAllowed) {\n                        System.arraycopy(isNullVector, 0, nulls, 0, filteredPositionCount);\n                    }\n                }\n            }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java",
    "search": "        if (presentStream != null) {\n            isNullVector = ensureCapacity(isNullVector, totalPositions);\n            nullCount = presentStream.getUnsetBits(totalPositions, isNullVector);\n        }\n\n        if (lengthStream != null) {\n            int nonNullCount = totalPositions - nullCount;\n            lengthVector = ensureCapacity(lengthVector, nonNullCount);\n            lengthStream.nextIntVector(nonNullCount, lengthVector, 0);\n\n            if (useBatchMode(positionCount, totalPositions)) {\n                for (int i = 0; i < nonNullCount; i++) {\n                    totalLength += lengthVector[i];\n                    maxLength = Math.max(maxLength, lengthVector[i]);\n                }\n            }\n            else {\n                int positionIndex = 0;\n                int lengthIndex = 0;\n                for (int i = 0; i < totalPositions; i++) {\n                    boolean isNotNull = nullCount == 0 || !isNullVector[i];\n                    if (i == positions[positionIndex]) {\n                        if (isNotNull) {\n                            totalLength += lengthVector[lengthIndex];\n                            maxLength = Math.max(maxLength, lengthVector[lengthIndex]);\n                            lengthIndex++;\n                        }\n                        positionIndex++;\n                    }\n                    else if (isNotNull) {\n                        lengthIndex++;\n                    }\n                }\n            }",
    "replace": "        if (presentStream != null) {\n            isNullVector = ensureCapacity(isNullVector, totalPositions);\n            nullCount = presentStream.getUnsetBits(totalPositions, isNullVector);\n        }\n\n        if (lengthStream != null) {\n            int nonNullCount = totalPositions - nullCount;\n            lengthVector = ensureCapacity(lengthVector, nonNullCount);\n            lengthStream.nextIntVector(nonNullCount, lengthVector, 0);\n\n            boolean useBatch = useBatchMode(positionCount, totalPositions);\n            if (useBatch) {\n                for (int i = 0; i < nonNullCount; i++) {\n                    int length = lengthVector[i];\n                    totalLength += length;\n                    if (length > maxLength) {\n                        maxLength = length;\n                    }\n                }\n            }\n            else {\n                int positionIndex = 0;\n                int lengthIndex = 0;\n                for (int i = 0; i < totalPositions; i++) {\n                    boolean isNotNull = nullCount == 0 || !isNullVector[i];\n                    if (i == positions[positionIndex]) {\n                        if (isNotNull) {\n                            int length = lengthVector[lengthIndex];\n                            totalLength += length;\n                            if (length > maxLength) {\n                                maxLength = length;\n                            }\n                            lengthIndex++;\n                        }\n                        positionIndex++;\n                    }\n                    else if (isNotNull) {\n                        lengthIndex++;\n                    }\n                }\n            }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java",
    "search": "            if (presentStream == null) {\n                if (dataStream != null) {\n                    dataStream.next(data, 0, dataLength);\n                    convertLengthVectorToOffsetVector(lengthVector, totalPositionCount, offsets);\n\n                    if (totalPositionCount > positionCount) {\n                        packByteArrayAndOffsets(data, offsets, positions, positionCount);\n                    }\n                }\n            }\n            else {\n                if (dataStream != null) {\n                    dataStream.next(data, 0, dataLength);\n                    convertLengthVectorToOffsetVector(lengthVector, isNullVector, totalPositionCount, offsets);\n                }\n\n                if (totalPositionCount > positionCount) {\n                    packByteArrayOffsetsAndNulls(data, offsets, isNullVector, positions, positionCount);\n                }\n\n                if (nullsAllowed) {\n                    System.arraycopy(isNullVector, 0, nulls, 0, positionCount);\n                }\n            }",
    "replace": "            if (presentStream == null) {\n                if (dataStream != null) {\n                    dataStream.next(data, 0, dataLength);\n                    convertLengthVectorToOffsetVector(lengthVector, totalPositionCount, offsets);\n\n                    if (totalPositionCount > positionCount) {\n                        packByteArrayAndOffsets(data, offsets, positions, positionCount);\n                    }\n                }\n            }\n            else {\n                if (dataStream != null) {\n                    dataStream.next(data, 0, dataLength);\n                    convertLengthVectorToOffsetVector(lengthVector, isNullVector, totalPositionCount, offsets);\n                }\n\n                if (totalPositionCount > positionCount) {\n                    packByteArrayOffsetsAndNulls(data, offsets, isNullVector, positions, positionCount);\n                }\n                else if (nullsAllowed) {\n                    // If we're processing all positions, we can use the isNullVector directly\n                    nulls = isNullVector;\n                }\n\n                if (nullsAllowed && totalPositionCount > positionCount) {\n                    System.arraycopy(isNullVector, 0, nulls, 0, positionCount);\n                }\n            }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java",
    "search": "        int streamPosition = 0;\n        int dataToSkip = 0;\n\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skipData(streamPosition, position - streamPosition);\n                streamPosition = position;\n            }\n\n            int offset = outputRequired ? offsets[outputPositionCount] : 0;\n            if (presentStream != null && isNullVector[position]) {\n                if ((nonDeterministicFilter && filter.testNull()) || nullsAllowed) {\n                    if (outputRequired) {\n                        offsets[outputPositionCount + 1] = offset;\n                        nulls[outputPositionCount] = true;\n                    }\n                    outputPositions[outputPositionCount] = position;\n                    outputPositionCount++;\n                }\n            }\n            else {\n                int length = lengthVector[lengthIndex];\n                int dataOffset = outputRequired ? offset : 0;\n                if (filter.testLength(length)) {\n                    if (dataStream != null) {\n                        dataStream.skip(dataToSkip);\n                        dataToSkip = 0;\n                        dataStream.next(data, dataOffset, dataOffset + length);\n                        if (filter.testBytes(data, dataOffset, length)) {\n                            if (outputRequired) {\n                                int truncatedLength = computeTruncatedLength(dataAsSlice, dataOffset, length, maxCodePointCount, isCharType);\n                                offsets[outputPositionCount + 1] = offset + truncatedLength;\n                                if (nullsAllowed && presentStream != null) {\n                                    nulls[outputPositionCount] = false;\n                                }\n                            }\n                            outputPositions[outputPositionCount] = position;\n                            outputPositionCount++;\n                        }\n                    }\n                    else {\n                        assert length == 0;\n                        if (filter.testBytes(\"\".getBytes(), 0, 0)) {\n                            if (outputRequired) {\n                                offsets[outputPositionCount + 1] = offset;\n                                if (nullsAllowed && presentStream != null) {\n                                    nulls[outputPositionCount] = false;\n                                }\n                            }\n                            outputPositions[outputPositionCount] = position;\n                            outputPositionCount++;\n                        }\n                    }\n                }\n                else {\n                    dataToSkip += length;\n                }\n                lengthIndex++;\n            }\n\n            streamPosition++;",
    "replace": "        int streamPosition = 0;\n        int dataToSkip = 0;\n\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skipData(streamPosition, position - streamPosition);\n                streamPosition = position;\n            }\n\n            int offset = outputRequired ? offsets[outputPositionCount] : 0;\n            boolean isNull = presentStream != null && isNullVector[position];\n            if (isNull) {\n                if ((nonDeterministicFilter && filter.testNull()) || nullsAllowed) {\n                    if (outputRequired) {\n                        offsets[outputPositionCount + 1] = offset;\n                        nulls[outputPositionCount] = true;\n                    }\n                    outputPositions[outputPositionCount] = position;\n                    outputPositionCount++;\n                }\n            }\n            else {\n                int length = lengthVector[lengthIndex];\n                if (filter.testLength(length)) {\n                    if (dataStream != null) {\n                        dataStream.skip(dataToSkip);\n                        dataToSkip = 0;\n                        int dataOffset = outputRequired ? offset : 0;\n                        dataStream.next(data, dataOffset, dataOffset + length);\n                        if (filter.testBytes(data, dataOffset, length)) {\n                            if (outputRequired) {\n                                int truncatedLength = computeTruncatedLength(dataAsSlice, dataOffset, length, maxCodePointCount, isCharType);\n                                offsets[outputPositionCount + 1] = offset + truncatedLength;\n                                if (nullsAllowed && presentStream != null) {\n                                    nulls[outputPositionCount] = false;\n                                }\n                            }\n                            outputPositions[outputPositionCount] = position;\n                            outputPositionCount++;\n                        }\n                    }\n                    else {\n                        assert length == 0;\n                        if (filter.testBytes(\"\".getBytes(), 0, 0)) {\n                            if (outputRequired) {\n                                offsets[outputPositionCount + 1] = offset;\n                                if (nullsAllowed && presentStream != null) {\n                                    nulls[outputPositionCount] = false;\n                                }\n                            }\n                            outputPositions[outputPositionCount] = position;\n                            outputPositionCount++;\n                        }\n                    }\n                }\n                else {\n                    dataToSkip += length;\n                }\n                lengthIndex++;\n            }\n\n            streamPosition++;"
  }
]
```