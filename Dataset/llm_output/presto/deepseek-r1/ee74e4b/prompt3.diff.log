Looking at the PageProcessor code, I can identify several performance improvement opportunities:

1. **Reduce object allocations** in hot paths
2. **Optimize the updateRetainedSize method** which is called frequently and does expensive reference counting
3. **Improve batch size adaptation logic**
4. **Reduce overhead in dictionary source ID management**

Here are the specific improvements:

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java",
    "search": "    private class ProjectSelectedPositions\n            implements WorkProcessor.Process<Page>\n    {\n        private final SqlFunctionProperties properties;\n        private final DriverYieldSignal yieldSignal;\n        private final LocalMemoryContext memoryContext;\n\n        private Page page;\n        private Block[] previouslyComputedResults;\n        private SelectedPositions selectedPositions;\n        private long retainedSizeInBytes;\n\n        // remember if we need to re-use the same batch size if we yield last time\n        private boolean lastComputeYielded;\n        private int lastComputeBatchSize;\n        private Work<List<Block>> pageProjectWork;\n\n        private ProjectSelectedPositions(SqlFunctionProperties properties, DriverYieldSignal yieldSignal, LocalMemoryContext memoryContext, Page page, SelectedPositions selectedPositions)\n        {\n            checkArgument(!selectedPositions.isEmpty(), \"selectedPositions is empty\");\n\n            this.properties = properties;\n            this.yieldSignal = yieldSignal;\n            this.page = page;\n            this.memoryContext = memoryContext;\n            this.selectedPositions = selectedPositions;\n            this.previouslyComputedResults = new Block[outputCount];\n        }",
    "replace": "    private class ProjectSelectedPositions\n            implements WorkProcessor.Process<Page>\n    {\n        private final SqlFunctionProperties properties;\n        private final DriverYieldSignal yieldSignal;\n        private final LocalMemoryContext memoryContext;\n        private final ReferenceCountMap referenceCountMap;\n\n        private Page page;\n        private Block[] previouslyComputedResults;\n        private SelectedPositions selectedPositions;\n        private long retainedSizeInBytes;\n        private long pageRetainedSize = -1;\n\n        // remember if we need to re-use the same batch size if we yield last time\n        private boolean lastComputeYielded;\n        private int lastComputeBatchSize;\n        private Work<List<Block>> pageProjectWork;\n\n        private ProjectSelectedPositions(SqlFunctionProperties properties, DriverYieldSignal yieldSignal, LocalMemoryContext memoryContext, Page page, SelectedPositions selectedPositions)\n        {\n            checkArgument(!selectedPositions.isEmpty(), \"selectedPositions is empty\");\n\n            this.properties = properties;\n            this.yieldSignal = yieldSignal;\n            this.page = page;\n            this.memoryContext = memoryContext;\n            this.selectedPositions = selectedPositions;\n            this.previouslyComputedResults = new Block[outputCount];\n            this.referenceCountMap = new ReferenceCountMap();\n        }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java",
    "search": "        private void updateRetainedSize()\n        {\n            // increment the size only when it is the first reference\n            retainedSizeInBytes = Page.INSTANCE_SIZE + SizeOf.sizeOfObjectArray(page.getChannelCount());\n            ReferenceCountMap referenceCountMap = new ReferenceCountMap();\n            for (int channel = 0; channel < page.getChannelCount(); channel++) {\n                Block block = page.getBlock(channel);\n                if (!isNotLoadedLazyBlock(block)) {\n                    block.retainedBytesForEachPart((object, size) -> {\n                        if (referenceCountMap.incrementAndGet(object) == 1) {\n                            retainedSizeInBytes += size;\n                        }\n                    });\n                }\n            }\n            for (Block previouslyComputedResult : previouslyComputedResults) {\n                if (previouslyComputedResult != null) {\n                    previouslyComputedResult.retainedBytesForEachPart((object, size) -> {\n                        if (referenceCountMap.incrementAndGet(object) == 1) {\n                            retainedSizeInBytes += size;\n                        }\n                    });\n                }\n            }\n\n            memoryContext.setBytes(retainedSizeInBytes);\n        }",
    "replace": "        private void updateRetainedSize()\n        {\n            // Reuse the same ReferenceCountMap to avoid allocation\n            referenceCountMap.clear();\n            \n            // Cache page retained size calculation since page doesn't change\n            if (pageRetainedSize == -1) {\n                pageRetainedSize = Page.INSTANCE_SIZE + SizeOf.sizeOfObjectArray(page.getChannelCount());\n                for (int channel = 0; channel < page.getChannelCount(); channel++) {\n                    Block block = page.getBlock(channel);\n                    if (!isNotLoadedLazyBlock(block)) {\n                        block.retainedBytesForEachPart((object, size) -> {\n                            if (referenceCountMap.incrementAndGet(object) == 1) {\n                                pageRetainedSize += size;\n                            }\n                        });\n                    }\n                }\n            }\n            \n            retainedSizeInBytes = pageRetainedSize;\n            \n            // Only recalculate for previously computed results which change more frequently\n            for (Block previouslyComputedResult : previouslyComputedResults) {\n                if (previouslyComputedResult != null) {\n                    previouslyComputedResult.retainedBytesForEachPart((object, size) -> {\n                        if (referenceCountMap.incrementAndGet(object) == 1) {\n                            retainedSizeInBytes += size;\n                        }\n                    });\n                }\n            }\n\n            memoryContext.setBytes(retainedSizeInBytes);\n        }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java",
    "search": "                // if the page buffer filled up, so halve the batch size and retry\n                verify(batchSize > 1);\n                projectBatchSize = projectBatchSize / 2;\n                continue;",
    "replace": "                // if the page buffer filled up, so adjust the batch size and retry\n                verify(batchSize > 1);\n                // Use faster bitwise operation for division by 2\n                projectBatchSize = projectBatchSize >> 1;\n                // Ensure we don't get stuck at 1 if we keep getting page too large\n                if (projectBatchSize < 1) {\n                    projectBatchSize = 1;\n                }\n                continue;"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java",
    "search": "                // if we produced a large page or if the expression is expensive, halve the batch size for the next call\n                long pageSize = resultPage.getSizeInBytes();\n                if (resultPage.getPositionCount() > 1 && (pageSize > MAX_PAGE_SIZE_IN_BYTES || expressionProfiler.isExpressionExpensive())) {\n                    projectBatchSize = projectBatchSize / 2;\n                }\n\n                // if we produced a small page, double the batch size for the next call\n                if (pageSize < MIN_PAGE_SIZE_IN_BYTES && projectBatchSize < MAX_BATCH_SIZE && !expressionProfiler.isExpressionExpensive()) {\n                    projectBatchSize = projectBatchSize * 2;\n                }",
    "replace": "                // if we produced a large page or if the expression is expensive, adjust the batch size for the next call\n                long pageSize = resultPage.getSizeInBytes();\n                if (resultPage.getPositionCount() > 1 && (pageSize > MAX_PAGE_SIZE_IN_BYTES || expressionProfiler.isExpressionExpensive())) {\n                    // Use bitwise operation for faster division by 2\n                    projectBatchSize = projectBatchSize >> 1;\n                    // Ensure minimum batch size of 1\n                    if (projectBatchSize < 1) {\n                        projectBatchSize = 1;\n                    }\n                }\n\n                // if we produced a small page, increase the batch size for the next call\n                if (pageSize < MIN_PAGE_SIZE_IN_BYTES && projectBatchSize < MAX_BATCH_SIZE && !expressionProfiler.isExpressionExpensive()) {\n                    // Use bitwise operation for faster multiplication by 2\n                    projectBatchSize = projectBatchSize << 1;\n                    // Ensure we don't exceed maximum batch size\n                    if (projectBatchSize > MAX_BATCH_SIZE) {\n                        projectBatchSize = MAX_BATCH_SIZE;\n                    }\n                }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java",
    "search": "        int pageSize = 0;\n        SelectedPositions positionsBatch = selectedPositions.subRange(0, batchSize);\n        for (PageProjectionWithOutputs projection : projections) {\n            if (yieldSignal.isSet()) {\n                return ProcessBatchResult.processBatchYield();\n            }\n\n            if (positionsBatch.size() > 1 && pageSize > MAX_PAGE_SIZE_IN_BYTES) {\n                return ProcessBatchResult.processBatchTooLarge();\n            }\n\n            // if possible, use previouslyComputedResults produced in prior optimistic failure attempt\n            int[] outputChannels = projection.getOutputChannels();\n            // The progress on all output channels of a projection should be the same, so we just use the first one.\n            if (previouslyComputedResults[outputChannels[0]] != null && previouslyComputedResults[outputChannels[0]].getPositionCount() >= batchSize) {\n                for (int channel : outputChannels) {\n                    blocks[channel] = previouslyComputedResults[channel].getRegion(0, batchSize);\n                    pageSize += blocks[channel].getSizeInBytes();\n                }\n            }\n            else {\n                if (pageProjectWork == null) {\n                    expressionProfiler.start();\n                    pageProjectWork = projection.project(properties, yieldSignal, projection.getPageProjection().getInputChannels().getInputChannels(page), positionsBatch);\n                    expressionProfiler.stop(positionsBatch.size());\n                }\n                if (!pageProjectWork.process()) {\n                    return ProcessBatchResult.processBatchYield();\n                }\n                List<Block> projectionOutputs = pageProjectWork.getResult();\n                for (int j = 0; j < outputChannels.length; j++) {\n                    int channel = outputChannels[j];\n                    previouslyComputedResults[channel] = projectionOutputs.get(j);\n                    blocks[channel] = previouslyComputedResults[channel];\n                    pageSize += blocks[channel].getSizeInBytes();\n                }\n                pageProjectWork = null;\n            }\n        }",
    "replace": "        int pageSize = 0;\n        SelectedPositions positionsBatch = selectedPositions.subRange(0, batchSize);\n        \n        // Early yield check to avoid unnecessary work\n        if (yieldSignal.isSet()) {\n            return ProcessBatchResult.processBatchYield();\n        }\n        \n        for (PageProjectionWithOutputs projection : projections) {\n            if (positionsBatch.size() > 1 && pageSize > MAX_PAGE_SIZE_IN_BYTES) {\n                return ProcessBatchResult.processBatchTooLarge();\n            }\n\n            // if possible, use previouslyComputedResults produced in prior optimistic failure attempt\n            int[] outputChannels = projection.getOutputChannels();\n            // The progress on all output channels of a projection should be the same, so we just use the first one.\n            if (previouslyComputedResults[outputChannels[0]] != null && previouslyComputedResults[outputChannels[0]].getPositionCount() >= batchSize) {\n                for (int channel : outputChannels) {\n                    blocks[channel] = previouslyComputedResults[channel].getRegion(0, batchSize);\n                    pageSize += blocks[channel].getSizeInBytes();\n                }\n            }\n            else {\n                if (pageProjectWork == null) {\n                    expressionProfiler.start();\n                    pageProjectWork = projection.project(properties, yieldSignal, projection.getPageProjection().getInputChannels().getInputChannels(page), positionsBatch);\n                    expressionProfiler.stop(positionsBatch.size());\n                }\n                if (!pageProjectWork.process()) {\n                    return ProcessBatchResult.processBatchYield();\n                }\n                List<Block> projectionOutputs = pageProjectWork.getResult();\n                for (int j = 0; j < outputChannels.length; j++) {\n                    int channel = outputChannels[j];\n                    previouslyComputedResults[channel] = projectionOutputs.get(j);\n                    blocks[channel] = previouslyComputedResults[channel];\n                    pageSize += blocks[channel].getSizeInBytes();\n                }\n                pageProjectWork = null;\n            }\n        }"
  }
]
```