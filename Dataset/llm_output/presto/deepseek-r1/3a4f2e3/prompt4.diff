diff --git a/presto-orc/src/main/java/com/facebook/presto/orc/reader/BooleanSelectiveStreamReader.java b/presto-orc/src/main/java/com/facebook/presto/orc/reader/BooleanSelectiveStreamReader.java
index aab2765889..318a24843b 100644
--- a/presto-orc/src/main/java/com/facebook/presto/orc/reader/BooleanSelectiveStreamReader.java
+++ b/presto-orc/src/main/java/com/facebook/presto/orc/reader/BooleanSelectiveStreamReader.java
@@ -273,24 +273,65 @@ public class BooleanSelectiveStreamReader
     {
         // filter == null implies outputRequired == true
         int streamPosition = 0;
-        for (int i = 0; i < positionCount; i++) {
-            int position = positions[i];
-            if (position > streamPosition) {
-                skip(position - streamPosition);
-                streamPosition = position;
+        
+        // Check if positions are contiguous to enable bulk reading
+        boolean isContiguous = isContiguous(positions, positionCount);
+        
+        if (isContiguous && presentStream == null) {
+            // Fast path: contiguous positions with no nulls
+            int startPosition = positions[0];
+            if (startPosition > streamPosition) {
+                skip(startPosition - streamPosition);
             }
-
-            if (presentStream != null && !presentStream.nextBit()) {
-                nulls[i] = true;
-            }
-            else {
+            streamPosition = startPosition;
+            
+            // Bulk read bits for the entire contiguous range
+            for (int i = 0; i < positionCount; i++) {
                 values[i] = (byte) (dataStream.nextBit() ? 1 : 0);
-                if (presentStream != null) {
+                streamPosition++;
+            }
+        }
+        else if (isContiguous && presentStream != null) {
+            // Contiguous positions with potential nulls
+            int startPosition = positions[0];
+            if (startPosition > streamPosition) {
+                skip(startPosition - streamPosition);
+            }
+            streamPosition = startPosition;
+            
+            for (int i = 0; i < positionCount; i++) {
+                if (!presentStream.nextBit()) {
+                    nulls[i] = true;
+                }
+                else {
+                    values[i] = (byte) (dataStream.nextBit() ? 1 : 0);
                     nulls[i] = false;
                 }
+                streamPosition++;
+            }
+        }
+        else {
+            // Non-contiguous positions, use original algorithm
+            for (int i = 0; i < positionCount; i++) {
+                int position = positions[i];
+                if (position > streamPosition) {
+                    skip(position - streamPosition);
+                    streamPosition = position;
+                }
+
+                if (presentStream != null && !presentStream.nextBit()) {
+                    nulls[i] = true;
+                }
+                else {
+                    values[i] = (byte) (dataStream.nextBit() ? 1 : 0);
+                    if (presentStream != null) {
+                        nulls[i] = false;
+                    }
+                }
+                streamPosition++;
             }
-            streamPosition++;
         }
+        
         outputPositionCount = positionCount;
         return streamPosition;
     }
@@ -309,6 +350,21 @@ public class BooleanSelectiveStreamReader
             dataStream.skip(items);
         }
     }
+    
+    private boolean isContiguous(int[] positions, int positionCount)
+    {
+        if (positionCount <= 1) {
+            return true;
+        }
+        
+        // Check if positions form a contiguous sequence
+        for (int i = 1; i < positionCount; i++) {
+            if (positions[i] != positions[i - 1] + 1) {
+                return false;
+            }
+        }
+        return true;
+    }
 
     private void ensureValuesCapacity(int capacity, boolean recordNulls)
     {
