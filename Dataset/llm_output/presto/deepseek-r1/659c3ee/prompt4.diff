diff --git a/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java b/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java
index 93aeb97e76..644a4b10ae 100644
--- a/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java
+++ b/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java
@@ -264,6 +264,51 @@ public class ByteSelectiveStreamReader
             return positionCount;
         }
 
+        // Check if positions are contiguous (even with nulls)
+        boolean positionsContiguous = positions[positionCount - 1] == positionCount - 1;
+        
+        if (positionsContiguous) {
+            // Positions are contiguous 0..positionCount-1
+            if (presentStream == null) {
+                // Already handled above, but kept for clarity
+                dataStream.next(values, positionCount);
+                outputPositionCount = positionCount;
+                return positionCount;
+            } else {
+                // We have nulls but positions are contiguous
+                // Read present stream bits in bulk and count non-nulls
+                int nonNullCount = 0;
+                for (int i = 0; i < positionCount; i++) {
+                    boolean isNull = !presentStream.nextBit();
+                    if (isNull) {
+                        nulls[i] = true;
+                    } else {
+                        nulls[i] = false;
+                        nonNullCount++;
+                    }
+                }
+                
+                // Bulk read non-null values if there are any
+                if (nonNullCount > 0) {
+                    // Read all non-null values in bulk
+                    byte[] tempValues = new byte[nonNullCount];
+                    dataStream.next(tempValues, nonNullCount);
+                    
+                    // Distribute values to the right positions
+                    int tempIndex = 0;
+                    for (int i = 0; i < positionCount; i++) {
+                        if (!nulls[i]) {
+                            values[i] = tempValues[tempIndex++];
+                        }
+                    }
+                }
+                
+                outputPositionCount = positionCount;
+                return positionCount;
+            }
+        }
+
+        // Non-contiguous positions
         int streamPosition = 0;
         for (int i = 0; i < positionCount; i++) {
             int position = positions[i];
@@ -294,6 +339,7 @@ public class ByteSelectiveStreamReader
             presentStream.skip(items);
         }
         else if (presentStream != null) {
+            // Optimize skipping by using countBitsSet
             int dataToSkip = presentStream.countBitsSet(items);
             dataStream.skip(dataToSkip);
         }
