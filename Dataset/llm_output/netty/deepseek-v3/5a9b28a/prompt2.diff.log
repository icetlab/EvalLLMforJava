The performance issue indicates that calling `ArrayDeque::pollFirst` is inefficient. To address this, we'll replace the `ArrayDeque` used in `LocalPool.batch` with a custom circular buffer implementation. This eliminates the overhead of `ArrayDeque`'s method calls and internal checks, providing faster `pollFirst` and `addLast` operations. Since `batch` is only accessed by the owner thread, we can safely implement a simple array-based FIFO queue with manual index management.

Here are the atomic changes to implement this optimization:

```json
[
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "    private static final class LocalPool<T> implements MessagePassingQueue.Consumer<DefaultHandle<T>> {\n        private final int ratioInterval;\n        private final int chunkSize;\n        private final ArrayDeque<DefaultHandle<T>> batch;",
    "replace": "    private static final class LocalPool<T> implements MessagePassingQueue.Consumer<DefaultHandle<T>> {\n        private final int ratioInterval;\n        private final int chunkSize;\n        private final DefaultHandle<T>[] batchArray;\n        private int batchHead;\n        private int batchTail;\n        private int batchSize;"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "            this.ratioInterval = ratioInterval;\n            this.chunkSize = chunkSize;\n            batch = new ArrayDeque<DefaultHandle<T>>(chunkSize);",
    "replace": "            this.ratioInterval = ratioInterval;\n            this.chunkSize = chunkSize;\n            batchArray = (DefaultHandle<T>[]) new DefaultHandle[chunkSize];\n            batchHead = 0;\n            batchTail = 0;\n            batchSize = 0;"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "        DefaultHandle<T> claim() {\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            if (handles == null) {\n                return null;\n            }\n            if (batch.isEmpty()) {\n                handles.drain(this, chunkSize);\n            }\n            DefaultHandle<T> handle = batch.pollFirst();\n            if (null != handle) {\n                handle.toClaimed();\n            }\n            return handle;\n        }",
    "replace": "        DefaultHandle<T> claim() {\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            if (handles == null) {\n                return null;\n            }\n            if (batchSize == 0) {\n                handles.drain(this, chunkSize);\n            }\n            DefaultHandle<T> handle = pollFirstBatch();\n            if (null != handle) {\n                handle.toClaimed();\n            }\n            return handle;\n        }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "            if (owner != null && Thread.currentThread() == owner && batch.size() < chunkSize) {\n                accept(handle);",
    "replace": "            if (owner != null && Thread.currentThread() == owner && batchSize < chunkSize) {\n                accept(handle);"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "        @Override\n        public void accept(DefaultHandle<T> e) {\n            batch.addLast(e);\n        }",
    "replace": "        @Override\n        public void accept(DefaultHandle<T> e) {\n            if (batchSize < chunkSize) {\n                batchArray[batchTail] = e;\n                batchTail = (batchTail + 1) % chunkSize;\n                batchSize++;\n            }\n        }\n\n        private DefaultHandle<T> pollFirstBatch() {\n            if (batchSize == 0) {\n                return null;\n            }\n            DefaultHandle<T> handle = batchArray[batchHead];\n            batchArray[batchHead] = null;\n            batchHead = (batchHead + 1) % chunkSize;\n            batchSize--;\n            return handle;\n        }\n\n        int batchSize() {\n            return batchSize;\n        }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "    @VisibleForTesting\n    final int threadLocalSize() {\n        LocalPool<T> localPool = threadLocal.getIfExists();\n        return localPool == null ? 0 : localPool.pooledHandles.size() + localPool.batch.size();\n    }",
    "replace": "    @VisibleForTesting\n    final int threadLocalSize() {\n        LocalPool<T> localPool = threadLocal.getIfExists();\n        return localPool == null ? 0 : localPool.pooledHandles.size() + localPool.batchSize();\n    }"
  }
]
```