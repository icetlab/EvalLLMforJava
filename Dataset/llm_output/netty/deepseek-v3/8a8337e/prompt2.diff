diff --git a/common/src/main/java/io/netty/util/Recycler.java b/common/src/main/java/io/netty/util/Recycler.java
index dd7b2d73be..7d4aa6b5d7 100644
--- a/common/src/main/java/io/netty/util/Recycler.java
+++ b/common/src/main/java/io/netty/util/Recycler.java
@@ -104,7 +104,11 @@ public abstract class Recycler<T> {
             super.onRemoval(value);
             MessagePassingQueue<DefaultHandle<T>> handles = value.pooledHandles;
             value.pooledHandles = null;
-            handles.clear();
+            if (handles != null) {
+                handles.clear();
+            }
+            // Clear fast-path stack to avoid memory leak.
+            value.fastPathStack = null;
         }
     };
 
@@ -259,10 +263,16 @@ public abstract class Recycler<T> {
         private final int ratioInterval;
         private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;
         private int ratioCounter;
+        private final Thread ownerThread;
+        private DefaultHandle<T>[] fastPathStack;
+        private int fastPathIndex;
 
         @SuppressWarnings("unchecked")
         LocalPool(int maxCapacity, int ratioInterval, int chunkSize) {
             this.ratioInterval = ratioInterval;
+            this.ownerThread = Thread.currentThread();
+            this.fastPathStack = new DefaultHandle[chunkSize];
+            this.fastPathIndex = 0;
             if (BLOCKING_POOL) {
                 pooledHandles = new BlockingMessageQueue<DefaultHandle<T>>(maxCapacity);
             } else {
@@ -272,6 +282,12 @@ public abstract class Recycler<T> {
         }
 
         DefaultHandle<T> claim() {
+            // First try the fast-path stack if we are the owner thread.
+            if (Thread.currentThread() == ownerThread && fastPathIndex > 0) {
+                DefaultHandle<T> handle = fastPathStack[--fastPathIndex];
+                handle.toClaimed();
+                return handle;
+            }
             MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
             if (handles == null) {
                 return null;
@@ -285,6 +301,27 @@ public abstract class Recycler<T> {
 
         void release(DefaultHandle<T> handle) {
             handle.toAvailable();
+            if (Thread.currentThread() == ownerThread) {
+                // Fast-path: release on the same thread.
+                if (fastPathIndex < fastPathStack.length) {
+                    fastPathStack[fastPathIndex++] = handle;
+                    return;
+                } else {
+                    // Fast-path stack is full, move half to the MPSC queue.
+                    int half = fastPathStack.length >> 1;
+                    MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
+                    if (handles != null) {
+                        for (int i = 0; i < half; i++) {
+                            handles.relaxedOffer(fastPathStack[i]);
+                        }
+                        System.arraycopy(fastPathStack, half, fastPathStack, 0, fastPathIndex - half);
+                        fastPathIndex -= half;
+                        fastPathStack[fastPathIndex++] = handle;
+                        return;
+                    }
+                }
+            }
+            // Slow-path: release from a different thread.
             MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
             if (handles != null) {
                 handles.relaxedOffer(handle);
