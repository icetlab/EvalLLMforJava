diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
index 8c9ad17821..bd168a6c67 100644
--- a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
@@ -264,7 +264,10 @@ class EpollEventLoop extends SingleThreadEventLoop {
             long totalDelay = delayNanos(System.nanoTime());
             prevDeadlineNanos = curDeadlineNanos;
             delaySeconds = (int) min(totalDelay / 1000000000L, Integer.MAX_VALUE);
-            delayNanos = (int) min(totalDelay - delaySeconds * 1000000000L, MAX_SCHEDULED_TIMERFD_NS);
+            delayNanos = (int) (totalDelay - delaySeconds * 1000000000L);
+            if (delayNanos > MAX_SCHEDULED_TIMERFD_NS) {
+                delayNanos = (int) MAX_SCHEDULED_TIMERFD_NS;
+            }
         }
         return Native.epollWait(epollFd, events, timerFd, delaySeconds, delayNanos);
     }
@@ -348,7 +351,11 @@ class EpollEventLoop extends SingleThreadEventLoop {
                     } finally {
                         // Ensure we always run tasks.
                         final long ioTime = System.nanoTime() - ioStartTime;
-                        runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
+                        if (ioTime == 0) {
+                            runAllTasks(0);
+                        } else {
+                            runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
+                        }
                     }
                 }
                 if (allowGrowing && strategy == events.length()) {
@@ -396,10 +403,17 @@ class EpollEventLoop extends SingleThreadEventLoop {
 
         // Using the intermediate collection to prevent ConcurrentModificationException.
         // In the `close()` method, the channel is deleted from `channels` map.
-        AbstractEpollChannel[] localChannels = channels.values().toArray(new AbstractEpollChannel[0]);
+        // Pre-size the array to avoid resizing
+        AbstractEpollChannel[] localChannels = new AbstractEpollChannel[channels.size()];
+        int i = 0;
+        for (AbstractEpollChannel ch : channels.values()) {
+            localChannels[i++] = ch;
+        }
 
         for (AbstractEpollChannel ch: localChannels) {
-            ch.unsafe().close(ch.unsafe().voidPromise());
+            if (ch != null) {
+                ch.unsafe().close(ch.unsafe().voidPromise());
+            }
         }
     }
 
@@ -452,13 +466,16 @@ class EpollEventLoop extends SingleThreadEventLoop {
                     }
                 } else {
                     // We received an event for an fd which we not use anymore. Remove it from the epoll_event set.
-                    try {
-                        Native.epollCtlDel(epollFd.intValue(), fd);
-                    } catch (IOException ignore) {
-                        // This can happen but is nothing we need to worry about as we only try to delete
-                        // the fd from the epoll set as we not found it in our mappings. So this call to
-                        // epollCtlDel(...) is just to ensure we cleanup stuff and so may fail if it was
-                        // deleted before or the file descriptor was closed before.
+                    // Only attempt removal if the fd is still registered (not already removed by channel closure)
+                    if (channels.get(fd) == null) {
+                        try {
+                            Native.epollCtlDel(epollFd.intValue(), fd);
+                        } catch (IOException ignore) {
+                            // This can happen but is nothing we need to worry about as we only try to delete
+                            // the fd from the epoll set as we not found it in our mappings. So this call to
+                            // epollCtlDel(...) is just to ensure we cleanup stuff and so may fail if it was
+                            // deleted before or the file descriptor was closed before.
+                        }
                     }
                 }
             }
