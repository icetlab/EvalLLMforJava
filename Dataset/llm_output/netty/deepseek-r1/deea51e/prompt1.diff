diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java
index 301a2c51cf..b675fe5e52 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java
@@ -130,8 +130,8 @@ final class HpackEncoder {
         for (Map.Entry<CharSequence, CharSequence> header : headers) {
             CharSequence name = header.getKey();
             CharSequence value = header.getValue();
-            encodeHeader(out, name, value, sensitivityDetector.isSensitive(name, value),
-                         HpackHeaderField.sizeOf(name, value));
+            boolean sensitive = sensitivityDetector.isSensitive(name, value);
+            encodeHeader(out, name, value, sensitive, HpackHeaderField.sizeOf(name, value));
         }
     }
 
@@ -250,16 +250,17 @@ final class HpackEncoder {
      * Encode string literal according to Section 5.2.
      */
     private void encodeStringLiteral(ByteBuf out, CharSequence string) {
+        int length = string.length();
         int huffmanLength = hpackHuffmanEncoder.getEncodedLength(string);
-        if (huffmanLength < string.length()) {
+        if (huffmanLength < length) {
             encodeInteger(out, 0x80, 7, huffmanLength);
             hpackHuffmanEncoder.encode(out, string);
         } else {
-            encodeInteger(out, 0x00, 7, string.length());
+            encodeInteger(out, 0x00, 7, length);
             if (string instanceof AsciiString) {
                 // Fast-path
                 AsciiString asciiString = (AsciiString) string;
-                out.writeBytes(asciiString.array(), asciiString.arrayOffset(), asciiString.length());
+                out.writeBytes(asciiString.array(), asciiString.arrayOffset(), length);
             } else {
                 // Only ASCII is allowed in http2 headers, so its fine to use this.
                 // https://tools.ietf.org/html/rfc7540#section-8.1.2
@@ -354,9 +355,12 @@ final class HpackEncoder {
         int h = AsciiString.hashCode(name);
         int i = index(h);
         for (HeaderEntry e = headerFields[i]; e != null; e = e.next) {
-            // To avoid short circuit behavior a bitwise operator is used instead of a boolean operator.
-            if (e.hash == h && (equalsConstantTime(name, e.name) & equalsConstantTime(value, e.value)) != 0) {
-                return e;
+            if (e.hash == h) {
+                // Compare names first since it's more likely to differ
+                boolean nameEquals = equalsConstantTime(name, e.name) != 0;
+                if (nameEquals && equalsConstantTime(value, e.value) != 0) {
+                    return e;
+                }
             }
         }
         return null;
