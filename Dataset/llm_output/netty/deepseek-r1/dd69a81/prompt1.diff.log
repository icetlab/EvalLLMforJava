Looking at the `HttpRequestEncoder` code, the main performance concern is in the `encodeInitialLine` method where URI normalization logic uses multiple string operations (`indexOf`, `lastIndexOf`, and potentially `StringBuilder`) for absolute URIs. This can be optimized by reducing string scanning operations and avoiding unnecessary `StringBuilder` allocations when possible.

The key improvements:
1. Minimize repeated scanning of the URI string by storing results
2. Avoid creating `StringBuilder` objects for URIs that don't need modification
3. Simplify logic flow to reduce branching

```json
[
  {
    "filepath": "../netty/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java",
    "search": "        String uri = request.uri();\n\n        if (uri.isEmpty()) {\n            uri += SLASH;\n        } else {\n            int start = uri.indexOf(\"://\");\n            if (start != -1 && uri.charAt(0) != SLASH) {\n                int startIndex = start + 3;\n                // Correctly handle query params.\n                // See https://github.com/netty/netty/issues/2732\n                int index = uri.indexOf(QUESTION_MARK, startIndex);\n                if (index == -1) {\n                    if (uri.lastIndexOf(SLASH) <= startIndex) {\n                        uri += SLASH;\n                    }\n                } else {\n                    if (uri.lastIndexOf(SLASH, index) <= startIndex) {\n                        int len = uri.length();\n                        StringBuilder sb = new StringBuilder(len + 1);\n                        sb.append(uri, 0, index)\n                          .append(SLASH)\n                          .append(uri, index, len);\n                        uri = sb.toString();\n                    }\n                }\n            }\n        }\n\n        buf.writeCharSequence(uri, CharsetUtil.UTF_8);",
    "replace": "        String uri = request.uri();\n\n        if (uri.isEmpty()) {\n            buf.writeByte(SLASH);\n            buf.writeByte(SP);\n            request.protocolVersion().encode(buf);\n            buf.writeBytes(CRLF);\n            return;\n        }\n        \n        int start = uri.indexOf(\"://\");\n        if (start == -1 || uri.charAt(0) == SLASH) {\n            // Relative URI or already starts with slash - write as-is\n            buf.writeCharSequence(uri, CharsetUtil.UTF_8);\n        } else {\n            int startIndex = start + 3;\n            int queryIndex = uri.indexOf(QUESTION_MARK, startIndex);\n            \n            // Find the last slash before query params (or end of string)\n            int lastSlashBeforeQuery = (queryIndex == -1) \n                ? uri.lastIndexOf(SLASH) \n                : uri.lastIndexOf(SLASH, queryIndex);\n                \n            if (lastSlashBeforeQuery <= startIndex) {\n                // Need to insert slash\n                if (queryIndex == -1) {\n                    // No query params - append slash at end\n                    buf.writeCharSequence(uri, CharsetUtil.UTF_8);\n                    buf.writeByte(SLASH);\n                } else {\n                    // Has query params - insert slash before query\n                    buf.writeCharSequence(uri, 0, queryIndex, CharsetUtil.UTF_8);\n                    buf.writeByte(SLASH);\n                    buf.writeCharSequence(uri, queryIndex, uri.length(), CharsetUtil.UTF_8);\n                }\n            } else {\n                // Already has slash in path - write as-is\n                buf.writeCharSequence(uri, CharsetUtil.UTF_8);\n            }\n        }"
  }
]
```