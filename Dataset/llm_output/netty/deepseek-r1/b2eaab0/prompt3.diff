diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent.java b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
index 0a70c36401..e2f4792f71 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
@@ -755,79 +755,54 @@ public final class PlatformDependent {
      */
     public static int hashCodeAscii(CharSequence bytes) {
         int hash = HASH_CODE_ASCII_SEED;
-        final int remainingBytes = bytes.length() & 7;
-        // Benchmarking shows that by just naively looping for inputs 8~31 bytes long we incur a relatively large
-        // performance penalty (only achieve about 60% performance of loop which iterates over each char). So because
-        // of this we take special provisions to unroll the looping for these conditions.
-        switch (bytes.length()) {
-            case 31:
-            case 30:
-            case 29:
-            case 28:
-            case 27:
-            case 26:
-            case 25:
-            case 24:
-                hash = hashCodeAsciiCompute(bytes, bytes.length() - 24,
-                        hashCodeAsciiCompute(bytes, bytes.length() - 16,
-                          hashCodeAsciiCompute(bytes, bytes.length() - 8, hash)));
-                break;
-            case 23:
-            case 22:
-            case 21:
-            case 20:
-            case 19:
-            case 18:
-            case 17:
-            case 16:
-                hash = hashCodeAsciiCompute(bytes, bytes.length() - 16,
-                         hashCodeAsciiCompute(bytes, bytes.length() - 8, hash));
-                break;
-            case 15:
-            case 14:
-            case 13:
-            case 12:
-            case 11:
-            case 10:
-            case 9:
-            case 8:
-                hash = hashCodeAsciiCompute(bytes, bytes.length() - 8, hash);
-                break;
-            case 7:
-            case 6:
-            case 5:
-            case 4:
-            case 3:
-            case 2:
-            case 1:
-            case 0:
-                break;
-            default:
-                for (int i = bytes.length() - 8; i >= remainingBytes; i -= 8) {
-                    hash = hashCodeAsciiCompute(bytes, i, hash);
-                }
-                break;
-        }
+        final int len = bytes.length();
+        final int remainingBytes = len & 7;
+        
+        // Process 24 bytes at a time for larger strings
+        if (len >= 24) {
+            int i = len - 24;
+            hash = hashCodeAsciiCompute(bytes, i + 16,
+                    hashCodeAsciiCompute(bytes, i + 8,
+                    hashCodeAsciiCompute(bytes, i, hash)));
+            i -= 24;
+            while (i >= remainingBytes) {
+                hash = hashCodeAsciiCompute(bytes, i + 16,
+                        hashCodeAsciiCompute(bytes, i + 8,
+                        hashCodeAsciiCompute(bytes, i, hash)));
+                i -= 24;
+            }
+        } else if (len >= 16) {
+            hash = hashCodeAsciiCompute(bytes, len - 16,
+                     hashCodeAsciiCompute(bytes, len - 8, hash));
+        } else if (len >= 8) {
+            hash = hashCodeAsciiCompute(bytes, len - 8, hash);
+        }
+        
+        // Handle remaining bytes
         switch(remainingBytes) {
             case 7:
-                return ((hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(0)))
-                              * HASH_CODE_C2 + hashCodeAsciiSanitizeShort(bytes, 1))
-                              * HASH_CODE_C1 + hashCodeAsciiSanitizeInt(bytes, 3);
+                return ((hash * HASH_CODE_C1 + (bytes.charAt(0) & 0x1f))
+                              * HASH_CODE_C2 + ((bytes.charAt(2) & 0x1f) << 8 | (bytes.charAt(1) & 0x1f)))
+                              * HASH_CODE_C1 + ((bytes.charAt(6) & 0x1f) << 24 | (bytes.charAt(5) & 0x1f) << 16 | 
+                                                (bytes.charAt(4) & 0x1f) << 8 | (bytes.charAt(3) & 0x1f));
             case 6:
-                return (hash * HASH_CODE_C1 + hashCodeAsciiSanitizeShort(bytes, 0))
-                             * HASH_CODE_C2 + hashCodeAsciiSanitizeInt(bytes, 2);
+                return (hash * HASH_CODE_C1 + ((bytes.charAt(1) & 0x1f) << 8 | (bytes.charAt(0) & 0x1f)))
+                             * HASH_CODE_C2 + ((bytes.charAt(5) & 0x1f) << 24 | (bytes.charAt(4) & 0x1f) << 16 | 
+                                               (bytes.charAt(3) & 0x1f) << 8 | (bytes.charAt(2) & 0x1f));
             case 5:
-                return (hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(0)))
-                             * HASH_CODE_C2 + hashCodeAsciiSanitizeInt(bytes, 1);
+                return (hash * HASH_CODE_C1 + (bytes.charAt(0) & 0x1f))
+                             * HASH_CODE_C2 + ((bytes.charAt(4) & 0x1f) << 24 | (bytes.charAt(3) & 0x1f) << 16 | 
+                                               (bytes.charAt(2) & 0x1f) << 8 | (bytes.charAt(1) & 0x1f));
             case 4:
-                return hash * HASH_CODE_C1 + hashCodeAsciiSanitizeInt(bytes, 0);
+                return hash * HASH_CODE_C1 + ((bytes.charAt(3) & 0x1f) << 24 | (bytes.charAt(2) & 0x1f) << 16 | 
+                                              (bytes.charAt(1) & 0x1f) << 8 | (bytes.charAt(0) & 0x1f));
             case 3:
-                return (hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(0)))
-                             * HASH_CODE_C2 + hashCodeAsciiSanitizeShort(bytes, 1);
+                return (hash * HASH_CODE_C1 + (bytes.charAt(0) & 0x1f))
+                             * HASH_CODE_C2 + ((bytes.charAt(2) & 0x1f) << 8 | (bytes.charAt(1) & 0x1f));
             case 2:
-                return hash * HASH_CODE_C1 + hashCodeAsciiSanitizeShort(bytes, 0);
+                return hash * HASH_CODE_C1 + ((bytes.charAt(1) & 0x1f) << 8 | (bytes.charAt(0) & 0x1f));
             case 1:
-                return hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(0));
+                return hash * HASH_CODE_C1 + (bytes.charAt(0) & 0x1f);
             default:
                 return hash;
         }
diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
index df45d1614a..19ab4f815e 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
@@ -627,26 +627,41 @@ final class PlatformDependent0 {
         }
         final long baseOffset1 = BYTE_ARRAY_BASE_OFFSET + startPos1;
         final long baseOffset2 = BYTE_ARRAY_BASE_OFFSET + startPos2;
-        int remainingBytes = length & 7;
-        final long end = baseOffset1 + remainingBytes;
-        for (long i = baseOffset1 - 8 + length, j = baseOffset2 - 8 + length; i >= end; i -= 8, j -= 8) {
+        final int remainingBytes = length & 7;
+        final long limit = baseOffset1 + (length & ~7);
+        
+        for (long i = baseOffset1, j = baseOffset2; i < limit; i += 8, j += 8) {
             if (UNSAFE.getLong(bytes1, i) != UNSAFE.getLong(bytes2, j)) {
                 return false;
             }
         }
 
         if (remainingBytes >= 4) {
-            remainingBytes -= 4;
-            if (UNSAFE.getInt(bytes1, baseOffset1 + remainingBytes) !=
-                UNSAFE.getInt(bytes2, baseOffset2 + remainingBytes)) {
+            final long offset = limit;
+            if (UNSAFE.getInt(bytes1, offset) != UNSAFE.getInt(bytes2, baseOffset2 + (limit - baseOffset1))) {
                 return false;
             }
+            if (remainingBytes == 4) return true;
+            final char c1 = UNSAFE.getChar(bytes1, offset + 4);
+            final char c2 = UNSAFE.getChar(bytes2, baseOffset2 + (limit - baseOffset1) + 4);
+            if (c1 != c2) return false;
+            if (remainingBytes == 6) return true;
+            return bytes1[(int)(offset - BYTE_ARRAY_BASE_OFFSET + 6)] == 
+                   bytes2[(int)(baseOffset2 + (limit - baseOffset1) - BYTE_ARRAY_BASE_OFFSET + 6)];
         }
+        
         if (remainingBytes >= 2) {
-            return UNSAFE.getChar(bytes1, baseOffset1) == UNSAFE.getChar(bytes2, baseOffset2) &&
-                   (remainingBytes == 2 || bytes1[startPos1 + 2] == bytes2[startPos2 + 2]);
+            final char c1 = UNSAFE.getChar(bytes1, limit);
+            final char c2 = UNSAFE.getChar(bytes2, baseOffset2 + (limit - baseOffset1));
+            if (c1 != c2) return false;
+            if (remainingBytes == 2) return true;
+            return bytes1[(int)(limit - BYTE_ARRAY_BASE_OFFSET + 2)] == 
+                   bytes2[(int)(baseOffset2 + (limit - baseOffset1) - BYTE_ARRAY_BASE_OFFSET + 2)];
         }
-        return bytes1[startPos1] == bytes2[startPos2];
+        
+        return remainingBytes == 0 || 
+               bytes1[(int)(limit - BYTE_ARRAY_BASE_OFFSET)] == 
+               bytes2[(int)(baseOffset2 + (limit - baseOffset1) - BYTE_ARRAY_BASE_OFFSET)];
     }
 
     static int equalsConstantTime(byte[] bytes1, int startPos1, byte[] bytes2, int startPos2, int length) {
@@ -654,40 +669,39 @@ final class PlatformDependent0 {
         final long baseOffset1 = BYTE_ARRAY_BASE_OFFSET + startPos1;
         final long baseOffset2 = BYTE_ARRAY_BASE_OFFSET + startPos2;
         final int remainingBytes = length & 7;
-        final long end = baseOffset1 + remainingBytes;
-        for (long i = baseOffset1 - 8 + length, j = baseOffset2 - 8 + length; i >= end; i -= 8, j -= 8) {
+        final long limit = baseOffset1 + (length & ~7);
+        
+        for (long i = baseOffset1, j = baseOffset2; i < limit; i += 8, j += 8) {
             result |= UNSAFE.getLong(bytes1, i) ^ UNSAFE.getLong(bytes2, j);
         }
-        switch (remainingBytes) {
-            case 7:
-                return ConstantTimeUtils.equalsConstantTime(result |
-                        (UNSAFE.getInt(bytes1, baseOffset1 + 3) ^ UNSAFE.getInt(bytes2, baseOffset2 + 3)) |
-                        (UNSAFE.getChar(bytes1, baseOffset1 + 1) ^ UNSAFE.getChar(bytes2, baseOffset2 + 1)) |
-                        (UNSAFE.getByte(bytes1, baseOffset1) ^ UNSAFE.getByte(bytes2, baseOffset2)), 0);
-            case 6:
-                return ConstantTimeUtils.equalsConstantTime(result |
-                        (UNSAFE.getInt(bytes1, baseOffset1 + 2) ^ UNSAFE.getInt(bytes2, baseOffset2 + 2)) |
-                        (UNSAFE.getChar(bytes1, baseOffset1) ^ UNSAFE.getChar(bytes2, baseOffset2)), 0);
-            case 5:
-                return ConstantTimeUtils.equalsConstantTime(result |
-                        (UNSAFE.getInt(bytes1, baseOffset1 + 1) ^ UNSAFE.getInt(bytes2, baseOffset2 + 1)) |
-                        (UNSAFE.getByte(bytes1, baseOffset1) ^ UNSAFE.getByte(bytes2, baseOffset2)), 0);
-            case 4:
-                return ConstantTimeUtils.equalsConstantTime(result |
-                        (UNSAFE.getInt(bytes1, baseOffset1) ^ UNSAFE.getInt(bytes2, baseOffset2)), 0);
-            case 3:
-                return ConstantTimeUtils.equalsConstantTime(result |
-                        (UNSAFE.getChar(bytes1, baseOffset1 + 1) ^ UNSAFE.getChar(bytes2, baseOffset2 + 1)) |
-                        (UNSAFE.getByte(bytes1, baseOffset1) ^ UNSAFE.getByte(bytes2, baseOffset2)), 0);
-            case 2:
-                return ConstantTimeUtils.equalsConstantTime(result |
-                        (UNSAFE.getChar(bytes1, baseOffset1) ^ UNSAFE.getChar(bytes2, baseOffset2)), 0);
-            case 1:
-                return ConstantTimeUtils.equalsConstantTime(result |
-                        (UNSAFE.getByte(bytes1, baseOffset1) ^ UNSAFE.getByte(bytes2, baseOffset2)), 0);
-            default:
-                return ConstantTimeUtils.equalsConstantTime(result, 0);
+        
+        if (remainingBytes >= 4) {
+            final long offset = limit;
+            result |= UNSAFE.getInt(bytes1, offset) ^ UNSAFE.getInt(bytes2, baseOffset2 + (limit - baseOffset1));
+            if (remainingBytes >= 5) {
+                final long offset2 = offset + 4;
+                result |= UNSAFE.getByte(bytes1, offset2) ^ UNSAFE.getByte(bytes2, baseOffset2 + (limit - baseOffset1) + 4);
+                if (remainingBytes >= 6) {
+                    final long offset3 = offset2 + 1;
+                    result |= UNSAFE.getByte(bytes1, offset3) ^ UNSAFE.getByte(bytes2, baseOffset2 + (limit - baseOffset1) + 5);
+                    if (remainingBytes == 7) {
+                        final long offset4 = offset3 + 1;
+                        result |= UNSAFE.getByte(bytes1, offset4) ^ UNSAFE.getByte(bytes2, baseOffset2 + (limit - baseOffset1) + 6);
+                    }
+                }
+            }
+        } else if (remainingBytes >= 2) {
+            final long offset = limit;
+            result |= UNSAFE.getChar(bytes1, offset) ^ UNSAFE.getChar(bytes2, baseOffset2 + (limit - baseOffset1));
+            if (remainingBytes == 3) {
+                final long offset2 = offset + 2;
+                result |= UNSAFE.getByte(bytes1, offset2) ^ UNSAFE.getByte(bytes2, baseOffset2 + (limit - baseOffset1) + 2);
+            }
+        } else if (remainingBytes == 1) {
+            result |= UNSAFE.getByte(bytes1, limit) ^ UNSAFE.getByte(bytes2, baseOffset2 + (limit - baseOffset1));
         }
+        
+        return ConstantTimeUtils.equalsConstantTime(result, 0);
     }
 
     static boolean isZero(byte[] bytes, int startPos, int length) {
