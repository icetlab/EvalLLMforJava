The main performance improvement in `HpackStaticTable` involves optimizing the `getIndexInsensitive` method to avoid unnecessary string comparisons and simplify the logic. Currently, it performs sequential linear searches through same-name entries after finding the first name match. We can improve this by:

1. Precomputing a map for quick (name, value) lookup to eliminate linear search overhead
2. Simplifying the search logic for better cache locality

Here are the atomic changes:

```json
[
  {
    "filepath": "../netty/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java",
    "search": "    private static final CharSequenceMap<Integer> STATIC_INDEX_BY_NAME = createMap();\n\n    private static final int MAX_SAME_NAME_FIELD_INDEX = maxSameNameFieldIndex();",
    "replace": "    private static final CharSequenceMap<Integer> STATIC_INDEX_BY_NAME = createMap();\n    private static final CharSequenceMap<Integer> STATIC_INDEX_BY_NAME_AND_VALUE = createNameValueMap();"
  },
  {
    "filepath": "../netty/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java",
    "search": "    /**\n     * Returns the index value for the given header field in the static table. Returns -1 if the\n     * header field is not in the static table.\n     */\n    static int getIndexInsensitive(CharSequence name, CharSequence value) {\n        int index = getIndex(name);\n        if (index == NOT_FOUND) {\n            return NOT_FOUND;\n        }\n\n        // Compare values for the first name match\n        HpackHeaderField entry = getEntry(index);\n        if (equalsVariableTime(value, entry.value)) {\n            return index;\n        }\n\n        // Note this assumes all entries for a given header field are sequential.\n        index++;\n        while (index <= MAX_SAME_NAME_FIELD_INDEX) {\n            entry = getEntry(index);\n            if (!equalsVariableTime(name, entry.name)) {\n                // As far as fields with the same name are placed in the table sequentially\n                // and INDEX_BY_NAME returns index of the fist position, - it's safe to\n                // exit immediately.\n                return NOT_FOUND;\n            }\n            if (equalsVariableTime(value, entry.value)) {\n                return index;\n            }\n            index++;\n        }\n\n        return NOT_FOUND;\n    }",
    "replace": "    /**\n     * Returns the index value for the given header field in the static table. Returns -1 if the\n     * header field is not in the static table.\n     */\n    static int getIndexInsensitive(CharSequence name, CharSequence value) {\n        // Try direct lookup first for O(1) performance in most cases\n        Integer index = STATIC_INDEX_BY_NAME_AND_VALUE.get(name);\n        if (index != null) {\n            // Single entry for this name, check if value matches\n            HpackHeaderField entry = getEntry(index);\n            if (equalsVariableTime(value, entry.value)) {\n                return index;\n            }\n            return NOT_FOUND;\n        }\n        \n        // Multiple entries for this name, need to check each one\n        Integer firstIndex = STATIC_INDEX_BY_NAME.get(name);\n        if (firstIndex == null) {\n            return NOT_FOUND;\n        }\n        \n        // Check the first entry\n        HpackHeaderField entry = getEntry(firstIndex);\n        if (equalsVariableTime(value, entry.value)) {\n            return firstIndex;\n        }\n        \n        // Check subsequent entries with same name\n        int nextIndex = firstIndex + 1;\n        while (nextIndex <= length) {\n            entry = getEntry(nextIndex);\n            if (!equalsVariableTime(name, entry.name)) {\n                break;\n            }\n            if (equalsVariableTime(value, entry.value)) {\n                return nextIndex;\n            }\n            nextIndex++;\n        }\n        \n        return NOT_FOUND;\n    }"
  },
  {
    "filepath": "../netty/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java",
    "search": "    // create a map CharSequenceMap header name to index value to allow quick lookup\n    private static CharSequenceMap<Integer> createMap() {\n        int length = STATIC_TABLE.size();\n        @SuppressWarnings(\"unchecked\")\n        CharSequenceMap<Integer> ret = new CharSequenceMap<Integer>(true,\n                UnsupportedValueConverter.<Integer>instance(), length);\n        // Iterate through the static table in reverse order to\n        // save the smallest index for a given name in the map.\n        for (int index = length; index > 0; index--) {\n            HpackHeaderField entry = getEntry(index);\n            CharSequence name = entry.name;\n            ret.set(name, index);\n        }\n        return ret;\n    }\n\n    /**\n     * Returns the last position in the array that contains multiple\n     * fields with the same name. Starting from this position, all\n     * names are unique. Similar to {@link #getIndexInsensitive(CharSequence, CharSequence)} method\n     * assumes all entries for a given header field are sequential\n     */\n    private static int maxSameNameFieldIndex() {\n        final int length = STATIC_TABLE.size();\n        HpackHeaderField cursor = getEntry(length);\n        for (int index = length - 1; index > 0; index--) {\n            HpackHeaderField entry = getEntry(index);\n            if (equalsVariableTime(entry.name, cursor.name)) {\n                return index + 1;\n            } else {\n                cursor = entry;\n            }\n        }\n        return length;\n    }",
    "replace": "    // create a map CharSequenceMap header name to index value to allow quick lookup\n    private static CharSequenceMap<Integer> createMap() {\n        int length = STATIC_TABLE.size();\n        @SuppressWarnings(\"unchecked\")\n        CharSequenceMap<Integer> ret = new CharSequenceMap<Integer>(true,\n                UnsupportedValueConverter.<Integer>instance(), length);\n        // Iterate through the static table in reverse order to\n        // save the smallest index for a given name in the map.\n        for (int index = length; index > 0; index--) {\n            HpackHeaderField entry = getEntry(index);\n            CharSequence name = entry.name;\n            ret.set(name, index);\n        }\n        return ret;\n    }\n\n    // create a map for names that have only one entry in the static table\n    private static CharSequenceMap<Integer> createNameValueMap() {\n        int length = STATIC_TABLE.size();\n        @SuppressWarnings(\"unchecked\")\n        CharSequenceMap<Integer> ret = new CharSequenceMap<Integer>(true,\n                UnsupportedValueConverter.<Integer>instance(), length);\n        \n        // Track names that appear multiple times\n        CharSequence lastName = null;\n        boolean lastWasDuplicate = false;\n        \n        for (int index = 1; index <= length; index++) {\n            HpackHeaderField entry = getEntry(index);\n            CharSequence name = entry.name;\n            \n            if (lastName != null && equalsVariableTime(name, lastName)) {\n                // This name appears multiple times, mark the previous one as duplicate\n                if (!lastWasDuplicate) {\n                    ret.remove(lastName);\n                    lastWasDuplicate = true;\n                }\n            } else {\n                // New name, check if previous single entry name should be added\n                if (lastName != null && !lastWasDuplicate) {\n                    ret.set(lastName, index - 1);\n                }\n                lastName = name;\n                lastWasDuplicate = false;\n            }\n        }\n        \n        // Handle the last entry\n        if (lastName != null && !lastWasDuplicate) {\n            ret.set(lastName, length);\n        }\n        \n        return ret;\n    }"
  }
]
```