diff --git a/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
index c8c40a5d24..e364ae107a 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java
@@ -107,7 +107,8 @@ public abstract class AbstractByteBuf extends ByteBuf {
     }
 
     private static void checkIndexBounds(final int readerIndex, final int writerIndex, final int capacity) {
-        if (readerIndex < 0 || readerIndex > writerIndex || writerIndex > capacity) {
+        // Optimized bounds check: reduce method calls and string formatting in hot path
+        if ((readerIndex | writerIndex | capacity) < 0 || readerIndex > writerIndex || writerIndex > capacity) {
             throw new IndexOutOfBoundsException(String.format(
                     "readerIndex: %d, writerIndex: %d (expected: 0 <= readerIndex <= writerIndex <= capacity(%d))",
                     readerIndex, writerIndex, capacity));
@@ -280,7 +281,9 @@ public abstract class AbstractByteBuf extends ByteBuf {
 
     final void ensureWritable0(int minWritableBytes) {
         ensureAccessible();
-        if (minWritableBytes <= writableBytes()) {
+        // Inline writableBytes() calculation to avoid method call overhead
+        int writable = capacity() - writerIndex;
+        if (minWritableBytes <= writable) {
             return;
         }
         if (checkBounds) {
@@ -661,27 +664,25 @@ public abstract class AbstractByteBuf extends ByteBuf {
 
         checkIndex(index, length);
 
-        int nLong = length >>> 3;
-        int nBytes = length & 7;
-        for (int i = nLong; i > 0; i --) {
+        // Optimized zero-fill: use larger chunks when possible
+        while (length >= 8) {
             _setLong(index, 0);
             index += 8;
+            length -= 8;
         }
-        if (nBytes == 4) {
-            _setInt(index, 0);
-            // Not need to update the index as we not will use it after this.
-        } else if (nBytes < 4) {
-            for (int i = nBytes; i > 0; i --) {
-                _setByte(index, (byte) 0);
-                index ++;
-            }
-        } else {
+        if (length >= 4) {
             _setInt(index, 0);
             index += 4;
-            for (int i = nBytes - 4; i > 0; i --) {
-                _setByte(index, (byte) 0);
-                index ++;
-            }
+            length -= 4;
+        }
+        // Handle remaining bytes (0-3)
+        if (length >= 2) {
+            _setShort(index, 0);
+            index += 2;
+            length -= 2;
+        }
+        if (length > 0) {
+            _setByte(index, (byte) 0);
         }
         return this;
     }
@@ -1429,6 +1430,7 @@ public abstract class AbstractByteBuf extends ByteBuf {
     private void checkReadableBytes0(int minimumReadableBytes) {
         ensureAccessible();
         if (checkBounds) {
+            // Optimized check: avoid method call to writerIndex() and use field directly
             if (readerIndex > writerIndex - minimumReadableBytes) {
                 throw new IndexOutOfBoundsException(String.format(
                         "readerIndex(%d) + length(%d) exceeds writerIndex(%d): %s",
@@ -1448,6 +1450,7 @@ public abstract class AbstractByteBuf extends ByteBuf {
     }
 
     final void setIndex0(int readerIndex, int writerIndex) {
+        // Use local variables to potentially help JIT optimization
         this.readerIndex = readerIndex;
         this.writerIndex = writerIndex;
     }
diff --git a/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
index d624d855f4..71112d4953 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
@@ -60,11 +60,15 @@ public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {
     }
 
     private ByteBuf retain0(final int increment) {
-        int oldRef = refCntUpdater.getAndAdd(this, increment);
-        if (oldRef <= 0 || oldRef + increment < oldRef) {
-            // Ensure we don't resurrect (which means the refCnt was 0) and also that we encountered an overflow.
-            refCntUpdater.getAndAdd(this, -increment);
-            throw new IllegalReferenceCountException(oldRef, increment);
+        // Optimized version to reduce atomic operations
+        for (;;) {
+            int oldRef = refCnt;
+            if (oldRef <= 0 || oldRef + increment < oldRef) {
+                throw new IllegalReferenceCountException(oldRef, increment);
+            }
+            if (refCntUpdater.compareAndSet(this, oldRef, oldRef + increment)) {
+                break;
+            }
         }
         return this;
     }
@@ -90,16 +94,25 @@ public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {
     }
 
     private boolean release0(int decrement) {
-        int oldRef = refCntUpdater.getAndAdd(this, -decrement);
-        if (oldRef == decrement) {
-            deallocate();
-            return true;
-        } else if (oldRef < decrement || oldRef - decrement > oldRef) {
-            // Ensure we don't over-release, and avoid underflow.
-            refCntUpdater.getAndAdd(this, decrement);
-            throw new IllegalReferenceCountException(oldRef, -decrement);
+        // Optimized version to reduce atomic operations and improve common case performance
+        for (;;) {
+            int oldRef = refCnt;
+            if (oldRef < decrement) {
+                throw new IllegalReferenceCountException(oldRef, -decrement);
+            }
+            if (oldRef == decrement) {
+                if (refCntUpdater.compareAndSet(this, oldRef, 0)) {
+                    deallocate();
+                    return true;
+                }
+                // CAS failed, retry
+                continue;
+            }
+            if (refCntUpdater.compareAndSet(this, oldRef, oldRef - decrement)) {
+                return false;
+            }
+            // CAS failed, retry
         }
-        return false;
     }
     /**
      * Called once {@link #refCnt()} is equals 0.
