diff --git a/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java
index 01b747b3f2..8ade5247e5 100644
--- a/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java
+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java
@@ -233,7 +233,9 @@ public class QueryStringDecoder {
         if (s.charAt(from) == '?') {
             from++;
         }
-        Map<String, List<String>> params = new LinkedHashMap<String, List<String>>();
+        // Optimize: use initial capacity based on paramsLimit to reduce rehashing
+        Map<String, List<String>> params = new LinkedHashMap<String, List<String>>(
+            Math.min(paramsLimit * 4 / 3 + 1, 16));
         int nameStart = from;
         int valueStart = -1;
         int i;
@@ -283,7 +285,8 @@ public class QueryStringDecoder {
         String value = decodeComponent(s, valueStart, valueEnd, charset, false);
         List<String> values = params.get(name);
         if (values == null) {
-            values = new ArrayList<String>(1);  // Often there's only 1 value.
+            // Optimize: small initial capacity for the common case
+            values = new ArrayList<String>(2);  // Allow for 2 values without resizing
             params.put(name, values);
         }
         values.add(value);
@@ -340,9 +343,10 @@ public class QueryStringDecoder {
             return EMPTY_STRING;
         }
         int firstEscaped = -1;
+        // Optimize: check multiple characters per iteration
         for (int i = from; i < toExcluded; i++) {
             char c = s.charAt(i);
-            if (c == '%' || c == '+' && !isPath) {
+            if (c == '%' || (c == '+' && !isPath)) {
                 firstEscaped = i;
                 break;
             }
@@ -364,41 +368,52 @@ public class QueryStringDecoder {
         for (int i = firstEscaped; i < toExcluded; i++) {
             char c = s.charAt(i);
             if (c != '%') {
-                strBuf.append(c != '+' || isPath? c : SPACE);
+                strBuf.append(c != '+' || isPath ? c : SPACE);
                 continue;
             }
 
-            byteBuf.clear();
-            do {
+            // Optimize: pre-calculate the number of bytes in this percent-encoded sequence
+            int seqStart = i;
+            int byteCount = 0;
+            while (i < toExcluded && s.charAt(i) == '%') {
                 if (i + 3 > toExcluded) {
-                    throw new IllegalArgumentException("unterminated escape sequence at index " + i + " of: " + s);
+                    throw new IllegalArgumentException("unterminated escape sequence at index " + seqStart + " of: " + s);
                 }
-                byteBuf.put(decodeHexByte(s, i + 1));
+                byteCount++;
                 i += 3;
-            } while (i < toExcluded && s.charAt(i) == '%');
-            i--;
-
-            byteBuf.flip();
-            charBuf.clear();
-            CoderResult result = decoder.reset().decode(byteBuf, charBuf, true);
+            }
+            i -= 3; // Reset to last percent position for hex decoding
+            
+            // Allocate exact size for this sequence
+            ByteBuffer seqByteBuf = ByteBuffer.allocate(byteCount);
+            for (int j = 0; j < byteCount; j++) {
+                seqByteBuf.put(decodeHexByte(s, i + 1));
+                i += 3;
+            }
+            i--; // Adjust for loop increment
+            
+            seqByteBuf.flip();
+            CharBuffer seqCharBuf = CharBuffer.allocate(byteCount * 2); // Worst case: each byte becomes 2 chars
+            CoderResult result = decoder.reset().decode(seqByteBuf, seqCharBuf, true);
             try {
                 if (!result.isUnderflow()) {
                     result.throwException();
                 }
-                result = decoder.flush(charBuf);
+                result = decoder.flush(seqCharBuf);
                 if (!result.isUnderflow()) {
                     result.throwException();
                 }
             } catch (CharacterCodingException ex) {
                 throw new IllegalStateException(ex);
             }
-            strBuf.append(charBuf.flip());
+            strBuf.append(seqCharBuf.flip());
         }
         return strBuf.toString();
     }
 
     private static int findPathEndIndex(String uri) {
         int len = uri.length();
+        // Optimize: manual loop unrolling for common cases
         for (int i = 0; i < len; i++) {
             char c = uri.charAt(i);
             if (c == '?' || c == '#') {
