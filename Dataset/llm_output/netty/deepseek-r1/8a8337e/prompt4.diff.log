The performance issue is that the Recycler's release operation often occurs on the same thread that claimed the object, yet it still uses a thread-safe MPSC queue, incurring unnecessary overhead. The goal is to optimize the common case of same-thread release by using a thread-local stack, while preserving cross-thread release capability via the existing MPSC queue. This reduces contention and improves performance when objects are recycled by their owning thread.

```json
[
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "    private static final class LocalPool<T> {\n        private final int ratioInterval;\n        private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;\n        private int ratioCounter;\n\n        @SuppressWarnings(\"unchecked\")\n        LocalPool(int maxCapacity, int ratioInterval, int chunkSize) {\n            this.ratioInterval = ratioInterval;\n            if (BLOCKING_POOL) {\n                pooledHandles = new BlockingMessageQueue<DefaultHandle<T>>(maxCapacity);\n            } else {\n                pooledHandles = (MessagePassingQueue<DefaultHandle<T>>) newMpscQueue(chunkSize, maxCapacity);\n            }\n            ratioCounter = ratioInterval; // Start at interval so the first one will be recycled.\n        }",
    "replace": "    private static final class LocalPool<T> {\n        private final int ratioInterval;\n        private final int maxCapacity;\n        private final Thread ownerThread;\n        private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;\n        private final ArrayDeque<DefaultHandle<T>> localStack;\n        private int ratioCounter;\n\n        @SuppressWarnings(\"unchecked\")\n        LocalPool(int maxCapacity, int ratioInterval, int chunkSize) {\n            this.ratioInterval = ratioInterval;\n            this.maxCapacity = maxCapacity;\n            this.ownerThread = Thread.currentThread();\n            if (maxCapacity > 0) {\n                localStack = new ArrayDeque<DefaultHandle<T>>(Math.min(chunkSize, maxCapacity));\n            } else {\n                localStack = null;\n            }\n            if (BLOCKING_POOL) {\n                pooledHandles = new BlockingMessageQueue<DefaultHandle<T>>(maxCapacity);\n            } else {\n                pooledHandles = (MessagePassingQueue<DefaultHandle<T>>) newMpscQueue(chunkSize, maxCapacity);\n            }\n            ratioCounter = ratioInterval; // Start at interval so the first one will be recycled.\n        }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "        DefaultHandle<T> claim() {\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            if (handles == null) {\n                return null;\n            }\n            DefaultHandle<T> handle = handles.relaxedPoll();\n            if (null != handle) {\n                handle.toClaimed();\n            }\n            return handle;\n        }",
    "replace": "        DefaultHandle<T> claim() {\n            if (localStack != null) {\n                DefaultHandle<T> handle = localStack.pollLast();\n                if (handle != null) {\n                    handle.toClaimed();\n                    return handle;\n                }\n            }\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            if (handles == null) {\n                return null;\n            }\n            DefaultHandle<T> handle = handles.relaxedPoll();\n            if (null != handle) {\n                handle.toClaimed();\n            }\n            return handle;\n        }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "        void release(DefaultHandle<T> handle) {\n            handle.toAvailable();\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            if (handles != null) {\n                handles.relaxedOffer(handle);\n            }\n        }",
    "replace": "        void release(DefaultHandle<T> handle) {\n            handle.toAvailable();\n            if (Thread.currentThread() == ownerThread && localStack != null && localStack.size() < maxCapacity) {\n                localStack.offerLast(handle);\n                return;\n            }\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            if (handles != null) {\n                handles.relaxedOffer(handle);\n            }\n        }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "        @Override\n        protected void onRemoval(LocalPool<T> value) throws Exception {\n            super.onRemoval(value);\n            MessagePassingQueue<DefaultHandle<T>> handles = value.pooledHandles;\n            value.pooledHandles = null;\n            handles.clear();\n        }",
    "replace": "        @Override\n        protected void onRemoval(LocalPool<T> value) throws Exception {\n            super.onRemoval(value);\n            value.clear();\n        }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "    private static final class LocalPool<T> {\n        private final int ratioInterval;\n        private final int maxCapacity;\n        private final Thread ownerThread;\n        private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;\n        private final ArrayDeque<DefaultHandle<T>> localStack;\n        private int ratioCounter;\n\n        @SuppressWarnings(\"unchecked\")\n        LocalPool(int maxCapacity, int ratioInterval, int chunkSize) {\n            this.ratioInterval = ratioInterval;\n            this.maxCapacity = maxCapacity;\n            this.ownerThread = Thread.currentThread();\n            if (maxCapacity > 0) {\n                localStack = new ArrayDeque<DefaultHandle<T>>(Math.min(chunkSize, maxCapacity));\n            } else {\n                localStack = null;\n            }\n            if (BLOCKING_POOL) {\n                pooledHandles = new BlockingMessageQueue<DefaultHandle<T>>(maxCapacity);\n            } else {\n                pooledHandles = (MessagePassingQueue<DefaultHandle<T>>) newMpscQueue(chunkSize, maxCapacity);\n            }\n            ratioCounter = ratioInterval; // Start at interval so the first one will be recycled.\n        }\n\n        DefaultHandle<T> claim() {\n            if (localStack != null) {\n                DefaultHandle<T> handle = localStack.pollLast();\n                if (handle != null) {\n                    handle.toClaimed();\n                    return handle;\n                }\n            }\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            if (handles == null) {\n                return null;\n            }\n            DefaultHandle<T> handle = handles.relaxedPoll();\n            if (null != handle) {\n                handle.toClaimed();\n            }\n            return handle;\n        }\n\n        void release(DefaultHandle<T> handle) {\n            handle.toAvailable();\n            if (Thread.currentThread() == ownerThread && localStack != null && localStack.size() < maxCapacity) {\n                localStack.offerLast(handle);\n                return;\n            }\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            if (handles != null) {\n                handles.relaxedOffer(handle);\n            }\n        }\n\n        DefaultHandle<T> newHandle() {\n            if (++ratioCounter >= ratioInterval) {\n                ratioCounter = 0;\n                return new DefaultHandle<T>(this);\n            }\n            return null;\n        }",
    "replace": "    private static final class LocalPool<T> {\n        private final int ratioInterval;\n        private final int maxCapacity;\n        private final Thread ownerThread;\n        private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;\n        private final ArrayDeque<DefaultHandle<T>> localStack;\n        private int ratioCounter;\n\n        @SuppressWarnings(\"unchecked\")\n        LocalPool(int maxCapacity, int ratioInterval, int chunkSize) {\n            this.ratioInterval = ratioInterval;\n            this.maxCapacity = maxCapacity;\n            this.ownerThread = Thread.currentThread();\n            if (maxCapacity > 0) {\n                localStack = new ArrayDeque<DefaultHandle<T>>(Math.min(chunkSize, maxCapacity));\n            } else {\n                localStack = null;\n            }\n            if (BLOCKING_POOL) {\n                pooledHandles = new BlockingMessageQueue<DefaultHandle<T>>(maxCapacity);\n            } else {\n                pooledHandles = (MessagePassingQueue<DefaultHandle<T>>) newMpscQueue(chunkSize, maxCapacity);\n            }\n            ratioCounter = ratioInterval; // Start at interval so the first one will be recycled.\n        }\n\n        DefaultHandle<T> claim() {\n            if (localStack != null) {\n                DefaultHandle<T> handle = localStack.pollLast();\n                if (handle != null) {\n                    handle.toClaimed();\n                    return handle;\n                }\n            }\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            if (handles == null) {\n                return null;\n            }\n            DefaultHandle<T> handle = handles.relaxedPoll();\n            if (null != handle) {\n                handle.toClaimed();\n            }\n            return handle;\n        }\n\n        void release(DefaultHandle<T> handle) {\n            handle.toAvailable();\n            if (Thread.currentThread() == ownerThread && localStack != null && localStack.size() < maxCapacity) {\n                localStack.offerLast(handle);\n                return;\n            }\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            if (handles != null) {\n                handles.relaxedOffer(handle);\n            }\n        }\n\n        DefaultHandle<T> newHandle() {\n            if (++ratioCounter >= ratioInterval) {\n                ratioCounter = 0;\n                return new DefaultHandle<T>(this);\n            }\n            return null;\n        }\n\n        void clear() {\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            pooledHandles = null;\n            if (handles != null) {\n                handles.clear();\n            }\n            if (localStack != null) {\n                localStack.clear();\n            }\n        }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "    final int threadLocalSize() {\n        LocalPool<T> localPool = threadLocal.getIfExists();\n        return localPool == null ? 0 : localPool.pooledHandles.size();\n    }",
    "replace": "    final int threadLocalSize() {\n        LocalPool<T> localPool = threadLocal.getIfExists();\n        if (localPool == null) {\n            return 0;\n        }\n        int size = 0;\n        if (localPool.localStack != null) {\n            size += localPool.localStack.size();\n        }\n        MessagePassingQueue<DefaultHandle<T>> handles = localPool.pooledHandles;\n        if (handles != null) {\n            size += handles.size();\n        }\n        return size;\n    }"
  }
]
```