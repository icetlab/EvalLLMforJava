diff --git a/common/src/main/java/io/netty/util/Recycler.java b/common/src/main/java/io/netty/util/Recycler.java
index dd7b2d73be..113cc64b52 100644
--- a/common/src/main/java/io/netty/util/Recycler.java
+++ b/common/src/main/java/io/netty/util/Recycler.java
@@ -102,9 +102,7 @@ public abstract class Recycler<T> {
         @Override
         protected void onRemoval(LocalPool<T> value) throws Exception {
             super.onRemoval(value);
-            MessagePassingQueue<DefaultHandle<T>> handles = value.pooledHandles;
-            value.pooledHandles = null;
-            handles.clear();
+            value.clear();
         }
     };
 
@@ -197,7 +195,18 @@ public abstract class Recycler<T> {
 
     final int threadLocalSize() {
         LocalPool<T> localPool = threadLocal.getIfExists();
-        return localPool == null ? 0 : localPool.pooledHandles.size();
+        if (localPool == null) {
+            return 0;
+        }
+        int size = 0;
+        if (localPool.localStack != null) {
+            size += localPool.localStack.size();
+        }
+        MessagePassingQueue<DefaultHandle<T>> handles = localPool.pooledHandles;
+        if (handles != null) {
+            size += handles.size();
+        }
+        return size;
     }
 
     /**
@@ -257,12 +266,22 @@ public abstract class Recycler<T> {
 
     private static final class LocalPool<T> {
         private final int ratioInterval;
+        private final int maxCapacity;
+        private final Thread ownerThread;
         private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;
+        private final ArrayDeque<DefaultHandle<T>> localStack;
         private int ratioCounter;
 
         @SuppressWarnings("unchecked")
         LocalPool(int maxCapacity, int ratioInterval, int chunkSize) {
             this.ratioInterval = ratioInterval;
+            this.maxCapacity = maxCapacity;
+            this.ownerThread = Thread.currentThread();
+            if (maxCapacity > 0) {
+                localStack = new ArrayDeque<DefaultHandle<T>>(Math.min(chunkSize, maxCapacity));
+            } else {
+                localStack = null;
+            }
             if (BLOCKING_POOL) {
                 pooledHandles = new BlockingMessageQueue<DefaultHandle<T>>(maxCapacity);
             } else {
@@ -272,6 +291,13 @@ public abstract class Recycler<T> {
         }
 
         DefaultHandle<T> claim() {
+            if (localStack != null) {
+                DefaultHandle<T> handle = localStack.pollLast();
+                if (handle != null) {
+                    handle.toClaimed();
+                    return handle;
+                }
+            }
             MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
             if (handles == null) {
                 return null;
@@ -285,6 +311,10 @@ public abstract class Recycler<T> {
 
         void release(DefaultHandle<T> handle) {
             handle.toAvailable();
+            if (Thread.currentThread() == ownerThread && localStack != null && localStack.size() < maxCapacity) {
+                localStack.offerLast(handle);
+                return;
+            }
             MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
             if (handles != null) {
                 handles.relaxedOffer(handle);
@@ -298,6 +328,17 @@ public abstract class Recycler<T> {
             }
             return null;
         }
+
+        void clear() {
+            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
+            pooledHandles = null;
+            if (handles != null) {
+                handles.clear();
+            }
+            if (localStack != null) {
+                localStack.clear();
+            }
+        }
     }
 
     /**
