Looking at the performance issue "Avoid computing cardinality for run containers when not needed", I can see that the `getCardinality()` method is being called in several places, particularly in the `contains(RoaringBitmap subset)` method. For RunContainers, computing cardinality requires iterating through all runs, which can be expensive. We should avoid this when possible.

The main issue I found is in the `contains(RoaringBitmap subset)` method, which calls `getCardinality()` to check if a container is full. We can replace this with the more efficient `isFull()` method when available.

Here are the improvements:

1. In `RoaringBitmap.contains(RoaringBitmap subset)`, replace the cardinality check with `isFull()` for containers.
2. In `RoaringBitmap.contains(long minimum, long supremum)`, similarly avoid computing cardinality for full containers.

```json
[
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java",
    "search": "  public boolean contains(RoaringBitmap subset) {\n    final int length1 = this.highLowContainer.size;\n    final int length2 = subset.highLowContainer.size;\n    int pos1 = 0, pos2 = 0;\n    while (pos1 < length1 && pos2 < length2) {\n      final char s1 = this.highLowContainer.getKeyAtIndex(pos1);\n      final char s2 = subset.highLowContainer.getKeyAtIndex(pos2);\n      if (s1 == s2) {\n        Container c1 = this.highLowContainer.getContainerAtIndex(pos1);\n        Container c2 = subset.highLowContainer.getContainerAtIndex(pos2);\n        if(!c1.contains(c2)) {\n          return false;\n        }\n        ++pos1;\n        ++pos2;\n      } else if (s1 - s2 > 0) {\n        return false;\n      } else {\n        pos1 = subset.highLowContainer.advanceUntil(s2, pos1);\n      }\n    }\n    return pos2 == length2;\n  }",
    "replace": "  public boolean contains(RoaringBitmap subset) {\n    final int length1 = this.highLowContainer.size;\n    final int length2 = subset.highLowContainer.size;\n    int pos1 = 0, pos2 = 0;\n    while (pos1 < length1 && pos2 < length2) {\n      final char s1 = this.highLowContainer.getKeyAtIndex(pos1);\n      final char s2 = subset.highLowContainer.getKeyAtIndex(pos2);\n      if (s1 == s2) {\n        Container c1 = this.highLowContainer.getContainerAtIndex(pos1);\n        Container c2 = subset.highLowContainer.getContainerAtIndex(pos2);\n        if(!c1.contains(c2)) {\n          return false;\n        }\n        ++pos1;\n        ++pos2;\n      } else if (s1 - s2 > 0) {\n        return false;\n      } else {\n        pos1 = subset.highLowContainer.advanceUntil(s2, pos1);\n      }\n    }\n    return pos2 == length2;\n  }"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java",
    "search": "    for (int i = begin + 1; i < end; ++i) {\n      if (highLowContainer.getContainerAtIndex(i).getCardinality() != 1 << 16) {\n        return false;\n      }\n    }",
    "replace": "    for (int i = begin + 1; i < end; ++i) {\n      Container c = highLowContainer.getContainerAtIndex(i);\n      if (!c.isFull()) {\n        return false;\n      }\n    }"
  }
]
```

Wait, I need to reconsider. Looking more carefully at the code, I see that `Container.isFull()` might not be available in all container implementations. Let me check the container hierarchy. Actually, looking at the `contains(RoaringBitmap subset)` method, it already uses `c1.contains(c2)` which should be optimized internally. The real issue might be elsewhere.

Let me examine the benchmark provided. The benchmark is testing `checkedAdd`, and the performance issue mentions avoiding cardinality computation for run containers. Looking at the `checkedAdd` method:

```java
public boolean checkedAdd(final int x) {
  final char hb = Util.highbits(x);
  final int i = highLowContainer.getIndex(hb);
  if (i >= 0) {
    Container c = highLowContainer.getContainerAtIndex(i);
    int oldCard = c.getCardinality();
    // we need to keep the newContainer if a switch between containers type
    // occur, in order to get the new cardinality
    Container newCont = c.add(Util.lowbits(x));
    highLowContainer.setContainerAtIndex(i, newCont);
    if (newCont.getCardinality() > oldCard) {
      return true;
    }
  } else {
    final ArrayContainer newac = new ArrayContainer();
    highLowContainer.insertNewKeyValueAt(-i - 1, hb, newac.add(Util.lowbits(x)));
    return true;
  }
  return false;
}
```

The issue is that `getCardinality()` is called twice: once for `oldCard` and once for `newCont.getCardinality()`. For RunContainers, this is expensive. We can optimize this by checking if the value was already present before adding it.

Actually, looking at the benchmark code more carefully, I see it's comparing an "optimized" version with the "original". The optimized version in the benchmark uses `bitmap.checkedAdd(a[i])` directly. Let me check if there's already an optimization.

Actually, I think the real issue is that we're computing cardinality unnecessarily. Instead of computing the full cardinality before and after, we could:
1. Check if the value is already present using `contains()`
2. Only if not present, add it and return true

But wait, that's what the benchmark's "optimized" version seems to do. Let me re-examine...

Actually, I think the issue is that `checkedAdd` is computing cardinality even when we could avoid it. Here's a better approach:

```json
[
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java",
    "search": "  public boolean checkedAdd(final int x) {\n    final char hb = Util.highbits(x);\n    final int i = highLowContainer.getIndex(hb);\n    if (i >= 0) {\n      Container c = highLowContainer.getContainerAtIndex(i);\n      int oldCard = c.getCardinality();\n      // we need to keep the newContainer if a switch between containers type\n      // occur, in order to get the new cardinality\n      Container newCont = c.add(Util.lowbits(x));\n      highLowContainer.setContainerAtIndex(i, newCont);\n      if (newCont.getCardinality() > oldCard) {\n        return true;\n      }\n    } else {\n      final ArrayContainer newac = new ArrayContainer();\n      highLowContainer.insertNewKeyValueAt(-i - 1, hb, newac.add(Util.lowbits(x)));\n      return true;\n    }\n    return false;\n  }",
    "replace": "  public boolean checkedAdd(final int x) {\n    final char hb = Util.highbits(x);\n    final int i = highLowContainer.getIndex(hb);\n    if (i >= 0) {\n      Container c = highLowContainer.getContainerAtIndex(i);\n      // First check if the value is already present to avoid cardinality computation\n      if (c.contains(Util.lowbits(x))) {\n        return false;\n      }\n      Container newCont = c.add(Util.lowbits(x));\n      highLowContainer.setContainerAtIndex(i, newCont);\n      return true;\n    } else {\n      final ArrayContainer newac = new ArrayContainer();\n      highLowContainer.insertNewKeyValueAt(-i - 1, hb, newac.add(Util.lowbits(x)));\n      return true;\n    }\n  }"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MutableRoaringBitmap.java",
    "search": "  public boolean checkedAdd(final int x) {\n    final char hb = BufferUtil.highbits(x);\n    final int i = highLowContainer.getIndex(hb);\n    if (i >= 0) {\n      MappeableContainer C = highLowContainer.getContainerAtIndex(i);\n      int oldcard = C.getCardinality();\n      C = C.add(BufferUtil.lowbits(x));\n      getMappeableRoaringArray().setContainerAtIndex(i, C);\n      return C.getCardinality() > oldcard;\n    } else {\n      final MappeableArrayContainer newac = new MappeableArrayContainer();\n      getMappeableRoaringArray().insertNewKeyValueAt(-i - 1, hb, newac.add(BufferUtil.lowbits(x)));\n      return true;\n    }\n  }",
    "replace": "  public boolean checkedAdd(final int x) {\n    final char hb = BufferUtil.highbits(x);\n    final int i = highLowContainer.getIndex(hb);\n    if (i >= 0) {\n      MappeableContainer C = highLowContainer.getContainerAtIndex(i);\n      // First check if the value is already present to avoid cardinality computation\n      if (C.contains(BufferUtil.lowbits(x))) {\n        return false;\n      }\n      C = C.add(BufferUtil.lowbits(x));\n      getMappeableRoaringArray().setContainerAtIndex(i, C);\n      return true;\n    } else {\n      final MappeableArrayContainer newac = new MappeableArrayContainer();\n      getMappeableRoaringArray().insertNewKeyValueAt(-i - 1, hb, newac.add(BufferUtil.lowbits(x)));\n      return true;\n    }\n  }"
  }
]
```

This optimization avoids computing cardinality entirely for the `checkedAdd` operation by first checking if the value is already present using `contains()`. For RunContainers, `contains()` is typically faster than computing the full cardinality, especially when the value is not present or found early in the search.