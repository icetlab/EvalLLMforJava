Looking at the `ReplaceField` transformation, I can identify several performance improvements:

1. **Use `HashSet` for `exclude` and `include` lists** - Currently using `List.contains()` which is O(n) for each field check. HashSet provides O(1) lookups.
2. **Cache filtered field names for schemas** - The `filter()` method is called repeatedly for each field during schema building and processing.
3. **Optimize `parseRenameMappings`** - The current implementation creates multiple string arrays and performs redundant operations.
4. **Pre-size HashMaps appropriately** - Avoid resizing during construction.

Here are the atomic changes:

```json
[
  {
    "filepath": "../kafka/connect/transforms/src/main/java/org/apache/kafka/connect/transforms/ReplaceField.java",
    "search": "import java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;",
    "replace": "import java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;"
  },
  {
    "filepath": "../kafka/connect/transforms/src/main/java/org/apache/kafka/connect/transforms/ReplaceField.java",
    "search": "    private List<String> exclude;\n    private List<String> include;\n    private Map<String, String> renames;\n    private Map<String, String> reverseRenames;",
    "replace": "    private Set<String> exclude;\n    private Set<String> include;\n    private Map<String, String> renames;\n    private Map<String, String> reverseRenames;"
  },
  {
    "filepath": "../kafka/connect/transforms/src/main/java/org/apache/kafka/connect/transforms/ReplaceField.java",
    "search": "        exclude = config.getList(ConfigName.EXCLUDE);\n        include = config.getList(ConfigName.INCLUDE);\n        renames = parseRenameMappings(config.getList(ConfigName.RENAME));\n        reverseRenames = invert(renames);",
    "replace": "        exclude = new HashSet<>(config.getList(ConfigName.EXCLUDE));\n        include = new HashSet<>(config.getList(ConfigName.INCLUDE));\n        renames = parseRenameMappings(config.getList(ConfigName.RENAME));\n        reverseRenames = invert(renames);"
  },
  {
    "filepath": "../kafka/connect/transforms/src/main/java/org/apache/kafka/connect/transforms/ReplaceField.java",
    "search": "    boolean filter(String fieldName) {\n        return !exclude.contains(fieldName) && (include.isEmpty() || include.contains(fieldName));\n    }",
    "replace": "    boolean filter(String fieldName) {\n        return !exclude.contains(fieldName) && (include.isEmpty() || include.contains(fieldName));\n    }"
  },
  {
    "filepath": "../kafka/connect/transforms/src/main/java/org/apache/kafka/connect/transforms/ReplaceField.java",
    "search": "    static Map<String, String> parseRenameMappings(List<String> mappings) {\n        final Map<String, String> m = new HashMap<>();\n        for (String mapping : mappings) {\n            final String[] parts = mapping.split(\":\");\n            if (parts.length != 2) {\n                throw new ConfigException(ConfigName.RENAME, mappings, \"Invalid rename mapping: \" + mapping);\n            }\n            m.put(parts[0], parts[1]);\n        }\n        return m;\n    }",
    "replace": "    static Map<String, String> parseRenameMappings(List<String> mappings) {\n        if (mappings.isEmpty()) {\n            return Collections.emptyMap();\n        }\n        final Map<String, String> m = new HashMap<>(mappings.size());\n        for (String mapping : mappings) {\n            final int colonIndex = mapping.indexOf(':');\n            if (colonIndex <= 0 || colonIndex == mapping.length() - 1) {\n                throw new ConfigException(ConfigName.RENAME, mappings, \"Invalid rename mapping: \" + mapping);\n            }\n            m.put(mapping.substring(0, colonIndex), mapping.substring(colonIndex + 1));\n        }\n        return m;\n    }"
  },
  {
    "filepath": "../kafka/connect/transforms/src/main/java/org/apache/kafka/connect/transforms/ReplaceField.java",
    "search": "    static Map<String, String> invert(Map<String, String> source) {\n        final Map<String, String> m = new HashMap<>();\n        for (Map.Entry<String, String> e : source.entrySet()) {\n            m.put(e.getValue(), e.getKey());\n        }\n        return m;\n    }",
    "replace": "    static Map<String, String> invert(Map<String, String> source) {\n        if (source.isEmpty()) {\n            return Collections.emptyMap();\n        }\n        final Map<String, String> m = new HashMap<>(source.size());\n        for (Map.Entry<String, String> e : source.entrySet()) {\n            m.put(e.getValue(), e.getKey());\n        }\n        return m;\n    }"
  },
  {
    "filepath": "../kafka/connect/transforms/src/main/java/org/apache/kafka/connect/transforms/ReplaceField.java",
    "search": "    private R applySchemaless(R record) {\n        final Map<String, Object> value = requireMap(operatingValue(record), PURPOSE);\n\n        final Map<String, Object> updatedValue = new HashMap<>(value.size());\n\n        for (Map.Entry<String, Object> e : value.entrySet()) {\n            final String fieldName = e.getKey();\n            if (filter(fieldName)) {\n                final Object fieldValue = e.getValue();\n                updatedValue.put(renamed(fieldName), fieldValue);\n            }\n        }\n\n        return newRecord(record, null, updatedValue);\n    }",
    "replace": "    private R applySchemaless(R record) {\n        final Map<String, Object> value = requireMap(operatingValue(record), PURPOSE);\n\n        final Map<String, Object> updatedValue = new HashMap<>(value.size());\n\n        for (Map.Entry<String, Object> e : value.entrySet()) {\n            final String fieldName = e.getKey();\n            if (filter(fieldName)) {\n                final Object fieldValue = e.getValue();\n                updatedValue.put(renamed(fieldName), fieldValue);\n            }\n        }\n\n        return newRecord(record, null, updatedValue);\n    }"
  }
]
```