commit 2ed95c906a0c0a59e16683c234122bb52c6400f9
Author: amirhadadi <amirhadadi@hotmail.com>
Date:   Mon Oct 3 20:47:03 2022 +0300

    Optimize HpackStaticTable by using a perfect hash function (#12713)
    
    Motivation:
    
    HpackStaticTable performance can be improved by using a perfect hash function.
    
    Modifications:
    
    Use 2 tables, one for mapping header name -> index and one for mapping header name + value -> index.
    Choose the tables and the hash function in such a way that each entry maps to a single hash bucket.
    
    Results:
    
    Benchmark                                      (optimized)  Mode  Cnt   Score   Error  Units
    HpackStaticTableBenchmark.lookupHttp                 false  avgt   10  15.998 ± 1.646  ns/op
    HpackStaticTableBenchmark.lookupHttp                  true  avgt   10  10.457 ± 0.274  ns/op
    HpackStaticTableBenchmark.lookupHttps                false  avgt   10  20.942 ± 1.365  ns/op
    HpackStaticTableBenchmark.lookupHttps                 true  avgt   10  10.618 ± 0.138  ns/op
    HpackStaticTableBenchmark.lookupNameOnlyMatch        false  avgt   10  13.710 ± 0.273  ns/op
    HpackStaticTableBenchmark.lookupNameOnlyMatch         true  avgt   10   3.156 ± 0.052  ns/op
    HpackStaticTableBenchmark.lookupNoNameMatch          false  avgt   10   3.528 ± 0.047  ns/op
    HpackStaticTableBenchmark.lookupNoNameMatch           true  avgt   10   3.145 ± 0.031  ns/op
    
    Caveats:
    
    This implementation couples HpackStaticTable implementation to the implementation of AsciiString.hashCode, relying on the values it returns for the static table headers to yield a perfect hash function. If AsciiString.hashCode implementation changes, HpackStaticTable implementation will also need to change. Moreover, if AsciiString.hashCode can return different values on different platforms (maybe due to endianness) or in general in different jvm instances, then it invalidates the approach taken here (or at least makes its implementation much more complex).
    
    Co-authored-by: ahadadi <ahadadi@outbrain.com>
    Co-authored-by: Norman Maurer <norman_maurer@apple.com>

diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java
index 389d8ef150..666c14c3b1 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java
@@ -31,8 +31,8 @@
  */
 package io.netty.handler.codec.http2;
 
-import io.netty.handler.codec.UnsupportedValueConverter;
 import io.netty.util.AsciiString;
+import io.netty.util.internal.PlatformDependent;
 
 import java.util.Arrays;
 import java.util.List;
@@ -117,9 +117,53 @@ final class HpackStaticTable {
         return new HpackHeaderField(AsciiString.cached(name), AsciiString.cached(value));
     }
 
-    private static final CharSequenceMap<Integer> STATIC_INDEX_BY_NAME = createMap();
+    // The table size and bit shift are chosen so that each hash bucket contains a single header name.
+    private static final int HEADER_NAMES_TABLE_SIZE = 1 << 9;
 
-    private static final int MAX_SAME_NAME_FIELD_INDEX = maxSameNameFieldIndex();
+    private static final int HEADER_NAMES_TABLE_SHIFT = PlatformDependent.BIG_ENDIAN_NATIVE_ORDER ? 22 : 18;
+
+    // A table mapping header names to their associated indexes.
+    private static final HeaderNameIndex[] HEADER_NAMES = new HeaderNameIndex[HEADER_NAMES_TABLE_SIZE];
+    static {
+        // Iterate through the static table in reverse order to
+        // save the smallest index for a given name in the table.
+        for (int index = STATIC_TABLE.size(); index > 0; index--) {
+            HpackHeaderField entry = getEntry(index);
+            int bucket = headerNameBucket(entry.name);
+            HeaderNameIndex tableEntry = HEADER_NAMES[bucket];
+            if (tableEntry != null && !equalsVariableTime(tableEntry.name, entry.name)) {
+                // Can happen if AsciiString.hashCode changes
+                throw new IllegalStateException("Hash bucket collision between " +
+                  tableEntry.name + " and " + entry.name);
+            }
+            HEADER_NAMES[bucket] = new HeaderNameIndex(entry.name, index, entry.value.length() == 0);
+        }
+    }
+
+    // The table size and bit shift are chosen so that each hash bucket contains a single header.
+    private static final int HEADERS_WITH_NON_EMPTY_VALUES_TABLE_SIZE = 1 << 6;
+
+    private static final int HEADERS_WITH_NON_EMPTY_VALUES_TABLE_SHIFT =
+      PlatformDependent.BIG_ENDIAN_NATIVE_ORDER ? 0 : 6;
+
+    // A table mapping headers with non-empty values to their associated indexes.
+    private static final HeaderIndex[] HEADERS_WITH_NON_EMPTY_VALUES =
+      new HeaderIndex[HEADERS_WITH_NON_EMPTY_VALUES_TABLE_SIZE];
+    static {
+        for (int index = STATIC_TABLE.size(); index > 0; index--) {
+            HpackHeaderField entry = getEntry(index);
+            if (entry.value.length() > 0) {
+                int bucket = headerBucket(entry.value);
+                HeaderIndex tableEntry = HEADERS_WITH_NON_EMPTY_VALUES[bucket];
+                if (tableEntry != null) {
+                    // Can happen if AsciiString.hashCode changes
+                    throw new IllegalStateException("Hash bucket collision between " +
+                      tableEntry.value + " and " + entry.value);
+                }
+                HEADERS_WITH_NON_EMPTY_VALUES[bucket] = new HeaderIndex(entry.name, entry.value, index);
+            }
+        }
+    }
 
     /**
      * The number of header fields in the static table.
@@ -138,11 +182,8 @@ final class HpackStaticTable {
      * -1 if the header field name is not in the static table.
      */
     static int getIndex(CharSequence name) {
-        Integer index = STATIC_INDEX_BY_NAME.get(name);
-        if (index == null) {
-            return NOT_FOUND;
-        }
-        return index;
+        HeaderNameIndex entry = getEntry(name);
+        return entry == null ? NOT_FOUND : entry.index;
     }
 
     /**
@@ -150,70 +191,64 @@ final class HpackStaticTable {
      * header field is not in the static table.
      */
     static int getIndexInsensitive(CharSequence name, CharSequence value) {
-        int index = getIndex(name);
-        if (index == NOT_FOUND) {
+        if (value.length() == 0) {
+            HeaderNameIndex entry = getEntry(name);
+            return entry == null || !entry.emptyValue ? NOT_FOUND : entry.index;
+        }
+        int bucket = headerBucket(value);
+        HeaderIndex header = HEADERS_WITH_NON_EMPTY_VALUES[bucket];
+        if (header == null) {
             return NOT_FOUND;
         }
-
-        // Compare values for the first name match
-        HpackHeaderField entry = getEntry(index);
-        if (equalsVariableTime(value, entry.value)) {
-            return index;
+        if (equalsVariableTime(header.name, name) && equalsVariableTime(header.value, value)) {
+            return header.index;
         }
+        return NOT_FOUND;
+    }
 
-        // Note this assumes all entries for a given header field are sequential.
-        index++;
-        while (index <= MAX_SAME_NAME_FIELD_INDEX) {
-            entry = getEntry(index);
-            if (!equalsVariableTime(name, entry.name)) {
-                // As far as fields with the same name are placed in the table sequentially
-                // and INDEX_BY_NAME returns index of the fist position, - it's safe to
-                // exit immediately.
-                return NOT_FOUND;
-            }
-            if (equalsVariableTime(value, entry.value)) {
-                return index;
-            }
-            index++;
+    private static HeaderNameIndex getEntry(CharSequence name) {
+        int bucket = headerNameBucket(name);
+        HeaderNameIndex entry = HEADER_NAMES[bucket];
+        if (entry == null) {
+            return null;
         }
+        return equalsVariableTime(entry.name, name) ? entry : null;
+    }
 
-        return NOT_FOUND;
+    private static int headerNameBucket(CharSequence name) {
+        return bucket(name, HEADER_NAMES_TABLE_SHIFT, HEADER_NAMES_TABLE_SIZE - 1);
     }
 
-    // create a map CharSequenceMap header name to index value to allow quick lookup
-    private static CharSequenceMap<Integer> createMap() {
-        int length = STATIC_TABLE.size();
-        @SuppressWarnings("unchecked")
-        CharSequenceMap<Integer> ret = new CharSequenceMap<Integer>(true,
-                UnsupportedValueConverter.<Integer>instance(), length);
-        // Iterate through the static table in reverse order to
-        // save the smallest index for a given name in the map.
-        for (int index = length; index > 0; index--) {
-            HpackHeaderField entry = getEntry(index);
-            CharSequence name = entry.name;
-            ret.set(name, index);
+    private static int headerBucket(CharSequence value) {
+        return bucket(value, HEADERS_WITH_NON_EMPTY_VALUES_TABLE_SHIFT, HEADERS_WITH_NON_EMPTY_VALUES_TABLE_SIZE - 1);
+    }
+
+    private static int bucket(CharSequence s, int shift, int mask) {
+        return (AsciiString.hashCode(s) >> shift) & mask;
+    }
+
+    private static final class HeaderNameIndex {
+        final CharSequence name;
+        final int index;
+        final boolean emptyValue;
+
+        HeaderNameIndex(CharSequence name, int index, boolean emptyValue) {
+            this.name = name;
+            this.index = index;
+            this.emptyValue = emptyValue;
         }
-        return ret;
     }
 
-    /**
-     * Returns the last position in the array that contains multiple
-     * fields with the same name. Starting from this position, all
-     * names are unique. Similar to {@link #getIndexInsensitive(CharSequence, CharSequence)} method
-     * assumes all entries for a given header field are sequential
-     */
-    private static int maxSameNameFieldIndex() {
-        final int length = STATIC_TABLE.size();
-        HpackHeaderField cursor = getEntry(length);
-        for (int index = length - 1; index > 0; index--) {
-            HpackHeaderField entry = getEntry(index);
-            if (equalsVariableTime(entry.name, cursor.name)) {
-                return index + 1;
-            } else {
-                cursor = entry;
-            }
+    private static final class HeaderIndex {
+        final CharSequence name;
+        final CharSequence value;
+        final int index;
+
+        HeaderIndex(CharSequence name, CharSequence value, int index) {
+            this.name = name;
+            this.value = value;
+            this.index = index;
         }
-        return length;
     }
 
     // singleton
