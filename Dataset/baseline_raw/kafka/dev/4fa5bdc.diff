commit 4fa5bdcfe3cd49c96c1902cff82ce286c4eb96df
Author: Lucas Bradstreet <lucas@confluent.io>
Date:   Mon Mar 30 10:41:04 2020 -0700

    KAFKA-9685: PT2, avoid unnecessary set creation in ACL matching (#8382)
    
    #8261 went a long way to solving some of the ACL performance issues. I don't think
    we need to create sets at all for the `find` and `isEmpty` calls. ` testAuthorizer` is
    22% to 62% of the cost after this change:
    
    ```
    Before:
    Benchmark                                (aclCount)  (resourceCount)  Mode  Cnt   Score    Error  Units
    AclAuthorizerBenchmark.testAclsIterator           5             5000  avgt   15   0.430 ±  0.004  ms/op
    AclAuthorizerBenchmark.testAclsIterator           5            10000  avgt   15   0.980 ±  0.007  ms/op
    AclAuthorizerBenchmark.testAclsIterator           5            50000  avgt   15  11.191 ±  0.032  ms/op
    AclAuthorizerBenchmark.testAclsIterator          10             5000  avgt   15   0.880 ±  0.007  ms/op
    AclAuthorizerBenchmark.testAclsIterator          10            10000  avgt   15   2.642 ±  0.029  ms/op
    AclAuthorizerBenchmark.testAclsIterator          10            50000  avgt   15  26.361 ±  0.242  ms/op
    AclAuthorizerBenchmark.testAclsIterator          15             5000  avgt   15   1.655 ±  0.024  ms/op
    AclAuthorizerBenchmark.testAclsIterator          15            10000  avgt   15   5.276 ±  0.041  ms/op
    AclAuthorizerBenchmark.testAclsIterator          15            50000  avgt   15  40.702 ±  0.574  ms/op
    AclAuthorizerBenchmark.testAuthorizer             5             5000  avgt   15   0.202 ±  0.001  ms/op
    AclAuthorizerBenchmark.testAuthorizer             5            10000  avgt   15   0.233 ±  0.001  ms/op
    AclAuthorizerBenchmark.testAuthorizer             5            50000  avgt   15   0.424 ±  0.001  ms/op
    AclAuthorizerBenchmark.testAuthorizer            10             5000  avgt   15   0.202 ±  0.001  ms/op
    AclAuthorizerBenchmark.testAuthorizer            10            10000  avgt   15   0.253 ±  0.001  ms/op
    AclAuthorizerBenchmark.testAuthorizer            10            50000  avgt   15   0.423 ±  0.001  ms/op
    AclAuthorizerBenchmark.testAuthorizer            15             5000  avgt   15   0.198 ±  0.001  ms/op
    AclAuthorizerBenchmark.testAuthorizer            15            10000  avgt   15   0.242 ±  0.001  ms/op
    AclAuthorizerBenchmark.testAuthorizer            15            50000  avgt   15   0.391 ±  0.002  ms/op
    JMH benchmarks done
    
    After:
    Benchmark                                (aclCount)  (resourceCount)  Mode  Cnt   Score    Error  Units
    AclAuthorizerBenchmark.testAclsIterator           5             5000  avgt   15   0.504 ±  0.164  ms/op
    AclAuthorizerBenchmark.testAclsIterator           5            10000  avgt   15   1.038 ±  0.271  ms/op
    AclAuthorizerBenchmark.testAclsIterator           5            50000  avgt   15  11.767 ±  0.028  ms/op
    AclAuthorizerBenchmark.testAclsIterator          10             5000  avgt   15   0.827 ±  0.016  ms/op
    AclAuthorizerBenchmark.testAclsIterator          10            10000  avgt   15   2.801 ±  0.027  ms/op
    AclAuthorizerBenchmark.testAclsIterator          10            50000  avgt   15  26.157 ±  0.191  ms/op
    AclAuthorizerBenchmark.testAclsIterator          15             5000  avgt   15   1.814 ±  0.053  ms/op
    AclAuthorizerBenchmark.testAclsIterator          15            10000  avgt   15   5.420 ±  0.065  ms/op
    AclAuthorizerBenchmark.testAclsIterator          15            50000  avgt   15  41.372 ±  0.659  ms/op
    AclAuthorizerBenchmark.testAuthorizer             5             5000  avgt   15   0.064 ±  0.001  ms/op
    AclAuthorizerBenchmark.testAuthorizer             5            10000  avgt   15   0.070 ±  0.001  ms/op
    AclAuthorizerBenchmark.testAuthorizer             5            50000  avgt   15   0.240 ±  0.001  ms/op
    AclAuthorizerBenchmark.testAuthorizer            10             5000  avgt   15   0.055 ±  0.001  ms/op
    AclAuthorizerBenchmark.testAuthorizer            10            10000  avgt   15   0.084 ±  0.001  ms/op
    AclAuthorizerBenchmark.testAuthorizer            10            50000  avgt   15   0.249 ±  0.001  ms/op
    AclAuthorizerBenchmark.testAuthorizer            15             5000  avgt   15   0.057 ±  0.001  ms/op
    AclAuthorizerBenchmark.testAuthorizer            15            10000  avgt   15   0.084 ±  0.001  ms/op
    AclAuthorizerBenchmark.testAuthorizer            15            50000  avgt   15   0.243 ±  0.001  ms/op
    ```
    
    Reviewers: Ismael Juma <ismael@juma.me.uk>

diff --git a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
index 58860be864..53e715b5bb 100644
--- a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
+++ b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
@@ -21,7 +21,7 @@ import java.util.concurrent.{CompletableFuture, CompletionStage}
 
 import com.typesafe.scalalogging.Logger
 import kafka.api.KAFKA_2_0_IV1
-import kafka.security.authorizer.AclAuthorizer.{AclSets, ResourceOrdering, VersionedAcls}
+import kafka.security.authorizer.AclAuthorizer.{AclBuffers, ResourceOrdering, VersionedAcls}
 import kafka.security.authorizer.AclEntry.ResourceSeparator
 import kafka.server.{KafkaConfig, KafkaServer}
 import kafka.utils._
@@ -62,9 +62,9 @@ object AclAuthorizer {
     def exists: Boolean = zkVersion != ZkVersion.UnknownVersion
   }
 
-  class AclSets(sets: Set[AclEntry]*) {
-    def find(p: AclEntry => Boolean): Option[AclEntry] = sets.flatMap(_.find(p)).headOption
-    def isEmpty: Boolean = !sets.exists(_.nonEmpty)
+  class AclBuffers(classes: mutable.Buffer[AclEntry]*) {
+    def find(p: AclEntry => Boolean): Option[AclEntry] = classes.flatMap(_.find(p)).headOption
+    def isEmpty: Boolean = !classes.exists(_.nonEmpty)
   }
 
   val NoAcls = VersionedAcls(Set.empty, ZkVersion.UnknownVersion)
@@ -295,7 +295,7 @@ class AclAuthorizer extends Authorizer with Logging {
     val host = requestContext.clientAddress.getHostAddress
     val operation = action.operation
 
-    def isEmptyAclAndAuthorized(acls: AclSets): Boolean = {
+    def isEmptyAclAndAuthorized(acls: AclBuffers): Boolean = {
       if (acls.isEmpty) {
         // No ACLs found for this resource, permission is determined by value of config allow.everyone.if.no.acl.found
         authorizerLogger.debug(s"No acl found for resource $resource, authorized = $shouldAllowEveryoneIfNoAclIsFound")
@@ -303,12 +303,12 @@ class AclAuthorizer extends Authorizer with Logging {
       } else false
     }
 
-    def denyAclExists(acls: AclSets): Boolean = {
+    def denyAclExists(acls: AclBuffers): Boolean = {
       // Check if there are any Deny ACLs which would forbid this operation.
       matchingAclExists(operation, resource, principal, host, DENY, acls)
     }
 
-    def allowAclExists(acls: AclSets): Boolean = {
+    def allowAclExists(acls: AclBuffers): Boolean = {
       // Check if there are any Allow ACLs which would allow this operation.
       // Allowing read, write, delete, or alter implies allowing describe.
       // See #{org.apache.kafka.common.acl.AclOperation} for more details about ACL inheritance.
@@ -341,26 +341,26 @@ class AclAuthorizer extends Authorizer with Logging {
     } else false
   }
 
-  private def matchingAcls(resourceType: ResourceType, resourceName: String): AclSets = {
+  private def matchingAcls(resourceType: ResourceType, resourceName: String): AclBuffers = {
     // save aclCache reference to a local val to get a consistent view of the cache during acl updates.
     val aclCacheSnapshot = aclCache
     val wildcard = aclCacheSnapshot.get(new ResourcePattern(resourceType, ResourcePattern.WILDCARD_RESOURCE, PatternType.LITERAL))
-      .map(_.acls)
-      .getOrElse(Set.empty)
+      .map(_.acls.toBuffer)
+      .getOrElse(mutable.Buffer.empty)
 
     val literal = aclCacheSnapshot.get(new ResourcePattern(resourceType, resourceName, PatternType.LITERAL))
-      .map(_.acls)
-      .getOrElse(Set.empty)
+      .map(_.acls.toBuffer)
+      .getOrElse(mutable.Buffer.empty)
 
     val prefixed = aclCacheSnapshot
       .from(new ResourcePattern(resourceType, resourceName, PatternType.PREFIXED))
       .to(new ResourcePattern(resourceType, resourceName.take(1), PatternType.PREFIXED))
       .filterKeys(resource => resourceName.startsWith(resource.name))
       .values
-      .flatMap { _.acls }
-      .toSet
+      .flatMap { _.acls.toBuffer }
+      .toBuffer
 
-    new AclSets(prefixed, wildcard, literal)
+    new AclBuffers(prefixed, wildcard, literal)
   }
 
   private def matchingAclExists(operation: AclOperation,
@@ -368,7 +368,7 @@ class AclAuthorizer extends Authorizer with Logging {
                                 principal: KafkaPrincipal,
                                 host: String,
                                 permissionType: AclPermissionType,
-                                acls: AclSets): Boolean = {
+                                acls: AclBuffers): Boolean = {
     acls.find { acl =>
       acl.permissionType == permissionType &&
         (acl.kafkaPrincipal == principal || acl.kafkaPrincipal == AclEntry.WildcardPrincipal) &&
