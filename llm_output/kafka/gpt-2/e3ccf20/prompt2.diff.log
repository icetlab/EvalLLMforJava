I’ve optimized the hot‐path in `authorizeAction` by replacing the single merged `Set` creation with direct read‐lock retrieval of the three ACL subsets (wildcard, literal, prefixed) and then performing existence checks on those, avoiding expensive `++` and large `HashCode` computation.

```json
[
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "    def aclsAllowAccess = {\n      //we allow an operation if no acls are found and user has configured to allow all users\n      //when no acls are found or if no deny acls are found and at least one allow acls matches.\n      val acls = matchingAcls(resource.resourceType, resource.name)\n      isEmptyAclAndAuthorized(acls) || (!denyAclExists(acls) && allowAclExists(acls))\n    }",
    "replace": "    def aclsAllowAccess = {\n      val (wildcardAcls, literalAcls, prefixedAcls) = inReadLock(lock) {\n        val wildcardSet = aclCache.get(new ResourcePattern(resource.resourceType, ResourcePattern.WILDCARD_RESOURCE, PatternType.LITERAL))\n          .map(_.acls).getOrElse(Set.empty)\n        val literalSet = aclCache.get(new ResourcePattern(resource.resourceType, resource.name, PatternType.LITERAL))\n          .map(_.acls).getOrElse(Set.empty)\n        val prefixedSet = aclCache\n          .from(new ResourcePattern(resource.resourceType, resource.name, PatternType.PREFIXED))\n          .to(new ResourcePattern(resource.resourceType, resource.name.take(1), PatternType.PREFIXED))\n          .filterKeys(rp => resource.name.startsWith(rp.name))\n          .values.flatMap(_.acls).toSet\n        (wildcardSet, literalSet, prefixedSet)\n      }\n      val emptyAcls = wildcardAcls.isEmpty && literalAcls.isEmpty && prefixedAcls.isEmpty\n      if (emptyAcls) {\n        authorizerLogger.debug(s\"No acl found for resource $resource, authorized = $shouldAllowEveryoneIfNoAclIsFound\")\n        shouldAllowEveryoneIfNoAclIsFound\n      } else {\n        val denyExists = Seq(literalAcls, wildcardAcls, prefixedAcls)\n          .exists(set => matchingAclExists(operation, resource, principal, host, DENY, set))\n        if (denyExists) false\n        else {\n          val allowOps = operation match {\n            case DESCRIBE => Set(DESCRIBE, READ, WRITE, DELETE, ALTER)\n            case DESCRIBE_CONFIGS => Set(DESCRIBE_CONFIGS, ALTER_CONFIGS)\n            case _ => Set(operation)\n          }\n          allowOps.exists(op => Seq(literalAcls, wildcardAcls, prefixedAcls)\n            .exists(set => matchingAclExists(op, resource, principal, host, ALLOW, set)))\n        }\n      }\n    }"
  }
]
```