I’ve replaced the shared scala.util.Random with java’s ThreadLocalRandom to avoid contention and improve backoff jitter performance. Below are the two atomic changes.

```json
[
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "import scala.util.{Failure, Random, Success, Try}",
    "replace": "import scala.util.{Failure, Success, Try}\nimport java.util.concurrent.ThreadLocalRandom"
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "private def backoffTime = {\n    retryBackoffMs + Random.nextInt(retryBackoffJitterMs)\n  }",
    "replace": "private def backoffTime = {\n    retryBackoffMs + ThreadLocalRandom.current().nextInt(retryBackoffJitterMs)\n  }"
  }
]
```