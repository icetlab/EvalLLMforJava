Iâ€™ve optimized the hot paths in both `makeLeader` and `makeFollower` by avoiding unnecessary calls to `createLogIfNotExists` when a log already exists. This should reduce contention and allocation in benchmarks without altering behavior.

```json
[
  {
    "filepath": "../kafka/core/src/main/scala/kafka/cluster/Partition.scala",
    "search": "    updateAssignmentAndIsr(\n        assignment = partitionState.replicas.asScala.iterator.map(_.toInt).toSeq,\n        isr = Set.empty[Int],\n        addingReplicas = partitionState.addingReplicas.asScala.map(_.toInt),\n        removingReplicas = partitionState.removingReplicas.asScala.map(_.toInt)\n      )\n      createLogIfNotExists(localBrokerId, partitionState.isNew, isFutureReplica = false, highWatermarkCheckpoints)",
    "replace": "    updateAssignmentAndIsr(\n        assignment = partitionState.replicas.asScala.iterator.map(_.toInt).toSeq,\n        isr = Set.empty[Int],\n        addingReplicas = partitionState.addingReplicas.asScala.map(_.toInt),\n        removingReplicas = partitionState.removingReplicas.asScala.map(_.toInt)\n      )\n      // Only initialize log if it doesn't already exist to save work on repeated calls\n      if (log.isEmpty)\n        createLogIfNotExists(localBrokerId, partitionState.isNew, isFutureReplica = false, highWatermarkCheckpoints)"
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/cluster/Partition.scala",
    "search": "      updateAssignmentAndIsr(\n        assignment = partitionState.replicas.asScala.map(_.toInt),\n        isr = partitionState.isr.asScala.map(_.toInt).toSet,\n        addingReplicas = partitionState.addingReplicas.asScala.map(_.toInt),\n        removingReplicas = partitionState.removingReplicas.asScala.map(_.toInt)\n      )\n      createLogIfNotExists(localBrokerId, partitionState.isNew, isFutureReplica = false, highWatermarkCheckpoints)",
    "replace": "      updateAssignmentAndIsr(\n        assignment = partitionState.replicas.asScala.map(_.toInt),\n        isr = partitionState.isr.asScala.map(_.toInt).toSet,\n        addingReplicas = partitionState.addingReplicas.asScala.map(_.toInt),\n        removingReplicas = partitionState.removingReplicas.asScala.map(_.toInt)\n      )\n      // Only initialize log if it doesn't already exist to save work on repeated calls\n      if (log.isEmpty)\n        createLogIfNotExists(localBrokerId, partitionState.isNew, isFutureReplica = false, highWatermarkCheckpoints)"
  }
]
```