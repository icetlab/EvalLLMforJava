Iâ€™ve corrected the prefix-range lookup in `matchingAcls` to a proper filter over all PREFIXED entries, and updated the principal comparison in `matchingAclExists` to match on type/name rather than object identity.

```json
[
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "    val prefixed = aclCacheSnapshot\n      .from(new ResourcePattern(resourceType, resourceName, PatternType.PREFIXED))\n      .to(new ResourcePattern(resourceType, resourceName.take(1), PatternType.PREFIXED))\n      .filterKeys(resource => resourceName.startsWith(resource.name))\n      .values\n      .flatMap { _.acls }\n      .toSet",
    "replace": "    val prefixed = aclCacheSnapshot\n      .filter { case (rp, versioned) =>\n        rp.resourceType == resourceType && rp.patternType == PatternType.PREFIXED && resourceName.startsWith(rp.name)\n      }\n      .values\n      .flatMap(_.acls)\n      .toSet"
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "(acl.kafkaPrincipal == principal || acl.kafkaPrincipal == AclEntry.WildcardPrincipal)",
    "replace": "((acl.kafkaPrincipal.getPrincipalType == principal.getPrincipalType && acl.kafkaPrincipal.getName == principal.getName) || acl.kafkaPrincipal == AclEntry.WildcardPrincipal)"
  }
]
```