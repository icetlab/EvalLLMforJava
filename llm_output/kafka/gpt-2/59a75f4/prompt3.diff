diff --git a/clients/src/main/java/org/apache/kafka/common/internals/PartitionStates.java b/clients/src/main/java/org/apache/kafka/common/internals/PartitionStates.java
index c289eaa59b..0106fd2606 100644
--- a/clients/src/main/java/org/apache/kafka/common/internals/PartitionStates.java
+++ b/clients/src/main/java/org/apache/kafka/common/internals/PartitionStates.java
@@ -43,7 +43,7 @@ import java.util.stream.Stream;
  */
 public class PartitionStates<S> {
 
-    private final LinkedHashMap<TopicPartition, S> map = new LinkedHashMap<>();
+    private final LinkedHashMap<TopicPartition, S> map = new LinkedHashMap<>(16, 0.75f, true);
     private final Set<TopicPartition> partitionSetView = Collections.unmodifiableSet(map.keySet());
 
     /* the number of partitions that are currently assigned available in a thread safe manner */
@@ -52,13 +52,12 @@ public class PartitionStates<S> {
     public PartitionStates() {}
 
     public void moveToEnd(TopicPartition topicPartition) {
-        S state = map.remove(topicPartition);
-        if (state != null)
-            map.put(topicPartition, state);
+        // Accessing the entry moves it to the end in accessOrder mode
+        map.get(topicPartition);
     }
 
     public void updateAndMoveToEnd(TopicPartition topicPartition, S state) {
-        map.remove(topicPartition);
+        // put in accessOrder map moves existing entries to end or inserts new ones at end
         map.put(topicPartition, state);
         updateSize();
     }
@@ -139,15 +138,16 @@ public class PartitionStates<S> {
     }
 
     private void update(Map<TopicPartition, S> partitionToState) {
-        LinkedHashMap<String, List<TopicPartition>> topicToPartitions = new LinkedHashMap<>();
-        for (TopicPartition tp : partitionToState.keySet()) {
-            List<TopicPartition> partitions = topicToPartitions.computeIfAbsent(tp.topic(), k -> new ArrayList<>());
-            partitions.add(tp);
-        }
-        for (Map.Entry<String, List<TopicPartition>> entry : topicToPartitions.entrySet()) {
-            for (TopicPartition tp : entry.getValue()) {
-                S state = partitionToState.get(tp);
-                map.put(tp, state);
+        LinkedHashMap<String, List<Map.Entry<TopicPartition, S>>> topicToEntries = new LinkedHashMap<>();
+        for (Map.Entry<TopicPartition, S> e : partitionToState.entrySet()) {
+            TopicPartition tp = e.getKey();
+            S state = e.getValue();
+            List<Map.Entry<TopicPartition, S>> entries = topicToEntries.computeIfAbsent(tp.topic(), k -> new ArrayList<>());
+            entries.add(e);
+        }
+        for (List<Map.Entry<TopicPartition, S>> entries : topicToEntries.values()) {
+            for (Map.Entry<TopicPartition, S> e : entries) {
+                map.put(e.getKey(), e.getValue());
             }
         }
     }
