Overall intent: Replace expensive stream-based removal in `removeExpiredProducers` with iterator-based loops to reduce allocations, and simplify `firstUnstableOffset` to avoid extra Optional allocations.

```json
[
  {
    "filepath": "../kafka/storage/src/main/java/org/apache/kafka/storage/internals/log/ProducerStateManager.java",
    "search": "public void removeExpiredProducers(long currentTimeMs) {\n        List<Long> keys = producers.entrySet().stream()\n                .filter(entry -> isProducerExpired(currentTimeMs, entry.getValue()))\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toList());\n        removeProducerIds(keys);\n\n        List<Long> verificationKeys = verificationStates.entrySet().stream()\n                .filter(entry -> currentTimeMs - entry.getValue().timestamp() >= producerStateManagerConfig.producerIdExpirationMs())\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toList());\n        verificationKeys.forEach(verificationStates::remove);\n    }",
    "replace": "public void removeExpiredProducers(long currentTimeMs) {\n        // Remove expired producers without intermediate collections\n        Iterator<Map.Entry<Long, ProducerStateEntry>> prodIter = producers.entrySet().iterator();\n        while (prodIter.hasNext()) {\n            Map.Entry<Long, ProducerStateEntry> entry = prodIter.next();\n            if (isProducerExpired(currentTimeMs, entry.getValue())) {\n                prodIter.remove();\n            }\n        }\n        producerIdCount = producers.size();\n\n        // Remove expired verification states\n        long expiration = producerStateManagerConfig.producerIdExpirationMs();\n        Iterator<Map.Entry<Long, VerificationStateEntry>> verifIter = verificationStates.entrySet().iterator();\n        while (verifIter.hasNext()) {\n            Map.Entry<Long, VerificationStateEntry> entry = verifIter.next();\n            if (currentTimeMs - entry.getValue().timestamp() >= expiration) {\n                verifIter.remove();\n            }\n        }\n    }"
  },
  {
    "filepath": "../kafka/storage/src/main/java/org/apache/kafka/storage/internals/log/ProducerStateManager.java",
    "search": "public Optional<LogOffsetMetadata> firstUnstableOffset() {\n        Optional<LogOffsetMetadata> unreplicatedFirstOffset = Optional.ofNullable(unreplicatedTxns.firstEntry()).map(e -> e.getValue().firstOffset);\n        Optional<LogOffsetMetadata> undecidedFirstOffset = Optional.ofNullable(ongoingTxns.firstEntry()).map(e -> e.getValue().firstOffset);\n\n        if (!unreplicatedFirstOffset.isPresent())\n            return undecidedFirstOffset;\n        else if (!undecidedFirstOffset.isPresent())\n            return unreplicatedFirstOffset;\n        else if (undecidedFirstOffset.get().messageOffset < unreplicatedFirstOffset.get().messageOffset)\n            return undecidedFirstOffset;\n        else\n            return unreplicatedFirstOffset;\n    }",
    "replace": "public Optional<LogOffsetMetadata> firstUnstableOffset() {\n        Map.Entry<Long, TxnMetadata> unrepEntry = unreplicatedTxns.firstEntry();\n        Map.Entry<Long, TxnMetadata> undecEntry = ongoingTxns.firstEntry();\n\n        if (unrepEntry == null) {\n            return undecEntry == null ? Optional.empty() : Optional.of(undecEntry.getValue().firstOffset);\n        }\n        if (undecEntry == null) {\n            return Optional.of(unrepEntry.getValue().firstOffset);\n        }\n        LogOffsetMetadata undecOffset = undecEntry.getValue().firstOffset;\n        LogOffsetMetadata unrepOffset = unrepEntry.getValue().firstOffset;\n        return undecOffset.messageOffset < unrepOffset.messageOffset\n                ? Optional.of(undecOffset)\n                : Optional.of(unrepOffset);\n    }"
  }
]
```