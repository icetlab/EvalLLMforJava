diff --git a/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java b/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java
index 679b59249d..c2e8bab5e8 100644
--- a/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java
+++ b/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java
@@ -33,6 +33,19 @@ public final class Checksums {
     private Checksums() {
     }
 
+    private static final java.lang.reflect.Method UPDATE_BYTEBUFFER_METHOD;
+
+    static {
+        java.lang.reflect.Method m = null;
+        try {
+            Class<?> c = Class.forName("java.util.zip.CRC32C");
+            m = c.getMethod("update", java.nio.ByteBuffer.class);
+        } catch (Exception e) {
+            // No optimized CRC32C available
+        }
+        UPDATE_BYTEBUFFER_METHOD = m;
+    }
+
     public static void update(Checksum checksum, ByteBuffer buffer, int length) {
         update(checksum, buffer, 0, length);
     }
@@ -40,6 +53,17 @@ public final class Checksums {
     public static void update(Checksum checksum, ByteBuffer buffer, int offset, int length) {
         if (buffer.hasArray()) {
             checksum.update(buffer.array(), buffer.position() + buffer.arrayOffset() + offset, length);
+        } else if (UPDATE_BYTEBUFFER_METHOD != null && checksum.getClass() == UPDATE_BYTEBUFFER_METHOD.getDeclaringClass()) {
+            ByteBuffer dup = buffer.duplicate();
+            dup.position(buffer.position() + offset);
+            dup.limit(buffer.position() + offset + length);
+            try {
+                UPDATE_BYTEBUFFER_METHOD.invoke(checksum, dup);
+            } catch (Exception e) {
+                int start = buffer.position() + offset;
+                for (int i = start; i < start + length; i++)
+                    checksum.update(buffer.get(i));
+            }
         } else {
             int start = buffer.position() + offset;
             for (int i = start; i < start + length; i++)
