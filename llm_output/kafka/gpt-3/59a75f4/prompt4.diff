diff --git a/core/src/main/scala/kafka/server/AbstractFetcherThread.scala b/core/src/main/scala/kafka/server/AbstractFetcherThread.scala
index 0f3b06952a..c24e8f49e2 100755
--- a/core/src/main/scala/kafka/server/AbstractFetcherThread.scala
+++ b/core/src/main/scala/kafka/server/AbstractFetcherThread.scala
@@ -435,8 +435,22 @@ abstract class AbstractFetcherThread(name: String,
     * @param fetchOffsets the partitions to update fetch offset and maybe mark truncation complete
     */
   private def updateFetchOffsetAndMaybeMarkTruncationComplete(fetchOffsets: Map[TopicPartition, OffsetTruncationState]): Unit = {
-    val newStates: Map[TopicPartition, PartitionFetchState] = partitionStates.partitionStates.asScala
-      .map { state =>
+  // Efficiently update partitionStates without creating intermediate PartitionState objects
+  val newStates = new java.util.LinkedHashMap[TopicPartition, PartitionFetchState]()
+  partitionStates.partitionStateMap.forEach(new BiConsumer[TopicPartition, PartitionFetchState] {
+    override def accept(tp: TopicPartition, currentFetchState: PartitionFetchState): Unit = {
+      val newState = fetchOffsets.get(tp) match {
+        case Some(offsetTruncationState) =>
+          val stateType = if (offsetTruncationState.truncationCompleted) Fetching else Truncating
+          PartitionFetchState(offsetTruncationState.offset, currentFetchState.lag,
+            currentFetchState.currentLeaderEpoch, currentFetchState.delay, stateType)
+        case None => currentFetchState
+      }
+      newStates.put(tp, newState)
+    }
+  })
+  partitionStates.set(newStates)
+}
         val currentFetchState = state.value
         val maybeTruncationComplete = fetchOffsets.get(state.topicPartition) match {
           case Some(offsetTruncationState) =>
@@ -648,7 +662,13 @@ abstract class AbstractFetcherThread(name: String,
   }
 
   private[server] def partitionsAndOffsets: Map[TopicPartition, InitialFetchState] = inLock(partitionMapLock) {
-    partitionStates.partitionStates.asScala.map { state =>
+  // Use partitionStateMap directly to avoid creating PartitionState wrappers
+  partitionStates.partitionStateMap.asScala.map { case (tp, state) =>
+    tp -> InitialFetchState(sourceBroker,
+      currentLeaderEpoch = state.currentLeaderEpoch,
+      initOffset = state.fetchOffset)
+  }.toMap
+}
       val initialFetchState = InitialFetchState(sourceBroker,
         currentLeaderEpoch = state.value.currentLeaderEpoch,
         initOffset = state.value.fetchOffset)
