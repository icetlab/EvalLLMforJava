I have optimized the AbstractFetcherThread to eliminate intermediate `PartitionState` allocations by leveraging the existing `partitionStateMap` directly in both `updateFetchOffsetAndMaybeMarkTruncationComplete` and `partitionsAndOffsets`. This reduces object churn and simplifies the update logic.

```json
[
  {
    "filepath": "../kafka/core/src/main/scala/kafka/server/AbstractFetcherThread.scala",
    "search": "private def updateFetchOffsetAndMaybeMarkTruncationComplete(fetchOffsets: Map[TopicPartition, OffsetTruncationState]): Unit = {\n    val newStates: Map[TopicPartition, PartitionFetchState] = partitionStates.partitionStates.asScala\n      .map { state =>",
    "replace": "private def updateFetchOffsetAndMaybeMarkTruncationComplete(fetchOffsets: Map[TopicPartition, OffsetTruncationState]): Unit = {\n  // Efficiently update partitionStates without creating intermediate PartitionState objects\n  val newStates = new java.util.LinkedHashMap[TopicPartition, PartitionFetchState]()\n  partitionStates.partitionStateMap.forEach(new BiConsumer[TopicPartition, PartitionFetchState] {\n    override def accept(tp: TopicPartition, currentFetchState: PartitionFetchState): Unit = {\n      val newState = fetchOffsets.get(tp) match {\n        case Some(offsetTruncationState) =>\n          val stateType = if (offsetTruncationState.truncationCompleted) Fetching else Truncating\n          PartitionFetchState(offsetTruncationState.offset, currentFetchState.lag,\n            currentFetchState.currentLeaderEpoch, currentFetchState.delay, stateType)\n        case None => currentFetchState\n      }\n      newStates.put(tp, newState)\n    }\n  })\n  partitionStates.set(newStates)\n}"
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/server/AbstractFetcherThread.scala",
    "search": "private[server] def partitionsAndOffsets: Map[TopicPartition, InitialFetchState] = inLock(partitionMapLock) {\n    partitionStates.partitionStates.asScala.map { state =>",
    "replace": "private[server] def partitionsAndOffsets: Map[TopicPartition, InitialFetchState] = inLock(partitionMapLock) {\n  // Use partitionStateMap directly to avoid creating PartitionState wrappers\n  partitionStates.partitionStateMap.asScala.map { case (tp, state) =>\n    tp -> InitialFetchState(sourceBroker,\n      currentLeaderEpoch = state.currentLeaderEpoch,\n      initOffset = state.fetchOffset)\n  }.toMap\n}"
  }
]
```