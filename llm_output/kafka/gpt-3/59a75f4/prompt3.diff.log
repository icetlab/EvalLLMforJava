I’ve optimized the partition reordering by switching to an access‐order LinkedHashMap, which allows moving entries to the end on access instead of costly remove+put operations. The changes simplify moveToEnd and updateAndMoveToEnd to single operations and improve performance.

```json
[
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/internals/PartitionStates.java",
    "search": "private final LinkedHashMap<TopicPartition, S> map = new LinkedHashMap<>();",
    "replace": "private final LinkedHashMap<TopicPartition, S> map = new LinkedHashMap<>(16, 0.75f, true);"
  },
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/internals/PartitionStates.java",
    "search": "public void moveToEnd(TopicPartition topicPartition) {\n        S state = map.remove(topicPartition);\n        if (state != null)\n            map.put(topicPartition, state);\n    }",
    "replace": "public void moveToEnd(TopicPartition topicPartition) {\n        // Access-order map will move an existing key to the end on get()\n        map.get(topicPartition);\n    }"
  },
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/internals/PartitionStates.java",
    "search": "public void updateAndMoveToEnd(TopicPartition topicPartition, S state) {\n        map.remove(topicPartition);\n        map.put(topicPartition, state);\n        updateSize();\n    }",
    "replace": "public void updateAndMoveToEnd(TopicPartition topicPartition, S state) {\n        // put(...) on an access-order map updates value and moves key to end\n        map.put(topicPartition, state);\n        updateSize();\n    }"
  }
]
```