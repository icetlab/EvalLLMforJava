I have optimized the producer ID count maintenance to avoid repeated map size calculations and eliminated temporary collections in the expiration logic by using iterator-based removal.

```json
[
  {
    "filepath": "../kafka/storage/src/main/java/org/apache/kafka/storage/internals/log/ProducerStateManager.java",
    "search": "private void addProducerId(long producerId, ProducerStateEntry entry) {\n        producers.put(producerId, entry);\n        producerIdCount = producers.size();\n    }",
    "replace": "private void addProducerId(long producerId, ProducerStateEntry entry) {\n        // Only increment count if this is a new producer ID\n        if (producers.put(producerId, entry) == null) {\n            producerIdCount++;\n        }\n    }"
  },
  {
    "filepath": "../kafka/storage/src/main/java/org/apache/kafka/storage/internals/log/ProducerStateManager.java",
    "search": "private void removeProducerIds(List<Long> keys) {\n        keys.forEach(producers::remove);\n        producerIdCount = producers.size();\n    }",
    "replace": "private void removeProducerIds(List<Long> keys) {\n        // Remove each ID and decrement count for each removed entry\n        for (Long key : keys) {\n            if (producers.remove(key) != null) {\n                producerIdCount--;\n            }\n        }\n    }"
  },
  {
    "filepath": "../kafka/storage/src/main/java/org/apache/kafka/storage/internals/log/ProducerStateManager.java",
    "search": "public void removeExpiredProducers(long currentTimeMs) {\n        List<Long> keys = producers.entrySet().stream()\n                .filter(entry -> isProducerExpired(currentTimeMs, entry.getValue()))\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toList());\n        removeProducerIds(keys);\n\n        List<Long> verificationKeys = verificationStates.entrySet().stream()\n                .filter(entry -> currentTimeMs - entry.getValue().timestamp() >= producerStateManagerConfig.producerIdExpirationMs())\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toList());\n        verificationKeys.forEach(verificationStates::remove);\n    }",
    "replace": "public void removeExpiredProducers(long currentTimeMs) {\n        // Remove expired producer IDs directly via iterator to avoid temporary collections\n        Iterator<Map.Entry<Long, ProducerStateEntry>> it = producers.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry<Long, ProducerStateEntry> entry = it.next();\n            if (isProducerExpired(currentTimeMs, entry.getValue())) {\n                it.remove();\n            }\n        }\n        producerIdCount = producers.size();\n\n        // Remove expired verification entries directly via iterator\n        long expirationMs = producerStateManagerConfig.producerIdExpirationMs();\n        Iterator<Map.Entry<Long, VerificationStateEntry>> vit = verificationStates.entrySet().iterator();\n        while (vit.hasNext()) {\n            Map.Entry<Long, VerificationStateEntry> entry = vit.next();\n            if (currentTimeMs - entry.getValue().timestamp() >= expirationMs) {\n                vit.remove();\n            }\n        }\n    }"
  }
]
```