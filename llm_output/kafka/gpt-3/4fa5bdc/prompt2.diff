diff --git a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
index 58860be864..899c7a5625 100644
--- a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
+++ b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
@@ -62,9 +62,25 @@ object AclAuthorizer {
     def exists: Boolean = zkVersion != ZkVersion.UnknownVersion
   }
 
-  class AclSets(sets: Set[AclEntry]*) {
-    def find(p: AclEntry => Boolean): Option[AclEntry] = sets.flatMap(_.find(p)).headOption
-    def isEmpty: Boolean = !sets.exists(_.nonEmpty)
+  class AclSets(sets: Iterable[AclEntry]*) {
+    def find(p: AclEntry => Boolean): Option[AclEntry] = {
+      var idx = 0
+      while (idx < sets.length) {
+        val s = sets(idx)
+        val result = s.find(p)
+        if (result.isDefined) return result
+        idx += 1
+      }
+      None
+    }
+    def isEmpty: Boolean = {
+      var idx = 0
+      while (idx < sets.length) {
+        if (sets(idx).nonEmpty) return false
+        idx += 1
+      }
+      true
+    }
   }
 
   val NoAcls = VersionedAcls(Set.empty, ZkVersion.UnknownVersion)
@@ -355,10 +371,9 @@ class AclAuthorizer extends Authorizer with Logging {
     val prefixed = aclCacheSnapshot
       .from(new ResourcePattern(resourceType, resourceName, PatternType.PREFIXED))
       .to(new ResourcePattern(resourceType, resourceName.take(1), PatternType.PREFIXED))
-      .filterKeys(resource => resourceName.startsWith(resource.name))
+      .filter { case (pattern, versionedAcls) => resourceName.startsWith(pattern.name) }
       .values
-      .flatMap { _.acls }
-      .toSet
+      .flatMap(_.acls)
 
     new AclSets(prefixed, wildcard, literal)
   }
