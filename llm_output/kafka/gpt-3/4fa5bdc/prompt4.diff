diff --git a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
index 58860be864..715923907a 100644
--- a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
+++ b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
@@ -63,7 +63,18 @@ object AclAuthorizer {
   }
 
   class AclSets(sets: Set[AclEntry]*) {
-    def find(p: AclEntry => Boolean): Option[AclEntry] = sets.flatMap(_.find(p)).headOption
+    def find(p: AclEntry => Boolean): Option[AclEntry] = {
+      val it = sets.iterator
+      while (it.hasNext) {
+        val s = it.next()
+        val elemIt = s.iterator
+        while (elemIt.hasNext) {
+          val acl = elemIt.next()
+          if (p(acl)) return Some(acl)
+        }
+      }
+      None
+    }
     def isEmpty: Boolean = !sets.exists(_.nonEmpty)
   }
 
@@ -313,11 +324,11 @@ class AclAuthorizer extends Authorizer with Logging {
       // Allowing read, write, delete, or alter implies allowing describe.
       // See #{org.apache.kafka.common.acl.AclOperation} for more details about ACL inheritance.
       val allowOps = operation match {
-        case DESCRIBE => Set[AclOperation](DESCRIBE, READ, WRITE, DELETE, ALTER)
-        case DESCRIBE_CONFIGS => Set[AclOperation](DESCRIBE_CONFIGS, ALTER_CONFIGS)
-        case _ => Set[AclOperation](operation)
+        case DESCRIBE => Seq(DESCRIBE, READ, WRITE, DELETE, ALTER)
+        case DESCRIBE_CONFIGS => Seq(DESCRIBE_CONFIGS, ALTER_CONFIGS)
+        case _ => Seq(operation)
       }
-      allowOps.exists(operation => matchingAclExists(operation, resource, principal, host, ALLOW, acls))
+      allowOps.exists(op => matchingAclExists(op, resource, principal, host, ALLOW, acls))
     }
 
     def aclsAllowAccess = {
