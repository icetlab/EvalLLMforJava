Iâ€™ve replaced the costly immutable Set unions in `matchingAcls` with a single builder-based accumulation, avoiding repeated `++` operations and heavy hash code work.

```json
[
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "val prefixed = aclCache\n        .from(new ResourcePattern(resourceType, resourceName, PatternType.PREFIXED))\n        .to(new ResourcePattern(resourceType, resourceName.take(1), PatternType.PREFIXED))\n        .filterKeys(resource => resourceName.startsWith(resource.name))\n        .values\n        .flatMap { _.acls }\n        .toSet\n\n      prefixed ++ wildcard ++ literal",
    "replace": "val builder = Set.newBuilder[AclEntry]\n      val from = new ResourcePattern(resourceType, resourceName, PatternType.PREFIXED)\n      val to = new ResourcePattern(resourceType, resourceName.take(1), PatternType.PREFIXED)\n      val rangeIter = aclCache.from(from).to(to).iterator\n      while (rangeIter.hasNext) {\n        val (pattern, versioned) = rangeIter.next()\n        if (resourceName.startsWith(pattern.name)) {\n          builder ++= versioned.acls\n        }\n      }\n      if (wildcard.nonEmpty) builder ++= wildcard\n      if (literal.nonEmpty) builder ++= literal\n      builder.result()"
  }
]
```