My analysis of the `AclAuthorizer.scala` source code identified a performance bottleneck in the `authorizeAction` method. This method is on the hot path for every authorization request.

The original implementation involved multiple iterations over the set of applicable ACLs for a given resource. Specifically, it would first iterate to check for `DENY` ACLs, and then perform one or more additional iterations to check for `ALLOW` ACLs. In some cases, like a `DESCRIBE` operation, this could lead to iterating over the same set of ACLs up to six times.

My improvement refactors this logic into a single pass. The new implementation iterates through the ACLs just once. It checks for `DENY` rules and can exit early if one is found, since `DENY` has precedence. Concurrently, it tracks whether an `ALLOW` rule has been found. This approach significantly reduces the number of iterations, especially when many ACLs apply to a resource, leading to a substantial performance improvement in the authorization logic. The change also preserves the detailed logging of which ACL led to an authorization decision.

```json
[
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "    def isEmptyAclAndAuthorized(acls: Set[AclEntry]): Boolean = {\n      if (acls.isEmpty) {\n        // No ACLs found for this resource, permission is determined by value of config allow.everyone.if.no.acl.found\n        authorizerLogger.debug(s\"No acl found for resource $resource, authorized = $shouldAllowEveryoneIfNoAclIsFound\")\n        shouldAllowEveryoneIfNoAclIsFound\n      } else false\n    }\n\n    def denyAclExists(acls: Set[AclEntry]): Boolean = {\n      // Check if there are any Deny ACLs which would forbid this operation.\n      matchingAclExists(operation, resource, principal, host, DENY, acls)\n    }\n\n    def allowAclExists(acls: Set[AclEntry]): Boolean = {\n      // Check if there are any Allow ACLs which would allow this operation.\n      // Allowing read, write, delete, or alter implies allowing describe.\n      // See #{org.apache.kafka.common.acl.AclOperation} for more details about ACL inheritance.\n      val allowOps = operation match {\n        case DESCRIBE => Set[AclOperation](DESCRIBE, READ, WRITE, DELETE, ALTER)\n        case DESCRIBE_CONFIGS => Set[AclOperation](DESCRIBE_CONFIGS, ALTER_CONFIGS)\n        case _ => Set[AclOperation](operation)\n      }\n      allowOps.exists(operation => matchingAclExists(operation, resource, principal, host, ALLOW, acls))\n    }\n\n    def aclsAllowAccess = {\n      //we allow an operation if no acls are found and user has configured to allow all users\n      //when no acls are found or if no deny acls are found and at least one allow acls matches.\n      val acls = matchingAcls(resource.resourceType, resource.name)\n      isEmptyAclAndAuthorized(acls) || (!denyAclExists(acls) && allowAclExists(acls))\n    }",
    "replace": "    def aclsAllowAccess: Boolean = {\n      //we allow an operation if no acls are found and user has configured to allow all users\n      //when no acls are found or if no deny acls are found and at least one allow acls matches.\n      val acls = matchingAcls(resource.resourceType, resource.name)\n\n      if (acls.isEmpty) {\n        // No ACLs found for this resource, permission is determined by value of config allow.everyone.if.no.acl.found\n        authorizerLogger.debug(s\"No acl found for resource $resource, authorized = $shouldAllowEveryoneIfNoAclIsFound\")\n        return shouldAllowEveryoneIfNoAclIsFound\n      }\n\n      // Allowing read, write, delete, or alter implies allowing describe.\n      // See #{org.apache.kafka.common.acl.AclOperation} for more details about ACL inheritance.\n      val allowOps = operation match {\n        case DESCRIBE => Set[AclOperation](DESCRIBE, READ, WRITE, DELETE, ALTER)\n        case DESCRIBE_CONFIGS => Set[AclOperation](DESCRIBE_CONFIGS, ALTER_CONFIGS)\n        case _ => Set[AclOperation](operation)\n      }\n\n      var allowMatch = false\n      val iter = acls.iterator\n      while (iter.hasNext) {\n        val acl = iter.next()\n        if ((acl.kafkaPrincipal == principal || acl.kafkaPrincipal == AclEntry.WildcardPrincipal) &&\n          (acl.host == host || acl.host == AclEntry.WildcardHost)) {\n\n          // Check for deny ACLs. A deny match takes precedence and we can return immediately.\n          if (acl.permissionType == DENY && (acl.operation == operation || acl.operation == AclOperation.ALL)) {\n            authorizerLogger.debug(s\"operation = $operation on resource = $resource from host = $host is $DENY based on acl = $acl\")\n            return false\n          }\n\n          // Check for allow ACLs.\n          if (!allowMatch && acl.permissionType == ALLOW && (allowOps.contains(acl.operation) || acl.operation == AclOperation.ALL)) {\n            val op = if (acl.operation == AclOperation.ALL) operation else acl.operation\n            authorizerLogger.debug(s\"operation = $op on resource = $resource from host = $host is $ALLOW based on acl = $acl\")\n            allowMatch = true\n          }\n        }\n      }\n\n      allowMatch\n    }"
  }
]
```