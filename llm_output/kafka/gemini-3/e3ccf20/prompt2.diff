diff --git a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
index 86f06981ff..577ade7356 100644
--- a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
+++ b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
@@ -293,20 +293,42 @@ class AclAuthorizer extends Authorizer with Logging {
     val host = requestContext.clientAddress.getHostAddress
     val operation = action.operation
 
-    def isEmptyAclAndAuthorized(acls: Set[AclEntry]): Boolean = {
-      if (acls.isEmpty) {
-        // No ACLs found for this resource, permission is determined by value of config allow.everyone.if.no.acl.found
-        authorizerLogger.debug(s"No acl found for resource $resource, authorized = $shouldAllowEveryoneIfNoAclIsFound")
-        shouldAllowEveryoneIfNoAclIsFound
-      } else false
+    def aclsAllowAccess: Boolean = {
+      val (wildcardAcls, prefixedAcls, literalAcls) = inReadLock(lock) {
+        val wildcard = aclCache.get(new ResourcePattern(resource.resourceType, ResourcePattern.WILDCARD_RESOURCE, PatternType.LITERAL))
+          .map(_.acls)
+          .getOrElse(Set.empty)
+
+        val literal = aclCache.get(new ResourcePattern(resource.resourceType, resource.name, PatternType.LITERAL))
+          .map(_.acls)
+          .getOrElse(Set.empty)
+
+        val prefixed = aclCache
+          .from(new ResourcePattern(resource.resourceType, resource.name, PatternType.PREFIXED))
+          .to(new ResourcePattern(resource.resourceType, resource.name.take(1), PatternType.PREFIXED))
+          .filterKeys(resourcePattern => resource.name.startsWith(resourcePattern.name))
+          .values
+          .flatMap { _.acls }
+          .toSet
+        (wildcard, prefixed, literal)
       }
 
-    def denyAclExists(acls: Set[AclEntry]): Boolean = {
+      //we allow an operation if no acls are found and user has configured to allow all users
+      //when no acls are found or if no deny acls are found and at least one allow acls matches.
+      if (literalAcls.isEmpty && prefixedAcls.isEmpty && wildcardAcls.isEmpty) {
+        authorizerLogger.debug(s"No acl found for resource $resource, authorized = $shouldAllowEveryoneIfNoAclIsFound")
+        shouldAllowEveryoneIfNoAclIsFound
+      } else {
         // Check if there are any Deny ACLs which would forbid this operation.
-      matchingAclExists(operation, resource, principal, host, DENY, acls)
-    }
+        // The order of checks is important here for performance. Literal is most specific, so we check it first.
+        val denyAclExists =
+          matchingAclExists(operation, resource, principal, host, DENY, literalAcls) ||
+          matchingAclExists(operation, resource, principal, host, DENY, prefixedAcls) ||
+          matchingAclExists(operation, resource, principal, host, DENY, wildcardAcls)
 
-    def allowAclExists(acls: Set[AclEntry]): Boolean = {
+        if (denyAclExists) {
+          false
+        } else {
           // Check if there are any Allow ACLs which would allow this operation.
           // Allowing read, write, delete, or alter implies allowing describe.
           // See #{org.apache.kafka.common.acl.AclOperation} for more details about ACL inheritance.
@@ -315,14 +337,14 @@ class AclAuthorizer extends Authorizer with Logging {
             case DESCRIBE_CONFIGS => Set[AclOperation](DESCRIBE_CONFIGS, ALTER_CONFIGS)
             case _ => Set[AclOperation](operation)
           }
-      allowOps.exists(operation => matchingAclExists(operation, resource, principal, host, ALLOW, acls))
+          val allowAclExists = allowOps.exists { op =>
+            matchingAclExists(op, resource, principal, host, ALLOW, literalAcls) ||
+            matchingAclExists(op, resource, principal, host, ALLOW, prefixedAcls) ||
+            matchingAclExists(op, resource, principal, host, ALLOW, wildcardAcls)
+          }
+          allowAclExists
+        }
       }
-
-    def aclsAllowAccess = {
-      //we allow an operation if no acls are found and user has configured to allow all users
-      //when no acls are found or if no deny acls are found and at least one allow acls matches.
-      val acls = matchingAcls(resource.resourceType, resource.name)
-      isEmptyAclAndAuthorized(acls) || (!denyAclExists(acls) && allowAclExists(acls))
     }
 
     // Evaluate if operation is allowed
@@ -339,28 +361,6 @@ class AclAuthorizer extends Authorizer with Logging {
     } else false
   }
 
-  private def matchingAcls(resourceType: ResourceType, resourceName: String): Set[AclEntry] = {
-    inReadLock(lock) {
-      val wildcard = aclCache.get(new ResourcePattern(resourceType, ResourcePattern.WILDCARD_RESOURCE, PatternType.LITERAL))
-        .map(_.acls)
-        .getOrElse(Set.empty)
-
-      val literal = aclCache.get(new ResourcePattern(resourceType, resourceName, PatternType.LITERAL))
-        .map(_.acls)
-        .getOrElse(Set.empty)
-
-      val prefixed = aclCache
-        .from(new ResourcePattern(resourceType, resourceName, PatternType.PREFIXED))
-        .to(new ResourcePattern(resourceType, resourceName.take(1), PatternType.PREFIXED))
-        .filterKeys(resource => resourceName.startsWith(resource.name))
-        .values
-        .flatMap { _.acls }
-        .toSet
-
-      prefixed ++ wildcard ++ literal
-    }
-  }
-
   private def matchingAclExists(operation: AclOperation,
                                 resource: ResourcePattern,
                                 principal: KafkaPrincipal,
