diff --git a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
index 86f06981ff..b55f682699 100644
--- a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
+++ b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
@@ -46,6 +46,9 @@ import scala.collection.JavaConverters._
 import scala.util.{Failure, Random, Success, Try}
 
 object AclAuthorizer {
+  private val DescribeOps = Set[AclOperation](DESCRIBE, READ, WRITE, DELETE, ALTER)
+  private val DescribeConfigsOps = Set[AclOperation](DESCRIBE_CONFIGS, ALTER_CONFIGS)
+
   // Optional override zookeeper cluster configuration where acls will be stored. If not specified,
   // acls will be stored in the same zookeeper where all other kafka broker metadata is stored.
   val configPrefix = "authorizer."
@@ -310,12 +313,11 @@ class AclAuthorizer extends Authorizer with Logging {
       // Check if there are any Allow ACLs which would allow this operation.
       // Allowing read, write, delete, or alter implies allowing describe.
       // See #{org.apache.kafka.common.acl.AclOperation} for more details about ACL inheritance.
-      val allowOps = operation match {
-        case DESCRIBE => Set[AclOperation](DESCRIBE, READ, WRITE, DELETE, ALTER)
-        case DESCRIBE_CONFIGS => Set[AclOperation](DESCRIBE_CONFIGS, ALTER_CONFIGS)
-        case _ => Set[AclOperation](operation)
+      operation match {
+        case DESCRIBE => AclAuthorizer.DescribeOps.exists(op => matchingAclExists(op, resource, principal, host, ALLOW, acls))
+        case DESCRIBE_CONFIGS => AclAuthorizer.DescribeConfigsOps.exists(op => matchingAclExists(op, resource, principal, host, ALLOW, acls))
+        case _ => matchingAclExists(operation, resource, principal, host, ALLOW, acls)
       }
-      allowOps.exists(operation => matchingAclExists(operation, resource, principal, host, ALLOW, acls))
     }
 
     def aclsAllowAccess = {
@@ -352,9 +354,9 @@ class AclAuthorizer extends Authorizer with Logging {
       val prefixed = aclCache
         .from(new ResourcePattern(resourceType, resourceName, PatternType.PREFIXED))
         .to(new ResourcePattern(resourceType, resourceName.take(1), PatternType.PREFIXED))
-        .filterKeys(resource => resourceName.startsWith(resource.name))
-        .values
-        .flatMap { _.acls }
+        .iterator
+        .filter { case (resource, _) => resourceName.startsWith(resource.name) }
+        .flatMap { case (_, versionedAcls) => versionedAcls.acls }
         .toSet
 
       prefixed ++ wildcard ++ literal
