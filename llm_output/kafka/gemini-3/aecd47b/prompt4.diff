diff --git a/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java b/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java
index 679b59249d..c72f346838 100644
--- a/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java
+++ b/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java
@@ -16,6 +16,8 @@
  */
 package org.apache.kafka.common.utils;
 
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.nio.ByteBuffer;
 import java.util.zip.Checksum;
 
@@ -30,6 +32,18 @@ import java.util.zip.Checksum;
  */
 public final class Checksums {
 
+    private static final Method CHECKSUM_UPDATE_METHOD;
+
+    static {
+        Method method = null;
+        try {
+            method = Checksum.class.getMethod("update", ByteBuffer.class);
+        } catch (NoSuchMethodException e) {
+            // Not available on Java 8
+        }
+        CHECKSUM_UPDATE_METHOD = method;
+    }
+
     private Checksums() {
     }
 
@@ -40,6 +54,19 @@ public final class Checksums {
     public static void update(Checksum checksum, ByteBuffer buffer, int offset, int length) {
         if (buffer.hasArray()) {
             checksum.update(buffer.array(), buffer.position() + buffer.arrayOffset() + offset, length);
+        } else if (CHECKSUM_UPDATE_METHOD != null) {
+            int pos = buffer.position();
+            try {
+                buffer.position(pos + offset);
+                ByteBuffer slice = buffer.slice();
+                slice.limit(length);
+                CHECKSUM_UPDATE_METHOD.invoke(checksum, slice);
+            } catch (IllegalAccessException | InvocationTargetException e) {
+                // Should not happen
+                throw new RuntimeException(e);
+            } finally {
+                buffer.position(pos);
+            }
         } else {
             int start = buffer.position() + offset;
             for (int i = start; i < start + length; i++)
