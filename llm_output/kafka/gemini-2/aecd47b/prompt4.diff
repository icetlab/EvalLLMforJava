diff --git a/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java b/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java
index 679b59249d..33a4fc48d8 100644
--- a/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java
+++ b/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java
@@ -30,6 +30,18 @@ import java.util.zip.Checksum;
  */
 public final class Checksums {
 
+    private static final java.lang.reflect.Method UPDATE_BYTE_BUFFER_METHOD;
+
+    static {
+        java.lang.reflect.Method method = null;
+        try {
+            method = Checksum.class.getMethod("update", ByteBuffer.class);
+        } catch (NoSuchMethodException e) {
+            // Not on Java 9+, fall back to byte-by-byte update
+        }
+        UPDATE_BYTE_BUFFER_METHOD = method;
+    }
+
     private Checksums() {
     }
 
@@ -41,6 +53,23 @@ public final class Checksums {
         if (buffer.hasArray()) {
             checksum.update(buffer.array(), buffer.position() + buffer.arrayOffset() + offset, length);
         } else {
+            if (UPDATE_BYTE_BUFFER_METHOD != null) {
+                int pos = buffer.position();
+                int limit = buffer.limit();
+                try {
+                    buffer.position(pos + offset);
+                    buffer.limit(pos + offset + length);
+                    UPDATE_BYTE_BUFFER_METHOD.invoke(checksum, buffer);
+                    return;
+                } catch (IllegalAccessException | java.lang.reflect.InvocationTargetException e) {
+                    // This is not expected, but fall back to byte-by-byte update
+                } finally {
+                    buffer.limit(limit);
+                    buffer.position(pos);
+                }
+            }
+
+            // Fallback for Java 8 or if reflection fails
             int start = buffer.position() + offset;
             for (int i = start; i < start + length; i++)
                 checksum.update(buffer.get(i));
