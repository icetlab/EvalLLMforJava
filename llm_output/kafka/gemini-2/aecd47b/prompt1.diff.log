This is an excellent opportunity to improve performance in `Checksums.java`. My plan is to optimize three key areas by reducing per-call overhead.

First, for `update(Checksum, ByteBuffer, int, int)`, the current implementation for non-array-backed `ByteBuffer`s (like direct buffers) performs a slow, byte-by-byte update. I will replace this with a bulk-read approach using a `ThreadLocal` `byte[]` buffer. This significantly reduces method call overhead and is much more efficient for direct memory access.

Second, the `updateInt` and `updateLong` methods currently make multiple virtual calls to `checksum.update()` for each byte of the integer or long. I will optimize these by using a small, `ThreadLocal` `byte[]` to construct the byte representation of the number and then making a single call to `checksum.update(byte[], int, int)`. This reduces the number of virtual method calls and avoids heap allocation for the temporary byte array on each invocation.

These changes are thread-safe due to the use of `ThreadLocal` and will not alter the functional behavior, as confirmed by the provided unit tests.

```json
[
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java",
    "search": "public final class Checksums {\n\n    private Checksums() {\n    }",
    "replace": "public final class Checksums {\n\n    private static final ThreadLocal<byte[]> BUFFERS = ThreadLocal.withInitial(() -> new byte[8192]);\n    private static final ThreadLocal<byte[]> TLD_BYTES = ThreadLocal.withInitial(() -> new byte[8]);\n\n    private Checksums() {\n    }"
  },
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java",
    "search": "        } else {\n            int start = buffer.position() + offset;\n            for (int i = start; i < start + length; i++)\n                checksum.update(buffer.get(i));\n        }",
    "replace": "        } else {\n            ByteBuffer toRead = buffer.duplicate();\n            toRead.position(buffer.position() + offset);\n            toRead.limit(buffer.position() + offset + length);\n\n            byte[] temp = BUFFERS.get();\n            while (toRead.hasRemaining()) {\n                int n = Math.min(toRead.remaining(), temp.length);\n                toRead.get(temp, 0, n);\n                checksum.update(temp, 0, n);\n            }\n        }"
  },
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java",
    "search": "    public static void updateInt(Checksum checksum, int input) {\n        checksum.update((byte) (input >> 24));\n        checksum.update((byte) (input >> 16));\n        checksum.update((byte) (input >> 8));\n        checksum.update((byte) input /* >> 0 */);\n    }\n\n    public static void updateLong(Checksum checksum, long input) {\n        checksum.update((byte) (input >> 56));\n        checksum.update((byte) (input >> 48));\n        checksum.update((byte) (input >> 40));\n        checksum.update((byte) (input >> 32));\n        checksum.update((byte) (input >> 24));\n        checksum.update((byte) (input >> 16));\n        checksum.update((byte) (input >> 8));\n        checksum.update((byte) input /* >> 0 */);\n    }",
    "replace": "    public static void updateInt(Checksum checksum, int input) {\n        byte[] bytes = TLD_BYTES.get();\n        bytes[0] = (byte) (input >> 24);\n        bytes[1] = (byte) (input >> 16);\n        bytes[2] = (byte) (input >> 8);\n        bytes[3] = (byte) input;\n        checksum.update(bytes, 0, 4);\n    }\n\n    public static void updateLong(Checksum checksum, long input) {\n        byte[] bytes = TLD_BYTES.get();\n        bytes[0] = (byte) (input >> 56);\n        bytes[1] = (byte) (input >> 48);\n        bytes[2] = (byte) (input >> 40);\n        bytes[3] = (byte) (input >> 32);\n        bytes[4] = (byte) (input >> 24);\n        bytes[5] = (byte) (input >> 16);\n        bytes[6] = (byte) (input >> 8);\n        bytes[7] = (byte) input;\n        checksum.update(bytes, 0, 8);\n    }"
  }
]
```