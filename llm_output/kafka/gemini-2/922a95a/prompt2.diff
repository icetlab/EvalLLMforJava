diff --git a/core/src/main/scala/kafka/cluster/Partition.scala b/core/src/main/scala/kafka/cluster/Partition.scala
index 9cfd99e8e5..524e9d0e9a 100755
--- a/core/src/main/scala/kafka/cluster/Partition.scala
+++ b/core/src/main/scala/kafka/cluster/Partition.scala
@@ -203,6 +203,7 @@ class Partition(val topicPartition: TopicPartition,
   private val remoteReplicasMap = new Pool[Int, Replica]
   // The read lock is only required when multiple reads are executed and needs to be in a consistent manner
   private val leaderIsrUpdateLock = new ReentrantReadWriteLock
+  private val futureLogLock = new ReentrantReadWriteLock
   private var zkVersion: Int = LeaderAndIsr.initialZKVersion
   @volatile private var leaderEpoch: Int = LeaderAndIsr.initialLeaderEpoch - 1
   // start offset for 'leaderEpoch' above (leader epoch of the current leader for this partition),
@@ -411,17 +412,20 @@ class Partition(val topicPartition: TopicPartition,
   }
 
   def removeFutureLocalReplica(deleteFromLogDir: Boolean = true): Unit = {
+    inWriteLock(futureLogLock) {
       inWriteLock(leaderIsrUpdateLock) {
         futureLog = None
         if (deleteFromLogDir)
           logManager.asyncDelete(topicPartition, isFuture = true)
       }
     }
+  }
 
   // Return true iff the future replica exists and it has caught up with the current replica for this partition
   // Only ReplicaAlterDirThread will call this method and ReplicaAlterDirThread should remove the partition
   // from its partitionStates if this method returns true
   def maybeReplaceCurrentWithFutureReplica(): Boolean = {
+    inWriteLock(futureLogLock) {
       val localReplicaLEO = localLogOrException.logEndOffset
       val futureReplicaLEO = futureLog.map(_.logEndOffset)
       if (futureReplicaLEO.contains(localReplicaLEO)) {
@@ -446,6 +450,7 @@ class Partition(val topicPartition: TopicPartition,
         }
       } else false
     }
+  }
 
   def delete(): Unit = {
     // need to hold the lock to prevent appendMessagesToLeader() from hitting I/O exceptions due to log being deleted
@@ -913,7 +918,7 @@ class Partition(val topicPartition: TopicPartition,
   private def doAppendRecordsToFollowerOrFutureReplica(records: MemoryRecords, isFuture: Boolean): Option[LogAppendInfo] = {
     // The read lock is needed to handle race condition if request handler thread tries to
     // remove future replica after receiving AlterReplicaLogDirsRequest.
-    inReadLock(leaderIsrUpdateLock) {
+    inReadLock(futureLogLock) {
       if (isFuture) {
         // Note the replica may be undefined if it is removed by a non-ReplicaAlterLogDirsThread before
         // this method is called
