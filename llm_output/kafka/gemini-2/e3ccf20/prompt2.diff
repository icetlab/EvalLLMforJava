diff --git a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
index 86f06981ff..e04f23af6b 100644
--- a/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
+++ b/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala
@@ -293,14 +293,6 @@ class AclAuthorizer extends Authorizer with Logging {
     val host = requestContext.clientAddress.getHostAddress
     val operation = action.operation
 
-    def isEmptyAclAndAuthorized(acls: Set[AclEntry]): Boolean = {
-      if (acls.isEmpty) {
-        // No ACLs found for this resource, permission is determined by value of config allow.everyone.if.no.acl.found
-        authorizerLogger.debug(s"No acl found for resource $resource, authorized = $shouldAllowEveryoneIfNoAclIsFound")
-        shouldAllowEveryoneIfNoAclIsFound
-      } else false
-    }
-
     def denyAclExists(acls: Set[AclEntry]): Boolean = {
       // Check if there are any Deny ACLs which would forbid this operation.
       matchingAclExists(operation, resource, principal, host, DENY, acls)
@@ -321,8 +313,13 @@ class AclAuthorizer extends Authorizer with Logging {
     def aclsAllowAccess = {
       //we allow an operation if no acls are found and user has configured to allow all users
       //when no acls are found or if no deny acls are found and at least one allow acls matches.
-      val acls = matchingAcls(resource.resourceType, resource.name)
-      isEmptyAclAndAuthorized(acls) || (!denyAclExists(acls) && allowAclExists(acls))
+      val aclSets = matchingAcls(resource.resourceType, resource.name)
+      if (aclSets.forall(_.isEmpty)) {
+        authorizerLogger.debug(s"No acl found for resource $resource, authorized = $shouldAllowEveryoneIfNoAclIsFound")
+        shouldAllowEveryoneIfNoAclIsFound
+      } else {
+        !aclSets.exists(denyAclExists) && aclSets.exists(allowAclExists)
+      }
     }
 
     // Evaluate if operation is allowed
@@ -339,7 +336,7 @@ class AclAuthorizer extends Authorizer with Logging {
     } else false
   }
 
-  private def matchingAcls(resourceType: ResourceType, resourceName: String): Set[AclEntry] = {
+  private def matchingAcls(resourceType: ResourceType, resourceName: String): Iterable[Set[AclEntry]] = {
     inReadLock(lock) {
       val wildcard = aclCache.get(new ResourcePattern(resourceType, ResourcePattern.WILDCARD_RESOURCE, PatternType.LITERAL))
         .map(_.acls)
@@ -354,10 +351,9 @@ class AclAuthorizer extends Authorizer with Logging {
         .to(new ResourcePattern(resourceType, resourceName.take(1), PatternType.PREFIXED))
         .filterKeys(resource => resourceName.startsWith(resource.name))
         .values
-        .flatMap { _.acls }
-        .toSet
+        .map { _.acls }
 
-      prefixed ++ wildcard ++ literal
+      Seq(literal) ++ prefixed ++ Seq(wildcard)
     }
   }
 
