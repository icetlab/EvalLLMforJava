This optimization improves the performance of the `authorize` method, which is a critical hot path in the `AclAuthorizer`.

The primary change is within the `allowAclExists` helper function inside `authorizeAction`. The original implementation iterated through a set of applicable operations (`allowOps`) and, for each operation, performed a full scan of all relevant ACLs. This resulted in a complexity of O(M * N), where M is the number of applicable operations and N is the number of ACLs. For operations like `DESCRIBE`, this meant up to five full scans of the ACL set.

The improved implementation performs only a single scan of the ACLs. It checks if any ACL grants permission for any of the applicable operations. This reduces the complexity to O(N), significantly speeding up authorization checks, especially when dealing with operations that imply others (like `DESCRIBE`) and when there's a large number of ACLs for a resource. The logging behavior is preserved to ensure that debugging information remains consistent with the original implementation.

```json
[
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "    def allowAclExists(acls: Set[AclEntry]): Boolean = {\n      // Check if there are any Allow ACLs which would allow this operation.\n      // Allowing read, write, delete, or alter implies allowing describe.\n      // See #{org.apache.kafka.common.acl.AclOperation} for more details about ACL inheritance.\n      val allowOps = operation match {\n        case DESCRIBE => Set[AclOperation](DESCRIBE, READ, WRITE, DELETE, ALTER)\n        case DESCRIBE_CONFIGS => Set[AclOperation](DESCRIBE_CONFIGS, ALTER_CONFIGS)\n        case _ => Set[AclOperation](operation)\n      }\n      allowOps.exists(operation => matchingAclExists(operation, resource, principal, host, ALLOW, acls))\n    }",
    "replace": "    def allowAclExists(acls: Set[AclEntry]): Boolean = {\n      // Check if there are any Allow ACLs which would allow this operation.\n      // Allowing read, write, delete, or alter implies allowing describe.\n      // See #{org.apache.kafka.common.acl.AclOperation} for more details about ACL inheritance.\n      val allowOps = operation match {\n        case DESCRIBE => Set[AclOperation](DESCRIBE, READ, WRITE, DELETE, ALTER)\n        case DESCRIBE_CONFIGS => Set[AclOperation](DESCRIBE_CONFIGS, ALTER_CONFIGS)\n        case _ => Set[AclOperation](operation)\n      }\n      // This is more efficient than `allowOps.exists(op => matchingAclExists(op, ...))`\n      // which performs a full scan for each operation in allowOps. This performs a single scan.\n      acls.find { acl =>\n        acl.permissionType == ALLOW &&\n          (acl.kafkaPrincipal == principal || acl.kafkaPrincipal == AclEntry.WildcardPrincipal) &&\n          (acl.host == host || acl.host == AclEntry.WildcardHost) &&\n          (allowOps.contains(acl.operation) || acl.operation == AclOperation.ALL)\n      }.exists { acl =>\n        val matchedOperation = if (acl.operation == AclOperation.ALL) operation else acl.operation\n        authorizerLogger.debug(s\"operation = $matchedOperation on resource = $resource from host = $host is $ALLOW based on acl = $acl\")\n        true\n      }\n    }"
  }
]
```