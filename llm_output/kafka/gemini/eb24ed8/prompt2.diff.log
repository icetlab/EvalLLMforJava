The performance of ZSTD compression can be improved by addressing two main issues with the `zstd-jni` library. First, the default internal buffers in `ZstdInputStream` and `ZstdOutputStream` are quite large, leading to significant memory allocation and GC overhead, especially when many streams are created and destroyed. Second, single-byte read and write operations are inefficient due to the overhead of JNI calls and object allocation within the stream implementations.

To mitigate this, I will make the following changes:
1.  Modify the `ZstdConstructors` to look for `ZstdInputStream` and `ZstdOutputStream` constructors that accept a buffer size parameter. This allows us to specify smaller internal buffers, reducing memory pressure.
2.  Update `CompressionType.ZSTD` to use these constructors with smaller, more reasonable buffer sizes (e.g., 16KB for output, 8KB for input's compressed data buffer), similar to what is done for GZIP.
3.  Wrap the `ZstdInputStream` and `ZstdOutputStream` with `BufferedInputStream` and `BufferedOutputStream` respectively. This will buffer small read/write operations in Java, coalescing them into larger chunks before passing them to the underlying ZSTD streams, thus avoiding the inefficient single-byte JNI calls.

These changes mirror the proven implementation pattern used for GZIP compression within Kafka, aiming for better memory management and improved throughput.

```json
[
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/record/CompressionType.java",
    "search": "    ZSTD(4, \"zstd\", 1.0f) {\n        @Override\n        public OutputStream wrapForOutput(ByteBufferOutputStream buffer, byte messageVersion) {\n            try {\n                return (OutputStream) ZstdConstructors.OUTPUT.invoke(buffer);\n            } catch (Throwable e) {\n                throw new KafkaException(e);\n            }\n        }\n\n        @Override\n        public InputStream wrapForInput(ByteBuffer buffer, byte messageVersion, BufferSupplier decompressionBufferSupplier) {\n            try {\n                return (InputStream) ZstdConstructors.INPUT.invoke(new ByteBufferInputStream(buffer));\n            } catch (Throwable e) {\n                throw new KafkaException(e);\n            }\n        }\n    };",
    "replace": "    ZSTD(4, \"zstd\", 1.0f) {\n        @Override\n        public OutputStream wrapForOutput(ByteBufferOutputStream buffer, byte messageVersion) {\n            try {\n                // Set input buffer (uncompressed) to 16 KB. The zstd-jni library has its own internal buffer,\n                // the default size is 128 KB. We use 16 KB as a tradeoff between memory usage and performance.\n                // We then wrap ZstdOutputStream with a BufferedOutputStream to batch small writes,\n                // because ZstdOutputStream.write(int) is inefficient.\n                return new BufferedOutputStream((OutputStream) ZstdConstructors.OUTPUT.invoke(buffer, 16 * 1024), 16 * 1024);\n            } catch (Throwable e) {\n                throw new KafkaException(e);\n            }\n        }\n\n        @Override\n        public InputStream wrapForInput(ByteBuffer buffer, byte messageVersion, BufferSupplier decompressionBufferSupplier) {\n            try {\n                // Set input buffer (compressed) to 8 KB (the default is 64 KB) and\n                // output buffer (uncompressed) to 16 KB to ensure reasonable performance in cases where the\n                // caller reads a small number of bytes (potentially a single byte).\n                // ZstdInputStream's read() is inefficient, so we wrap it in a BufferedInputStream.\n                return new BufferedInputStream((InputStream) ZstdConstructors.INPUT.invoke(new ByteBufferInputStream(buffer), 8 * 1024),\n                        16 * 1024);\n            } catch (Throwable e) {\n                throw new KafkaException(e);\n            }\n        }\n    };"
  },
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/record/CompressionType.java",
    "search": "    private static class ZstdConstructors {\n        static final MethodHandle INPUT = findConstructor(\"com.github.luben.zstd.ZstdInputStream\",\n            MethodType.methodType(void.class, InputStream.class));\n        static final MethodHandle OUTPUT = findConstructor(\"com.github.luben.zstd.ZstdOutputStream\",\n            MethodType.methodType(void.class, OutputStream.class));\n    }",
    "replace": "    private static class ZstdConstructors {\n        static final MethodHandle INPUT = findConstructor(\"com.github.luben.zstd.ZstdInputStream\",\n            MethodType.methodType(void.class, InputStream.class, int.class));\n        static final MethodHandle OUTPUT = findConstructor(\"com.github.luben.zstd.ZstdOutputStream\",\n            MethodType.methodType(void.class, OutputStream.class, int.class));\n    }"
  }
]
```