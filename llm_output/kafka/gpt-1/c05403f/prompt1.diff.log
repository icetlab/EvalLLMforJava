I’ve optimized the little-endian byte‐array routines to eliminate an unnecessary shift and mask, and switched to arithmetic shifts for consistency in the write method. These changes are functionally equivalent but slightly more efficient.

```json
[
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/utils/ByteUtils.java",
    "search": "public static int readUnsignedIntLE(byte[] buffer, int offset) {\n        return (buffer[offset] << 0 & 0xff)\n                | ((buffer[offset + 1] & 0xff) << 8)\n                | ((buffer[offset + 2] & 0xff) << 16)\n                | ((buffer[offset + 3] & 0xff) << 24);\n    }",
    "replace": "public static int readUnsignedIntLE(byte[] buffer, int offset) {\n        return (buffer[offset] & 0xff)\n                | ((buffer[offset + 1] & 0xff) << 8)\n                | ((buffer[offset + 2] & 0xff) << 16)\n                | ((buffer[offset + 3] & 0xff) << 24);\n    }"
  },
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/utils/ByteUtils.java",
    "search": "public static void writeUnsignedIntLE(byte[] buffer, int offset, int value) {\n        buffer[offset] = (byte) value;\n        buffer[offset + 1] = (byte) (value >>> 8);\n        buffer[offset + 2] = (byte) (value >>> 16);\n        buffer[offset + 3]   = (byte) (value >>> 24);\n    }",
    "replace": "public static void writeUnsignedIntLE(byte[] buffer, int offset, int value) {\n        buffer[offset] = (byte) value;\n        buffer[offset + 1] = (byte) (value >> 8);\n        buffer[offset + 2] = (byte) (value >> 16);\n        buffer[offset + 3] = (byte) (value >> 24);\n    }"
  }
]
```