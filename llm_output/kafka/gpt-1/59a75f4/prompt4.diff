diff --git a/core/src/main/scala/kafka/server/AbstractFetcherThread.scala b/core/src/main/scala/kafka/server/AbstractFetcherThread.scala
index 0f3b06952a..bb47326b97 100755
--- a/core/src/main/scala/kafka/server/AbstractFetcherThread.scala
+++ b/core/src/main/scala/kafka/server/AbstractFetcherThread.scala
@@ -435,8 +435,25 @@ abstract class AbstractFetcherThread(name: String,
     * @param fetchOffsets the partitions to update fetch offset and maybe mark truncation complete
     */
   private def updateFetchOffsetAndMaybeMarkTruncationComplete(fetchOffsets: Map[TopicPartition, OffsetTruncationState]): Unit = {
-    val newStates: Map[TopicPartition, PartitionFetchState] = partitionStates.partitionStates.asScala
-      .map { state =>
+    val newStates: Map[TopicPartition, PartitionFetchState] = partitionStates.partitionStateMap.asScala
+      .map { case (tp, currentFetchState) =>
+        fetchOffsets.get(tp) match {
+          case Some(offsetTruncationState) =>
+            val replicaState = if (offsetTruncationState.truncationCompleted) Fetching else Truncating
+            val newState = PartitionFetchState(
+              offsetTruncationState.offset,
+              currentFetchState.lag,
+              currentFetchState.currentLeaderEpoch,
+              currentFetchState.delay,
+              replicaState
+            )
+            tp -> newState
+          case None =>
+            tp -> currentFetchState
+        }
+      }.toMap
+    partitionStates.set(newStates.asJava)
+  }
         val currentFetchState = state.value
         val maybeTruncationComplete = fetchOffsets.get(state.topicPartition) match {
           case Some(offsetTruncationState) =>
@@ -648,7 +665,14 @@ abstract class AbstractFetcherThread(name: String,
   }
 
   private[server] def partitionsAndOffsets: Map[TopicPartition, InitialFetchState] = inLock(partitionMapLock) {
-    partitionStates.partitionStates.asScala.map { state =>
+    partitionStates.partitionStateMap.asScala.map { case (tp, currentFetchState) =>
+      tp -> InitialFetchState(
+        sourceBroker,
+        currentLeaderEpoch = currentFetchState.currentLeaderEpoch,
+        initOffset = currentFetchState.fetchOffset
+      )
+    }.toMap
+  }
       val initialFetchState = InitialFetchState(sourceBroker,
         currentLeaderEpoch = state.value.currentLeaderEpoch,
         initOffset = state.value.fetchOffset)
