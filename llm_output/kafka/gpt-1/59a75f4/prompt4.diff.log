The changes below refactor AbstractFetcherThread to iterate directly over the internal partitionStateMap instead of calling partitionStates.partitionStates (which allocates new PartitionState objects) when updating fetch offsets and building the partitionsAndOffsets map. This avoids unnecessary object creation on each fetch cycle.

```json
[
  {
    "filepath": "../kafka/core/src/main/scala/kafka/server/AbstractFetcherThread.scala",
    "search": "private def updateFetchOffsetAndMaybeMarkTruncationComplete(fetchOffsets: Map[TopicPartition, OffsetTruncationState]): Unit = {\n    val newStates: Map[TopicPartition, PartitionFetchState] = partitionStates.partitionStates.asScala\n      .map { state =>",
    "replace": "private def updateFetchOffsetAndMaybeMarkTruncationComplete(fetchOffsets: Map[TopicPartition, OffsetTruncationState]): Unit = {\n    val newStates: Map[TopicPartition, PartitionFetchState] = partitionStates.partitionStateMap.asScala\n      .map { case (tp, currentFetchState) =>\n        fetchOffsets.get(tp) match {\n          case Some(offsetTruncationState) =>\n            val replicaState = if (offsetTruncationState.truncationCompleted) Fetching else Truncating\n            val newState = PartitionFetchState(\n              offsetTruncationState.offset,\n              currentFetchState.lag,\n              currentFetchState.currentLeaderEpoch,\n              currentFetchState.delay,\n              replicaState\n            )\n            tp -> newState\n          case None =>\n            tp -> currentFetchState\n        }\n      }.toMap\n    partitionStates.set(newStates.asJava)\n  }"
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/server/AbstractFetcherThread.scala",
    "search": "private[server] def partitionsAndOffsets: Map[TopicPartition, InitialFetchState] = inLock(partitionMapLock) {\n    partitionStates.partitionStates.asScala.map { state =>",
    "replace": "private[server] def partitionsAndOffsets: Map[TopicPartition, InitialFetchState] = inLock(partitionMapLock) {\n    partitionStates.partitionStateMap.asScala.map { case (tp, currentFetchState) =>\n      tp -> InitialFetchState(\n        sourceBroker,\n        currentLeaderEpoch = currentFetchState.currentLeaderEpoch,\n        initOffset = currentFetchState.fetchOffset\n      )\n    }.toMap\n  }"
  }
]
```