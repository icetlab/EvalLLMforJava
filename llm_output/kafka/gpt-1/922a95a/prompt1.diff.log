I have optimized the creation of AdminZkClient in ZkPartitionStateStore by instantiating it once per store, and improved the efficiency of key reuse in DelayedOperations by caching the `TopicPartitionOperationKey`. These changes reduce object allocations in hot paths.

```json
[
  {
    "filepath": "../kafka/core/src/main/scala/kafka/cluster/Partition.scala",
    "search": "class ZkPartitionStateStore(topicPartition: TopicPartition,\n                            zkClient: KafkaZkClient,\n                            replicaManager: ReplicaManager) extends PartitionStateStore {",
    "replace": "class ZkPartitionStateStore(topicPartition: TopicPartition,\n                            zkClient: KafkaZkClient,\n                            replicaManager: ReplicaManager) extends PartitionStateStore {\n  private val adminZkClient = new AdminZkClient(zkClient)"
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/cluster/Partition.scala",
    "search": "override def fetchTopicConfig(): Properties = {\n    val adminZkClient = new AdminZkClient(zkClient)\n    adminZkClient.fetchEntityConfig(ConfigType.Topic, topicPartition.topic)\n  }",
    "replace": "override def fetchTopicConfig(): Properties = {\n    adminZkClient.fetchEntityConfig(ConfigType.Topic, topicPartition.topic)\n  }"
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/cluster/Partition.scala",
    "search": "class DelayedOperations(topicPartition: TopicPartition,\n                        produce: DelayedOperationPurgatory[DelayedProduce],\n                        fetch: DelayedOperationPurgatory[DelayedFetch],\n                        deleteRecords: DelayedOperationPurgatory[DelayedDeleteRecords]) {",
    "replace": "class DelayedOperations(topicPartition: TopicPartition,\n                        produce: DelayedOperationPurgatory[DelayedProduce],\n                        fetch: DelayedOperationPurgatory[DelayedFetch],\n                        deleteRecords: DelayedOperationPurgatory[DelayedDeleteRecords]) {\n  private val requestKey = TopicPartitionOperationKey(topicPartition)"
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/cluster/Partition.scala",
    "search": "def checkAndCompleteAll(): Unit = {\n    val requestKey = TopicPartitionOperationKey(topicPartition)\n    fetch.checkAndComplete(requestKey)\n    produce.checkAndComplete(requestKey)\n    deleteRecords.checkAndComplete(requestKey)\n  }",
    "replace": "def checkAndCompleteAll(): Unit = {\n    fetch.checkAndComplete(requestKey)\n    produce.checkAndComplete(requestKey)\n    deleteRecords.checkAndComplete(requestKey)\n  }"
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/cluster/Partition.scala",
    "search": "def checkAndCompleteFetch(): Unit = {\n    fetch.checkAndComplete(TopicPartitionOperationKey(topicPartition))\n  }",
    "replace": "def checkAndCompleteFetch(): Unit = {\n    fetch.checkAndComplete(requestKey)\n  }"
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/cluster/Partition.scala",
    "search": "def checkAndCompleteProduce(): Unit = {\n    produce.checkAndComplete(TopicPartitionOperationKey(topicPartition))\n  }",
    "replace": "def checkAndCompleteProduce(): Unit = {\n    produce.checkAndComplete(requestKey)\n  }"
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/cluster/Partition.scala",
    "search": "def checkAndCompleteDeleteRecords(): Unit = {\n    deleteRecords.checkAndComplete(TopicPartitionOperationKey(topicPartition))\n  }",
    "replace": "def checkAndCompleteDeleteRecords(): Unit = {\n    deleteRecords.checkAndComplete(requestKey)\n  }"
  }
]
```