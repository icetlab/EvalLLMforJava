I’ve added reflective support for Java 9’s Checksum.update(ByteBuffer) to leverage bulk updates on direct ByteBuffers when available, while preserving the existing per-byte fallback and keeping the original functionality and tests intact.

```json
[
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java",
    "search": "import java.util.zip.Checksum;",
    "replace": "import java.util.zip.Checksum;\nimport java.lang.reflect.Method;"
  },
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java",
    "search": "    private Checksums() {\n    }",
    "replace": "    private Checksums() {\n    }\n\n    private static final Method UPDATE_BYTEBUFFER_METHOD;\n\n    static {\n        Method m = null;\n        try {\n            m = Checksum.class.getMethod(\"update\", ByteBuffer.class);\n        } catch (NoSuchMethodException e) {\n            // Method not available (pre-Java 9)\n        }\n        UPDATE_BYTEBUFFER_METHOD = m;\n    }"
  },
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/utils/Checksums.java",
    "search": "    public static void update(Checksum checksum, ByteBuffer buffer, int offset, int length) {\n        if (buffer.hasArray()) {\n            checksum.update(buffer.array(), buffer.position() + buffer.arrayOffset() + offset, length);\n        } else {\n            int start = buffer.position() + offset;\n            for (int i = start; i < start + length; i++)\n                checksum.update(buffer.get(i));\n        }\n    }",
    "replace": "    public static void update(Checksum checksum, ByteBuffer buffer, int offset, int length) {\n        if (buffer.hasArray()) {\n            checksum.update(buffer.array(), buffer.position() + buffer.arrayOffset() + offset, length);\n        } else if (UPDATE_BYTEBUFFER_METHOD != null) {\n            ByteBuffer duplicate = buffer.duplicate();\n            duplicate.position(buffer.position() + offset);\n            duplicate.limit(buffer.position() + offset + length);\n            try {\n                UPDATE_BYTEBUFFER_METHOD.invoke(checksum, duplicate);\n            } catch (Exception e) {\n                // Fallback to per-byte update if reflective call fails\n                int start = buffer.position() + offset;\n                for (int i = start; i < start + length; i++) {\n                    checksum.update(buffer.get(i));\n                }\n            }\n        } else {\n            int start = buffer.position() + offset;\n            for (int i = start; i < start + length; i++) {\n                checksum.update(buffer.get(i));\n            }\n        }\n    }"
  }
]
```