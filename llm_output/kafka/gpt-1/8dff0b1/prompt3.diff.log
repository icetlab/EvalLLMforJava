Iâ€™ve replaced the shared scala.util.Random (which can contend under high concurrency) with ThreadLocalRandom for backoff jitter, and added the necessary import. This avoids synchronization in Random and should improve throughput when many threads retry ACL updates.

```json
[
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "import scala.util.{Failure, Random, Success, Try}",
    "replace": "import scala.util.{Failure, Random, Success, Try}\nimport java.util.concurrent.ThreadLocalRandom"
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "private def backoffTime = {\n    retryBackoffMs + Random.nextInt(retryBackoffJitterMs)\n  }",
    "replace": "private def backoffTime: Int = retryBackoffMs + ThreadLocalRandom.current().nextInt(retryBackoffJitterMs)"
  }
]
```