diff --git a/storage/src/main/java/org/apache/kafka/storage/internals/log/ProducerStateManager.java b/storage/src/main/java/org/apache/kafka/storage/internals/log/ProducerStateManager.java
index da56ddaccc..e9e88a6dd6 100644
--- a/storage/src/main/java/org/apache/kafka/storage/internals/log/ProducerStateManager.java
+++ b/storage/src/main/java/org/apache/kafka/storage/internals/log/ProducerStateManager.java
@@ -369,17 +369,14 @@ public class ProducerStateManager {
      * Also expire any verification state entries that are lingering as unverified.
      */
     public void removeExpiredProducers(long currentTimeMs) {
-        List<Long> keys = producers.entrySet().stream()
-                .filter(entry -> isProducerExpired(currentTimeMs, entry.getValue()))
-                .map(Map.Entry::getKey)
-                .collect(Collectors.toList());
-        removeProducerIds(keys);
+        final int originalSize = producers.size();
+        producers.entrySet().removeIf(entry -> isProducerExpired(currentTimeMs, entry.getValue()));
+        if (producers.size() != originalSize) {
+            producerIdCount = producers.size();
+        }
 
-        List<Long> verificationKeys = verificationStates.entrySet().stream()
-                .filter(entry -> currentTimeMs - entry.getValue().timestamp() >= producerStateManagerConfig.producerIdExpirationMs())
-                .map(Map.Entry::getKey)
-                .collect(Collectors.toList());
-        verificationKeys.forEach(verificationStates::remove);
+        long expirationMs = producerStateManagerConfig.producerIdExpirationMs();
+        verificationStates.entrySet().removeIf(entry -> currentTimeMs - entry.getValue().timestamp() >= expirationMs);
     }
 
     /**
@@ -392,9 +389,14 @@ public class ProducerStateManager {
      */
     public void truncateAndReload(long logStartOffset, long logEndOffset, long currentTimeMs) throws IOException {
         // remove all out of range snapshots
-        for (SnapshotFile snapshot : snapshots.values()) {
+        {
+            Iterator<Map.Entry<Long, SnapshotFile>> iterator = snapshots.entrySet().iterator();
+            while (iterator.hasNext()) {
+                SnapshotFile snapshot = iterator.next().getValue();
                 if (snapshot.offset > logEndOffset || snapshot.offset <= logStartOffset) {
-                removeAndDeleteSnapshot(snapshot.offset);
+                    iterator.remove();
+                    snapshot.deleteIfExists();
+                }
             }
         }
 
@@ -599,8 +601,11 @@ public class ProducerStateManager {
      * @throws IOException if any IOException occurs while deleting the files.
      */
     public void deleteSnapshotsBefore(long offset) throws IOException {
-        for (SnapshotFile snapshot : snapshots.subMap(0L, offset).values()) {
-            removeAndDeleteSnapshot(snapshot.offset);
+        Iterator<Map.Entry<Long, SnapshotFile>> iterator = snapshots.subMap(0L, offset).entrySet().iterator();
+        while (iterator.hasNext()) {
+            SnapshotFile snapshot = iterator.next().getValue();
+            iterator.remove();
+            snapshot.deleteIfExists();
         }
     }
 
