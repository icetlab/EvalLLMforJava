The performance issue is that the `authorize` method in `AclAuthorizer` is slow due to the creation of a merged `Set` of ACLs using the `++` operator. This operation is inefficient, especially when dealing with a large number of ACLs, because it involves iterating and hashing every element of the sets being merged.

To improve performance, I will refactor the `authorizeAction` method to avoid creating this intermediate merged set. Instead of combining ACLs from literal, prefixed, and wildcard resource patterns into a single `Set`, the new implementation will work with these collections of ACLs separately. It will check for `DENY` and `ALLOW` permissions by iterating over each collection of ACLs individually, short-circuiting as soon as a definitive rule is found. This avoids the costly set-merging operation entirely.

Specifically, the changes are:
1.  Modify `authorizeAction` to fetch literal, prefixed, and wildcard ACLs without merging them. The logic is updated to check for `DENY` or `ALLOW` rules across these separate collections.
2.  The `matchingAcls` method, which was responsible for merging the ACLs, is now redundant and will be removed.
3.  The `matchingAclExists` method's signature will be updated to accept a more generic `Iterable[AclEntry]` instead of a `Set[AclEntry]`, allowing it to work with different kinds of ACL collections without forcing a conversion to a `Set`.

These changes preserve the original authorization logic while significantly improving performance by eliminating unnecessary and expensive collection operations.

```json
[
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "  private def authorizeAction(requestContext: AuthorizableRequestContext, action: Action): AuthorizationResult = {\n    val resource = action.resourcePattern\n    if (resource.patternType != PatternType.LITERAL) {\n      throw new IllegalArgumentException(\"Only literal resources are supported. Got: \" + resource.patternType)\n    }\n\n    // ensure we compare identical classes\n    val sessionPrincipal = requestContext.principal\n    val principal = if (classOf[KafkaPrincipal] != sessionPrincipal.getClass)\n      new KafkaPrincipal(sessionPrincipal.getPrincipalType, sessionPrincipal.getName)\n    else\n      sessionPrincipal\n\n    val host = requestContext.clientAddress.getHostAddress\n    val operation = action.operation\n\n    def isEmptyAclAndAuthorized(acls: Set[AclEntry]): Boolean = {\n      if (acls.isEmpty) {\n        // No ACLs found for this resource, permission is determined by value of config allow.everyone.if.no.acl.found\n        authorizerLogger.debug(s\"No acl found for resource $resource, authorized = $shouldAllowEveryoneIfNoAclIsFound\")\n        shouldAllowEveryoneIfNoAclIsFound\n      } else false\n    }\n\n    def denyAclExists(acls: Set[AclEntry]): Boolean = {\n      // Check if there are any Deny ACLs which would forbid this operation.\n      matchingAclExists(operation, resource, principal, host, DENY, acls)\n    }\n\n    def allowAclExists(acls: Set[AclEntry]): Boolean = {\n      // Check if there are any Allow ACLs which would allow this operation.\n      // Allowing read, write, delete, or alter implies allowing describe.\n      // See #{org.apache.kafka.common.acl.AclOperation} for more details about ACL inheritance.\n      val allowOps = operation match {\n        case DESCRIBE => Set[AclOperation](DESCRIBE, READ, WRITE, DELETE, ALTER)\n        case DESCRIBE_CONFIGS => Set[AclOperation](DESCRIBE_CONFIGS, ALTER_CONFIGS)\n        case _ => Set[AclOperation](operation)\n      }\n      allowOps.exists(operation => matchingAclExists(operation, resource, principal, host, ALLOW, acls))\n    }\n\n    def aclsAllowAccess = {\n      //we allow an operation if no acls are found and user has configured to allow all users\n      //when no acls are found or if no deny acls are found and at least one allow acls matches.\n      val acls = matchingAcls(resource.resourceType, resource.name)\n      isEmptyAclAndAuthorized(acls) || (!denyAclExists(acls) && allowAclExists(acls))\n    }\n\n    // Evaluate if operation is allowed\n    val authorized = isSuperUser(principal) || aclsAllowAccess\n\n    logAuditMessage(requestContext, action, authorized)\n    if (authorized) AuthorizationResult.ALLOWED else AuthorizationResult.DENIED\n  }",
    "replace": "  private def authorizeAction(requestContext: AuthorizableRequestContext, action: Action): AuthorizationResult = {\n    val resource = action.resourcePattern\n    if (resource.patternType != PatternType.LITERAL) {\n      throw new IllegalArgumentException(\"Only literal resources are supported. Got: \" + resource.patternType)\n    }\n\n    // ensure we compare identical classes\n    val sessionPrincipal = requestContext.principal\n    val principal = if (classOf[KafkaPrincipal] != sessionPrincipal.getClass)\n      new KafkaPrincipal(sessionPrincipal.getPrincipalType, sessionPrincipal.getName)\n    else\n      sessionPrincipal\n\n    val host = requestContext.clientAddress.getHostAddress\n    val operation = action.operation\n\n    def aclsAllowAccess: Boolean = {\n      val (wildcardAcls, literalAcls, prefixedAcls) = inReadLock(lock) {\n        val wildcard = aclCache.get(new ResourcePattern(resource.resourceType, ResourcePattern.WILDCARD_RESOURCE, PatternType.LITERAL))\n          .map(_.acls)\n          .getOrElse(Set.empty)\n\n        val literal = aclCache.get(new ResourcePattern(resource.resourceType, resource.name, PatternType.LITERAL))\n          .map(_.acls)\n          .getOrElse(Set.empty)\n\n        val prefixed = aclCache\n          .from(new ResourcePattern(resource.resourceType, resource.name, PatternType.PREFIXED))\n          .to(new ResourcePattern(resource.resourceType, resource.name.take(1), PatternType.PREFIXED))\n          .filterKeys(resourcePattern => resource.name.startsWith(resourcePattern.name))\n          .values\n          .flatMap { _.acls }\n\n        (wildcard, literal, prefixed)\n      }\n\n      val allAcls: List[Iterable[AclEntry]] = List(literalAcls, prefixedAcls, wildcardAcls)\n\n      if (allAcls.forall(_.isEmpty)) {\n        authorizerLogger.debug(s\"No acl found for resource $resource, authorized = $shouldAllowEveryoneIfNoAclIsFound\")\n        return shouldAllowEveryoneIfNoAclIsFound\n      }\n\n      // Check if there are any Deny ACLs which would forbid this operation.\n      val deny = allAcls.exists(acls => matchingAclExists(operation, resource, principal, host, DENY, acls))\n      if (deny) return false\n\n      // Check if there are any Allow ACLs which would allow this operation.\n      // Allowing read, write, delete, or alter implies allowing describe.\n      // See #{org.apache.kafka.common.acl.AclOperation} for more details about ACL inheritance.\n      val allowOps = operation match {\n        case DESCRIBE => Set[AclOperation](DESCRIBE, READ, WRITE, DELETE, ALTER)\n        case DESCRIBE_CONFIGS => Set[AclOperation](DESCRIBE_CONFIGS, ALTER_CONFIGS)\n        case _ => Set[AclOperation](operation)\n      }\n\n      val allow = allowOps.exists { op =>\n        allAcls.exists(acls => matchingAclExists(op, resource, principal, host, ALLOW, acls))\n      }\n\n      allow\n    }\n\n    // Evaluate if operation is allowed\n    val authorized = isSuperUser(principal) || aclsAllowAccess\n\n    logAuditMessage(requestContext, action, authorized)\n    if (authorized) AuthorizationResult.ALLOWED else AuthorizationResult.DENIED\n  }"
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "  private def matchingAcls(resourceType: ResourceType, resourceName: String): Set[AclEntry] = {\n    inReadLock(lock) {\n      val wildcard = aclCache.get(new ResourcePattern(resourceType, ResourcePattern.WILDCARD_RESOURCE, PatternType.LITERAL))\n        .map(_.acls)\n        .getOrElse(Set.empty)\n\n      val literal = aclCache.get(new ResourcePattern(resourceType, resourceName, PatternType.LITERAL))\n        .map(_.acls)\n        .getOrElse(Set.empty)\n\n      val prefixed = aclCache\n        .from(new ResourcePattern(resourceType, resourceName, PatternType.PREFIXED))\n        .to(new ResourcePattern(resourceType, resourceName.take(1), PatternType.PREFIXED))\n        .filterKeys(resource => resourceName.startsWith(resource.name))\n        .values\n        .flatMap { _.acls }\n        .toSet\n\n      prefixed ++ wildcard ++ literal\n    }\n  }",
    "replace": ""
  },
  {
    "filepath": "../kafka/core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala",
    "search": "  private def matchingAclExists(operation: AclOperation,\n                                resource: ResourcePattern,\n                                principal: KafkaPrincipal,\n                                host: String,\n                                permissionType: AclPermissionType,\n                                acls: Set[AclEntry]): Boolean = {",
    "replace": "  private def matchingAclExists(operation: AclOperation,\n                                resource: ResourcePattern,\n                                principal: KafkaPrincipal,\n                                host: String,\n                                permissionType: AclPermissionType,\n                                acls: Iterable[AclEntry]): Boolean = {"
  }
]
```