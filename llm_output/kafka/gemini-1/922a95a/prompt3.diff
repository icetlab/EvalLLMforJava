diff --git a/core/src/main/scala/kafka/cluster/Partition.scala b/core/src/main/scala/kafka/cluster/Partition.scala
index 9cfd99e8e5..98ee18a332 100755
--- a/core/src/main/scala/kafka/cluster/Partition.scala
+++ b/core/src/main/scala/kafka/cluster/Partition.scala
@@ -548,13 +548,15 @@ class Partition(val topicPartition: TopicPartition,
                    highWatermarkCheckpoints: OffsetCheckpoints): Boolean = {
     inWriteLock(leaderIsrUpdateLock) {
       val newLeaderBrokerId = partitionState.leader
-      val oldLeaderEpoch = leaderEpoch
+      if (leaderReplicaIdOpt.contains(newLeaderBrokerId) && partitionState.leaderEpoch == leaderEpoch) {
+        false
+      } else {
         // record the epoch of the controller that made the leadership decision. This is useful while updating the isr
         // to maintain the decision maker controller's epoch in the zookeeper path
         controllerEpoch = partitionState.controllerEpoch
 
         updateAssignmentAndIsr(
-        assignment = partitionState.replicas.asScala.iterator.map(_.toInt).toSeq,
+          assignment = partitionState.replicas.asScala.map(_.toInt),
           isr = Set.empty[Int],
           addingReplicas = partitionState.addingReplicas.asScala.map(_.toInt),
           removingReplicas = partitionState.removingReplicas.asScala.map(_.toInt)
@@ -565,9 +567,6 @@ class Partition(val topicPartition: TopicPartition,
         leaderEpochStartOffsetOpt = None
         zkVersion = partitionState.zkVersion
 
-      if (leaderReplicaIdOpt.contains(newLeaderBrokerId) && leaderEpoch == oldLeaderEpoch) {
-        false
-      } else {
         leaderReplicaIdOpt = Some(newLeaderBrokerId)
         true
       }
