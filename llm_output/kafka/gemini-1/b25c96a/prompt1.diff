diff --git a/storage/src/main/java/org/apache/kafka/storage/internals/log/ProducerStateManager.java b/storage/src/main/java/org/apache/kafka/storage/internals/log/ProducerStateManager.java
index 6bcafd2d60..e67094df90 100644
--- a/storage/src/main/java/org/apache/kafka/storage/internals/log/ProducerStateManager.java
+++ b/storage/src/main/java/org/apache/kafka/storage/internals/log/ProducerStateManager.java
@@ -43,7 +43,6 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
@@ -233,7 +232,7 @@ public class ProducerStateManager {
      * largest stray snapshot file which was emitted during clean shutdown.
      */
     public void removeStraySnapshots(Collection<Long> segmentBaseOffsets) throws IOException {
-        OptionalLong maxSegmentBaseOffset = segmentBaseOffsets.isEmpty() ? OptionalLong.empty() : OptionalLong.of(segmentBaseOffsets.stream().max(Long::compare).get());
+        OptionalLong maxSegmentBaseOffset = segmentBaseOffsets.stream().mapToLong(Long::longValue).max();
 
         HashSet<Long> baseOffsets = new HashSet<>(segmentBaseOffsets);
         Optional<SnapshotFile> latestStraySnapshot = Optional.empty();
@@ -369,17 +368,11 @@ public class ProducerStateManager {
      * Also expire any verification state entries that are lingering as unverified.
      */
     public void removeExpiredProducers(long currentTimeMs) {
-        List<Long> keys = producers.entrySet().stream()
-                .filter(entry -> isProducerExpired(currentTimeMs, entry.getValue()))
-                .map(Map.Entry::getKey)
-                .collect(Collectors.toList());
-        removeProducerIds(keys);
+        if (producers.entrySet().removeIf(entry -> isProducerExpired(currentTimeMs, entry.getValue()))) {
+            producerIdCount = producers.size();
+        }
 
-        List<Long> verificationKeys = verificationStates.entrySet().stream()
-                .filter(entry -> currentTimeMs - entry.getValue().timestamp() >= producerStateManagerConfig.producerIdExpirationMs())
-                .map(Map.Entry::getKey)
-                .collect(Collectors.toList());
-        verificationKeys.forEach(verificationStates::remove);
+        verificationStates.entrySet().removeIf(entry -> currentTimeMs - entry.getValue().timestamp() >= producerStateManagerConfig.producerIdExpirationMs());
     }
 
     /**
@@ -534,12 +527,10 @@ public class ProducerStateManager {
     }
 
     private void removeUnreplicatedTransactions(long offset) {
-        Iterator<Map.Entry<Long, TxnMetadata>> iterator = unreplicatedTxns.entrySet().iterator();
-        while (iterator.hasNext()) {
-            Map.Entry<Long, TxnMetadata> txnEntry = iterator.next();
+        unreplicatedTxns.entrySet().removeIf(txnEntry -> {
             OptionalLong lastOffset = txnEntry.getValue().lastOffset;
-            if (lastOffset.isPresent() && lastOffset.getAsLong() < offset) iterator.remove();
-        }
+            return lastOffset.isPresent() && lastOffset.getAsLong() < offset;
+        });
     }
 
     /**
