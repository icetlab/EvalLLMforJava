My overall improvement strategy is to optimize the `forId` and `forName` methods in the `CompressionType` enum. The original implementations use a `switch` statement and a chain of `if-else if` statements, respectively. These can be slow, especially `forName` which involves string comparisons.

I will replace these with pre-computed lookup tables:
1.  An array (`ID_TO_TYPE`) for `forId`, which provides O(1) lookup time.
2.  A `HashMap` (`NAME_TO_TYPE`) for `forName`, which provides an average O(1) lookup time.

These tables will be initialized once in a `static` block, ensuring that the cost of building them is paid only at class loading time. This change improves performance by replacing linear-time or branching logic with constant-time lookups, and it also makes the code more robust to non-contiguous `id` values.

```json
[
  {
    "filepath": "../kafka/clients/src/main/java/org/apache/kafka/common/record/CompressionType.java",
    "search": "    public abstract InputStream wrapForInput(ByteBuffer buffer, byte messageVersion, BufferSupplier decompressionBufferSupplier);\n\n    public static CompressionType forId(int id) {\n        switch (id) {\n            case 0:\n                return NONE;\n            case 1:\n                return GZIP;\n            case 2:\n                return SNAPPY;\n            case 3:\n                return LZ4;\n            case 4:\n                return ZSTD;\n            default:\n                throw new IllegalArgumentException(\"Unknown compression type id: \" + id);\n        }\n    }\n\n    public static CompressionType forName(String name) {\n        if (NONE.name.equals(name))\n            return NONE;\n        else if (GZIP.name.equals(name))\n            return GZIP;\n        else if (SNAPPY.name.equals(name))\n            return SNAPPY;\n        else if (LZ4.name.equals(name))\n            return LZ4;\n        else if (ZSTD.name.equals(name))\n            return ZSTD;\n        else\n            throw new IllegalArgumentException(\"Unknown compression name: \" + name);\n    }",
    "replace": "    public abstract InputStream wrapForInput(ByteBuffer buffer, byte messageVersion, BufferSupplier decompressionBufferSupplier);\n\n    private static final java.util.Map<String, CompressionType> NAME_TO_TYPE;\n    private static final CompressionType[] ID_TO_TYPE;\n\n    static {\n        CompressionType[] values = values();\n        int maxId = -1;\n        for (CompressionType type : values) {\n            maxId = Math.max(maxId, type.id);\n        }\n\n        ID_TO_TYPE = new CompressionType[maxId + 1];\n        NAME_TO_TYPE = new java.util.HashMap<>(values.length);\n\n        for (CompressionType type : values) {\n            ID_TO_TYPE[type.id] = type;\n            NAME_TO_TYPE.put(type.name, type);\n        }\n    }\n\n    public static CompressionType forId(int id) {\n        if (id < 0 || id >= ID_TO_TYPE.length || ID_TO_TYPE[id] == null) {\n            throw new IllegalArgumentException(\"Unknown compression type id: \" + id);\n        }\n        return ID_TO_TYPE[id];\n    }\n\n    public static CompressionType forName(String name) {\n        CompressionType type = NAME_TO_TYPE.get(name);\n        if (type == null) {\n            throw new IllegalArgumentException(\"Unknown compression name: \" + name);\n        }\n        return type;\n    }"
  }
]
```