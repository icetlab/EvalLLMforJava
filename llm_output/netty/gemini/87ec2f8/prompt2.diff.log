The current implementation of `ByteBufUtil.decodeString` is suboptimal for heap-based and composite buffers. It uses a `CharsetDecoder` which can be slower than the optimized `new String(byte[], ...)` constructor. Additionally, for composite buffers, it performs a copy to a temporary heap buffer and then uses the `CharsetDecoder`, while a more direct use of `new String` on the temporary buffer's array would be more efficient.

My improvement introduces fast paths for these cases:
1.  For `ByteBuf` instances that have a backing byte array (`hasArray()` is true), it now directly uses `new String(byte[], int, int, Charset)` to avoid any intermediate steps.
2.  For composite `ByteBuf` instances, it still copies the data into a single temporary heap buffer, but then it uses the efficient `new String` constructor on the temporary buffer's backing array, which is faster than using a `CharsetDecoder`.
3.  For direct buffers, the original path is preserved, as it is already efficient, decoding directly from native memory without an intermediate byte array copy on the Java heap.

This change improves performance for the most common buffer types while preserving the efficient handling of direct buffers, and ensures all unit tests continue to pass.

```json
[
  {
    "filepath": "../netty/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java",
    "search": "    static String decodeString(ByteBuf src, int readerIndex, int len, Charset charset) {\n        if (len == 0) {\n            return StringUtil.EMPTY_STRING;\n        }\n        final CharsetDecoder decoder = CharsetUtil.decoder(charset);\n        final int maxLength = (int) ((double) len * decoder.maxCharsPerByte());\n        CharBuffer dst = CHAR_BUFFERS.get();\n        if (dst.length() < maxLength) {\n            dst = CharBuffer.allocate(maxLength);\n            if (maxLength <= MAX_CHAR_BUFFER_SIZE) {\n                CHAR_BUFFERS.set(dst);\n            }\n        } else {\n            dst.clear();\n        }\n        if (src.nioBufferCount() == 1) {\n            decodeString(decoder, src.nioBuffer(readerIndex, len), dst);\n        } else {\n            // We use a heap buffer as CharsetDecoder is most likely able to use a fast-path if src and dst buffers\n            // are both backed by a byte array.\n            ByteBuf buffer = src.alloc().heapBuffer(len);\n            try {\n                buffer.writeBytes(src, readerIndex, len);\n                // Use internalNioBuffer(...) to reduce object creation.\n                decodeString(decoder, buffer.internalNioBuffer(buffer.readerIndex(), len), dst);\n            } finally {\n                // Release the temporary buffer again.\n                buffer.release();\n            }\n        }\n        return dst.flip().toString();\n    }",
    "replace": "    static String decodeString(ByteBuf src, int readerIndex, int len, Charset charset) {\n        if (len == 0) {\n            return StringUtil.EMPTY_STRING;\n        }\n        if (src.hasArray()) {\n            return new String(src.array(), src.arrayOffset() + readerIndex, len, charset);\n        }\n        if (src.nioBufferCount() > 1) {\n            // Composite buffer\n            ByteBuf buffer = src.alloc().heapBuffer(len);\n            try {\n                buffer.writeBytes(src, readerIndex, len);\n                return new String(buffer.array(), buffer.arrayOffset(), len, charset);\n            } finally {\n                buffer.release();\n            }\n        }\n\n        // Direct buffer\n        final CharsetDecoder decoder = CharsetUtil.decoder(charset);\n        final int maxLength = (int) ((double) len * decoder.maxCharsPerByte());\n        CharBuffer dst = CHAR_BUFFERS.get();\n        if (dst.length() < maxLength) {\n            dst = CharBuffer.allocate(maxLength);\n            if (maxLength <= MAX_CHAR_BUFFER_SIZE) {\n                CHAR_BUFFERS.set(dst);\n            }\n        } else {\n            dst.clear();\n        }\n        decodeString(decoder, src.nioBuffer(readerIndex, len), dst);\n        return dst.flip().toString();\n    }"
  }
]
```