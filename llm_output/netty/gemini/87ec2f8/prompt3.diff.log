My overall improvement strategy is to optimize `ByteBufUtil.decodeString` for different buffer types and charsets, as benchmarked.

For heap-backed buffers (`hasArray() == true`), I'll bypass the `CharsetDecoder` and `CharBuffer` management by using the `new String(byte[], int, int, Charset)` constructor directly. This is highly optimized in the JDK for common charsets and avoids intermediate object allocations. This will improve performance for `HEAP` and `HEAP_OFFSET` buffer types in the benchmark.

For composite buffers (`nioBufferCount() > 1`), the original code already copies data to a temporary heap buffer to get a contiguous memory region. I'll extend this by also using the `new String(byte[], ...)` constructor on this temporary buffer, which is more direct and faster than using a `CharsetDecoder`. This will benefit the `COMPOSITE` buffer type.

For direct buffers, which are not array-backed and have a single NIO buffer, I'll retain the existing `CharsetDecoder`-based implementation. This path is already efficient for `DirectByteBuffer` as the JDK's decoders are often optimized (e.g., via intrinsics) for direct memory access, and this avoids an unnecessary copy to a heap buffer.

This set of changes provides targeted optimizations for each buffer type, leading to significant performance gains where applicable, while preserving the correctness and performance of the existing well-tuned paths.

```json
[
  {
    "filepath": "../netty/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java",
    "search": "    static String decodeString(ByteBuf src, int readerIndex, int len, Charset charset) {\n        if (len == 0) {\n            return StringUtil.EMPTY_STRING;\n        }\n        final CharsetDecoder decoder = CharsetUtil.decoder(charset);\n        final int maxLength = (int) ((double) len * decoder.maxCharsPerByte());\n        CharBuffer dst = CHAR_BUFFERS.get();\n        if (dst.length() < maxLength) {\n            dst = CharBuffer.allocate(maxLength);\n            if (maxLength <= MAX_CHAR_BUFFER_SIZE) {\n                CHAR_BUFFERS.set(dst);\n            }\n        } else {\n            dst.clear();\n        }\n        if (src.nioBufferCount() == 1) {\n            decodeString(decoder, src.nioBuffer(readerIndex, len), dst);\n        } else {\n            // We use a heap buffer as CharsetDecoder is most likely able to use a fast-path if src and dst buffers\n            // are both backed by a byte array.\n            ByteBuf buffer = src.alloc().heapBuffer(len);\n            try {\n                buffer.writeBytes(src, readerIndex, len);\n                // Use internalNioBuffer(...) to reduce object creation.\n                decodeString(decoder, buffer.internalNioBuffer(buffer.readerIndex(), len), dst);\n            } finally {\n                // Release the temporary buffer again.\n                buffer.release();\n            }\n        }\n        return dst.flip().toString();\n    }",
    "replace": "    static String decodeString(ByteBuf src, int readerIndex, int len, Charset charset) {\n        if (len == 0) {\n            return StringUtil.EMPTY_STRING;\n        }\n        if (src.hasArray()) {\n            return new String(src.array(), src.arrayOffset() + readerIndex, len, charset);\n        }\n\n        if (src.nioBufferCount() > 1) {\n            // For composite buffers, we need to copy to a contiguous buffer first.\n            ByteBuf buffer = src.alloc().heapBuffer(len);\n            try {\n                buffer.writeBytes(src, readerIndex, len);\n                return new String(buffer.array(), buffer.arrayOffset(), len, charset);\n            } finally {\n                buffer.release();\n            }\n        }\n\n        // The buffer has a single NIO buffer and is not array-backed, i.e. a direct buffer.\n        final CharsetDecoder decoder = CharsetUtil.decoder(charset);\n        final int maxLength = (int) ((double) len * decoder.maxCharsPerByte());\n        CharBuffer dst = CHAR_BUFFERS.get();\n        if (dst.length() < maxLength) {\n            dst = CharBuffer.allocate(maxLength);\n            if (maxLength <= MAX_CHAR_BUFFER_SIZE) {\n                CHAR_BUFFERS.set(dst);\n            }\n        } else {\n            dst.clear();\n        }\n\n        decodeString(decoder, src.nioBuffer(readerIndex, len), dst);\n        return dst.flip().toString();\n    }"
  }
]
```