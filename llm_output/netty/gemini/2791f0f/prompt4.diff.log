To address the performance bottleneck caused by the static `AtomicLong` for task ID generation, I will implement a per-executor ID counter. This eliminates the contention that occurs when multiple event loops schedule tasks concurrently.

The changes involve:
1.  In `AbstractScheduledEventExecutor`, I will introduce a non-volatile `long` counter for task IDs. This counter will be incremented and its value assigned to a task only when the task is being added to the `scheduledTaskQueue`, which always happens within the event loop thread. This ensures thread-safety without requiring atomic operations or locks.
2.  In `ScheduledFutureTask`, the static `AtomicLong` will be removed. The `id` field will no longer be `final` and will be assigned a value via a new package-private setter method just before the task is enqueued. This approach maintains the uniqueness of task IDs within each executor's queue, which is sufficient for the `compareTo` logic, while significantly improving performance under high-frequency task scheduling across multiple threads.

```json
[
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java",
    "search": "    PriorityQueue<ScheduledFutureTask<?>> scheduledTaskQueue;\n\n    protected AbstractScheduledEventExecutor() {",
    "replace": "    PriorityQueue<ScheduledFutureTask<?>> scheduledTaskQueue;\n\n    private long nextTaskId;\n\n    protected AbstractScheduledEventExecutor() {"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java",
    "search": "    private <V> ScheduledFuture<V> schedule(final ScheduledFutureTask<V> task) {\n        if (inEventLoop()) {\n            scheduledTaskQueue().add(task);\n        } else {\n            executeScheduledRunnable(new Runnable() {\n                @Override\n                public void run() {\n                    scheduledTaskQueue().add(task);\n                }\n            }, true, task.deadlineNanos());\n        }\n\n        return task;\n    }",
    "replace": "    private <V> ScheduledFuture<V> schedule(final ScheduledFutureTask<V> task) {\n        if (inEventLoop()) {\n            task.setId(nextTaskId++);\n            scheduledTaskQueue().add(task);\n        } else {\n            executeScheduledRunnable(new Runnable() {\n                @Override\n                public void run() {\n                    task.setId(nextTaskId++);\n                    scheduledTaskQueue().add(task);\n                }\n            }, true, task.deadlineNanos());\n        }\n\n        return task;\n    }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java",
    "search": "final class ScheduledFutureTask<V> extends PromiseTask<V> implements ScheduledFuture<V>, PriorityQueueNode {\n    private static final AtomicLong nextTaskId = new AtomicLong();\n    private static final long START_TIME = System.nanoTime();\n\n    static long nanoTime() {\n        return System.nanoTime() - START_TIME;\n    }\n\n    static long deadlineNanos(long delay) {\n        long deadlineNanos = nanoTime() + delay;\n        // Guard against overflow\n        return deadlineNanos < 0 ? Long.MAX_VALUE : deadlineNanos;\n    }\n\n    static long initialNanoTime() {\n        return START_TIME;\n    }\n\n    private final long id = nextTaskId.getAndIncrement();",
    "replace": "final class ScheduledFutureTask<V> extends PromiseTask<V> implements ScheduledFuture<V>, PriorityQueueNode {\n    private static final long START_TIME = System.nanoTime();\n\n    static long nanoTime() {\n        return System.nanoTime() - START_TIME;\n    }\n\n    static long deadlineNanos(long delay) {\n        long deadlineNanos = nanoTime() + delay;\n        // Guard against overflow\n        return deadlineNanos < 0 ? Long.MAX_VALUE : deadlineNanos;\n    }\n\n    static long initialNanoTime() {\n        return START_TIME;\n    }\n\n    private long id;"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java",
    "search": "    ScheduledFutureTask(\n            AbstractScheduledEventExecutor executor,\n            Callable<V> callable, long nanoTime) {\n\n        super(executor, callable);\n        deadlineNanos = nanoTime;\n        periodNanos = 0;\n    }\n\n    @Override\n    protected EventExecutor executor() {",
    "replace": "    ScheduledFutureTask(\n            AbstractScheduledEventExecutor executor,\n            Callable<V> callable, long nanoTime) {\n\n        super(executor, callable);\n        deadlineNanos = nanoTime;\n        periodNanos = 0;\n    }\n\n    void setId(long id) {\n        this.id = id;\n    }\n\n    @Override\n    protected EventExecutor executor() {"
  }
]
```