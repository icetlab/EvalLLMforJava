My change improves the performance of `QueryStringEncoder` by optimizing how strings are appended to the internal `StringBuilder`. The original code appended characters one-by-one, even for strings that didn't need any URL encoding.

I've introduced a fast path that first scans the input string to check if any character requires encoding.
1.  If no characters need encoding, the entire string is appended to the `StringBuilder` in a single call, which is much more efficient.
2.  If the string contains characters that need encoding, the initial portion of the string that is "safe" (requires no encoding) is appended as a single block. The encoding process then continues from the first character that requires it.

This approach significantly reduces the number of calls to `StringBuilder.append()`, minimizing overhead and improving performance, especially for query parameters that often contain unreserved characters. These optimizations are applied to both the UTF-8 and non-UTF-8 encoding paths.

```json
[
  {
    "filepath": "../netty/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java",
    "search": "    private void encodeNonUtf8Component(CharSequence s) {\n        //Don't allocate memory until needed\n        char[] buf = null;\n\n        for (int i = 0, len = s.length(); i < len;) {\n            char c = s.charAt(i);\n            if (dontNeedEncoding(c)) {\n                uriBuilder.append(c);\n                i++;\n            } else {\n                int index = 0;\n                if (buf == null) {\n                    buf = new char[s.length() - i];\n                }\n\n                do {\n                    buf[index] = c;\n                    index++;\n                    i++;\n                } while (i < s.length() && !dontNeedEncoding(c = s.charAt(i)));\n\n                byte[] bytes = new String(buf, 0, index).getBytes(charset);\n\n                for (byte b : bytes) {\n                    appendEncoded(b);\n                }\n            }\n        }\n    }",
    "replace": "    private void encodeNonUtf8Component(CharSequence s) {\n        int firstNeedToEncode = -1;\n        for (int i = 0; i < s.length(); i++) {\n            if (!dontNeedEncoding(s.charAt(i))) {\n                firstNeedToEncode = i;\n                break;\n            }\n        }\n\n        if (firstNeedToEncode == -1) {\n            uriBuilder.append(s);\n            return;\n        }\n\n        uriBuilder.append(s, 0, firstNeedToEncode);\n\n        //Don't allocate memory until needed\n        char[] buf = null;\n\n        for (int i = firstNeedToEncode, len = s.length(); i < len;) {\n            char c = s.charAt(i);\n            if (dontNeedEncoding(c)) {\n                uriBuilder.append(c);\n                i++;\n            } else {\n                int index = 0;\n                if (buf == null) {\n                    buf = new char[s.length() - i];\n                }\n\n                do {\n                    buf[index] = c;\n                    index++;\n                    i++;\n                } while (i < s.length() && !dontNeedEncoding(c = s.charAt(i)));\n\n                byte[] bytes = new String(buf, 0, index).getBytes(charset);\n\n                for (byte b : bytes) {\n                    appendEncoded(b);\n                }\n            }\n        }\n    }"
  },
  {
    "filepath": "../netty/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java",
    "search": "    private void encodeUtf8Component(CharSequence s) {\n        for (int i = 0, len = s.length(); i < len; i++) {\n            char c = s.charAt(i);\n            if (c < 0x80) {\n                if (dontNeedEncoding(c)) {\n                    uriBuilder.append(c);\n                } else {\n                    appendEncoded(c);\n                }\n            } else if (c < 0x800) {\n                appendEncoded(0xc0 | (c >> 6));\n                appendEncoded(0x80 | (c & 0x3f));\n            } else if (StringUtil.isSurrogate(c)) {\n                if (!Character.isHighSurrogate(c)) {\n                    appendEncoded(WRITE_UTF_UNKNOWN);\n                    continue;\n                }\n                // Surrogate Pair consumes 2 characters.\n                if (++i == s.length()) {\n                    appendEncoded(WRITE_UTF_UNKNOWN);\n                    break;\n                }\n                // Extra method to allow inlining the rest of writeUtf8 which is the most likely code path.\n                writeUtf8Surrogate(c, s.charAt(i));\n            } else {\n                appendEncoded(0xe0 | (c >> 12));\n                appendEncoded(0x80 | ((c >> 6) & 0x3f));\n                appendEncoded(0x80 | (c & 0x3f));\n            }\n        }\n    }",
    "replace": "    private void encodeUtf8Component(CharSequence s) {\n        int firstNeedToEncode = -1;\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c >= 0x80 || !dontNeedEncoding(c)) {\n                firstNeedToEncode = i;\n                break;\n            }\n        }\n\n        if (firstNeedToEncode == -1) {\n            uriBuilder.append(s);\n            return;\n        }\n\n        uriBuilder.append(s, 0, firstNeedToEncode);\n\n        for (int i = firstNeedToEncode, len = s.length(); i < len; i++) {\n            char c = s.charAt(i);\n            if (c < 0x80) {\n                if (dontNeedEncoding(c)) {\n                    uriBuilder.append(c);\n                } else {\n                    appendEncoded(c);\n                }\n            } else if (c < 0x800) {\n                appendEncoded(0xc0 | (c >> 6));\n                appendEncoded(0x80 | (c & 0x3f));\n            } else if (StringUtil.isSurrogate(c)) {\n                if (!Character.isHighSurrogate(c)) {\n                    appendEncoded(WRITE_UTF_UNKNOWN);\n                    continue;\n                }\n                // Surrogate Pair consumes 2 characters.\n                if (++i == s.length()) {\n                    appendEncoded(WRITE_UTF_UNKNOWN);\n                    break;\n                }\n                // Extra method to allow inlining the rest of writeUtf8 which is the most likely code path.\n                writeUtf8Surrogate(c, s.charAt(i));\n            } else {\n                appendEncoded(0xe0 | (c >> 12));\n                appendEncoded(0x80 | ((c >> 6) & 0x3f));\n                appendEncoded(0x80 | (c & 0x3f));\n            }\n        }\n    }"
  }
]
```