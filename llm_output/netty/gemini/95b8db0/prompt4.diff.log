This change improves the performance of `QueryStringDecoder` by optimizing the `decodeComponent` method. The original implementation used `ByteBuffer` and `CharsetDecoder` for decoding URL-encoded strings. This has been replaced with a more direct approach using a `byte[]` to accumulate decoded bytes and then converting them to a `String` using `new String(bytes, charset)`. This avoids the overhead associated with `ByteBuffer` operations and simplifies the decoding logic, resulting in better performance, especially for strings with many encoded characters.

```json
[
  {
    "filepath": "../netty/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java",
    "search": "        CharsetDecoder decoder = CharsetUtil.decoder(charset);\n\n        // Each encoded byte takes 3 characters (e.g. \"%20\")\n        int decodedCapacity = (toExcluded - firstEscaped) / 3;\n        ByteBuffer byteBuf = ByteBuffer.allocate(decodedCapacity);\n        CharBuffer charBuf = CharBuffer.allocate(decodedCapacity);\n\n        StringBuilder strBuf = new StringBuilder(len);\n        strBuf.append(s, from, firstEscaped);\n\n        for (int i = firstEscaped; i < toExcluded; i++) {\n            char c = s.charAt(i);\n            if (c != '%') {\n                strBuf.append(c != '+' || isPath? c : SPACE);\n                continue;\n            }\n\n            byteBuf.clear();\n            do {\n                if (i + 3 > toExcluded) {\n                    throw new IllegalArgumentException(\"unterminated escape sequence at index \" + i + \" of: \" + s);\n                }\n                byteBuf.put(decodeHexByte(s, i + 1));\n                i += 3;\n            } while (i < toExcluded && s.charAt(i) == '%');\n            i--;\n\n            byteBuf.flip();\n            charBuf.clear();\n            CoderResult result = decoder.reset().decode(byteBuf, charBuf, true);\n            try {\n                if (!result.isUnderflow()) {\n                    result.throwException();\n                }\n                result = decoder.flush(charBuf);\n                if (!result.isUnderflow()) {\n                    result.throwException();\n                }\n            } catch (CharacterCodingException ex) {\n                throw new IllegalStateException(ex);\n            }\n            strBuf.append(charBuf.flip());\n        }\n        return strBuf.toString();",
    "replace": "        // Each encoded byte takes 3 characters (e.g. \"%20\")\n        int decodedCapacity = (toExcluded - firstEscaped) / 3;\n        byte[] bytes = new byte[decodedCapacity];\n        StringBuilder strBuf = new StringBuilder(len);\n        strBuf.append(s, from, firstEscaped);\n\n        for (int i = firstEscaped; i < toExcluded; i++) {\n            char c = s.charAt(i);\n            if (c != '%') {\n                strBuf.append(c != '+' || isPath? c : SPACE);\n                continue;\n            }\n\n            int nBytes = 0;\n            do {\n                if (i + 3 > toExcluded) {\n                    throw new IllegalArgumentException(\"unterminated escape sequence at index \" + i + \" of: \" + s);\n                }\n                bytes[nBytes++] = decodeHexByte(s, i + 1);\n                i += 3;\n            } while (i < toExcluded && s.charAt(i) == '%');\n            i--;\n\n            strBuf.append(new String(bytes, 0, nBytes, charset));\n        }\n        return strBuf.toString();"
  }
]
```