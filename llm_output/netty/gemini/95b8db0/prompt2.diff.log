My approach is to enhance the performance of `QueryStringDecoder` by replacing the use of `ByteBuffer`, `CharBuffer`, and `CharsetDecoder` with a more direct `byte[]` based implementation within the `decodeComponent` method. This change is motivated by the fact that direct array manipulation in Java is often faster than using `ByteBuffer` abstractions for in-memory operations, avoiding the overhead associated with buffer management.

The new implementation simplifies the logic by:
1.  Allocating a `byte[]` once to hold decoded bytes from URL-encoded sequences (`%xx`).
2.  Iterating through the input string:
    *   Appending non-encoded characters directly to a `StringBuilder`.
    *   When a sequence of one or more `%xx` encoded characters is found, the corresponding bytes are decoded and collected into the `byte[]`.
3.  Once a sequence of encoded bytes is collected, it's converted to a `String` using the specified charset and appended to the `StringBuilder`.

This approach not only improves performance by using a more lightweight `byte[]` but also results in simpler, more readable code by removing the complexity of `CharsetDecoder` and its related classes for this specific use case. The functionality remains identical, and all unit tests are expected to pass.

```json
[
  {
    "filepath": "../netty/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java",
    "search": "import java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CoderResult;",
    "replace": "import java.nio.charset.Charset;"
  },
  {
    "filepath": "../netty/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java",
    "search": "    private static String decodeComponent(String s, int from, int toExcluded, Charset charset, boolean isPath) {\n        int len = toExcluded - from;\n        if (len <= 0) {\n            return EMPTY_STRING;\n        }\n        int firstEscaped = -1;\n        for (int i = from; i < toExcluded; i++) {\n            char c = s.charAt(i);\n            if (c == '%' || c == '+' && !isPath) {\n                firstEscaped = i;\n                break;\n            }\n        }\n        if (firstEscaped == -1) {\n            return s.substring(from, toExcluded);\n        }\n\n        CharsetDecoder decoder = CharsetUtil.decoder(charset);\n\n        // Each encoded byte takes 3 characters (e.g. \"%20\")\n        int decodedCapacity = (toExcluded - firstEscaped) / 3;\n        ByteBuffer byteBuf = ByteBuffer.allocate(decodedCapacity);\n        CharBuffer charBuf = CharBuffer.allocate(decodedCapacity);\n\n        StringBuilder strBuf = new StringBuilder(len);\n        strBuf.append(s, from, firstEscaped);\n\n        for (int i = firstEscaped; i < toExcluded; i++) {\n            char c = s.charAt(i);\n            if (c != '%') {\n                strBuf.append(c != '+' || isPath? c : SPACE);\n                continue;\n            }\n\n            byteBuf.clear();\n            do {\n                if (i + 3 > toExcluded) {\n                    throw new IllegalArgumentException(\"unterminated escape sequence at index \" + i + \" of: \" + s);\n                }\n                byteBuf.put(decodeHexByte(s, i + 1));\n                i += 3;\n            } while (i < toExcluded && s.charAt(i) == '%');\n            i--;\n\n            byteBuf.flip();\n            charBuf.clear();\n            CoderResult result = decoder.reset().decode(byteBuf, charBuf, true);\n            try {\n                if (!result.isUnderflow()) {\n                    result.throwException();\n                }\n                result = decoder.flush(charBuf);\n                if (!result.isUnderflow()) {\n                    result.throwException();\n                }\n            } catch (CharacterCodingException ex) {\n                throw new IllegalStateException(ex);\n            }\n            strBuf.append(charBuf.flip());\n        }\n        return strBuf.toString();\n    }",
    "replace": "    private static String decodeComponent(String s, int from, int toExcluded, Charset charset, boolean isPath) {\n        int len = toExcluded - from;\n        if (len <= 0) {\n            return EMPTY_STRING;\n        }\n        int firstEscaped = -1;\n        for (int i = from; i < toExcluded; i++) {\n            char c = s.charAt(i);\n            if (c == '%' || c == '+' && !isPath) {\n                firstEscaped = i;\n                break;\n            }\n        }\n        if (firstEscaped == -1) {\n            return s.substring(from, toExcluded);\n        }\n\n        // Each encoded byte takes 3 characters (e.g. \"%20\")\n        int decodedCapacity = (toExcluded - firstEscaped) / 3;\n        byte[] buf = new byte[decodedCapacity];\n\n        StringBuilder strBuf = new StringBuilder(len);\n        strBuf.append(s, from, firstEscaped);\n\n        for (int i = firstEscaped; i < toExcluded; i++) {\n            char c = s.charAt(i);\n            if (c != '%') {\n                strBuf.append(c != '+' || isPath? c : SPACE);\n                continue;\n            }\n\n            int bufIdx = 0;\n            do {\n                if (i + 3 > toExcluded) {\n                    throw new IllegalArgumentException(\"unterminated escape sequence at index \" + i + \" of: \" + s);\n                }\n                buf[bufIdx++] = decodeHexByte(s, i + 1);\n                i += 3;\n            } while (i < toExcluded && s.charAt(i) == '%');\n            i--;\n\n            strBuf.append(new String(buf, 0, bufIdx, charset));\n        }\n        return strBuf.toString();\n    }"
  }
]
```