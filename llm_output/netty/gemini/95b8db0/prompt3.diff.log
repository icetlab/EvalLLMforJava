My overall improvement strategy is to optimize the `decodeComponent` method, which is a performance-critical part of the `QueryStringDecoder`. The benchmarks indicate that decoding URI parameters is a key workload.

The primary optimization is to introduce a fast path for UTF-8, which is the most common charset on the web and the default in Netty. For UTF-8 encoded components, the improved code avoids the overhead of using a `java.nio.charset.CharsetDecoder` and allocating a `java.nio.CharBuffer`. Instead, it decodes the byte sequence directly into a `String`. This reduces object allocations and method call overhead.

To further reduce allocations, the `ByteBuffer`, `CharsetDecoder`, and `CharBuffer` are now lazily initialized only when they are actually needed for decoding. This benefits cases with no percent-encoded characters or when using the UTF-8 fast path.

These changes are localized within the private `decodeComponent` method, ensuring no impact on the public API while improving performance for the common use cases targeted by the benchmarks.

```json
[
  {
    "filepath": "../netty/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java",
    "search": "private static String decodeComponent(String s, int from, int toExcluded, Charset charset, boolean isPath) {\n        int len = toExcluded - from;\n        if (len <= 0) {\n            return EMPTY_STRING;\n        }\n        int firstEscaped = -1;\n        for (int i = from; i < toExcluded; i++) {\n            char c = s.charAt(i);\n            if (c == '%' || c == '+' && !isPath) {\n                firstEscaped = i;\n                break;\n            }\n        }\n        if (firstEscaped == -1) {\n            return s.substring(from, toExcluded);\n        }\n\n        CharsetDecoder decoder = CharsetUtil.decoder(charset);\n\n        // Each encoded byte takes 3 characters (e.g. \"%20\")\n        int decodedCapacity = (toExcluded - firstEscaped) / 3;\n        ByteBuffer byteBuf = ByteBuffer.allocate(decodedCapacity);\n        CharBuffer charBuf = CharBuffer.allocate(decodedCapacity);\n\n        StringBuilder strBuf = new StringBuilder(len);\n        strBuf.append(s, from, firstEscaped);\n\n        for (int i = firstEscaped; i < toExcluded; i++) {\n            char c = s.charAt(i);\n            if (c != '%') {\n                strBuf.append(c != '+' || isPath? c : SPACE);\n                continue;\n            }\n\n            byteBuf.clear();\n            do {\n                if (i + 3 > toExcluded) {\n                    throw new IllegalArgumentException(\"unterminated escape sequence at index \" + i + \" of: \" + s);\n                }\n                byteBuf.put(decodeHexByte(s, i + 1));\n                i += 3;\n            } while (i < toExcluded && s.charAt(i) == '%');\n            i--;\n\n            byteBuf.flip();\n            charBuf.clear();\n            CoderResult result = decoder.reset().decode(byteBuf, charBuf, true);\n            try {\n                if (!result.isUnderflow()) {\n                    result.throwException();\n                }\n                result = decoder.flush(charBuf);\n                if (!result.isUnderflow()) {\n                    result.throwException();\n                }\n            } catch (CharacterCodingException ex) {\n                throw new IllegalStateException(ex);\n            }\n            strBuf.append(charBuf.flip());\n        }\n        return strBuf.toString();\n    }",
    "replace": "    private static String decodeComponent(String s, int from, int toExcluded, Charset charset, boolean isPath) {\n        int len = toExcluded - from;\n        if (len <= 0) {\n            return EMPTY_STRING;\n        }\n        int firstEscaped = -1;\n        for (int i = from; i < toExcluded; i++) {\n            char c = s.charAt(i);\n            if (c == '%' || c == '+' && !isPath) {\n                firstEscaped = i;\n                break;\n            }\n        }\n        if (firstEscaped == -1) {\n            return s.substring(from, toExcluded);\n        }\n\n        // Each encoded byte takes 3 characters (e.g. \"%20\")\n        int decodedCapacity = (toExcluded - firstEscaped) / 3;\n        StringBuilder strBuf = new StringBuilder(len);\n        strBuf.append(s, from, firstEscaped);\n\n        ByteBuffer byteBuf = null;\n        CharBuffer charBuf = null;\n        CharsetDecoder decoder = null;\n\n        for (int i = firstEscaped; i < toExcluded; i++) {\n            char c = s.charAt(i);\n            if (c != '%') {\n                strBuf.append(c != '+' || isPath? c : SPACE);\n                continue;\n            }\n\n            if (byteBuf == null) {\n                byteBuf = ByteBuffer.allocate(decodedCapacity);\n            }\n            byteBuf.clear();\n            do {\n                if (i + 3 > toExcluded) {\n                    throw new IllegalArgumentException(\"unterminated escape sequence at index \" + i + \" of: \" + s);\n                }\n                byteBuf.put(decodeHexByte(s, i + 1));\n                i += 3;\n            } while (i < toExcluded && s.charAt(i) == '%');\n            i--;\n            byteBuf.flip();\n\n            if (charset.equals(CharsetUtil.UTF_8)) {\n                strBuf.append(new String(byteBuf.array(), byteBuf.arrayOffset() + byteBuf.position(),\n                                         byteBuf.remaining(), charset));\n            } else {\n                if (decoder == null) {\n                    decoder = CharsetUtil.decoder(charset);\n                    charBuf = CharBuffer.allocate(decodedCapacity);\n                }\n                charBuf.clear();\n                CoderResult result = decoder.reset().decode(byteBuf, charBuf, true);\n                try {\n                    if (!result.isUnderflow()) {\n                        result.throwException();\n                    }\n                    result = decoder.flush(charBuf);\n                    if (!result.isUnderflow()) {\n                        result.throwException();\n                    }\n                } catch (CharacterCodingException ex) {\n                    throw new IllegalStateException(ex);\n                }\n                strBuf.append(charBuf.flip());\n            }\n        }\n        return strBuf.toString();\n    }"
  }
]
```