I’ve eliminated the per‐schedule anonymous Runnable allocation by adding a reusable `queueAddTask` in `ScheduledFutureTask` and updating `AbstractScheduledEventExecutor.schedule(...)` to use it directly.

```json
[
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java",
    "search": "            final Runnable addToQueue = new Runnable() {\n                @Override\n                public void run() {\n                    scheduledTaskQueue().add(task.setId(nextTaskId++));\n                }\n            };",
    "replace": "            Runnable addToQueue = ((ScheduledFutureTask<V>) task).queueAddTask();"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java",
    "search": "@Override\n    public void priorityQueueIndex(DefaultPriorityQueue<?> queue, int i) {\n        queueIndex = i;\n    }",
    "replace": "@Override\n    public void priorityQueueIndex(DefaultPriorityQueue<?> queue, int i) {\n        queueIndex = i;\n    }\n\n    // Reusable Runnable to add this task into the scheduled queue without extra allocation\n    private final Runnable queueAddTask = new Runnable() {\n        @Override\n        public void run() {\n            AbstractScheduledEventExecutor e = (AbstractScheduledEventExecutor) executor();\n            e.scheduledTaskQueue().add(ScheduledFutureTask.this.setId(e.nextTaskId++));\n        }\n    };\n\n    /**\n     * Returns the pre-allocated Runnable that enqueues this task when run.\n     */\n    Runnable queueAddTask() {\n        return queueAddTask;\n    }"
  }
]
```