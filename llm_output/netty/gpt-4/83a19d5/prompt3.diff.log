Iâ€™ve replaced the reflective AtomicIntegerFieldUpdater and volatile int with a direct AtomicInteger, and updated all refCnt operations to use its atomic methods. This should reduce overhead in hot paths without changing behavior.

```json
[
  {
    "filepath": "../netty/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java",
    "search": "import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;",
    "replace": "import java.util.concurrent.atomic.AtomicInteger;"
  },
  {
    "filepath": "../netty/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java",
    "search": "private static final AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> refCntUpdater =\n            AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, \"refCnt\");\n\n    private volatile int refCnt;",
    "replace": "private final AtomicInteger refCnt = new AtomicInteger(1);"
  },
  {
    "filepath": "../netty/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java",
    "search": "refCntUpdater.set(this, 1);",
    "replace": ""
  },
  {
    "filepath": "../netty/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java",
    "search": "public int refCnt() {\n        return refCnt;\n    }",
    "replace": "public int refCnt() {\n        return refCnt.get();\n    }"
  },
  {
    "filepath": "../netty/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java",
    "search": "protected final void setRefCnt(int refCnt) {\n        refCntUpdater.set(this, refCnt);\n    }",
    "replace": "protected final void setRefCnt(int refCnt) {\n        this.refCnt.set(refCnt);\n    }"
  },
  {
    "filepath": "../netty/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java",
    "search": "private ByteBuf retain0(int increment) {\n        for (;;) {\n            int refCnt = this.refCnt;\n            final int nextCnt = refCnt + increment;\n\n            // Ensure we not resurrect (which means the refCnt was 0) and also that we encountered an overflow.\n            if (nextCnt <= increment) {\n                throw new IllegalReferenceCountException(refCnt, increment);\n            }\n            if (refCntUpdater.compareAndSet(this, refCnt, nextCnt)) {\n                break;\n            }\n        }\n        return this;\n    }",
    "replace": "private ByteBuf retain0(int increment) {\n        for (;;) {\n            int oldCnt = refCnt.get();\n            final int nextCnt = oldCnt + increment;\n\n            // Ensure we not resurrect (which means the refCnt was 0) and also that we encountered an overflow.\n            if (nextCnt <= increment) {\n                throw new IllegalReferenceCountException(oldCnt, increment);\n            }\n            if (refCnt.compareAndSet(oldCnt, nextCnt)) {\n                break;\n            }\n        }\n        return this;\n    }"
  },
  {
    "filepath": "../netty/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java",
    "search": "private boolean release0(int decrement) {\n        for (;;) {\n            int refCnt = this.refCnt;\n            if (refCnt < decrement) {\n                throw new IllegalReferenceCountException(refCnt, -decrement);\n            }\n\n            if (refCntUpdater.compareAndSet(this, refCnt, refCnt - decrement)) {\n                if (refCnt == decrement) {\n                    deallocate();\n                    return true;\n                }\n                return false;\n            }\n        }\n    }",
    "replace": "private boolean release0(int decrement) {\n        for (;;) {\n            int oldCnt = refCnt.get();\n            if (oldCnt < decrement) {\n                throw new IllegalReferenceCountException(oldCnt, -decrement);\n            }\n\n            if (refCnt.compareAndSet(oldCnt, oldCnt - decrement)) {\n                if (oldCnt == decrement) {\n                    deallocate();\n                    return true;\n                }\n                return false;\n            }\n        }\n    }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/AbstractReferenceCounted.java",
    "search": "import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;",
    "replace": "import java.util.concurrent.atomic.AtomicInteger;"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/AbstractReferenceCounted.java",
    "search": "private static final AtomicIntegerFieldUpdater<AbstractReferenceCounted> refCntUpdater =\n            AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCounted.class, \"refCnt\");\n\n    private volatile int refCnt = 1;",
    "replace": "private final AtomicInteger refCnt = new AtomicInteger(1);"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/AbstractReferenceCounted.java",
    "search": "public final int refCnt() {\n        return refCnt;\n    }",
    "replace": "public final int refCnt() {\n        return refCnt.get();\n    }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/AbstractReferenceCounted.java",
    "search": "protected final void setRefCnt(int refCnt) {\n        refCntUpdater.set(this, refCnt);\n    }",
    "replace": "protected final void setRefCnt(int refCnt) {\n        this.refCnt.set(refCnt);\n    }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/AbstractReferenceCounted.java",
    "search": "private ReferenceCounted retain0(int increment) {\n        for (;;) {\n            int refCnt = this.refCnt;\n            final int nextCnt = refCnt + increment;\n\n            // Ensure we not resurrect (which means the refCnt was 0) and also that we encountered an overflow.\n            if (nextCnt <= increment) {\n                throw new IllegalReferenceCountException(refCnt, increment);\n            }\n            if (refCntUpdater.compareAndSet(this, refCnt, nextCnt)) {\n                break;\n            }\n        }\n        return this;\n    }",
    "replace": "private ReferenceCounted retain0(int increment) {\n        for (;;) {\n            int oldCnt = refCnt.get();\n            final int nextCnt = oldCnt + increment;\n\n            // Ensure we not resurrect (which means the refCnt was 0) and also that we encountered an overflow.\n            if (nextCnt <= increment) {\n                throw new IllegalReferenceCountException(oldCnt, increment);\n            }\n            if (refCnt.compareAndSet(oldCnt, nextCnt)) {\n                break;\n            }\n        }\n        return this;\n    }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/AbstractReferenceCounted.java",
    "search": "private boolean release0(int decrement) {\n        for (;;) {\n            int refCnt = this.refCnt;\n            if (refCnt < decrement) {\n                throw new IllegalReferenceCountException(refCnt, -decrement);\n            }\n\n            if (refCntUpdater.compareAndSet(this, refCnt, refCnt - decrement)) {\n                if (refCnt == decrement) {\n                    deallocate();\n                    return true;\n                }\n                return false;\n            }\n        }\n    }",
    "replace": "private boolean release0(int decrement) {\n        for (;;) {\n            int oldCnt = refCnt.get();\n            if (oldCnt < decrement) {\n                throw new IllegalReferenceCountException(oldCnt, -decrement);\n            }\n\n            if (refCnt.compareAndSet(oldCnt, oldCnt - decrement)) {\n                if (oldCnt == decrement) {\n                    deallocate();\n                    return true;\n                }\n                return false;\n            }\n        }\n    }"
  }
]
```