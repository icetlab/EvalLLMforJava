I have refactored `encodeInitialLine` to eliminate the per-request `StringBuilder` and intermediate `String` allocation when inserting a slash. Instead, it computes an insertion index and writes the URI (or its substrings) directly to the `ByteBuf`, reducing garbage and improving throughput.

```json
[
  {
    "filepath": "../netty/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java",
    "search": "@Override\n    protected void encodeInitialLine(ByteBuf buf, HttpRequest request) throws Exception {\n        ByteBufUtil.copy(request.method().asciiName(), buf);\n        buf.writeByte(SP);\n\n        // Add / as absolute path if no is present.\n        // See http://tools.ietf.org/html/rfc2616#section-5.1.2\n        String uri = request.uri();",
    "replace": "@Override\n    protected void encodeInitialLine(ByteBuf buf, HttpRequest request) throws Exception {\n        ByteBufUtil.copy(request.method().asciiName(), buf);\n        buf.writeByte(SP);\n\n        String uri = request.uri();\n        int insertPos = -1;\n        if (uri.isEmpty()) {\n            // Empty URI -> write a single slash\n            buf.writeByte(SLASH);\n        } else {\n            // Detect absolute URI needing a slash before path or query\n            int start = uri.indexOf(\"://\");\n            if (start != -1 && uri.charAt(0) != SLASH) {\n                int startIndex = start + 3;\n                int questionIndex = uri.indexOf(QUESTION_MARK, startIndex);\n                if (questionIndex == -1) {\n                    if (uri.lastIndexOf(SLASH) <= startIndex) {\n                        insertPos = uri.length();\n                    }\n                } else {\n                    if (uri.lastIndexOf(SLASH, questionIndex) <= startIndex) {\n                        insertPos = questionIndex;\n                    }\n                }\n            }\n            if (insertPos >= 0) {\n                // Write segments around the inserted slash\n                buf.writeCharSequence(uri.substring(0, insertPos), CharsetUtil.UTF_8);\n                buf.writeByte(SLASH);\n                buf.writeCharSequence(uri.substring(insertPos), CharsetUtil.UTF_8);\n            } else {\n                buf.writeCharSequence(uri, CharsetUtil.UTF_8);\n            }\n        }\n\n        buf.writeByte(SP);\n        request.protocolVersion().encode(buf);\n        buf.writeBytes(CRLF);\n    }"
  }
]
```