The change replaces the `ByteBuffer`/`CharsetDecoder` based decoding in `decodeComponent` with a simpler byte[]‚Äêbased approach, eliminating intermediate buffers and reducing overhead.

```json
[
  {
    "filepath": "../netty/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java",
    "search": "        CharsetDecoder decoder = CharsetUtil.decoder(charset);\n\n        // Each encoded byte takes 3 characters (e.g. \"%20\")\n        int decodedCapacity = (toExcluded - firstEscaped) / 3;\n        ByteBuffer byteBuf = ByteBuffer.allocate(decodedCapacity);\n        CharBuffer charBuf = CharBuffer.allocate(decodedCapacity);\n\n        StringBuilder strBuf = new StringBuilder(len);\n        strBuf.append(s, from, firstEscaped);\n\n        for (int i = firstEscaped; i < toExcluded; i++) {\n            char c = s.charAt(i);\n            if (c != '%') {\n                strBuf.append(c != '+' || isPath? c : SPACE);\n                continue;\n            }\n\n            byteBuf.clear();\n            do {\n                if (i + 3 > toExcluded) {\n                    throw new IllegalArgumentException(\"unterminated escape sequence at index \" + i + \" of: \" + s);\n                }\n                byteBuf.put(decodeHexByte(s, i + 1));\n                i += 3;\n            } while (i < toExcluded && s.charAt(i) == '%');\n            i--;\n\n            byteBuf.flip();\n            charBuf.clear();\n            CoderResult result = decoder.reset().decode(byteBuf, charBuf, true);\n            try {\n                if (!result.isUnderflow()) {\n                    result.throwException();\n                }\n                result = decoder.flush(charBuf);\n                if (!result.isUnderflow()) {\n                    result.throwException();\n                }\n            } catch (CharacterCodingException ex) {\n                throw new IllegalStateException(ex);\n            }\n            strBuf.append(charBuf.flip());\n        }\n        return strBuf.toString();",
    "replace": "        StringBuilder strBuf = new StringBuilder(len);\n        strBuf.append(s, from, firstEscaped);\n        int i = firstEscaped;\n        while (i < toExcluded) {\n            char c = s.charAt(i);\n            if (c != '%') {\n                strBuf.append(c != '+' || isPath ? c : SPACE);\n                i++;\n            } else {\n                int start = i;\n                int maxBytes = (toExcluded - start) / 3;\n                byte[] bytes = new byte[maxBytes];\n                int bytesCount = 0;\n                while (i + 3 <= toExcluded && s.charAt(i) == '%') {\n                    bytes[bytesCount++] = decodeHexByte(s, i + 1);\n                    i += 3;\n                }\n                strBuf.append(new String(bytes, 0, bytesCount, charset));\n            }\n        }\n        return strBuf.toString();"
  }
]
```