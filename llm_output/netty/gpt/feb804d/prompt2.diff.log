The changes introduce a small flag in ScheduledFutureTask to let the task enqueue itself when run, eliminating the extra wrapper Runnable allocation in AbstractScheduledEventExecutor.schedule(...).

```json
[
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java",
    "search": "private int queueIndex = INDEX_NOT_IN_QUEUE;",
    "replace": "private int queueIndex = INDEX_NOT_IN_QUEUE;\n\n    // Flag indicating task needs to be enqueued to scheduledTaskQueue\n    private boolean addPending;\n\n    /**\n     * Mark or query that this task should be added to the scheduled queue when run()\n     */\n    void setAddPending(boolean addPending) {\n        this.addPending = addPending;\n    }\n\n    boolean isAddPending() {\n        return addPending;\n    }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java",
    "search": "@Override\n    public void run() {\n        assert executor().inEventLoop();",
    "replace": "@Override\n    public void run() {\n        assert executor().inEventLoop();\n        // If scheduled from another thread, enqueue ourselves rather than wrap a Runnable\n        if (addPending) {\n            addPending = false;\n            ((AbstractScheduledEventExecutor) executor()).scheduledTaskQueue().add(this);\n            return;\n        }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java",
    "search": "} else {\n            final long deadlineNanos = task.deadlineNanos();\n            final Runnable addToQueue = new Runnable() {\n                @Override\n                public void run() {\n                    scheduledTaskQueue().add(task.setId(nextTaskId++));\n                }\n            };\n            if (beforeScheduledTaskSubmitted(deadlineNanos)) {\n                execute(addToQueue);\n            } else {\n                lazyExecute(addToQueue);\n                // Second hook after scheduling to facilitate race-avoidance\n                if (afterScheduledTaskSubmitted(deadlineNanos)) {\n                    execute(WAKEUP_TASK);\n                }\n            }\n        }",
    "replace": "} else {\n            final long deadlineNanos = task.deadlineNanos();\n            // Assign id and mark the task for queue insertion\n            long id = nextTaskId++;\n            task.setId(id);\n            task.setAddPending(true);\n            if (beforeScheduledTaskSubmitted(deadlineNanos)) {\n                execute(task);\n            } else {\n                lazyExecute(task);\n                // Second hook after scheduling to facilitate race-avoidance\n                if (afterScheduledTaskSubmitted(deadlineNanos)) {\n                    execute(WAKEUP_TASK);\n                }\n            }\n        }"
  }
]
```