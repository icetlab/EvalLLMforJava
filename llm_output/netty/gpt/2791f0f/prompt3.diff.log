I’ve optimized the scheduler by eliminating redundant array allocation and dual queue operations. In cancelScheduledTasks, we now drain and cancel tasks via a single poll loop, and in pollScheduledTask we use poll() directly instead of peek() + remove(), reducing method calls and allocations.

```json
[
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java",
    "search": "final ScheduledFutureTask<?>[] scheduledTasks =\n                scheduledTaskQueue.toArray(new ScheduledFutureTask<?>[0]);\n\n        for (ScheduledFutureTask<?> task: scheduledTasks) {\n            task.cancelWithoutRemove(false);\n        }\n\n        scheduledTaskQueue.clearIgnoringIndexes();",
    "replace": "ScheduledFutureTask<?> task;\n        while ((task = scheduledTaskQueue.poll()) != null) {\n            task.cancelWithoutRemove(false);\n        }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java",
    "search": "ScheduledFutureTask<?> scheduledTask = scheduledTaskQueue == null ? null : scheduledTaskQueue.peek();\n        if (scheduledTask == null || scheduledTask.deadlineNanos() - nanoTime > 0) {\n            return null;\n        }\n        scheduledTaskQueue.remove();\n        return scheduledTask;",
    "replace": "ScheduledFutureTask<?> scheduledTask = scheduledTaskQueue == null ? null : scheduledTaskQueue.peek();\n        if (scheduledTask == null || scheduledTask.deadlineNanos() - nanoTime > 0) {\n            return null;\n        }\n        return scheduledTaskQueue.poll();"
  }
]
```