Iâ€™ve added an AtomicInteger counter in LocalPool to track the number of available handles in O(1) time, replacing the costly `MessagePassingQueue.size()` calls; this both speeds up `threadLocalSize()` and avoids traversing the queue for sizing. 

```json
[
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;",
    "replace": "import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\nimport java.util.concurrent.atomic.AtomicInteger;"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "private final int ratioInterval;\n        private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;\n        private int ratioCounter;",
    "replace": "private final int ratioInterval;\n        private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;\n        private final AtomicInteger handleCount;\n        private int ratioCounter;"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "ratioCounter = ratioInterval; // Start at interval so the first one will be recycled.",
    "replace": "ratioCounter = ratioInterval; // Start at interval so the first one will be recycled.\n            handleCount = new AtomicInteger(0);"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "DefaultHandle<T> claim() {\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            if (handles == null) {\n                return null;\n            }\n            DefaultHandle<T> handle = handles.relaxedPoll();\n            if (null != handle) {\n                handle.toClaimed();\n            }\n            return handle;\n        }",
    "replace": "DefaultHandle<T> claim() {\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            if (handles == null) {\n                return null;\n            }\n            DefaultHandle<T> handle = handles.relaxedPoll();\n            if (null != handle) {\n                handle.toClaimed();\n                handleCount.decrementAndGet();\n            }\n            return handle;\n        }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "void release(DefaultHandle<T> handle) {\n            handle.toAvailable();\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            if (handles != null) {\n                handles.relaxedOffer(handle);\n            }\n        }",
    "replace": "void release(DefaultHandle<T> handle) {\n            handle.toAvailable();\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            if (handles != null && handles.relaxedOffer(handle)) {\n                handleCount.incrementAndGet();\n            }\n        }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "final int threadLocalSize() {\n        LocalPool<T> localPool = threadLocal.getIfExists();\n        return localPool == null ? 0 : localPool.pooledHandles.size();\n    }",
    "replace": "final int threadLocalSize() {\n        LocalPool<T> localPool = threadLocal.getIfExists();\n        return localPool == null ? 0 : localPool.handleCount.get();\n    }"
  }
]
```