Iâ€™ve added thread-local cached CharsetDecoder instances for UTF-8 and US-ASCII to avoid per-call allocations and updated the decodeString method to reuse them when possible.

```json
[
  {
    "filepath": "../netty/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java",
    "search": "private static final byte WRITE_UTF_UNKNOWN = (byte) '?';",
    "replace": "// Reuse decoders for common charsets to avoid per-call allocation\nprivate static final FastThreadLocal<CharsetDecoder> UTF8_DECODER = new FastThreadLocal<CharsetDecoder>() {\n    @Override\n    protected CharsetDecoder initialValue() {\n        return CharsetUtil.decoder(CharsetUtil.UTF_8, CodingErrorAction.REPORT, CodingErrorAction.REPORT);\n    }\n};\n\nprivate static final FastThreadLocal<CharsetDecoder> ASCII_DECODER = new FastThreadLocal<CharsetDecoder>() {\n    @Override\n    protected CharsetDecoder initialValue() {\n        return CharsetUtil.decoder(CharsetUtil.US_ASCII, CodingErrorAction.REPORT, CodingErrorAction.REPORT);\n    }\n};\n\nprivate static final byte WRITE_UTF_UNKNOWN = (byte) '?';"
  },
  {
    "filepath": "../netty/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java",
    "search": "        final CharsetDecoder decoder = CharsetUtil.decoder(charset);",
    "replace": "        // Reuse thread-local decoders for common charsets\n        final CharsetDecoder decoder;\n        if (charset.equals(CharsetUtil.UTF_8)) {\n            decoder = UTF8_DECODER.get();\n            decoder.reset();\n        } else if (charset.equals(CharsetUtil.US_ASCII)) {\n            decoder = ASCII_DECODER.get();\n            decoder.reset();\n        } else {\n            decoder = CharsetUtil.decoder(charset);\n        }"
  }
]
```