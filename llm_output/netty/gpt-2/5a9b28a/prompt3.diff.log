Iâ€™ve replaced atomic updater lazySet calls in single-threaded state transitions with direct volatile writes to reduce overhead on the hot paths of reclaiming and unreclaimed handles.

```json
[
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "void toClaimed() {\n            assert state == STATE_AVAILABLE;\n            STATE_UPDATER.lazySet(this, STATE_CLAIMED);\n        }",
    "replace": "void toClaimed() {\n            assert state == STATE_AVAILABLE;\n            // Direct volatile write for performance\n            state = STATE_CLAIMED;\n        }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "void unguardedToAvailable() {\n            int prev = state;\n            if (prev == STATE_AVAILABLE) {\n                throw new IllegalStateException(\"Object has been recycled already.\");\n            }\n            STATE_UPDATER.lazySet(this, STATE_AVAILABLE);\n        }",
    "replace": "void unguardedToAvailable() {\n            int prev = state;\n            if (prev == STATE_AVAILABLE) {\n                throw new IllegalStateException(\"Object has been recycled already.\");\n            }\n            // Direct volatile write for performance\n            state = STATE_AVAILABLE;\n        }"
  }
]
```