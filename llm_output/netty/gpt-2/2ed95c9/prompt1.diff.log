I’ve optimized `getIndexInsensitive` by replacing the linear scan over the static table with a precomputed two‐level `CharSequenceMap` for direct name+value lookups. This eliminates the sequential loop and yields constant‐time resolution. Below are atomic changes to add the new map and refactor the lookup method.

```json
[
  {
    "filepath": "../netty/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java",
    "search": "private static final int MAX_SAME_NAME_FIELD_INDEX = maxSameNameFieldIndex();",
    "replace": "private static final int MAX_SAME_NAME_FIELD_INDEX = maxSameNameFieldIndex();\n\n    // create name and value to index map for fast lookup\n    private static final CharSequenceMap<CharSequenceMap<Integer>> STATIC_INDEX_BY_NAME_VALUE = createNameValueMap();\n\n    private static CharSequenceMap<CharSequenceMap<Integer>> createNameValueMap() {\n        int length = STATIC_TABLE.size();\n        @SuppressWarnings(\"unchecked\")\n        CharSequenceMap<CharSequenceMap<Integer>> ret = new CharSequenceMap<CharSequenceMap<Integer>>(true,\n                UnsupportedValueConverter.<CharSequenceMap<Integer>>instance(), length);\n        for (int index = length; index > 0; index--) {\n            HpackHeaderField entry = getEntry(index);\n            CharSequence nameKey = entry.name;\n            CharSequence valueKey = entry.value;\n            CharSequenceMap<Integer> valueMap = ret.get(nameKey);\n            if (valueMap == null) {\n                @SuppressWarnings(\"unchecked\")\n                CharSequenceMap<Integer> newValueMap = new CharSequenceMap<Integer>(true,\n                        UnsupportedValueConverter.<Integer>instance(), 2);\n                valueMap = newValueMap;\n                ret.set(nameKey, valueMap);\n            }\n            valueMap.set(valueKey, index);\n        }\n        return ret;\n    }"
  },
  {
    "filepath": "../netty/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java",
    "search": "static int getIndexInsensitive(CharSequence name, CharSequence value) {\n        int index = getIndex(name);\n        if (index == NOT_FOUND) {\n            return NOT_FOUND;\n        }\n\n        // Compare values for the first name match\n        HpackHeaderField entry = getEntry(index);\n        if (equalsVariableTime(value, entry.value)) {\n            return index;\n        }\n\n        // Note this assumes all entries for a given header field are sequential.\n        index++;\n        while (index <= MAX_SAME_NAME_FIELD_INDEX) {\n            entry = getEntry(index);\n            if (!equalsVariableTime(name, entry.name)) {\n                // As far as fields with the same name are placed in the table sequentially\n                // and INDEX_BY_NAME returns index of the fist position, - it's safe to\n                // exit immediately.\n                return NOT_FOUND;\n            }\n            if (equalsVariableTime(value, entry.value)) {\n                return index;\n            }\n            index++;\n        }\n\n        return NOT_FOUND;\n    }",
    "replace": "static int getIndexInsensitive(CharSequence name, CharSequence value) {\n        CharSequenceMap<Integer> innerMap = STATIC_INDEX_BY_NAME_VALUE.get(name);\n        if (innerMap == null) {\n            return NOT_FOUND;\n        }\n        Integer idx = innerMap.get(value);\n        return idx != null ? idx : NOT_FOUND;\n    }"
  }
]
```