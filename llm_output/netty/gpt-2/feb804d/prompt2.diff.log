The changes introduce a lightweight “enqueuePending” flag in ScheduledFutureTask so that the task itself can be submitted to the event loop to enqueue into the scheduled‐task queue, eliminating the extra Runnable allocation. When scheduling from a non‐event‐loop thread, we set the flag and hand the ScheduledFutureTask directly to execute()/lazyExecute(), and its first run() simply enqueues it rather than wrapping in a new Runnable.

```json
[
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java",
    "search": "private <V> ScheduledFuture<V> schedule(final ScheduledFutureTask<V> task) {\n        if (inEventLoop()) {\n            scheduledTaskQueue().add(task.setId(nextTaskId++));\n        } else {\n            final long deadlineNanos = task.deadlineNanos();\n            final Runnable addToQueue = new Runnable() {\n                @Override\n                public void run() {\n                    scheduledTaskQueue().add(task.setId(nextTaskId++));\n                }\n            };\n            if (beforeScheduledTaskSubmitted(deadlineNanos)) {\n                execute(addToQueue);\n            } else {\n                lazyExecute(addToQueue);\n                // Second hook after scheduling to facilitate race-avoidance\n                if (afterScheduledTaskSubmitted(deadlineNanos)) {\n                    execute(WAKEUP_TASK);\n                }\n            }\n        }",
    "replace": "private <V> ScheduledFuture<V> schedule(final ScheduledFutureTask<V> task) {\n        if (inEventLoop()) {\n            scheduledTaskQueue().add(task.setId(nextTaskId++));\n        } else {\n            final long deadlineNanos = task.deadlineNanos();\n            // assign id and mark task for enqueue when run()\n            task.setId(nextTaskId++);\n            task.setEnqueuePending(true);\n            if (beforeScheduledTaskSubmitted(deadlineNanos)) {\n                execute(task);\n            } else {\n                lazyExecute(task);\n                if (afterScheduledTaskSubmitted(deadlineNanos)) {\n                    execute(WAKEUP_TASK);\n                }\n            }\n        }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java",
    "search": "private int queueIndex = INDEX_NOT_IN_QUEUE;",
    "replace": "private int queueIndex = INDEX_NOT_IN_QUEUE;\n\n    // Flag indicating the first run should enqueue this task rather than execute it\n    private boolean enqueuePending;\n\n    void setEnqueuePending(boolean enqueuePending) {\n        this.enqueuePending = enqueuePending;\n    }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java",
    "search": "@Override\n    public void run() {\n        assert executor().inEventLoop();",
    "replace": "@Override\n    public void run() {\n        // scheduling phase: enqueue into the scheduledTaskQueue\n        if (enqueuePending) {\n            enqueuePending = false;\n            ((AbstractScheduledEventExecutor) executor()).scheduledTaskQueue().add(this);\n            return;\n        }\n        assert executor().inEventLoop();"
  }
]
```