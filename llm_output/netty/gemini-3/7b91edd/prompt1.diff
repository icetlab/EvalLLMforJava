diff --git a/common/src/main/java/io/netty/util/NetUtil.java b/common/src/main/java/io/netty/util/NetUtil.java
index fbe09ea676..fd792c20cd 100644
--- a/common/src/main/java/io/netty/util/NetUtil.java
+++ b/common/src/main/java/io/netty/util/NetUtil.java
@@ -271,8 +271,10 @@ public final class NetUtil {
             return validIpV4ToBytes(ipAddressString);
         }
 
-        if (isValidIpV6Address(ipAddressString)) {
-            if (ipAddressString.charAt(0) == '[') {
+        if (ipAddressString.length() > 0 && ipAddressString.charAt(0) == '[') {
+            if (ipAddressString.length() < 2 || ipAddressString.charAt(ipAddressString.length() - 1) != ']') {
+                return null;
+            }
             ipAddressString = ipAddressString.substring(1, ipAddressString.length() - 1);
         }
 
@@ -283,8 +285,6 @@ public final class NetUtil {
 
         return getIPv6ByName(ipAddressString, true);
     }
-        return null;
-    }
 
     /**
      * Creates an {@link InetAddress} based on an ipAddressString or might return null if it can't be parsed.
@@ -301,8 +301,10 @@ public final class NetUtil {
             }
         }
 
-        if (isValidIpV6Address(ipAddressString)) {
-            if (ipAddressString.charAt(0) == '[') {
+        if (ipAddressString.length() > 0 && ipAddressString.charAt(0) == '[') {
+            if (ipAddressString.length() < 2 || ipAddressString.charAt(ipAddressString.length() - 1) != ']') {
+                return null;
+            }
             ipAddressString = ipAddressString.substring(1, ipAddressString.length() - 1);
         }
 
@@ -336,8 +338,6 @@ public final class NetUtil {
             throw new IllegalStateException(e);
         }
     }
-        return null;
-    }
 
     private static int decimalDigit(String str, int pos) {
         return str.charAt(pos) - '0';
@@ -995,9 +995,8 @@ public final class NetUtil {
     private static String toAddressString(byte[] bytes, int offset, boolean ipv4Mapped) {
         final int[] words = new int[IPV6_WORD_COUNT];
         int i;
-        final int end = offset + words.length;
-        for (i = offset; i < end; ++i) {
-            words[i] = ((bytes[i << 1] & 0xff) << 8) | (bytes[(i << 1) + 1] & 0xff);
+        for (i = 0; i < IPV6_WORD_COUNT; i++) {
+            words[i] = ((bytes[offset + (i << 1)] & 0xff) << 8) | (bytes[offset + (i << 1) + 1] & 0xff);
         }
 
         // Find longest run of 0s, tie goes to first found instance
