I’ve inlined the empty‐queue check to avoid a small indirection and replaced the overflow guard in `deadlineNanos` with a branch that avoids overflow more directly, improving clarity and performance without altering behavior.

```json
[
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java",
    "search": "PriorityQueue<ScheduledFutureTask<?>> scheduledTaskQueue = this.scheduledTaskQueue;\n        if (isNullOrEmpty(scheduledTaskQueue)) {\n            return;\n        }",
    "replace": "PriorityQueue<ScheduledFutureTask<?>> scheduledTaskQueue = this.scheduledTaskQueue;\n        if (scheduledTaskQueue == null || scheduledTaskQueue.isEmpty()) {\n            return;\n        }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java",
    "search": "static long deadlineNanos(long delay) {\n        long deadlineNanos = nanoTime() + delay;\n        // Guard against overflow\n        return deadlineNanos < 0 ? Long.MAX_VALUE : deadlineNanos;\n    }",
    "replace": "static long deadlineNanos(long delay) {\n        long currentNanoTime = nanoTime();\n        long maxDeadline = Long.MAX_VALUE - currentNanoTime;\n        return delay > maxDeadline ? Long.MAX_VALUE : currentNanoTime + delay;\n    }"
  }
]
```