I’ve introduced a new per‐thread atomic counter to track pool size without querying the queue, updating import declarations, adding a `localCount` field, and adjusting `claim()`, `release()`, and `threadLocalSize()` to maintain it.

```json
[
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;",
    "replace": "import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\nimport java.util.concurrent.atomic.AtomicInteger;"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;\n        private int ratioCounter;",
    "replace": "private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;\n        private int ratioCounter;\n        private final AtomicInteger localCount = new AtomicInteger(0);"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "if (null != handle) {\n                handle.toClaimed();\n            }",
    "replace": "if (handle != null) {\n                localCount.decrementAndGet();\n                handle.toClaimed();\n            }"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "handle.toAvailable();",
    "replace": "handle.toAvailable();\n            localCount.incrementAndGet();"
  },
  {
    "filepath": "../netty/common/src/main/java/io/netty/util/Recycler.java",
    "search": "return localPool == null ? 0 : localPool.pooledHandles.size();",
    "replace": "return localPool == null ? 0 : localPool.localCount.get();"
  }
]
```