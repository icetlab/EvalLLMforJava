diff --git a/common/src/main/java/io/netty/util/Recycler.java b/common/src/main/java/io/netty/util/Recycler.java
index dd7b2d73be..207134b1d8 100644
--- a/common/src/main/java/io/netty/util/Recycler.java
+++ b/common/src/main/java/io/netty/util/Recycler.java
@@ -197,7 +197,7 @@ public abstract class Recycler<T> {
 
     final int threadLocalSize() {
         LocalPool<T> localPool = threadLocal.getIfExists();
-        return localPool == null ? 0 : localPool.pooledHandles.size();
+        return localPool == null ? 0 : localPool.size();
     }
 
     /**
@@ -256,9 +256,21 @@ public abstract class Recycler<T> {
     }
 
     private static final class LocalPool<T> {
+        // existing fields...
+        
+        // report total pooled size (fast stack + shared queue)
+        int size() {
+            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
+            int s = handles != null ? handles.size() : 0;
+            return s + fastStackSize;
+        }
         private final int ratioInterval;
         private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;
         private int ratioCounter;
+        private final long ownerThreadId;
+        @SuppressWarnings("unchecked")
+        private final DefaultHandle<T>[] fastStack;
+        private int fastStackSize;
 
         @SuppressWarnings("unchecked")
         LocalPool(int maxCapacity, int ratioInterval, int chunkSize) {
@@ -269,9 +281,20 @@ public abstract class Recycler<T> {
                 pooledHandles = (MessagePassingQueue<DefaultHandle<T>>) newMpscQueue(chunkSize, maxCapacity);
             }
             ratioCounter = ratioInterval; // Start at interval so the first one will be recycled.
+            ownerThreadId = Thread.currentThread().getId();
+            fastStack = (DefaultHandle<T>[]) new DefaultHandle[maxCapacity];
+            fastStackSize = 0;
         }
 
         DefaultHandle<T> claim() {
+            if (Thread.currentThread().getId() == ownerThreadId) {
+                if (fastStackSize > 0) {
+                    DefaultHandle<T> handle = fastStack[--fastStackSize];
+                    fastStack[fastStackSize] = null;
+                    handle.toClaimed();
+                    return handle;
+                }
+            }
             MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
             if (handles == null) {
                 return null;
@@ -286,8 +309,16 @@ public abstract class Recycler<T> {
         void release(DefaultHandle<T> handle) {
             handle.toAvailable();
             MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
-            if (handles != null) {
-                handles.relaxedOffer(handle);
+            if (Thread.currentThread().getId() == ownerThreadId) {
+                if (fastStackSize < fastStack.length) {
+                    fastStack[fastStackSize++] = handle;
+                } else if (handles != null) {
+                    handles.relaxedOffer(handle);
+                }
+            } else {
+                if (handles != null) {
+                    handles.relaxedOffer(handle);
+                }
             }
         }
 
