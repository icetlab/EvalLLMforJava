diff --git a/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java
index c132aa5b20..b39757f0af 100644
--- a/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java
+++ b/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java
@@ -31,16 +31,10 @@ import java.util.concurrent.TimeUnit;
  */
 public abstract class AbstractScheduledEventExecutor extends AbstractEventExecutor {
     private static final Comparator<ScheduledFutureTask<?>> SCHEDULED_FUTURE_TASK_COMPARATOR =
-            new Comparator<ScheduledFutureTask<?>>() {
-                @Override
-                public int compare(ScheduledFutureTask<?> o1, ScheduledFutureTask<?> o2) {
-                    return o1.compareTo(o2);
-                }
-            };
+            ScheduledFutureTask::compareTo;
 
-   static final Runnable WAKEUP_TASK = new Runnable() {
-       @Override
-       public void run() { } // Do nothing
+       static final Runnable WAKEUP_TASK = () -> {
+        // Do nothing
     };
 
     PriorityQueue<ScheduledFutureTask<?>> scheduledTaskQueue;
@@ -249,12 +243,7 @@ public abstract class AbstractScheduledEventExecutor extends AbstractEventExecut
             scheduledTaskQueue().add(task.setId(nextTaskId++));
         } else {
             final long deadlineNanos = task.deadlineNanos();
-            final Runnable addToQueue = new Runnable() {
-                @Override
-                public void run() {
-                    scheduledTaskQueue().add(task.setId(nextTaskId++));
-                }
-            };
+            final Runnable addToQueue = () -> scheduledTaskQueue().add(task.setId(nextTaskId++));
             if (beforeScheduledTaskSubmitted(deadlineNanos)) {
                 execute(addToQueue);
             } else {
@@ -273,12 +262,7 @@ public abstract class AbstractScheduledEventExecutor extends AbstractEventExecut
         if (inEventLoop()) {
             scheduledTaskQueue().removeTyped(task);
         } else {
-            lazyExecute(new Runnable() {
-                @Override
-                public void run() {
-                    scheduledTaskQueue().removeTyped(task);
-                }
-            });
+            lazyExecute(() -> scheduledTaskQueue().removeTyped(task));
         }
     }
 
diff --git a/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java b/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java
index 5ffe824119..3a0371a665 100644
--- a/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java
+++ b/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java
@@ -49,36 +49,42 @@ final class ScheduledFutureTask<V> extends PromiseTask<V> implements ScheduledFu
     /* 0 - no repeat, >0 - repeat at fixed rate, <0 - repeat with fixed delay */
     private final long periodNanos;
 
+    private final AbstractScheduledEventExecutor scheduledExecutor;
+
     private int queueIndex = INDEX_NOT_IN_QUEUE;
 
-    ScheduledFutureTask(AbstractScheduledEventExecutor executor,
+        ScheduledFutureTask(AbstractScheduledEventExecutor executor,
             Runnable runnable, long nanoTime) {
 
         super(executor, runnable);
+        scheduledExecutor = executor;
         deadlineNanos = nanoTime;
         periodNanos = 0;
     }
 
-    ScheduledFutureTask(AbstractScheduledEventExecutor executor,
+        ScheduledFutureTask(AbstractScheduledEventExecutor executor,
             Runnable runnable, long nanoTime, long period) {
 
         super(executor, runnable);
+        scheduledExecutor = executor;
         deadlineNanos = nanoTime;
         periodNanos = validatePeriod(period);
     }
 
-    ScheduledFutureTask(AbstractScheduledEventExecutor executor,
+        ScheduledFutureTask(AbstractScheduledEventExecutor executor,
             Callable<V> callable, long nanoTime, long period) {
 
         super(executor, callable);
+        scheduledExecutor = executor;
         deadlineNanos = nanoTime;
         periodNanos = validatePeriod(period);
     }
 
-    ScheduledFutureTask(AbstractScheduledEventExecutor executor,
+        ScheduledFutureTask(AbstractScheduledEventExecutor executor,
             Callable<V> callable, long nanoTime) {
 
         super(executor, callable);
+        scheduledExecutor = executor;
         deadlineNanos = nanoTime;
         periodNanos = 0;
     }
@@ -152,9 +158,9 @@ final class ScheduledFutureTask<V> extends PromiseTask<V> implements ScheduledFu
                 }
             } else {
                 // check if is done as it may was cancelled
-                if (!isCancelled()) {
+                                if (!isCancelled()) {
                     runTask();
-                    if (!executor().isShutdown()) {
+                    if (!scheduledExecutor.isShutdown()) {
                         if (periodNanos > 0) {
                             deadlineNanos += periodNanos;
                         } else {
@@ -163,7 +169,7 @@ final class ScheduledFutureTask<V> extends PromiseTask<V> implements ScheduledFu
                         if (!isCancelled()) {
                             // scheduledTaskQueue can never be null as we lazy init it before submit the task!
                             Queue<ScheduledFutureTask<?>> scheduledTaskQueue =
-                                    ((AbstractScheduledEventExecutor) executor()).scheduledTaskQueue;
+                                    scheduledExecutor.scheduledTaskQueue;
                             assert scheduledTaskQueue != null;
                             scheduledTaskQueue.add(this);
                         }
@@ -182,9 +188,9 @@ final class ScheduledFutureTask<V> extends PromiseTask<V> implements ScheduledFu
      */
     @Override
     public boolean cancel(boolean mayInterruptIfRunning) {
-        boolean canceled = super.cancel(mayInterruptIfRunning);
+                boolean canceled = super.cancel(mayInterruptIfRunning);
         if (canceled) {
-            ((AbstractScheduledEventExecutor) executor()).removeScheduled(this);
+            scheduledExecutor.removeScheduled(this);
         }
         return canceled;
     }
