diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java
index 389d8ef150..12dfa91276 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java
@@ -117,8 +117,6 @@ final class HpackStaticTable {
         return new HpackHeaderField(AsciiString.cached(name), AsciiString.cached(value));
     }
 
-    private static final CharSequenceMap<Integer> STATIC_INDEX_BY_NAME = createMap();
-
     private static final int MAX_SAME_NAME_FIELD_INDEX = maxSameNameFieldIndex();
 
     /**
@@ -138,11 +136,7 @@ final class HpackStaticTable {
      * -1 if the header field name is not in the static table.
      */
     static int getIndex(CharSequence name) {
-        Integer index = STATIC_INDEX_BY_NAME.get(name);
-        if (index == null) {
-            return NOT_FOUND;
-        }
-        return index;
+        return PerfectHash.getIndex(name);
     }
 
     /**
@@ -167,7 +161,7 @@ final class HpackStaticTable {
             entry = getEntry(index);
             if (!equalsVariableTime(name, entry.name)) {
                 // As far as fields with the same name are placed in the table sequentially
-                // and INDEX_BY_NAME returns index of the fist position, - it's safe to
+                // and getIndex() returns index of the fist position, - it's safe to
                 // exit immediately.
                 return NOT_FOUND;
             }
@@ -180,22 +174,6 @@ final class HpackStaticTable {
         return NOT_FOUND;
     }
 
-    // create a map CharSequenceMap header name to index value to allow quick lookup
-    private static CharSequenceMap<Integer> createMap() {
-        int length = STATIC_TABLE.size();
-        @SuppressWarnings("unchecked")
-        CharSequenceMap<Integer> ret = new CharSequenceMap<Integer>(true,
-                UnsupportedValueConverter.<Integer>instance(), length);
-        // Iterate through the static table in reverse order to
-        // save the smallest index for a given name in the map.
-        for (int index = length; index > 0; index--) {
-            HpackHeaderField entry = getEntry(index);
-            CharSequence name = entry.name;
-            ret.set(name, index);
-        }
-        return ret;
-    }
-
     /**
      * Returns the last position in the array that contains multiple
      * fields with the same name. Starting from this position, all
@@ -219,4 +197,197 @@ final class HpackStaticTable {
     // singleton
     private HpackStaticTable() {
     }
+
+    private static final class PerfectHash {
+        private static final int[] MAPPING = {
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, 38, -1, -1, -1, 33, 21, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, 51, 54, 44, -1, 34, 45, -1, 46, -1, -1, -1, -1, -1, -1, -1,
+            60, 58, 22, 52, 47, 36, -1, 53, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, 19, -1, 24, 32, 35, 37, 50, 48, 39, -1, 23, -1, 42, -1, -1,
+            -1, -1, -1, 56, -1, -1, -1, -1, -1, -1, -1, 59, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+
+            // :authority -> 1
+            // :method -> 2
+            // :path -> 4
+            // :scheme -> 6
+            // :status -> 8
+            // accept -> 19
+            // accept-charset -> 15
+            // accept-encoding -> 16
+            // accept-language -> 17
+            // accept-ranges -> 18
+            // access-control-allow-origin -> 20
+            // age -> 21
+            // allow -> 22
+            // authorization -> 23
+            // cache-control -> 24
+            // content-disposition -> 25
+            // content-encoding -> 26
+            // content-language -> 27
+            // content-length -> 28
+            // content-location -> 29
+            // content-range -> 30
+            // content-type -> 31
+            // cookie -> 32
+            // date -> 33
+            // etag -> 34
+            // expect -> 35
+            // expires -> 36
+            // from -> 37
+            // host -> 38
+            // if-match -> 39
+            // if-modified-since -> 40
+            // if-none-match -> 41
+            // if-range -> 42
+            // if-unmodified-since -> 43
+            // last-modified -> 44
+            // link -> 45
+            // location -> 46
+            // max-forwards -> 47
+            // proxy-authenticate -> 48
+            // proxy-authorization -> 49
+            // range -> 50
+            // referer -> 51
+            // refresh -> 52
+            // retry-after -> 53
+            // server -> 54
+            // set-cookie -> 55
+            // strict-transport-security -> 56
+            // transfer-encoding -> 57
+            // user-agent -> 58
+            // vary -> 59
+            // via -> 60
+            // www-authenticate -> 61
+            -1, -1, 1, 2, 4, 6, 8, 15, 16, 17, 18, 20, 25, 26, 27, 28,
+            29, 30, 31, 40, 41, 43, 49, 55, 57, -1, -1, -1, -1, -1, -1, -1
+        };
+
+        private static final HpackHeaderField[] STATIC_TABLE_NAME_ONLY = {
+            new HpackHeaderField(AsciiString.cached(":authority"), null),
+            new HpackHeaderField(AsciiString.cached(":method"), null),
+            null,
+            new HpackHeaderField(AsciiString.cached(":path"), null),
+            null,
+            new HpackHeaderField(AsciiString.cached(":scheme"), null),
+            null,
+            new HpackHeaderField(AsciiString.cached(":status"), null),
+            null, null, null, null, null, null,
+            new HpackHeaderField(AsciiString.cached("accept-charset"), null),
+            new HpackHeaderField(AsciiString.cached("accept-encoding"), null),
+            new HpackHeaderField(AsciiString.cached("accept-language"), null),
+            new HpackHeaderField(AsciiString.cached("accept-ranges"), null),
+            new HpackHeaderField(AsciiString.cached("accept"), null),
+            new HpackHeaderField(AsciiString.cached("access-control-allow-origin"), null),
+            new HpackHeaderField(AsciiString.cached("age"), null),
+            new HpackHeaderField(AsciiString.cached("allow"), null),
+            new HpackHeaderField(AsciiString.cached("authorization"), null),
+            new HpackHeaderField(AsciiString.cached("cache-control"), null),
+            new HpackHeaderField(AsciiString.cached("content-disposition"), null),
+            new HpackHeaderField(AsciiString.cached("content-encoding"), null),
+            new HpackHeaderField(AsciiString.cached("content-language"), null),
+            new HpackHeaderField(AsciiString.cached("content-length"), null),
+            new HpackHeaderField(AsciiString.cached("content-location"), null),
+            new HpackHeaderField(AsciiString.cached("content-range"), null),
+            new HpackHeaderField(AsciiString.cached("content-type"), null),
+            new HpackHeaderField(AsciiString.cached("cookie"), null),
+            new HpackHeaderField(AsciiString.cached("date"), null),
+            new HpackHeaderField(AsciiString.cached("etag"), null),
+            new HpackHeaderField(AsciiString.cached("expect"), null),
+            new HpackHeaderField(AsciiString.cached("expires"), null),
+            new HpackHeaderField(AsciiString.cached("from"), null),
+            new HpackHeaderField(AsciiString.cached("host"), null),
+            new HpackHeaderField(AsciiString.cached("if-match"), null),
+            new HpackHeaderField(AsciiString.cached("if-modified-since"), null),
+            new HpackHeaderField(AsciiString.cached("if-none-match"), null),
+            new HpackHeaderField(AsciiString.cached("if-range"), null),
+            new HpackHeaderField(AsciiString.cached("if-unmodified-since"), null),
+            new HpackHeaderField(AsciiString.cached("last-modified"), null),
+            new HpackHeaderField(AsciiString.cached("link"), null),
+            new HpackHeaderField(AsciiString.cached("location"), null),
+            new HpackHeaderField(AsciiString.cached("max-forwards"), null),
+            new HpackHeaderField(AsciiString.cached("proxy-authenticate"), null),
+            new HpackHeaderField(AsciiString.cached("proxy-authorization"), null),
+            new HpackHeaderField(AsciiString.cached("range"), null),
+            new HpackHeaderField(AsciiString.cached("referer"), null),
+            new HpackHeaderField(AsciiString.cached("refresh"), null),
+            new HpackHeaderField(AsciiString.cached("retry-after"), null),
+            new HpackHeaderField(AsciiString.cached("server"), null),
+            new HpackHeaderField(AsciiString.cached("set-cookie"), null),
+            new HpackHeaderField(AsciiString.cached("strict-transport-security"), null),
+            new HpackHeaderField(AsciiString.cached("transfer-encoding"), null),
+            new HpackHeaderField(AsciiString.cached("user-agent"), null),
+            new HpackHeaderField(AsciiString.cached("vary"), null),
+            new HpackHeaderField(AsciiString.cached("via"), null),
+            new HpackHeaderField(AsciiString.cached("www-authenticate"), null)
+        };
+
+        static int getIndex(CharSequence name) {
+            int h = hashCode(name);
+            if (h >= 0 && h < MAPPING.length) {
+                int index = MAPPING[h];
+                if (index != -1) {
+                    HpackHeaderField candidate = STATIC_TABLE_NAME_ONLY[index - 1];
+                    if (equalsVariableTime(name, candidate.name)) {
+                        return index;
+                    }
+                }
+            }
+            return -1;
+        }
+
+        private static int hashCode(CharSequence name) {
+            // This hash function is chosen as it is fast and provides a good distribution of values.
+            // It is a variation of the FNV-1a hash function.
+            // This is case-insensitive.
+            final int len = name.length();
+            if (len == 0) {
+                return -1;
+            }
+            // The initial value for the hash.
+            int h = len;
+            if (len > 8) {
+                // If the name is long, we use a different seed to get a better distribution.
+                h ^= 0xc3a5c3a5;
+            }
+            // Hash the first and last characters.
+            h ^= (toLowerCase(name.charAt(0)) << 16) | (toLowerCase(name.charAt(len - 1)) << 24);
+            // Hash the middle character.
+            h ^= toLowerCase(name.charAt(len >>> 1));
+            return h & 0x1FF;
+        }
+
+        private static char toLowerCase(char c) {
+            if (c >= 'A' && c <= 'Z') {
+                return (char) (c + ('a' - 'A'));
+            }
+            return c;
+        }
+
+        private PerfectHash() {
+        }
+    }
 }
