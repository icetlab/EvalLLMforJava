diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent.java b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
index 0a70c36401..470f2191d8 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
@@ -755,59 +755,11 @@ public final class PlatformDependent {
      */
     public static int hashCodeAscii(CharSequence bytes) {
         int hash = HASH_CODE_ASCII_SEED;
-        final int remainingBytes = bytes.length() & 7;
-        // Benchmarking shows that by just naively looping for inputs 8~31 bytes long we incur a relatively large
-        // performance penalty (only achieve about 60% performance of loop which iterates over each char). So because
-        // of this we take special provisions to unroll the looping for these conditions.
-        switch (bytes.length()) {
-            case 31:
-            case 30:
-            case 29:
-            case 28:
-            case 27:
-            case 26:
-            case 25:
-            case 24:
-                hash = hashCodeAsciiCompute(bytes, bytes.length() - 24,
-                        hashCodeAsciiCompute(bytes, bytes.length() - 16,
-                          hashCodeAsciiCompute(bytes, bytes.length() - 8, hash)));
-                break;
-            case 23:
-            case 22:
-            case 21:
-            case 20:
-            case 19:
-            case 18:
-            case 17:
-            case 16:
-                hash = hashCodeAsciiCompute(bytes, bytes.length() - 16,
-                         hashCodeAsciiCompute(bytes, bytes.length() - 8, hash));
-                break;
-            case 15:
-            case 14:
-            case 13:
-            case 12:
-            case 11:
-            case 10:
-            case 9:
-            case 8:
-                hash = hashCodeAsciiCompute(bytes, bytes.length() - 8, hash);
-                break;
-            case 7:
-            case 6:
-            case 5:
-            case 4:
-            case 3:
-            case 2:
-            case 1:
-            case 0:
-                break;
-            default:
-                for (int i = bytes.length() - 8; i >= remainingBytes; i -= 8) {
+        final int len = bytes.length();
+        final int remainingBytes = len & 7;
+        for (int i = len - 8; i >= remainingBytes; i -= 8) {
             hash = hashCodeAsciiCompute(bytes, i, hash);
         }
-                break;
-        }
         switch(remainingBytes) {
             case 7:
                 return ((hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(0)))
diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
index df45d1614a..a2bb455475 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
@@ -636,17 +636,20 @@ final class PlatformDependent0 {
         }
 
         if (remainingBytes >= 4) {
-            remainingBytes -= 4;
-            if (UNSAFE.getInt(bytes1, baseOffset1 + remainingBytes) !=
-                UNSAFE.getInt(bytes2, baseOffset2 + remainingBytes)) {
+            if (UNSAFE.getInt(bytes1, baseOffset1) != UNSAFE.getInt(bytes2, baseOffset2)) {
                 return false;
             }
+            if (remainingBytes >= 6) {
+                return UNSAFE.getChar(bytes1, baseOffset1 + 4) == UNSAFE.getChar(bytes2, baseOffset2 + 4) &&
+                        (remainingBytes == 6 || UNSAFE.getByte(bytes1, baseOffset1 + 6) == UNSAFE.getByte(bytes2, baseOffset2 + 6));
+            }
+            return remainingBytes == 4 || UNSAFE.getByte(bytes1, baseOffset1 + 4) == UNSAFE.getByte(bytes2, baseOffset2 + 4);
         }
         if (remainingBytes >= 2) {
             return UNSAFE.getChar(bytes1, baseOffset1) == UNSAFE.getChar(bytes2, baseOffset2) &&
-                   (remainingBytes == 2 || bytes1[startPos1 + 2] == bytes2[startPos2 + 2]);
+                    (remainingBytes == 2 || UNSAFE.getByte(bytes1, baseOffset1 + 2) == UNSAFE.getByte(bytes2, baseOffset2 + 2));
         }
-        return bytes1[startPos1] == bytes2[startPos2];
+        return remainingBytes == 0 || UNSAFE.getByte(bytes1, baseOffset1) == UNSAFE.getByte(bytes2, baseOffset2);
     }
 
     static int equalsConstantTime(byte[] bytes1, int startPos1, byte[] bytes2, int startPos2, int length) {
@@ -704,16 +707,20 @@ final class PlatformDependent0 {
         }
 
         if (remainingBytes >= 4) {
-            remainingBytes -= 4;
-            if (UNSAFE.getInt(bytes, baseOffset + remainingBytes) != 0) {
+            if (UNSAFE.getInt(bytes, baseOffset) != 0) {
                 return false;
             }
+            if (remainingBytes >= 6) {
+                return UNSAFE.getChar(bytes, baseOffset + 4) == 0 &&
+                        (remainingBytes == 6 || UNSAFE.getByte(bytes, baseOffset + 6) == 0);
+            }
+            return remainingBytes == 4 || UNSAFE.getByte(bytes, baseOffset + 4) == 0;
         }
         if (remainingBytes >= 2) {
             return UNSAFE.getChar(bytes, baseOffset) == 0 &&
-                    (remainingBytes == 2 || bytes[startPos + 2] == 0);
+                    (remainingBytes == 2 || UNSAFE.getByte(bytes, baseOffset + 2) == 0);
         }
-        return bytes[startPos] == 0;
+        return remainingBytes == 0 || UNSAFE.getByte(bytes, baseOffset) == 0;
     }
 
     static int hashCodeAscii(byte[] bytes, int startPos, int length) {
