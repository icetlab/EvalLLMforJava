diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java
index 5e0a9f6cf1..86831e07a6 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java
@@ -27,7 +27,7 @@ import static io.netty.util.internal.ObjectUtil.checkNotNull;
 public class DefaultHttp2HeadersEncoder implements Http2HeadersEncoder, Http2HeadersEncoder.Configuration {
     private final HpackEncoder hpackEncoder;
     private final SensitivityDetector sensitivityDetector;
-    private final ByteBuf tableSizeChangeOutput = Unpooled.buffer();
+        private final ByteBuf tableSizeChangeOutput = Unpooled.buffer(16);
 
     public DefaultHttp2HeadersEncoder() {
         this(NEVER_SENSITIVE);
diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java
index 301a2c51cf..9c4e389328 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java
@@ -111,18 +111,25 @@ final class HpackEncoder {
                                                        SensitivityDetector sensitivityDetector)
             throws Http2Exception {
         long headerSize = 0;
-        // To ensure we stay consistent with our peer check the size is valid before we potentially modify HPACK state.
+        // http2Headers should not be an iterator, but we have no choice because of the interface.
+        // This list is used to accumulate the headers and their sizes, so we can check the size before encoding.
+        final java.util.List<HeaderField> headerFields = new java.util.ArrayList<HeaderField>(headers.size());
+
         for (Map.Entry<CharSequence, CharSequence> header : headers) {
             CharSequence name = header.getKey();
             CharSequence value = header.getValue();
-            // OK to increment now and check for bounds after because this value is limited to unsigned int and will not
-            // overflow.
-            headerSize += HpackHeaderField.sizeOf(name, value);
+            long size = HpackHeaderField.sizeOf(name, value);
+            headerSize += size;
             if (headerSize > maxHeaderListSize) {
                 headerListSizeExceeded(streamId, maxHeaderListSize, false);
             }
+            headerFields.add(new HeaderField(name, value, size));
+        }
+
+        for (HeaderField headerField : headerFields) {
+            encodeHeader(out, headerField.name, headerField.value,
+                    sensitivityDetector.isSensitive(headerField.name, headerField.value), headerField.size);
         }
-        encodeHeadersIgnoreMaxHeaderListSize(out, headers, sensitivityDetector);
     }
 
     private void encodeHeadersIgnoreMaxHeaderListSize(ByteBuf out, Http2Headers headers,
@@ -459,6 +466,18 @@ final class HpackEncoder {
         return h & hashMask;
     }
 
+    private static final class HeaderField {
+        final CharSequence name;
+        final CharSequence value;
+        final long size;
+
+        HeaderField(CharSequence name, CharSequence value, long size) {
+            this.name = name;
+            this.value = value;
+            this.size = size;
+        }
+    }
+
     /**
      * A linked hash map HpackHeaderField entry.
      */
