diff --git a/common/src/main/java/io/netty/util/Recycler.java b/common/src/main/java/io/netty/util/Recycler.java
index dd7b2d73be..42997ae9b7 100644
--- a/common/src/main/java/io/netty/util/Recycler.java
+++ b/common/src/main/java/io/netty/util/Recycler.java
@@ -96,16 +96,19 @@ public abstract class Recycler<T> {
     private final FastThreadLocal<LocalPool<T>> threadLocal = new FastThreadLocal<LocalPool<T>>() {
         @Override
         protected LocalPool<T> initialValue() {
-            return new LocalPool<T>(maxCapacityPerThread, interval, chunkSize);
+            return new LocalPool<T>(Recycler.this, maxCapacityPerThread, interval, chunkSize);
         }
 
         @Override
         protected void onRemoval(LocalPool<T> value) throws Exception {
             super.onRemoval(value);
+            value.localHandles.clear();
             MessagePassingQueue<DefaultHandle<T>> handles = value.pooledHandles;
             value.pooledHandles = null;
+            if (handles != null) {
                 handles.clear();
             }
+        }
     };
 
     protected Recycler() {
@@ -197,7 +200,10 @@ public abstract class Recycler<T> {
 
     final int threadLocalSize() {
         LocalPool<T> localPool = threadLocal.getIfExists();
-        return localPool == null ? 0 : localPool.pooledHandles.size();
+        if (localPool == null) {
+            return 0;
+        }
+        return localPool.localHandles.size() + (localPool.pooledHandles != null? localPool.pooledHandles.size() : 0);
     }
 
     /**
@@ -256,13 +262,19 @@ public abstract class Recycler<T> {
     }
 
     private static final class LocalPool<T> {
+        final Recycler<T> recycler;
         private final int ratioInterval;
         private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;
         private int ratioCounter;
+        private final int maxCapacity;
+        private final Queue<DefaultHandle<T>> localHandles;
 
         @SuppressWarnings("unchecked")
-        LocalPool(int maxCapacity, int ratioInterval, int chunkSize) {
+        LocalPool(Recycler<T> recycler, int maxCapacity, int ratioInterval, int chunkSize) {
+            this.recycler = recycler;
             this.ratioInterval = ratioInterval;
+            this.maxCapacity = maxCapacity;
+            this.localHandles = new ArrayDeque<DefaultHandle<T>>();
             if (BLOCKING_POOL) {
                 pooledHandles = new BlockingMessageQueue<DefaultHandle<T>>(maxCapacity);
             } else {
@@ -272,12 +284,29 @@ public abstract class Recycler<T> {
         }
 
         DefaultHandle<T> claim() {
+            DefaultHandle<T> handle = localHandles.poll();
+            if (handle == null) {
                 MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
-            if (handles == null) {
-                return null;
+                if (handles != null) {
+                    int toScavenge = maxCapacity - localHandles.size();
+                    if (toScavenge > 0) {
+                        if (BLOCKING_POOL) {
+                            for (; toScavenge > 0; toScavenge--) {
+                                DefaultHandle<T> h = handles.relaxedPoll();
+                                if (h == null) {
+                                    break;
+                                }
+                                localHandles.add(h);
                             }
-            DefaultHandle<T> handle = handles.relaxedPoll();
-            if (null != handle) {
+                        } else {
+                            handles.drain(localHandles::add, toScavenge);
+                        }
+                    }
+                }
+                handle = localHandles.poll();
+            }
+
+            if (handle != null) {
                 handle.toClaimed();
             }
             return handle;
@@ -285,11 +314,18 @@ public abstract class Recycler<T> {
 
         void release(DefaultHandle<T> handle) {
             handle.toAvailable();
+            if (recycler.threadLocal.get() == this) {
+                if (localHandles.size() < maxCapacity) {
+                    localHandles.add(handle);
+                }
+                // If the queue is full, we just drop the object now.
+            } else {
                 MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
                 if (handles != null) {
                     handles.relaxedOffer(handle);
                 }
             }
+        }
 
         DefaultHandle<T> newHandle() {
             if (++ratioCounter >= ratioInterval) {
