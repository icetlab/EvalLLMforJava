My improvement strategy for `ByteBufUtil.java` focuses on optimizing the `decodeString` method, which is the target of the provided benchmark. The goal is to enhance performance for different buffer types and charsets.

My changes involve two main improvements:

1.  **Fast Path for US-ASCII:** I've introduced a specialized path for `US-ASCII` charset decoding. Since ASCII is a simple one-byte-per-character encoding, we can bypass the overhead of using a `CharsetDecoder`.
    *   For heap-backed buffers (`hasArray() == true`), I perform a direct array copy from bytes to chars, which is extremely fast.
    *   For direct or composite buffers, I use `forEachByte` with a `ByteProcessor` to iterate over the bytes and convert them to characters. This avoids the performance penalty of calling `getByte()` repeatedly on such buffers.

2.  **Efficient Composite Buffer Handling:** The original implementation handled composite buffers by copying their entire content into a temporary heap buffer before decoding. This is inefficient, especially for large buffers. My change eliminates this intermediate copy.
    *   I now use `ByteBuf.nioBuffers()` to get the underlying `ByteBuffer`s of the composite buffer.
    *   I then iterate through these `ByteBuffer`s, feeding them to the `CharsetDecoder` one by one. This allows for decoding directly from the composite buffer's memory, significantly reducing memory traffic and improving performance for `COMPOSITE` buffer types in the benchmark.

These changes are encapsulated within a single replacement of the `decodeString` method and the removal of its now-unused private helper, ensuring an atomic and functionality-preserving update.

```json
[
  {
    "filepath": "../netty/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java",
    "search": "    static String decodeString(ByteBuf src, int readerIndex, int len, Charset charset) {\n        if (len == 0) {\n            return StringUtil.EMPTY_STRING;\n        }\n        final CharsetDecoder decoder = CharsetUtil.decoder(charset);\n        final int maxLength = (int) ((double) len * decoder.maxCharsPerByte());\n        CharBuffer dst = CHAR_BUFFERS.get();\n        if (dst.length() < maxLength) {\n            dst = CharBuffer.allocate(maxLength);\n            if (maxLength <= MAX_CHAR_BUFFER_SIZE) {\n                CHAR_BUFFERS.set(dst);\n            }\n        } else {\n            dst.clear();\n        }\n        if (src.nioBufferCount() == 1) {\n            decodeString(decoder, src.nioBuffer(readerIndex, len), dst);\n        } else {\n            // We use a heap buffer as CharsetDecoder is most likely able to use a fast-path if src and dst buffers\n            // are both backed by a byte array.\n            ByteBuf buffer = src.alloc().heapBuffer(len);\n            try {\n                buffer.writeBytes(src, readerIndex, len);\n                // Use internalNioBuffer(...) to reduce object creation.\n                decodeString(decoder, buffer.internalNioBuffer(buffer.readerIndex(), len), dst);\n            } finally {\n                // Release the temporary buffer again.\n                buffer.release();\n            }\n        }\n        return dst.flip().toString();\n    }\n\n    private static void decodeString(CharsetDecoder decoder, ByteBuffer src, CharBuffer dst) {\n        try {\n            CoderResult cr = decoder.decode(src, dst, true);\n            if (!cr.isUnderflow()) {\n                cr.throwException();\n            }\n            cr = decoder.flush(dst);\n            if (!cr.isUnderflow()) {\n                cr.throwException();\n            }\n        } catch (CharacterCodingException x) {\n            throw new IllegalStateException(x);\n        }\n    }",
    "replace": "    static String decodeString(ByteBuf src, int readerIndex, int len, Charset charset) {\n        if (len == 0) {\n            return StringUtil.EMPTY_STRING;\n        }\n        if (charset.equals(CharsetUtil.US_ASCII)) {\n            CharBuffer dst = CHAR_BUFFERS.get();\n            if (dst.length() < len) {\n                dst = CharBuffer.allocate(len);\n                if (len <= MAX_CHAR_BUFFER_SIZE) {\n                    CHAR_BUFFERS.set(dst);\n                }\n            } else {\n                dst.clear();\n            }\n            if (src.hasArray()) {\n                final byte[] array = src.array();\n                final int start = src.arrayOffset() + readerIndex;\n                final char[] chars = dst.array();\n                final int dstStart = dst.arrayOffset() + dst.position();\n                for (int i = 0; i < len; i++) {\n                    chars[dstStart + i] = (char) (array[start + i] & 0xff);\n                }\n                dst.position(dst.position() + len);\n            } else {\n                final CharBuffer finalDst = dst;\n                src.forEachByte(readerIndex, len, new ByteProcessor() {\n                    @Override\n                    public boolean process(byte value) {\n                        finalDst.put((char) (value & 0xff));\n                        return true;\n                    }\n                });\n            }\n            return dst.flip().toString();\n        }\n\n        final CharsetDecoder decoder = CharsetUtil.decoder(charset);\n        final int maxLength = (int) ((double) len * decoder.maxCharsPerByte());\n        CharBuffer dst = CHAR_BUFFERS.get();\n        if (dst.length() < maxLength) {\n            dst = CharBuffer.allocate(maxLength);\n            if (maxLength <= MAX_CHAR_BUFFER_SIZE) {\n                CHAR_BUFFERS.set(dst);\n            }\n        } else {\n            dst.clear();\n        }\n        try {\n            if (src.nioBufferCount() == 1) {\n                ByteBuffer nioBuffer = src.nioBuffer(readerIndex, len);\n                CoderResult cr = decoder.decode(nioBuffer, dst, true);\n                if (!cr.isUnderflow()) {\n                    cr.throwException();\n                }\n            } else {\n                ByteBuffer[] nioBuffers = src.nioBuffers(readerIndex, len);\n                for (int i = 0; i < nioBuffers.length; i++) {\n                    ByteBuffer bb = nioBuffers[i];\n                    boolean endOfInput = i == nioBuffers.length - 1;\n                    CoderResult cr = decoder.decode(bb, dst, endOfInput);\n                    if (!cr.isUnderflow()) {\n                        cr.throwException();\n                    }\n                }\n            }\n            CoderResult cr = decoder.flush(dst);\n            if (!cr.isUnderflow()) {\n                cr.throwException();\n            }\n        } catch (CharacterCodingException x) {\n            throw new IllegalStateException(x);\n        }\n        return dst.flip().toString();\n    }"
  }
]
```