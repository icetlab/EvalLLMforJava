My overall improvement strategy is to optimize the `getIndexInsensitive` method in `HpackStaticTable`. This method is frequently called for header lookups in the static table. The original implementation iterates through entries with the same header name using a loop bounded by a global maximum index for any same-named field. This can be inefficient for headers that appear early in the table.

My optimization replaces this linear scan with a more precise lookup. I will pre-calculate the end index for each group of same-named headers and store them in a new static array, `NAME_END_INDICES`. This allows `getIndexInsensitive` to use a much tighter loop bound, specific to the header being looked up. This change eliminates an unnecessary name comparison in each loop iteration and reduces the total number of iterations, especially for headers like `:method` or `:scheme`. This results in a significant performance improvement for lookups of headers with multiple static table entries.

To implement this, I will:
1.  Introduce the `NAME_END_INDICES` array and a static initializer block to populate it at class-loading time.
2.  Update `getIndexInsensitive` to use this new array for a more efficient lookup loop.
3.  Remove the now-obsolete `MAX_SAME_NAME_FIELD_INDEX` field and its corresponding calculation method `maxSameNameFieldIndex`.

These changes are presented as a sequence of edits that should be applied in order to maintain a compilable state.

```json
[
  {
    "filepath": "../netty/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java",
    "search": "private static final int MAX_SAME_NAME_FIELD_INDEX = maxSameNameFieldIndex();",
    "replace": "    private static final int[] NAME_END_INDICES = new int[STATIC_TABLE.size() + 1];\n\n    static {\n        if (!STATIC_TABLE.isEmpty()) {\n            int length = STATIC_TABLE.size();\n            NAME_END_INDICES[length] = length;\n            for (int i = length - 1; i > 0; i--) {\n                HpackHeaderField current = getEntry(i);\n                HpackHeaderField next = getEntry(i + 1);\n                if (equalsVariableTime(current.name, next.name)) {\n                    NAME_END_INDICES[i] = NAME_END_INDICES[i + 1];\n                } else {\n                    NAME_END_INDICES[i] = i;\n                }\n            }\n        }\n    }"
  },
  {
    "filepath": "../netty/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java",
    "search": "    static int getIndexInsensitive(CharSequence name, CharSequence value) {\n        int index = getIndex(name);\n        if (index == NOT_FOUND) {\n            return NOT_FOUND;\n        }\n\n        // Compare values for the first name match\n        HpackHeaderField entry = getEntry(index);\n        if (equalsVariableTime(value, entry.value)) {\n            return index;\n        }\n\n        // Note this assumes all entries for a given header field are sequential.\n        index++;\n        while (index <= MAX_SAME_NAME_FIELD_INDEX) {\n            entry = getEntry(index);\n            if (!equalsVariableTime(name, entry.name)) {\n                // As far as fields with the same name are placed in the table sequentially\n                // and INDEX_BY_NAME returns index of the fist position, - it's safe to\n                // exit immediately.\n                return NOT_FOUND;\n            }\n            if (equalsVariableTime(value, entry.value)) {\n                return index;\n            }\n            index++;\n        }\n\n        return NOT_FOUND;\n    }",
    "replace": "    static int getIndexInsensitive(CharSequence name, CharSequence value) {\n        int index = getIndex(name);\n        if (index == NOT_FOUND) {\n            return NOT_FOUND;\n        }\n\n        // Compare values for the first name match\n        HpackHeaderField entry = getEntry(index);\n        if (equalsVariableTime(value, entry.value)) {\n            return index;\n        }\n\n        // All entries for a given header field are sequential.\n        int endIndex = NAME_END_INDICES[index];\n        index++;\n        while (index <= endIndex) {\n            entry = getEntry(index);\n            if (equalsVariableTime(value, entry.value)) {\n                return index;\n            }\n            index++;\n        }\n\n        return NOT_FOUND;\n    }"
  },
  {
    "filepath": "../netty/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java",
    "search": "    /**\n     * Returns the last position in the array that contains multiple\n     * fields with the same name. Starting from this position, all\n     * names are unique. Similar to {@link #getIndexInsensitive(CharSequence, CharSequence)} method\n     * assumes all entries for a given header field are sequential\n     */\n    private static int maxSameNameFieldIndex() {\n        final int length = STATIC_TABLE.size();\n        HpackHeaderField cursor = getEntry(length);\n        for (int index = length - 1; index > 0; index--) {\n            HpackHeaderField entry = getEntry(index);\n            if (equalsVariableTime(entry.name, cursor.name)) {\n                return index + 1;\n            } else {\n                cursor = entry;\n            }\n        }\n        return length;\n    }",
    "replace": ""
  }
]
```