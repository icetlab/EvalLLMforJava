diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java
index 389d8ef150..ffb9cda7e0 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java
@@ -31,7 +31,7 @@
  */
 package io.netty.handler.codec.http2;
 
-import io.netty.handler.codec.UnsupportedValueConverter;
+
 import io.netty.util.AsciiString;
 
 import java.util.Arrays;
@@ -117,7 +117,40 @@ final class HpackStaticTable {
         return new HpackHeaderField(AsciiString.cached(name), AsciiString.cached(value));
     }
 
-    private static final CharSequenceMap<Integer> STATIC_INDEX_BY_NAME = createMap();
+    private static final class StaticHeader {
+        final CharSequence name;
+        final int index;
+
+        StaticHeader(CharSequence name, int index) {
+            this.name = name;
+            this.index = index;
+        }
+    }
+
+    // A perfect hash function for the static table header names.
+    private static final StaticHeader[] STATIC_INDEX_TABLE = new StaticHeader[128];
+
+    static {
+        // Populate the static index table.
+        // This is a perfect hash table of size 128.
+        // The hash function is (length + 4 * (first_byte + last_byte)) & 127.
+        for (int index = STATIC_TABLE.size(); index > 0; index--) {
+            HpackHeaderField entry = getEntry(index);
+            CharSequence name = entry.name;
+            int h = hash(name);
+            STATIC_INDEX_TABLE[h] = new StaticHeader(name, index);
+        }
+    }
+
+    private static int hash(CharSequence name) {
+        int h = name.length();
+        if (h == 0) {
+            return 0;
+        }
+        // The hash function is chosen to be a perfect hash for the static header table names.
+        // (length + 4 * (first_byte + last_byte)) & 127
+        return (h + 4 * (name.charAt(0) + name.charAt(h - 1))) & 127;
+    }
 
     private static final int MAX_SAME_NAME_FIELD_INDEX = maxSameNameFieldIndex();
 
@@ -138,11 +171,12 @@ final class HpackStaticTable {
      * -1 if the header field name is not in the static table.
      */
     static int getIndex(CharSequence name) {
-        Integer index = STATIC_INDEX_BY_NAME.get(name);
-        if (index == null) {
+        int h = hash(name);
+        StaticHeader entry = STATIC_INDEX_TABLE[h];
+        if (entry == null || !equalsVariableTime(name, entry.name)) {
             return NOT_FOUND;
         }
-        return index;
+        return entry.index;
     }
 
     /**
@@ -180,21 +214,7 @@ final class HpackStaticTable {
         return NOT_FOUND;
     }
 
-    // create a map CharSequenceMap header name to index value to allow quick lookup
-    private static CharSequenceMap<Integer> createMap() {
-        int length = STATIC_TABLE.size();
-        @SuppressWarnings("unchecked")
-        CharSequenceMap<Integer> ret = new CharSequenceMap<Integer>(true,
-                UnsupportedValueConverter.<Integer>instance(), length);
-        // Iterate through the static table in reverse order to
-        // save the smallest index for a given name in the map.
-        for (int index = length; index > 0; index--) {
-            HpackHeaderField entry = getEntry(index);
-            CharSequence name = entry.name;
-            ret.set(name, index);
-        }
-        return ret;
-    }
+
 
     /**
      * Returns the last position in the array that contains multiple
