diff --git a/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java
index c132aa5b20..c3cb30a1fa 100644
--- a/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java
+++ b/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java
@@ -249,16 +249,12 @@ public abstract class AbstractScheduledEventExecutor extends AbstractEventExecut
             scheduledTaskQueue().add(task.setId(nextTaskId++));
         } else {
             final long deadlineNanos = task.deadlineNanos();
-            final Runnable addToQueue = new Runnable() {
-                @Override
-                public void run() {
-                    scheduledTaskQueue().add(task.setId(nextTaskId++));
-                }
-            };
+            // Use task itself to schedule without extra allocation
+            task.setScheduleTask(true);
             if (beforeScheduledTaskSubmitted(deadlineNanos)) {
-                execute(addToQueue);
+                execute(task);
             } else {
-                lazyExecute(addToQueue);
+                lazyExecute(task);
                 // Second hook after scheduling to facilitate race-avoidance
                 if (afterScheduledTaskSubmitted(deadlineNanos)) {
                     execute(WAKEUP_TASK);
@@ -282,6 +278,13 @@ public abstract class AbstractScheduledEventExecutor extends AbstractEventExecut
         }
     }
 
+    /**
+     * Internal scheduling action used to add a task to the scheduled task queue in the event loop.
+     */
+    void scheduleTask(final ScheduledFutureTask<?> task) {
+        scheduledTaskQueue().add(task.setId(nextTaskId++));
+    }
+
     /**
      * Called from arbitrary non-{@link EventExecutor} threads prior to scheduled task submission.
      * Returns {@code true} if the {@link EventExecutor} thread should be woken immediately to
diff --git a/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java b/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java
index 5ffe824119..42a9a067f1 100644
--- a/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java
+++ b/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java
@@ -18,6 +18,7 @@ package io.netty.util.concurrent;
 
 import io.netty.util.internal.DefaultPriorityQueue;
 import io.netty.util.internal.PriorityQueueNode;
+import io.netty.util.concurrent.AbstractScheduledEventExecutor;
 
 import java.util.Queue;
 import java.util.concurrent.Callable;
@@ -27,6 +28,8 @@ import java.util.concurrent.TimeUnit;
 @SuppressWarnings("ComparableImplementedButEqualsNotOverridden")
 final class ScheduledFutureTask<V> extends PromiseTask<V> implements ScheduledFuture<V>, PriorityQueueNode {
     private static final long START_TIME = System.nanoTime();
+    // Flag indicating this run() invocation is for initial scheduling
+    private boolean initialScheduled;
 
     static long nanoTime() {
         return System.nanoTime() - START_TIME;
@@ -90,6 +93,14 @@ final class ScheduledFutureTask<V> extends PromiseTask<V> implements ScheduledFu
         return period;
     }
 
+    /**
+     * Setter for initial scheduling flag.
+     */
+    ScheduledFutureTask<V> setScheduleTask(boolean initial) {
+        this.initialScheduled = initial;
+        return this;
+    }
+
     ScheduledFutureTask<V> setId(long id) {
         this.id = id;
         return this;
@@ -143,6 +154,12 @@ final class ScheduledFutureTask<V> extends PromiseTask<V> implements ScheduledFu
 
     @Override
     public void run() {
+        if (initialScheduled) {
+            initialScheduled = false;
+            AbstractScheduledEventExecutor exec = (AbstractScheduledEventExecutor) executor();
+            exec.scheduleTask(this);
+            return;
+        }
         assert executor().inEventLoop();
         try {
             if (periodNanos == 0) {
