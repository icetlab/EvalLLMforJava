diff --git a/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
index e7afab3672..50b1c1ef4c 100644
--- a/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
@@ -771,19 +771,23 @@ public final class ByteBufUtil {
         } else {
             dst.clear();
         }
-        if (src.nioBufferCount() == 1) {
-            decodeString(decoder, src.nioBuffer(readerIndex, len), dst);
-        } else {
-            // We use a heap buffer as CharsetDecoder is most likely able to use a fast-path if src and dst buffers
-            // are both backed by a byte array.
-            ByteBuf buffer = src.alloc().heapBuffer(len);
+        /* Decode across all underlying NIO buffers without an extra ByteBuf copy */
+        {
+            java.nio.ByteBuffer[] buffers = src.nioBuffers(readerIndex, len);
             try {
-                buffer.writeBytes(src, readerIndex, len);
-                // Use internalNioBuffer(...) to reduce object creation.
-                decodeString(decoder, buffer.internalNioBuffer(buffer.readerIndex(), len), dst);
-            } finally {
-                // Release the temporary buffer again.
-                buffer.release();
+                for (int i = 0; i < buffers.length; i++) {
+                    java.nio.ByteBuffer bb = buffers[i];
+                    CoderResult cr = decoder.decode(bb, dst, i == buffers.length - 1);
+                    if (!cr.isUnderflow()) {
+                        cr.throwException();
+                    }
+                }
+                CoderResult cr = decoder.flush(dst);
+                if (!cr.isUnderflow()) {
+                    cr.throwException();
+                }
+            } catch (CharacterCodingException x) {
+                throw new IllegalStateException(x);
             }
         }
         return dst.flip().toString();
