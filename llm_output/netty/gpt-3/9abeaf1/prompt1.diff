diff --git a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
index 8c9ad17821..2c9e1445d6 100644
--- a/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java
@@ -26,6 +26,9 @@ import io.netty.util.IntSupplier;
 import io.netty.util.collection.IntObjectHashMap;
 import io.netty.util.collection.IntObjectMap;
 import io.netty.util.concurrent.RejectedExecutionHandler;
+import java.util.concurrent.Callable;
+import java.util.concurrent.TimeUnit;
+import io.netty.util.concurrent.ScheduledFuture;
 import io.netty.util.internal.ObjectUtil;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.logging.InternalLogger;
@@ -42,6 +45,44 @@ import static java.lang.Math.min;
  * {@link EventLoop} which uses epoll under the covers. Only works on Linux!
  */
 class EpollEventLoop extends SingleThreadEventLoop {
+
+    // clamp maximum delay to avoid nanosecond overflow when scheduling
+    private long safeDelayNanos(long delay, TimeUnit unit) {
+        long d;
+        // convert requested delay to nanos, guarding against overflow
+        try {
+            d = unit.toNanos(delay);
+            if (delay > 0 && d < 0) {
+                // overflowed
+                d = Long.MAX_VALUE;
+            }
+        } catch (Exception e) {
+            // fallback if conversion fails
+            d = Long.MAX_VALUE;
+        }
+        long now = nanoTime();
+        long maxD = Long.MAX_VALUE - now;
+        if (d > maxD) {
+            d = maxD;
+        } else if (d < 0) {
+            d = 0;
+        }
+        return d;
+    }
+
+    @Override
+    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
+        long d = safeDelayNanos(delay, unit);
+        // schedule with a nanosecond-based delay to avoid re-conversion
+        return super.schedule(command, d, TimeUnit.NANOSECONDS);
+    }
+
+    @Override
+    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {
+        long d = safeDelayNanos(delay, unit);
+        return super.schedule(callable, d, TimeUnit.NANOSECONDS);
+    }
+
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(EpollEventLoop.class);
     private static final AtomicIntegerFieldUpdater<EpollEventLoop> WAKEN_UP_UPDATER =
             AtomicIntegerFieldUpdater.newUpdater(EpollEventLoop.class, "wakenUp");
