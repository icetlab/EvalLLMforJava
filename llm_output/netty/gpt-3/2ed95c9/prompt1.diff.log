I have introduced a precomputed nested lookup map for constant-time name+value index resolution and replaced the linear scan in `getIndexInsensitive` with a two-level map lookup, preserving all existing functionality and tests.

```json
[
  {
    "filepath": "../netty/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java",
    "search": "private static final CharSequenceMap<Integer> STATIC_INDEX_BY_NAME = createMap();",
    "replace": "private static final CharSequenceMap<Integer> STATIC_INDEX_BY_NAME = createMap();\n\n    // Precompute full name+value indices for O(1) lookup\n    private static final CharSequenceMap<CharSequenceMap<Integer>> STATIC_INDEX_BY_NAME_AND_VALUE = createMapByNameValue();\n\n    private static CharSequenceMap<CharSequenceMap<Integer>> createMapByNameValue() {\n        int length = STATIC_TABLE.size();\n        @SuppressWarnings(\"unchecked\")\n        CharSequenceMap<CharSequenceMap<Integer>> ret = new CharSequenceMap<>(true,\n                UnsupportedValueConverter.<CharSequenceMap<Integer>>instance(), length);\n        for (int index = 1; index <= length; index++) {\n            HpackHeaderField entry = getEntry(index);\n            CharSequence name = entry.name;\n            CharSequence value = entry.value;\n            CharSequenceMap<Integer> inner = ret.get(name);\n            if (inner == null) {\n                @SuppressWarnings(\"unchecked\")\n                CharSequenceMap<Integer> innerMap = new CharSequenceMap<>(false,\n                        UnsupportedValueConverter.<Integer>instance(), length);\n                ret.set(name, innerMap);\n                inner = innerMap;\n            }\n            inner.set(value, index);\n        }\n        return ret;\n    }"
  },
  {
    "filepath": "../netty/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackStaticTable.java",
    "search": "    static int getIndexInsensitive(CharSequence name, CharSequence value) {\n        int index = getIndex(name);\n        if (index == NOT_FOUND) {\n            return NOT_FOUND;\n        }\n\n        // Compare values for the first name match\n        HpackHeaderField entry = getEntry(index);\n        if (equalsVariableTime(value, entry.value)) {\n            return index;\n        }\n\n        // Note this assumes all entries for a given header field are sequential.\n        index++;\n        while (index <= MAX_SAME_NAME_FIELD_INDEX) {\n            entry = getEntry(index);\n            if (!equalsVariableTime(name, entry.name)) {\n                // As far as fields with the same name are placed in the table sequentially\n                // and INDEX_BY_NAME returns index of the fist position, - it's safe to\n                // exit immediately.\n                return NOT_FOUND;\n            }\n            if (equalsVariableTime(value, entry.value)) {\n                return index;\n            }\n            index++;\n        }\n\n        return NOT_FOUND;\n    }",
    "replace": "    static int getIndexInsensitive(CharSequence name, CharSequence value) {\n        // Two-level map lookup: name → (value → index)\n        CharSequenceMap<CharSequenceMap<Integer>> outer = STATIC_INDEX_BY_NAME_AND_VALUE;\n        CharSequenceMap<Integer> inner = outer.get(name);\n        if (inner == null) {\n            return NOT_FOUND;\n        }\n        Integer idx = inner.get(value);\n        return idx == null ? NOT_FOUND : idx;\n    }"
  }
]
```