The primary improvement is to optimize the row-to-partition mapping in `PagePartitioner.partitionPage`. Instead of calculating the destination partition for each row one by one within the main distribution loop, I've introduced a pre-computation step. Partitions for all rows in a page are now calculated upfront into an array. This allows the partitioning logic to be executed in a tight, JIT-friendly loop. The main distribution loop is now simpler, using the pre-computed partitions, which improves performance by reducing overhead and aiding branch prediction. A minor optimization is also added to `PartitionBuffer.populateSerializedRowSizes` to skip a loop when no fixed-width columns are present.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java",
    "search": "            Block nullBlock = nullChannel.isPresent() ? page.getBlock(nullChannel.getAsInt()) : null;\n            Page partitionFunctionArgs = getPartitionFunctionArguments(page);\n\n            for (int position = 0; position < positionCount; position++) {\n                boolean shouldReplicate = (replicatesAnyRow && !hasAnyRowBeenReplicated) ||\n                        nullBlock != null && nullBlock.isNull(position);\n\n                if (shouldReplicate) {\n                    for (int i = 0; i < partitionBuffers.length; i++) {\n                        partitionBuffers[i].addPosition(position);\n                    }\n                    hasAnyRowBeenReplicated = true;\n                }\n                else {\n                    int partition = partitionFunction.getPartition(partitionFunctionArgs, position);\n                    partitionBuffers[partition].addPosition(position);\n                }\n            }",
    "replace": "            Block nullBlock = nullChannel.isPresent() ? page.getBlock(nullChannel.getAsInt()) : null;\n            Page partitionFunctionArgs = getPartitionFunctionArguments(page);\n\n            // get partitions for all rows\n            int[] partitions = new int[positionCount];\n            for (int i = 0; i < positionCount; i++) {\n                partitions[i] = partitionFunction.getPartition(partitionFunctionArgs, i);\n            }\n\n            for (int position = 0; position < positionCount; position++) {\n                boolean shouldReplicate = (replicatesAnyRow && !hasAnyRowBeenReplicated) ||\n                        (nullBlock != null && nullBlock.isNull(position));\n\n                if (shouldReplicate) {\n                    for (int i = 0; i < partitionBuffers.length; i++) {\n                        partitionBuffers[i].addPosition(position);\n                    }\n                    hasAnyRowBeenReplicated = true;\n                }\n                else {\n                    partitionBuffers[partitions[position]].addPosition(position);\n                }\n            }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java",
    "search": "            for (int i : variableWidthChannels) {\n                blockEncodingBuffers[i].accumulateSerializedRowSizes(serializedRowSizes);\n            }\n\n            for (int i = 0; i < positionCount; i++) {\n                serializedRowSizes[i] += fixedWidthRowSize;\n            }",
    "replace": "            for (int i : variableWidthChannels) {\n                blockEncodingBuffers[i].accumulateSerializedRowSizes(serializedRowSizes);\n            }\n\n            if (fixedWidthRowSize > 0) {\n                for (int i = 0; i < positionCount; i++) {\n                    serializedRowSizes[i] += fixedWidthRowSize;\n                }\n            }"
  }
]
```