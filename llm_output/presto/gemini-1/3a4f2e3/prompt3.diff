diff --git a/presto-orc/src/main/java/com/facebook/presto/orc/reader/BooleanSelectiveStreamReader.java b/presto-orc/src/main/java/com/facebook/presto/orc/reader/BooleanSelectiveStreamReader.java
index aab2765889..1b3d0b5ddd 100644
--- a/presto-orc/src/main/java/com/facebook/presto/orc/reader/BooleanSelectiveStreamReader.java
+++ b/presto-orc/src/main/java/com/facebook/presto/orc/reader/BooleanSelectiveStreamReader.java
@@ -188,6 +188,7 @@ public class BooleanSelectiveStreamReader
             // - readBooleanNoNull: 0.045 vs.0.029 s/op
             // - readBooleanNoNullWithFilter: 0.112 vs 0.099 s/op
             outputPositionCount = 0;
+            if (presentStream == null) {
                 for (int i = 0; i < positionCount; i++) {
                     int position = positions[i];
                     if (position > streamPosition) {
@@ -195,7 +196,41 @@ public class BooleanSelectiveStreamReader
                         streamPosition = position;
                     }
 
-                if (presentStream != null && !presentStream.nextBit()) {
+                    boolean value = dataStream.nextBit();
+                    if (filter.testBoolean(value)) {
+                        if (outputRequired) {
+                            values[outputPositionCount] = (byte) (value ? 1 : 0);
+                        }
+                        outputPositions[outputPositionCount] = position;
+                        outputPositionCount++;
+                    }
+
+                    outputPositionCount -= filter.getPrecedingPositionsToFail();
+
+                    streamPosition++;
+
+                    int succeedingPositionsToFail = filter.getSucceedingPositionsToFail();
+                    if (succeedingPositionsToFail > 0) {
+                        int positionsToSkip = 0;
+                        for (int j = 0; j < succeedingPositionsToFail; j++) {
+                            i++;
+                            int nextPosition = positions[i];
+                            positionsToSkip += 1 + nextPosition - streamPosition;
+                            streamPosition = nextPosition + 1;
+                        }
+                        skip(positionsToSkip);
+                    }
+                }
+            }
+            else {
+                for (int i = 0; i < positionCount; i++) {
+                    int position = positions[i];
+                    if (position > streamPosition) {
+                        skip(position - streamPosition);
+                        streamPosition = position;
+                    }
+
+                    if (!presentStream.nextBit()) {
                         if ((nonDeterministicFilter && filter.testNull()) || nullsAllowed) {
                             if (outputRequired) {
                                 nulls[outputPositionCount] = true;
@@ -209,7 +244,7 @@ public class BooleanSelectiveStreamReader
                         if (filter.testBoolean(value)) {
                             if (outputRequired) {
                                 values[outputPositionCount] = (byte) (value ? 1 : 0);
-                            if (nullsAllowed && presentStream != null) {
+                                if (nullsAllowed) {
                                     nulls[outputPositionCount] = false;
                                 }
                             }
@@ -235,6 +270,7 @@ public class BooleanSelectiveStreamReader
                     }
                 }
             }
+        }
 
         readOffset = offset + streamPosition;
         return outputPositionCount;
@@ -273,6 +309,18 @@ public class BooleanSelectiveStreamReader
     {
         // filter == null implies outputRequired == true
         int streamPosition = 0;
+        if (presentStream == null) {
+            for (int i = 0; i < positionCount; i++) {
+                int position = positions[i];
+                if (position > streamPosition) {
+                    skip(position - streamPosition);
+                    streamPosition = position;
+                }
+                values[i] = (byte) (dataStream.nextBit() ? 1 : 0);
+                streamPosition++;
+            }
+        }
+        else {
             for (int i = 0; i < positionCount; i++) {
                 int position = positions[i];
                 if (position > streamPosition) {
@@ -280,17 +328,16 @@ public class BooleanSelectiveStreamReader
                     streamPosition = position;
                 }
 
-            if (presentStream != null && !presentStream.nextBit()) {
+                if (!presentStream.nextBit()) {
                     nulls[i] = true;
                 }
                 else {
                     values[i] = (byte) (dataStream.nextBit() ? 1 : 0);
-                if (presentStream != null) {
                     nulls[i] = false;
                 }
-            }
                 streamPosition++;
             }
+        }
         outputPositionCount = positionCount;
         return streamPosition;
     }
