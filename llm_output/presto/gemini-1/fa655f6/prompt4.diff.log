The performance issue is related to excessive `Slice` object creation during key lookups in `SingleMapBlock`. Specifically, `seekKeyExact(Slice nativeValue)` uses a `MethodHandle` (`keyBlockNativeEquals.invokeExact`) to compare keys. For `Slice`-based keys, this method handle's implementation creates a new `Slice` object for the key stored in the block before performing the comparison. In queries with many map subscript operations, this leads to high garbage collection overhead.

To improve this, I will modify `seekKeyExact(Slice nativeValue)` to use a more direct and allocation-free comparison method. Instead of invoking the `MethodHandle`, I will use the `Block.getSliceLength()` and `Block.bytesEqual()` methods. This approach compares the raw bytes of the input `Slice` with the key's bytes in the underlying `Block` without creating an intermediate `Slice` object. This change is safe as all `Slice`-based types in Presto define equality as byte-wise comparison. This optimization is targeted only at `Slice` keys, preserving the existing logic for other key types.

```json
[
  {
    "filepath": "../presto/presto-common/src/main/java/com/facebook/presto/common/block/SingleMapBlock.java",
    "search": "    public int seekKeyExact(Slice nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        mapBlock.ensureHashTableLoaded();\n        int[] hashTable = mapBlock.getHashTables().get();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        int hashTableOffset = offset / 2 * HASH_MULTIPLIER;\n        int hashTableSize = positionCount / 2 * HASH_MULTIPLIER;\n        int position = computePosition(hashCode, hashTableSize);\n        while (true) {\n            int keyPosition = hashTable[hashTableOffset + position];\n            if (keyPosition == -1) {\n                return -1;\n            }\n            Boolean match;\n            try {\n                // assuming maps with indeterminate keys are not supported\n                match = (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue);\n            }\n            catch (Throwable throwable) {\n                throw handleThrowable(throwable);\n            }\n            checkNotIndeterminate(match);\n            if (match) {\n                return keyPosition * 2 + 1;\n            }\n            position++;\n            if (position == hashTableSize) {\n                position = 0;\n            }\n        }\n    }",
    "replace": "    public int seekKeyExact(Slice nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        mapBlock.ensureHashTableLoaded();\n        int[] hashTable = mapBlock.getHashTables().get();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        int hashTableOffset = offset / 2 * HASH_MULTIPLIER;\n        int hashTableSize = positionCount / 2 * HASH_MULTIPLIER;\n        int position = computePosition(hashCode, hashTableSize);\n        Block rawKeyBlock = mapBlock.getRawKeyBlock();\n        while (true) {\n            int keyPosition = hashTable[hashTableOffset + position];\n            if (keyPosition == -1) {\n                return -1;\n            }\n            Boolean match;\n            try {\n                // an fast path for Slice comparison to avoid creating new Slice objects\n                // assuming maps with indeterminate keys are not supported\n                int keyBlockPosition = offset / 2 + keyPosition;\n                if (rawKeyBlock.getSliceLength(keyBlockPosition) != nativeValue.length()) {\n                    match = false;\n                }\n                else {\n                    match = rawKeyBlock.bytesEqual(keyBlockPosition, 0, nativeValue, 0, nativeValue.length());\n                }\n            }\n            catch (Throwable throwable) {\n                throw handleThrowable(throwable);\n            }\n            checkNotIndeterminate(match);\n            if (match) {\n                return keyPosition * 2 + 1;\n            }\n            position++;\n            if (position == hashTableSize) {\n                position = 0;\n            }\n        }\n    }"
  }
]
```