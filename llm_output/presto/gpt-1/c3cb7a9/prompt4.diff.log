We inline the binary search in the two `findGroupEnd` methods to avoid the overhead of the generic `BiPredicate` (boxing) and call the primitive hash/comparison methods directly.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java",
    "search": "    private static int findGroupEnd(Page page, PagesHashStrategy pagesHashStrategy, int startPosition)\n    {\n        checkArgument(page.getPositionCount() > 0, \"Must have at least one position\");\n        checkPositionIndex(startPosition, page.getPositionCount(), \"startPosition out of bounds\");\n\n        return findEndPosition(startPosition, page.getPositionCount(), (firstPosition, secondPosition) -> pagesHashStrategy.rowEqualsRow(firstPosition, page, secondPosition, page));\n    }",
    "replace": "    private static int findGroupEnd(Page page, PagesHashStrategy pagesHashStrategy, int startPosition)\n    {\n        checkArgument(page.getPositionCount() > 0, \"Must have at least one position\");\n        checkPositionIndex(startPosition, page.getPositionCount(), \"startPosition out of bounds\");\n\n        int left = startPosition;\n        int right = page.getPositionCount();\n\n        while (left + 1 < right) {\n            int middle = (left + right) >>> 1;\n            if (pagesHashStrategy.rowEqualsRow(startPosition, page, middle, page)) {\n                left = middle;\n            }\n            else {\n                right = middle;\n            }\n        }\n\n        return right;\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/WindowOperator.java",
    "search": "    private static int findGroupEnd(PagesIndex pagesIndex, PagesHashStrategy pagesHashStrategy, int startPosition)\n    {\n        checkArgument(pagesIndex.getPositionCount() > 0, \"Must have at least one position\");\n        checkPositionIndex(startPosition, pagesIndex.getPositionCount(), \"startPosition out of bounds\");\n\n        return findEndPosition(startPosition, pagesIndex.getPositionCount(), (firstPosition, secondPosition) -> pagesIndex.positionEqualsPosition(pagesHashStrategy, firstPosition, secondPosition));\n    }",
    "replace": "    private static int findGroupEnd(PagesIndex pagesIndex, PagesHashStrategy pagesHashStrategy, int startPosition)\n    {\n        checkArgument(pagesIndex.getPositionCount() > 0, \"Must have at least one position\");\n        checkPositionIndex(startPosition, pagesIndex.getPositionCount(), \"startPosition out of bounds\");\n\n        int left = startPosition;\n        int right = pagesIndex.getPositionCount();\n\n        while (left + 1 < right) {\n            int middle = (left + right) >>> 1;\n            if (pagesIndex.positionEqualsPosition(pagesHashStrategy, startPosition, middle)) {\n                left = middle;\n            }\n            else {\n                right = middle;\n            }\n        }\n\n        return right;\n    }"
  }
]
```