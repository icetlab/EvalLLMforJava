My goal is to optimize the `map_to_map_cast` operation by introducing a specialized path for a common scenario: when the key type of the map does not change during the cast.

The original implementation processes all keys first to create a temporary block of casted keys, and then iterates again to check for duplicates and process the values. This two-pass approach is inefficient.

My optimization introduces a new method, `mapCastKeySameType`, which is invoked when the `fromKeyType` and `toKeyType` are identical. This specialized method processes the map in a single pass. It iterates through the input map's key-value pairs, checks for duplicate keys using the original keys directly (since their type doesn't change), and then processes and appends the values. This avoids the creation of an intermediate block for keys and eliminates the second pass, significantly improving performance for this common use case.

To enable this, I've made two main changes:
1.  I've added the new `mapCastKeySameType` method, which contains the single-pass logic.
2.  I've updated the `specialize` method to detect when the key types are the same. When they are, it wires up the call to the new, optimized `mapCastKeySameType` method. A corresponding `MethodHandle` has also been added to support this.

These changes maintain the original functionality, including duplicate key and null key checks, while providing a significant performance boost for casts that do not alter the map's key type.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java",
    "search": "    private static final MethodHandle METHOD_HANDLE = methodHandle(\n            MapToMapCast.class,\n            \"mapCast\",\n            MethodHandle.class,\n            MethodHandle.class,\n            Type.class,\n            SqlFunctionProperties.class,\n            Block.class);",
    "replace": "    private static final MethodHandle METHOD_HANDLE = methodHandle(\n            MapToMapCast.class,\n            \"mapCast\",\n            MethodHandle.class,\n            MethodHandle.class,\n            Type.class,\n            SqlFunctionProperties.class,\n            Block.class);\n\n    private static final MethodHandle MAP_CAST_KEY_SAME_TYPE_METHOD_HANDLE = methodHandle(\n            MapToMapCast.class,\n            \"mapCastKeySameType\",\n            MethodHandle.class,\n            Type.class,\n            SqlFunctionProperties.class,\n            Block.class);"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java",
    "search": "    public BuiltInScalarFunctionImplementation specialize(BoundVariables boundVariables, int arity, FunctionAndTypeManager functionAndTypeManager)\n    {\n        checkArgument(arity == 1, \"Expected arity to be 1\");\n        Type fromKeyType = boundVariables.getTypeVariable(\"FK\");\n        Type fromValueType = boundVariables.getTypeVariable(\"FV\");\n        Type toKeyType = boundVariables.getTypeVariable(\"TK\");\n        Type toValueType = boundVariables.getTypeVariable(\"TV\");\n        Type toMapType = functionAndTypeManager.getParameterizedType(\n                \"map\",\n                ImmutableList.of(\n                        TypeSignatureParameter.of(toKeyType.getTypeSignature()),\n                        TypeSignatureParameter.of(toValueType.getTypeSignature())));\n\n        MethodHandle keyProcessor = buildProcessor(functionAndTypeManager, fromKeyType, toKeyType, true);\n        MethodHandle valueProcessor = buildProcessor(functionAndTypeManager, fromValueType, toValueType, false);\n        MethodHandle target = MethodHandles.insertArguments(METHOD_HANDLE, 0, keyProcessor, valueProcessor, toMapType);\n        return new BuiltInScalarFunctionImplementation(true, ImmutableList.of(valueTypeArgumentProperty(RETURN_NULL_ON_NULL)), target);\n    }",
    "replace": "    public BuiltInScalarFunctionImplementation specialize(BoundVariables boundVariables, int arity, FunctionAndTypeManager functionAndTypeManager)\n    {\n        checkArgument(arity == 1, \"Expected arity to be 1\");\n        Type fromKeyType = boundVariables.getTypeVariable(\"FK\");\n        Type fromValueType = boundVariables.getTypeVariable(\"FV\");\n        Type toKeyType = boundVariables.getTypeVariable(\"TK\");\n        Type toValueType = boundVariables.getTypeVariable(\"TV\");\n        Type toMapType = functionAndTypeManager.getParameterizedType(\n                \"map\",\n                ImmutableList.of(\n                        TypeSignatureParameter.of(toKeyType.getTypeSignature()),\n                        TypeSignatureParameter.of(toValueType.getTypeSignature())));\n\n        if (fromKeyType.equals(toKeyType)) {\n            MethodHandle valueProcessor = buildProcessor(functionAndTypeManager, fromValueType, toValueType, false);\n            MethodHandle target = MethodHandles.insertArguments(MAP_CAST_KEY_SAME_TYPE_METHOD_HANDLE, 0, valueProcessor, toMapType);\n            return new BuiltInScalarFunctionImplementation(true, ImmutableList.of(valueTypeArgumentProperty(RETURN_NULL_ON_NULL)), target);\n        }\n\n        MethodHandle keyProcessor = buildProcessor(functionAndTypeManager, fromKeyType, toKeyType, true);\n        MethodHandle valueProcessor = buildProcessor(functionAndTypeManager, fromValueType, toValueType, false);\n        MethodHandle target = MethodHandles.insertArguments(METHOD_HANDLE, 0, keyProcessor, valueProcessor, toMapType);\n        return new BuiltInScalarFunctionImplementation(true, ImmutableList.of(valueTypeArgumentProperty(RETURN_NULL_ON_NULL)), target);\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java",
    "search": "    @UsedByGeneratedCode\n    public static Block mapCast(",
    "replace": "    @UsedByGeneratedCode\n    public static Block mapCastKeySameType(\n            MethodHandle valueProcessFunction,\n            Type toMapType,\n            SqlFunctionProperties properties,\n            Block fromMap)\n    {\n        checkState(toMapType.getTypeParameters().size() == 2, \"Expect two type parameters for toMapType\");\n        Type keyType = toMapType.getTypeParameters().get(0);\n        TypedSet typedSet = new TypedSet(keyType, fromMap.getPositionCount() / 2, \"map-to-map cast\");\n\n        BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);\n        BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();\n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            if (fromMap.isNull(i)) {\n                throw new PrestoException(INVALID_CAST_ARGUMENT, \"map key is null\");\n            }\n            if (typedSet.add(fromMap, i)) {\n                keyType.appendTo(fromMap, i, blockBuilder);\n                if (fromMap.isNull(i + 1)) {\n                    blockBuilder.appendNull();\n                    continue;\n                }\n\n                try {\n                    valueProcessFunction.invokeExact(fromMap, i + 1, properties, blockBuilder);\n                }\n                catch (Throwable t) {\n                    throw internalError(t);\n                }\n            }\n            else {\n                // if there are duplicated keys, fail it!\n                throw new PrestoException(INVALID_CAST_ARGUMENT, \"duplicate keys\");\n            }\n        }\n\n        mapBlockBuilder.closeEntry();\n        return (Block) toMapType.getObject(mapBlockBuilder, mapBlockBuilder.getPositionCount() - 1);\n    }\n\n    @UsedByGeneratedCode\n    public static Block mapCast("
  }
]
```