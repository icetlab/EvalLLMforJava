My overall improvement strategy is to optimize the `updateRetainedSize` method within the `PageProcessor.ProjectSelectedPositions` inner class. This method is called frequently, for each generated output page chunk, to calculate memory usage.

The original implementation created new lambda expressions for each call to `block.retainedBytesForEachPart` inside `updateRetainedSize`. This repeated object allocation in a hot path can be a performance drag.

To address this, I will:
1.  Introduce a `BiConsumer` field, `retainedSizeConsumer`, in the `ProjectSelectedPositions` class, initialized once as a reusable lambda.
2.  Add a `referenceCountMap` field to be accessed by the `retainedSizeConsumer`.
3.  Modify `updateRetainedSize` to use this single `retainedSizeConsumer` instance, thereby eliminating the repeated allocation of lambda objects during page processing.

This change reduces garbage collection pressure and improves the overall performance of the page processing loop.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java",
    "search": "        private SelectedPositions selectedPositions;\n        private long retainedSizeInBytes;",
    "replace": "        private SelectedPositions selectedPositions;\n        private long retainedSizeInBytes;\n\n        private ReferenceCountMap referenceCountMap;\n        private final java.util.function.BiConsumer<Object, Long> retainedSizeConsumer = (object, size) -> {\n            if (referenceCountMap.incrementAndGet(object) == 1) {\n                retainedSizeInBytes += size;\n            }\n        };"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/project/PageProcessor.java",
    "search": "        private void updateRetainedSize()\n        {\n            // increment the size only when it is the first reference\n            retainedSizeInBytes = Page.INSTANCE_SIZE + SizeOf.sizeOfObjectArray(page.getChannelCount());\n            ReferenceCountMap referenceCountMap = new ReferenceCountMap();\n            for (int channel = 0; channel < page.getChannelCount(); channel++) {\n                Block block = page.getBlock(channel);\n                if (!isNotLoadedLazyBlock(block)) {\n                    block.retainedBytesForEachPart((object, size) -> {\n                        if (referenceCountMap.incrementAndGet(object) == 1) {\n                            retainedSizeInBytes += size;\n                        }\n                    });\n                }\n            }\n            for (Block previouslyComputedResult : previouslyComputedResults) {\n                if (previouslyComputedResult != null) {\n                    previouslyComputedResult.retainedBytesForEachPart((object, size) -> {\n                        if (referenceCountMap.incrementAndGet(object) == 1) {\n                            retainedSizeInBytes += size;\n                        }\n                    });\n                }\n            }\n\n            memoryContext.setBytes(retainedSizeInBytes);\n        }",
    "replace": "        private void updateRetainedSize()\n        {\n            // increment the size only when it is the first reference\n            retainedSizeInBytes = Page.INSTANCE_SIZE + SizeOf.sizeOfObjectArray(page.getChannelCount());\n            referenceCountMap = new ReferenceCountMap();\n            for (int channel = 0; channel < page.getChannelCount(); channel++) {\n                Block block = page.getBlock(channel);\n                if (!isNotLoadedLazyBlock(block)) {\n                    block.retainedBytesForEachPart(retainedSizeConsumer);\n                }\n            }\n            for (Block previouslyComputedResult : previouslyComputedResults) {\n                if (previouslyComputedResult != null) {\n                    previouslyComputedResult.retainedBytesForEachPart(retainedSizeConsumer);\n                }\n            }\n\n            memoryContext.setBytes(retainedSizeInBytes);\n        }"
  }
]
```