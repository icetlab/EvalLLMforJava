My goal is to improve the performance of `ByteSelectiveStreamReader` when reading data without a filter but with the presence of nulls. The current implementation processes rows one by one in a loop, which can be inefficient.

I will introduce an optimized path for the common case where the requested positions are contiguous. This new path will perform bulk operations, which is significantly faster than row-by-row processing.

The optimization consists of these steps:
1.  Check if the positions to be read form a contiguous block.
2.  If they are contiguous, first skip to the start of the block.
3.  Read all the presence bits for the block in a single operation into a boolean array.
4.  Calculate the number of non-null values from the presence bits.
5.  Read all non-null byte values for the block in a single bulk operation.
6.  "Unpack" the non-null values into their correct positions in the output `values` array, guided by the presence bits.
7.  Construct the `nulls` array, which indicates for each position whether the value is null.

This approach replaces the iterative reading of `presentStream` and `dataStream` with a few bulk operations, reducing method call overhead and improving data locality, leading to better performance for this specific scenario. The original row-by-row logic is retained as a fallback for non-contiguous positions, ensuring correctness for all cases.

```json
[
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java",
    "search": "        int streamPosition = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = dataStream.next();\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;",
    "replace": "        if (presentStream != null && positionCount > 0 && (positions[positionCount - 1] - positions[0] == positionCount - 1)) {\n            int streamPosition = 0;\n            int startPosition = positions[0];\n            if (startPosition > streamPosition) {\n                skip(startPosition - streamPosition);\n                streamPosition = startPosition;\n            }\n\n            boolean[] isPresent = this.nulls;\n            presentStream.get(isPresent, 0, positionCount);\n\n            int nonNullCount = 0;\n            for (int i = 0; i < positionCount; i++) {\n                if (isPresent[i]) {\n                    nonNullCount++;\n                }\n            }\n\n            if (nonNullCount > 0) {\n                byte[] nonNullValues = new byte[nonNullCount];\n                dataStream.next(nonNullValues, nonNullCount);\n\n                int currentNonNull = 0;\n                for (int i = 0; i < positionCount; i++) {\n                    if (isPresent[i]) {\n                        values[i] = nonNullValues[currentNonNull++];\n                    }\n                }\n            }\n\n            for (int i = 0; i < positionCount; i++) {\n                nulls[i] = !isPresent[i];\n            }\n\n            outputPositionCount = positionCount;\n            return streamPosition + positionCount;\n        }\n\n        int streamPosition = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = dataStream.next();\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;"
  }
]
```