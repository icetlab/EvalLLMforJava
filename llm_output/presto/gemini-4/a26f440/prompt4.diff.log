The overall improvement is to optimize the T-Digest data structure for small distributions by avoiding the allocation of large internal buffers until they are actually needed.

Currently, a `TDigest` instance immediately allocates several large arrays for centroids and temporary data, regardless of the number of values it will hold. This is inefficient for use cases involving many T-Digests with few data points each, as it leads to high memory consumption and garbage collection pressure.

The proposed changes introduce a "raw" mode for new T-Digest instances. In this mode, incoming data points are stored in small, fixed-size arrays. The T-Digest transitions to the "buffered" mode, allocating the large arrays, only when the small raw buffer is full or when an operation like compression or serialization is requested. This lazy allocation strategy significantly reduces the memory footprint for small T-Digests while maintaining performance for large ones.

This change involves:
1.  Introducing new fields for the small raw buffers and making the large buffer fields non-final.
2.  Modifying the constructor to initialize the small buffers instead of the large ones.
3.  Adding a `transitionToBuffered()` method to handle the switch from raw to buffered mode.
4.  Updating methods like `add()`, `mergeNewValues()`, `createTDigest(Slice)`, and `estimatedInMemorySizeInBytes()` to be aware of the two modes.

These changes ensure that T-Digests with few values remain lightweight, improving performance in scenarios with many small distributions.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TDigest.class).instanceSize();",
    "replace": "    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TDigest.class).instanceSize();\n    private static final int RAW_BUFFER_SIZE = 20;"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "    private int activeCentroids;\n\n    private double totalWeight;\n\n    private final double[] weight;\n\n    private final double[] mean;\n\n    private double unmergedWeight;\n\n    // this is the index of the next temporary centroid\n    // this is a more Java-like convention than activeCentroids uses\n    private int tempUsed;\n    private final double[] tempWeight;\n    private final double[] tempMean;\n\n    // array used for sorting the temp centroids\n    // to avoid allocations during operation\n    private final int[] order;",
    "replace": "    private int activeCentroids;\n\n    private double totalWeight;\n\n    private double[] weight;\n\n    private double[] mean;\n\n    // raw buffers for small digests\n    private double[] rawMean;\n    private double[] rawWeight;\n    private int rawUsed;\n\n    private double unmergedWeight;\n\n    // this is the index of the next temporary centroid\n    // this is a more Java-like convention than activeCentroids uses\n    private int tempUsed;\n    private double[] tempWeight;\n    private double[] tempMean;\n\n    // array used for sorting the temp centroids\n    // to avoid allocations during operation\n    private int[] order;"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "        // having a big buffer is good for speed\n        int bufferSize = 5 * (int) ceil(this.publicCompression + sizeFudge);\n        int size = (int) ceil(this.compression + sizeFudge);\n\n        weight = new double[size];\n        mean = new double[size];\n        tempWeight = new double[bufferSize];\n        tempMean = new double[bufferSize];\n        order = new int[bufferSize];\n\n        activeCentroids = 0;",
    "replace": "        rawMean = new double[RAW_BUFFER_SIZE];\n        rawWeight = new double[RAW_BUFFER_SIZE];\n\n        activeCentroids = 0;"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "        activeCentroids = 0;\n    }",
    "replace": "        activeCentroids = 0;\n    }\n\n    private void transitionToBuffered()\n    {\n        if (tempWeight != null) {\n            return;\n        }\n\n        // having a big buffer is good for speed\n        int bufferSize = 5 * (int) ceil(this.publicCompression + sizeFudge);\n        int size = (int) ceil(this.compression + sizeFudge);\n\n        weight = new double[size];\n        mean = new double[size];\n        tempWeight = new double[bufferSize];\n        tempMean = new double[bufferSize];\n        order = new int[bufferSize];\n\n        arraycopy(rawMean, 0, tempMean, 0, rawUsed);\n        arraycopy(rawWeight, 0, tempWeight, 0, rawUsed);\n        tempUsed = rawUsed;\n\n        rawMean = null;\n        rawWeight = null;\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "            double publicCompression = max(10, sliceInput.readDouble());\n            TDigest r = new TDigest(publicCompression);\n            r.setMinMax(min, max);",
    "replace": "            double publicCompression = max(10, sliceInput.readDouble());\n            TDigest r = new TDigest(publicCompression);\n            r.transitionToBuffered();\n            r.setMinMax(min, max);"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "    public void add(double x, long w)\n    {\n        checkArgument(!Double.isNaN(x), \"Cannot add NaN to t-digest\");\n        checkArgument(w > 0L, \"weight must be > 0\");\n\n        if (tempUsed >= tempWeight.length - activeCentroids - 1) {\n            mergeNewValues();\n        }\n        int where = tempUsed++;\n        tempWeight[where] = w;\n        tempMean[where] = x;\n        unmergedWeight += w;\n        if (x < min) {\n            min = x;\n        }\n        if (x > max) {\n            max = x;\n        }\n    }",
    "replace": "    public void add(double x, long w)\n    {\n        checkArgument(!Double.isNaN(x), \"Cannot add NaN to t-digest\");\n        checkArgument(w > 0L, \"weight must be > 0\");\n\n        if (rawWeight != null) {\n            if (rawUsed >= rawWeight.length) {\n                transitionToBuffered();\n            }\n            else {\n                int where = rawUsed++;\n                rawWeight[where] = w;\n                rawMean[where] = x;\n                unmergedWeight += w;\n                if (x < min) {\n                    min = x;\n                }\n                if (x > max) {\n                    max = x;\n                }\n                return;\n            }\n        }\n\n        if (tempUsed >= tempWeight.length - activeCentroids - 1) {\n            mergeNewValues();\n        }\n        int where = tempUsed++;\n        tempWeight[where] = w;\n        tempMean[where] = x;\n        unmergedWeight += w;\n        if (x < min) {\n            min = x;\n        }\n        if (x > max) {\n            max = x;\n        }\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "    private void mergeNewValues(boolean force, double compression)\n    {\n        if (unmergedWeight == 0) {\n            return;\n        }\n\n        if (force || unmergedWeight > 0) {\n            // note that we run the merge in reverse every other merge to avoid left-to-right bias in merging\n            merge(tempMean, tempWeight, tempUsed, order, unmergedWeight, mergeCount % 2 == 1, compression);\n            mergeCount++;\n            tempUsed = 0;\n            unmergedWeight = 0;\n        }\n    }",
    "replace": "    private void mergeNewValues(boolean force, double compression)\n    {\n        if (unmergedWeight == 0) {\n            return;\n        }\n\n        if (rawWeight != null) {\n            if (!force) {\n                // not forced, and raw buffer is not full (see add()), so we do nothing\n                return;\n            }\n            transitionToBuffered();\n        }\n\n        // note that we run the merge in reverse every other merge to avoid left-to-right bias in merging\n        merge(tempMean, tempWeight, tempUsed, order, unmergedWeight, mergeCount % 2 == 1, compression);\n        mergeCount++;\n        tempUsed = 0;\n        unmergedWeight = 0;\n    }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/tdigest/TDigest.java",
    "search": "    public long estimatedInMemorySizeInBytes()\n    {\n        return INSTANCE_SIZE + sizeOf(weight) + sizeOf(mean) + sizeOf(tempWeight) + sizeOf(tempMean) + sizeOf(order);\n    }",
    "replace": "    public long estimatedInMemorySizeInBytes()\n    {\n        if (rawWeight != null) {\n            return INSTANCE_SIZE + sizeOf(rawMean) + sizeOf(rawWeight);\n        }\n        return INSTANCE_SIZE + sizeOf(weight) + sizeOf(mean) + sizeOf(tempWeight) + sizeOf(tempMean) + sizeOf(order);\n    }"
  }
]
```