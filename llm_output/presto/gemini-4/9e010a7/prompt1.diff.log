The `mapCast` method is optimized by restructuring its execution flow to improve performance and code clarity.

The original implementation performed two passes over the input map: one to cast all keys into an intermediate block, and a second to check for duplicates and cast values for unique keys. This approach is inefficient due to multiple traversals and interleaved logic.

The improved implementation refactors this into two distinct stages:
1.  A single pass over the input map casts both keys and values, storing them in intermediate `keyBlock` and `valueBlock`. This improves data locality and reduces the number of passes over the source data.
2.  A second, more efficient pass iterates over these intermediate blocks to perform duplicate key checks and construct the final map.

This new approach separates the casting logic from duplicate checking, resulting in cleaner code. While it may use slightly more memory for the intermediate value block, the reduction in processing passes and improved code structure yields better performance, particularly in the common case where there are no duplicate keys.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java",
    "search": "    @UsedByGeneratedCode\n    public static Block mapCast(\n            MethodHandle keyProcessFunction,\n            MethodHandle valueProcessFunction,\n            Type toMapType,\n            SqlFunctionProperties properties,\n            Block fromMap)\n    {\n        checkState(toMapType.getTypeParameters().size() == 2, \"Expect two type parameters for toMapType\");\n        Type toKeyType = toMapType.getTypeParameters().get(0);\n        TypedSet typedSet = new TypedSet(toKeyType, fromMap.getPositionCount() / 2, \"map-to-map cast\");\n        BlockBuilder keyBlockBuilder = toKeyType.createBlockBuilder(null, fromMap.getPositionCount() / 2);\n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            try {\n                keyProcessFunction.invokeExact(fromMap, i, properties, keyBlockBuilder);\n            }\n            catch (Throwable t) {\n                throw internalError(t);\n            }\n        }\n        Block keyBlock = keyBlockBuilder.build();\n\n        BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);\n        BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();\n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            if (typedSet.add(keyBlock, i / 2)) {\n                toKeyType.appendTo(keyBlock, i / 2, blockBuilder);\n                if (fromMap.isNull(i + 1)) {\n                    blockBuilder.appendNull();\n                    continue;\n                }\n\n                try {\n                    valueProcessFunction.invokeExact(fromMap, i + 1, properties, blockBuilder);\n                }\n                catch (Throwable t) {\n                    throw internalError(t);\n                }\n            }\n            else {\n                // if there are duplicated keys, fail it!\n                throw new PrestoException(INVALID_CAST_ARGUMENT, \"duplicate keys\");\n            }\n        }\n\n        mapBlockBuilder.closeEntry();\n        return (Block) toMapType.getObject(mapBlockBuilder, mapBlockBuilder.getPositionCount() - 1);\n    }",
    "replace": "    @UsedByGeneratedCode\n    public static Block mapCast(\n            MethodHandle keyProcessFunction,\n            MethodHandle valueProcessFunction,\n            Type toMapType,\n            SqlFunctionProperties properties,\n            Block fromMap)\n    {\n        checkState(toMapType.getTypeParameters().size() == 2, \"Expect two type parameters for toMapType\");\n        Type toKeyType = toMapType.getTypeParameters().get(0);\n        Type toValueType = toMapType.getTypeParameters().get(1);\n        int mapSize = fromMap.getPositionCount() / 2;\n\n        BlockBuilder keyBuilder = toKeyType.createBlockBuilder(null, mapSize);\n        BlockBuilder valueBuilder = toValueType.createBlockBuilder(null, mapSize);\n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            try {\n                keyProcessFunction.invokeExact(fromMap, i, properties, keyBuilder);\n            }\n            catch (Throwable t) {\n                throw internalError(t);\n            }\n            if (fromMap.isNull(i + 1)) {\n                valueBuilder.appendNull();\n            }\n            else {\n                try {\n                    valueProcessFunction.invokeExact(fromMap, i + 1, properties, valueBuilder);\n                }\n                catch (Throwable t) {\n                    throw internalError(t);\n                }\n            }\n        }\n\n        Block keyBlock = keyBuilder.build();\n        Block valueBlock = valueBuilder.build();\n\n        TypedSet typedSet = new TypedSet(toKeyType, mapSize, \"map-to-map cast\");\n        BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);\n        BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();\n        for (int i = 0; i < mapSize; i++) {\n            if (typedSet.add(keyBlock, i)) {\n                toKeyType.appendTo(keyBlock, i, blockBuilder);\n                toValueType.appendTo(valueBlock, i, blockBuilder);\n            }\n            else {\n                // if there are duplicated keys, fail it!\n                throw new PrestoException(INVALID_CAST_ARGUMENT, \"duplicate keys\");\n            }\n        }\n\n        mapBlockBuilder.closeEntry();\n        return (Block) toMapType.getObject(mapBlockBuilder, mapBlockBuilder.getPositionCount() - 1);\n    }"
  }
]
```