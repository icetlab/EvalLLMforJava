The provided Java code in `SingleMapBlock.java` contains a significant amount of duplicated code across the `seekKey` and `seekKeyExact` methods. These methods implement hash table lookups and share the same probing logic, differing only in the method used for hashing and equality checks (`invoke` vs. `invokeExact`) and the type of the key.

My improvement focuses on refactoring these methods to eliminate code duplication. I will:
1.  Introduce a private helper method, `seekKey(long hashCode, KeyEquals keyEquals)`, that encapsulates the common hash table probing logic.
2.  Define a private functional interface, `KeyEquals`, to pass the key equality check as a lambda to the helper method.
3.  Modify all `seekKey` and `seekKeyExact` methods to delegate the probing logic to this new helper method, each providing a specific lambda for its equality check.

This change significantly improves code readability and maintainability by centralizing the complex probing logic. While this is primarily a code quality improvement, it can have performance benefits by making the code easier for the JIT compiler to analyze and optimize. It also makes future modifications or performance tuning of the hash lookup logic much simpler.

```json
[
  {
    "filepath": "../presto/presto-common/src/main/java/com/facebook/presto/common/block/SingleMapBlock.java",
    "search": "    /**\n     * @return position of the value under {@code nativeValue} key. -1 when key is not found.\n     */\n    public int seekKey(Object nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        mapBlock.ensureHashTableLoaded();\n        int[] hashTable = mapBlock.getHashTables().get();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invoke(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        int hashTableOffset = offset / 2 * HASH_MULTIPLIER;\n        int hashTableSize = positionCount / 2 * HASH_MULTIPLIER;\n        int position = computePosition(hashCode, hashTableSize);\n        while (true) {\n            int keyPosition = hashTable[hashTableOffset + position];\n            if (keyPosition == -1) {\n                return -1;\n            }\n            Boolean match;\n            try {\n                // assuming maps with indeterminate keys are not supported\n                match = (Boolean) mapBlock.keyBlockNativeEquals.invoke(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue);\n            }\n            catch (Throwable throwable) {\n                throw handleThrowable(throwable);\n            }\n            checkNotIndeterminate(match);\n            if (match) {\n                return keyPosition * 2 + 1;\n            }\n            position++;\n            if (position == hashTableSize) {\n                position = 0;\n            }\n        }\n    }\n\n    // The next 5 seekKeyExact functions are the same as seekKey\n    // except MethodHandle.invoke is replaced with invokeExact.\n\n    public int seekKeyExact(long nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        mapBlock.ensureHashTableLoaded();\n        int[] hashTable = mapBlock.getHashTables().get();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        int hashTableOffset = offset / 2 * HASH_MULTIPLIER;\n        int hashTableSize = positionCount / 2 * HASH_MULTIPLIER;\n        int position = computePosition(hashCode, hashTableSize);\n        while (true) {\n            int keyPosition = hashTable[hashTableOffset + position];\n            if (keyPosition == -1) {\n                return -1;\n            }\n            Boolean match;\n            try {\n                // assuming maps with indeterminate keys are not supported\n                match = (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue);\n            }\n            catch (Throwable throwable) {\n                throw handleThrowable(throwable);\n            }\n            checkNotIndeterminate(match);\n            if (match) {\n                return keyPosition * 2 + 1;\n            }\n            position++;\n            if (position == hashTableSize) {\n                position = 0;\n            }\n        }\n    }\n\n    public int seekKeyExact(boolean nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        mapBlock.ensureHashTableLoaded();\n        int[] hashTable = mapBlock.getHashTables().get();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        int hashTableOffset = offset / 2 * HASH_MULTIPLIER;\n        int hashTableSize = positionCount / 2 * HASH_MULTIPLIER;\n        int position = computePosition(hashCode, hashTableSize);\n        while (true) {\n            int keyPosition = hashTable[hashTableOffset + position];\n            if (keyPosition == -1) {\n                return -1;\n            }\n            Boolean match;\n            try {\n                // assuming maps with indeterminate keys are not supported\n                match = (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue);\n            }\n            catch (Throwable throwable) {\n                throw handleThrowable(throwable);\n            }\n            checkNotIndeterminate(match);\n            if (match) {\n                return keyPosition * 2 + 1;\n            }\n            position++;\n            if (position == hashTableSize) {\n                position = 0;\n            }\n        }\n    }\n\n    public int seekKeyExact(double nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        mapBlock.ensureHashTableLoaded();\n        int[] hashTable = mapBlock.getHashTables().get();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        int hashTableOffset = offset / 2 * HASH_MULTIPLIER;\n        int hashTableSize = positionCount / 2 * HASH_MULTIPLIER;\n        int position = computePosition(hashCode, hashTableSize);\n        while (true) {\n            int keyPosition = hashTable[hashTableOffset + position];\n            if (keyPosition == -1) {\n                return -1;\n            }\n            Boolean match;\n            try {\n                // assuming maps with indeterminate keys are not supported\n                match = (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue);\n            }\n            catch (Throwable throwable) {\n                throw handleThrowable(throwable);\n            }\n            checkNotIndeterminate(match);\n            if (match) {\n                return keyPosition * 2 + 1;\n            }\n            position++;\n            if (position == hashTableSize) {\n                position = 0;\n            }\n        }\n    }\n\n    public int seekKeyExact(Slice nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        mapBlock.ensureHashTableLoaded();\n        int[] hashTable = mapBlock.getHashTables().get();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        int hashTableOffset = offset / 2 * HASH_MULTIPLIER;\n        int hashTableSize = positionCount / 2 * HASH_MULTIPLIER;\n        int position = computePosition(hashCode, hashTableSize);\n        while (true) {\n            int keyPosition = hashTable[hashTableOffset + position];\n            if (keyPosition == -1) {\n                return -1;\n            }\n            Boolean match;\n            try {\n                // assuming maps with indeterminate keys are not supported\n                match = (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue);\n            }\n            catch (Throwable throwable) {\n                throw handleThrowable(throwable);\n            }\n            checkNotIndeterminate(match);\n            if (match) {\n                return keyPosition * 2 + 1;\n            }\n            position++;\n            if (position == hashTableSize) {\n                position = 0;\n            }\n        }\n    }\n\n    public int seekKeyExact(Block nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        mapBlock.ensureHashTableLoaded();\n        int[] hashTable = mapBlock.getHashTables().get();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        int hashTableOffset = offset / 2 * HASH_MULTIPLIER;\n        int hashTableSize = positionCount / 2 * HASH_MULTIPLIER;\n        int position = computePosition(hashCode, hashTableSize);\n        while (true) {\n            int keyPosition = hashTable[hashTableOffset + position];\n            if (keyPosition == -1) {\n                return -1;\n            }\n            Boolean match;\n            try {\n                // assuming maps with indeterminate keys are not supported\n                match = (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue);\n            }\n            catch (Throwable throwable) {\n                throw handleThrowable(throwable);\n            }\n            checkNotIndeterminate(match);\n            if (match) {\n                return keyPosition * 2 + 1;\n            }\n            position++;\n            if (position == hashTableSize) {\n                position = 0;\n            }\n        }\n    }",
    "replace": "    /**\n     * @return position of the value under {@code nativeValue} key. -1 when key is not found.\n     */\n    public int seekKey(Object nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invoke(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        return seekKey(hashCode, keyPosition -> (Boolean) mapBlock.keyBlockNativeEquals.invoke(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue));\n    }\n\n    // The next 5 seekKeyExact functions are the same as seekKey\n    // except MethodHandle.invoke is replaced with invokeExact.\n\n    public int seekKeyExact(long nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        return seekKey(hashCode, keyPosition -> (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue));\n    }\n\n    public int seekKeyExact(boolean nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        return seekKey(hashCode, keyPosition -> (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue));\n    }\n\n    public int seekKeyExact(double nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        return seekKey(hashCode, keyPosition -> (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue));\n    }\n\n    public int seekKeyExact(Slice nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        return seekKey(hashCode, keyPosition -> (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue));\n    }\n\n    public int seekKeyExact(Block nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invokeExact(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        return seekKey(hashCode, keyPosition -> (Boolean) mapBlock.keyBlockNativeEquals.invokeExact(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue));\n    }\n\n    @FunctionalInterface\n    private interface KeyEquals\n    {\n        Boolean equals(int keyPosition) throws Throwable;\n    }\n\n    private int seekKey(long hashCode, KeyEquals keyEquals)\n    {\n        mapBlock.ensureHashTableLoaded();\n        int[] hashTable = mapBlock.getHashTables().get();\n\n        int hashTableOffset = offset / 2 * HASH_MULTIPLIER;\n        int hashTableSize = positionCount / 2 * HASH_MULTIPLIER;\n        int position = computePosition(hashCode, hashTableSize);\n        while (true) {\n            int keyPosition = hashTable[hashTableOffset + position];\n            if (keyPosition == -1) {\n                return -1;\n            }\n            Boolean match;\n            try {\n                match = keyEquals.equals(keyPosition);\n            }\n            catch (Throwable throwable) {\n                throw handleThrowable(throwable);\n            }\n            checkNotIndeterminate(match);\n            if (match) {\n                return keyPosition * 2 + 1;\n            }\n            position++;\n            if (position == hashTableSize) {\n                position = 0;\n            }\n        }\n    }"
  }
]
```