My proposed improvement aims to reduce memory consumption in the `OptimizedPartitionedOutputOperator`. The primary issue is that for each incoming page, `PartitionBuffer` for every partition allocates a `positions` array sized to the total number of rows in the page. This is wasteful when a partition receives only a small fraction of the rows.

To address this, I've implemented a two-pass strategy within the `partitionPage` method. In the first pass, it iterates through the page to count the exact number of rows destined for each partition without actually storing the positions. Using these counts, it then allocates `positions` arrays of the precise required size for each `PartitionBuffer`. The second pass populates these correctly-sized arrays. This approach significantly reduces peak memory usage, especially in scenarios with a high partition count and skewed data distribution, at the cost of a second iteration over the page data.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java",
    "search": "        public void partitionPage(Page page)\n        {\n            // Populate positions to copy for each destination partition.\n            int positionCount = page.getPositionCount();\n\n            for (int i = 0; i < partitionBuffers.length; i++) {\n                partitionBuffers[i].resetPositions(positionCount);\n            }\n\n            Block nullBlock = nullChannel.isPresent() ? page.getBlock(nullChannel.getAsInt()) : null;\n            Page partitionFunctionArgs = getPartitionFunctionArguments(page);\n\n            for (int position = 0; position < positionCount; position++) {\n                boolean shouldReplicate = (replicatesAnyRow && !hasAnyRowBeenReplicated) ||\n                        nullBlock != null && nullBlock.isNull(position);\n\n                if (shouldReplicate) {\n                    for (int i = 0; i < partitionBuffers.length; i++) {\n                        partitionBuffers[i].addPosition(position);\n                    }\n                    hasAnyRowBeenReplicated = true;\n                }\n                else {\n                    int partition = partitionFunction.getPartition(partitionFunctionArgs, position);\n                    partitionBuffers[partition].addPosition(position);\n                }\n            }",
    "replace": "        public void partitionPage(Page page)\n        {\n            // Populate positions to copy for each destination partition.\n            int positionCount = page.getPositionCount();\n            Block nullBlock = nullChannel.isPresent() ? page.getBlock(nullChannel.getAsInt()) : null;\n            Page partitionFunctionArgs = getPartitionFunctionArguments(page);\n\n            // 1. Count the number of rows for each partition\n            int[] partitionRowCount = new int[partitionBuffers.length];\n            boolean hasReplicated = hasAnyRowBeenReplicated;\n            for (int position = 0; position < positionCount; position++) {\n                boolean shouldReplicate = (replicatesAnyRow && !hasReplicated) ||\n                        (nullBlock != null && nullBlock.isNull(position));\n\n                if (shouldReplicate) {\n                    for (int i = 0; i < partitionBuffers.length; i++) {\n                        partitionRowCount[i]++;\n                    }\n                    hasReplicated = true;\n                }\n                else {\n                    int partition = partitionFunction.getPartition(partitionFunctionArgs, position);\n                    partitionRowCount[partition]++;\n                }\n            }\n\n            // 2. Allocate positions array for each partition\n            for (int i = 0; i < partitionBuffers.length; i++) {\n                partitionBuffers[i].resetPositions(partitionRowCount[i]);\n            }\n\n            // 3. Populate positions array for each partition\n            for (int position = 0; position < positionCount; position++) {\n                boolean shouldReplicate = (replicatesAnyRow && !hasAnyRowBeenReplicated) ||\n                        (nullBlock != null && nullBlock.isNull(position));\n\n                if (shouldReplicate) {\n                    for (int i = 0; i < partitionBuffers.length; i++) {\n                        partitionBuffers[i].addPosition(position);\n                    }\n                    hasAnyRowBeenReplicated = true;\n                }\n                else {\n                    int partition = partitionFunction.getPartition(partitionFunctionArgs, position);\n                    partitionBuffers[partition].addPosition(position);\n                }\n            }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java",
    "search": "        private void resetPositions(int positionCount)\n        {\n            positions = ensureCapacity(positions, positionCount);\n            this.positionCount = 0;\n        }",
    "replace": "        private void resetPositions(int maxPositionCount)\n        {\n            positions = ensureCapacity(positions, maxPositionCount);\n            this.positionCount = 0;\n        }"
  }
]
```