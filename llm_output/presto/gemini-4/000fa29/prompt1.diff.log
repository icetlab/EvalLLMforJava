My overall improvement strategy focuses on reducing unnecessary work within the `PagePartitioner.partitionPage` method, which is on the hot path for data processing in the `OptimizedPartitionedOutputOperator`.

I've identified two key optimizations that I will apply in a single, atomic change:
1.  **Lazy Initialization of `partitionFunctionArgs`**: The `Page` object required by the `partitionFunction` is currently created for every input page, even if it's not used. This can happen if all rows in a page are replicated and don't require partitioning. By deferring the creation of `partitionFunctionArgs` until it's actually needed (i.e., when a non-replicated row is encountered), we can avoid unnecessary object allocations and setup costs.

2.  **Conditional Block Decoding**: The operator decodes all blocks in a page into a `DecodedBlockNode` structure, which is a potentially expensive operation. This decoding is performed for every page. However, it's possible that after the partitioning logic, no rows are destined for any of the partitions managed by the current operator instance. My change introduces a check to see if any partition has received rows *before* performing the decoding step. If no rows need to be appended, we can skip the costly decoding process entirely for that page by returning early.

These changes target different scenarios where work can be avoided, leading to better performance by reducing object allocations and CPU cycles on data that doesn't need to be processed.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java",
    "search": "            Block nullBlock = nullChannel.isPresent() ? page.getBlock(nullChannel.getAsInt()) : null;\n            Page partitionFunctionArgs = getPartitionFunctionArguments(page);\n\n            for (int position = 0; position < positionCount; position++) {\n                boolean shouldReplicate = (replicatesAnyRow && !hasAnyRowBeenReplicated) ||\n                        nullBlock != null && nullBlock.isNull(position);\n\n                if (shouldReplicate) {\n                    for (int i = 0; i < partitionBuffers.length; i++) {\n                        partitionBuffers[i].addPosition(position);\n                    }\n                    hasAnyRowBeenReplicated = true;\n                }\n                else {\n                    int partition = partitionFunction.getPartition(partitionFunctionArgs, position);\n                    partitionBuffers[partition].addPosition(position);\n                }\n            }\n\n            // Decode the page just once. The decoded blocks will be fed to each PartitionBuffer object to set up AbstractBlockEncodingBuffer.\n            for (int i = 0; i < decodedBlocks.length; i++) {\n                decodedBlocks[i] = decodeBlock(flattener, blockLeaseCloser, page.getBlock(i));\n            }\n\n            // Copy the data to their destination partitions and flush when the buffer is full.\n            for (int i = 0; i < partitionBuffers.length; i++) {\n                partitionBuffers[i].appendData(decodedBlocks, fixedWidthRowSize, variableWidthChannels, outputBuffer);\n            }",
    "replace": "            Block nullBlock = nullChannel.isPresent() ? page.getBlock(nullChannel.getAsInt()) : null;\n            Page partitionFunctionArgs = null;\n\n            for (int position = 0; position < positionCount; position++) {\n                boolean shouldReplicate = (replicatesAnyRow && !hasAnyRowBeenReplicated) ||\n                        (nullBlock != null && nullBlock.isNull(position));\n\n                if (shouldReplicate) {\n                    for (int i = 0; i < partitionBuffers.length; i++) {\n                        partitionBuffers[i].addPosition(position);\n                    }\n                    hasAnyRowBeenReplicated = true;\n                }\n                else {\n                    if (partitionFunctionArgs == null) {\n                        partitionFunctionArgs = getPartitionFunctionArguments(page);\n                    }\n                    int partition = partitionFunction.getPartition(partitionFunctionArgs, position);\n                    partitionBuffers[partition].addPosition(position);\n                }\n            }\n\n            boolean hasRowsToPartition = false;\n            for (PartitionBuffer partitionBuffer : partitionBuffers) {\n                if (partitionBuffer.positionCount > 0) {\n                    hasRowsToPartition = true;\n                    break;\n                }\n            }\n\n            if (!hasRowsToPartition) {\n                return;\n            }\n\n            // Decode the page just once. The decoded blocks will be fed to each PartitionBuffer object to set up AbstractBlockEncodingBuffer.\n            for (int i = 0; i < decodedBlocks.length; i++) {\n                decodedBlocks[i] = decodeBlock(flattener, blockLeaseCloser, page.getBlock(i));\n            }\n\n            // Copy the data to their destination partitions and flush when the buffer is full.\n            for (int i = 0; i < partitionBuffers.length; i++) {\n                partitionBuffers[i].appendData(decodedBlocks, fixedWidthRowSize, variableWidthChannels, outputBuffer);\n            }"
  }
]
```