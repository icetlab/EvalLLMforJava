The current implementation of `array_distinct` always creates a new array, even if the input array contains no duplicates. This leads to unnecessary object allocation and data copying. Furthermore, the result `BlockBuilder` is allocated with the size of the original array, which can be an overestimation and waste memory if the input array has many duplicate elements.

My improvement addresses these issues with the following strategy:
1.  A fast path is introduced for arrays that are already distinct. It first iterates through the array to find unique element positions. If no duplicates are found, it returns the original array block, avoiding expensive block creation and data copying.
2.  For arrays with duplicates, a `BlockBuilder` is created with the exact size required for the distinct elements, which is more memory-efficient than allocating for the original array's size.
3.  A quick check for arrays with fewer than two elements is added, as they are inherently distinct and can be returned immediately.

This approach improves overall performance and memory usage, especially for cases where arrays are often already distinct or contain a high number of duplicates.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/scalar/ArrayDistinctFunction.java",
    "search": "    public static Block distinct(Type type, Block array)\n    {\n        if (array.getPositionCount() == 0) {\n            return array;\n        }\n\n        TypedSet typedSet = new TypedSet(type, array.getPositionCount());\n        BlockBuilder distinctElementBlockBuilder = type.createBlockBuilder(new BlockBuilderStatus(), array.getPositionCount());\n        for (int i = 0; i < array.getPositionCount(); i++) {\n            if (!typedSet.contains(array, i)) {\n                typedSet.add(array, i);\n                type.appendTo(array, i, distinctElementBlockBuilder);\n            }\n        }\n\n        return distinctElementBlockBuilder.build();\n    }",
    "replace": "    public static Block distinct(Type type, Block array)\n    {\n        int positionCount = array.getPositionCount();\n        if (positionCount < 2) {\n            return array;\n        }\n\n        int[] distinctPositions = new int[positionCount];\n        int distinctCount = 0;\n\n        TypedSet typedSet = new TypedSet(type, positionCount);\n        for (int i = 0; i < positionCount; i++) {\n            if (!typedSet.contains(array, i)) {\n                typedSet.add(array, i);\n                distinctPositions[distinctCount++] = i;\n            }\n        }\n\n        if (distinctCount == positionCount) {\n            return array;\n        }\n\n        BlockBuilder distinctElementBlockBuilder = type.createBlockBuilder(new BlockBuilderStatus(), distinctCount);\n        for (int i = 0; i < distinctCount; i++) {\n            type.appendTo(array, distinctPositions[i], distinctElementBlockBuilder);\n        }\n\n        return distinctElementBlockBuilder.build();\n    }"
  }
]
```