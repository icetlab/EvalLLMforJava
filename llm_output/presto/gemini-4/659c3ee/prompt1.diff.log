My overall improvement strategy focuses on two areas:

1.  **Fixing redundant work in `ByteSelectiveStreamReader`**: The current implementation for reading data from streams has a logic issue with `readOffset`, causing it to repeatedly skip over the same data in subsequent reads. This is a significant performance bottleneck, especially for sparse reads. I will correct the stream position tracking to ensure data is read and skipped only once. This also involves improving a fast-path for reading contiguous data blocks.

2.  **Optimizing data unpacking in `ReaderUtils`**: The `unpack*Nulls` methods in `ReaderUtils` process data one element at a time. I will optimize these methods to use `System.arraycopy` to process contiguous blocks of non-null values at once. This reduces loop overhead and leverages optimized native code for memory copying, which is significantly faster for larger contiguous data segments.

These changes will improve query performance by reducing unnecessary I/O operations and CPU cycles.

```json
[
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java",
    "search": "        if (readOffset < offset) {\n            skip(offset - readOffset);\n        }\n\n        int streamPosition = 0;\n        if (dataStream == null && presentStream != null) {\n            streamPosition = readAllNulls(positions, positionCount);\n        }\n        else if (filter == null) {\n            streamPosition = readNoFilter(positions, positionCount);\n        }\n        else {\n            streamPosition = readWithFilter(positions, positionCount);\n        }\n\n        readOffset = offset + streamPosition;",
    "replace": "        int newReadOffset;\n        if (dataStream == null && presentStream != null) {\n            newReadOffset = readAllNulls(positions, positionCount);\n        }\n        else if (filter == null) {\n            newReadOffset = readNoFilter(positions, positionCount);\n        }\n        else {\n            newReadOffset = readWithFilter(positions, positionCount);\n        }\n\n        readOffset = newReadOffset;"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java",
    "search": "    private int readWithFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        int streamPosition = 0;",
    "replace": "    private int readWithFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        int streamPosition = readOffset;"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java",
    "search": "    private int readAllNulls(int[] positions, int positionCount)\n            throws IOException\n    {\n        presentStream.skip(positions[positionCount - 1]);",
    "replace": "    private int readAllNulls(int[] positions, int positionCount)\n            throws IOException\n    {\n        presentStream.skip(positions[positionCount - 1] - readOffset + 1);"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java",
    "search": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        if (presentStream == null && positions[positionCount - 1] == positionCount - 1) {\n            // contiguous chunk of rows, no nulls\n            dataStream.next(values, positionCount);\n            outputPositionCount = positionCount;\n            return positionCount;\n        }\n\n        int streamPosition = 0;",
    "replace": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        if (presentStream == null && positions[positionCount - 1] - positions[0] == positionCount - 1) {\n            // contiguous chunk of rows, no nulls\n            int toSkip = positions[0] - readOffset;\n            if (toSkip > 0) {\n                dataStream.skip(toSkip);\n            }\n            dataStream.next(values, positionCount);\n            outputPositionCount = positionCount;\n            return positions[positionCount - 1] + 1;\n        }\n\n        int streamPosition = readOffset;"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ReaderUtils.java",
    "search": "    public static byte[] unpackByteNulls(byte[] values, boolean[] isNull)\n    {\n        byte[] result = new byte[isNull.length];\n\n        int position = 0;\n        for (int i = 0; i < isNull.length; i++) {\n            if (!isNull[i]) {\n                result[i] = values[position];\n                position++;\n            }\n        }\n        return result;\n    }",
    "replace": "    public static byte[] unpackByteNulls(byte[] values, boolean[] isNull)\n    {\n        byte[] result = new byte[isNull.length];\n        int valuePosition = 0;\n        for (int i = 0; i < isNull.length; i++) {\n            if (isNull[i]) {\n                continue;\n            }\n\n            int nonNullsStart = i;\n            while (i < isNull.length && !isNull[i]) {\n                i++;\n            }\n            int count = i - nonNullsStart;\n            System.arraycopy(values, valuePosition, result, nonNullsStart, count);\n            valuePosition += count;\n            i--;\n        }\n        return result;\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ReaderUtils.java",
    "search": "    public static short[] unpackShortNulls(short[] values, boolean[] isNull)\n    {\n        short[] result = new short[isNull.length];\n\n        int position = 0;\n        for (int i = 0; i < isNull.length; i++) {\n            if (!isNull[i]) {\n                result[i] = values[position];\n                position++;\n            }\n        }\n        return result;\n    }",
    "replace": "    public static short[] unpackShortNulls(short[] values, boolean[] isNull)\n    {\n        short[] result = new short[isNull.length];\n        int valuePosition = 0;\n        for (int i = 0; i < isNull.length; i++) {\n            if (isNull[i]) {\n                continue;\n            }\n\n            int nonNullsStart = i;\n            while (i < isNull.length && !isNull[i]) {\n                i++;\n            }\n            int count = i - nonNullsStart;\n            System.arraycopy(values, valuePosition, result, nonNullsStart, count);\n            valuePosition += count;\n            i--;\n        }\n        return result;\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ReaderUtils.java",
    "search": "    public static int[] unpackIntNulls(int[] values, boolean[] isNull)\n    {\n        int[] result = new int[isNull.length];\n\n        int position = 0;\n        for (int i = 0; i < isNull.length; i++) {\n            if (!isNull[i]) {\n                result[i] = values[position];\n                position++;\n            }\n        }\n        return result;\n    }",
    "replace": "    public static int[] unpackIntNulls(int[] values, boolean[] isNull)\n    {\n        int[] result = new int[isNull.length];\n        int valuePosition = 0;\n        for (int i = 0; i < isNull.length; i++) {\n            if (isNull[i]) {\n                continue;\n            }\n\n            int nonNullsStart = i;\n            while (i < isNull.length && !isNull[i]) {\n                i++;\n            }\n            int count = i - nonNullsStart;\n            System.arraycopy(values, valuePosition, result, nonNullsStart, count);\n            valuePosition += count;\n            i--;\n        }\n        return result;\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ReaderUtils.java",
    "search": "    public static long[] unpackLongNulls(long[] values, boolean[] isNull)\n    {\n        long[] result = new long[isNull.length];\n\n        int position = 0;\n        for (int i = 0; i < isNull.length; i++) {\n            if (!isNull[i]) {\n                result[i] = values[position];\n                position++;\n            }\n        }\n        return result;\n    }",
    "replace": "    public static long[] unpackLongNulls(long[] values, boolean[] isNull)\n    {\n        long[] result = new long[isNull.length];\n        int valuePosition = 0;\n        for (int i = 0; i < isNull.length; i++) {\n            if (isNull[i]) {\n                continue;\n            }\n\n            int nonNullsStart = i;\n            while (i < isNull.length && !isNull[i]) {\n                i++;\n            }\n            int count = i - nonNullsStart;\n            System.arraycopy(values, valuePosition, result, nonNullsStart, count);\n            valuePosition += count;\n            i--;\n        }\n        return result;\n    }"
  }
]
```