My improvement focuses on optimizing the `prepareForNextRead` method in `SliceDirectSelectiveStreamReader`. The original implementation first reads all value lengths into a `lengthVector` and then iterates over this vector to calculate the total and maximum length. I've fused these two operations into a single loop. This new loop iterates once, reading each length from the stream, storing it in the `lengthVector`, and simultaneously updating the total and maximum length. This change enhances data locality and reduces the overhead of an extra loop, leading to better performance, especially when processing a large number of values.

```json
[
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/SliceDirectSelectiveStreamReader.java",
    "search": "            lengthVector = ensureCapacity(lengthVector, nonNullCount);\n            lengthStream.nextIntVector(nonNullCount, lengthVector, 0);\n\n            if (useBatchMode(positionCount, totalPositions)) {\n                for (int i = 0; i < nonNullCount; i++) {\n                    totalLength += lengthVector[i];\n                    maxLength = Math.max(maxLength, lengthVector[i]);\n                }\n            }\n            else {\n                int positionIndex = 0;\n                int lengthIndex = 0;\n                for (int i = 0; i < totalPositions; i++) {\n                    boolean isNotNull = nullCount == 0 || !isNullVector[i];\n                    if (i == positions[positionIndex]) {\n                        if (isNotNull) {\n                            totalLength += lengthVector[lengthIndex];\n                            maxLength = Math.max(maxLength, lengthVector[lengthIndex]);\n                            lengthIndex++;\n                        }\n                        positionIndex++;\n                    }\n                    else if (isNotNull) {\n                        lengthIndex++;\n                    }\n                }\n            }",
    "replace": "            lengthVector = ensureCapacity(lengthVector, nonNullCount);\n\n            if (useBatchMode(positionCount, totalPositions)) {\n                for (int i = 0; i < nonNullCount; i++) {\n                    int length = (int) lengthStream.next();\n                    lengthVector[i] = length;\n                    totalLength += length;\n                    maxLength = Math.max(maxLength, length);\n                }\n            }\n            else {\n                lengthStream.nextIntVector(nonNullCount, lengthVector, 0);\n                int positionIndex = 0;\n                int lengthIndex = 0;\n                for (int i = 0; i < totalPositions; i++) {\n                    boolean isNotNull = nullCount == 0 || !isNullVector[i];\n                    if (i == positions[positionIndex]) {\n                        if (isNotNull) {\n                            totalLength += lengthVector[lengthIndex];\n                            maxLength = Math.max(maxLength, lengthVector[lengthIndex]);\n                            lengthIndex++;\n                        }\n                        positionIndex++;\n                    }\n                    else if (isNotNull) {\n                        lengthIndex++;\n                    }\n                }\n            }"
  }
]
```