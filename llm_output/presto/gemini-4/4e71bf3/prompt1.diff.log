The overall improvement strategy is to introduce and leverage vectorized reading to reduce per-byte processing overhead. This is achieved by adding a bulk-reading method to `ByteInputStream` and utilizing it in `ByteSelectiveStreamReader` for cases where data can be read in contiguous chunks. Additionally, an existing vector-based method in `ByteInputStream` is optimized to process data in larger batches from its internal buffer.

Specifically:
1.  A new method `next(byte[] data, int offset, int length)` is added to `ByteInputStream` for efficient bulk data retrieval.
2.  `ByteSelectiveStreamReader.readNoFilter` is refactored to use this new bulk-read method. When no `present` stream exists (i.e., no null values), it identifies contiguous sequences of positions and reads them in a single vectorized call. This significantly reduces method call overhead compared to reading byte-by-byte. The refactoring also hoists the null-stream check out of the loop, which is a performance gain in itself.
3.  The `ByteInputStream.nextVector` method is optimized to process data in chunks from its internal buffer, minimizing redundant state checks within its loop and improving its throughput.

```json
[
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java",
    "search": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        int streamPosition = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = dataStream.next();\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }",
    "replace": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        int streamPosition = 0;\n        if (presentStream != null) {\n            for (int i = 0; i < positionCount; i++) {\n                int position = positions[i];\n                if (position > streamPosition) {\n                    skip(position - streamPosition);\n                    streamPosition = position;\n                }\n\n                if (!presentStream.nextBit()) {\n                    nulls[i] = true;\n                }\n                else {\n                    values[i] = dataStream.next();\n                    nulls[i] = false;\n                }\n                streamPosition++;\n            }\n        }\n        else {\n            // All values are present\n            int i = 0;\n            while (i < positionCount) {\n                int position = positions[i];\n                if (position > streamPosition) {\n                    skip(position - streamPosition);\n                    streamPosition = position;\n                }\n\n                // find a batch of contiguous positions\n                int runEnd = i;\n                while (runEnd + 1 < positionCount && positions[runEnd + 1] == positions[runEnd] + 1) {\n                    runEnd++;\n                }\n                int runLength = runEnd - i + 1;\n\n                dataStream.next(values, i, runLength);\n                streamPosition += runLength;\n                i += runLength;\n            }\n        }\n\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/stream/ByteInputStream.java",
    "search": "    public byte next()\n            throws IOException\n    {\n        if (offset == length) {\n            readNextBlock();\n        }\n        return buffer[offset++];\n    }",
    "replace": "    public byte next()\n            throws IOException\n    {\n        if (offset == length) {\n            readNextBlock();\n        }\n        return buffer[offset++];\n    }\n\n    public void next(byte[] data, int offset, int length)\n            throws IOException\n    {\n        int end = offset + length;\n        while (offset < end) {\n            if (this.offset == this.length) {\n                readNextBlock();\n            }\n            int chunk = Math.min(this.length - this.offset, end - offset);\n            System.arraycopy(this.buffer, this.offset, data, offset, chunk);\n            this.offset += chunk;\n            offset += chunk;\n        }\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/stream/ByteInputStream.java",
    "search": "    public void nextVector(Type type, long items, BlockBuilder builder)\n            throws IOException\n    {\n        for (int i = 0; i < items; i++) {\n            type.writeLong(builder, next());\n        }\n    }",
    "replace": "    public void nextVector(Type type, long items, BlockBuilder builder)\n            throws IOException\n    {\n        long remaining = items;\n        while (remaining > 0) {\n            if (offset == length) {\n                readNextBlock();\n            }\n            int chunk = (int) Math.min(remaining, length - offset);\n            for (int i = 0; i < chunk; i++) {\n                type.writeLong(builder, buffer[offset + i]);\n            }\n            offset += chunk;\n            remaining -= chunk;\n        }\n    }"
  }
]
```