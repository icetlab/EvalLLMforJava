The performance issue is related to reading boolean values, which are often stored as bytes. The provided `ByteSelectiveStreamReader` is used for `TINYINT` data. The goal is to optimize reading contiguous rows when there are no nulls and no filters applied.

My overall improvement strategy is to:
1.  Introduce a bulk-read method `nextBytes` in `ByteInputStream` to efficiently read a sequence of bytes into an array. This avoids the overhead of calling `next()` for each byte individually.
2.  In `ByteSelectiveStreamReader`, I will modify the `readNoFilter` method to detect the specific scenario of reading contiguous rows with no nulls. When this case is identified, it will use the new `nextBytes` method for a much faster data retrieval, bypassing the per-row processing loop.

This approach specifically targets the hot path described in the performance issue, leading to a significant speed-up for that case, while retaining the existing logic for all other scenarios.

```json
[
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/ByteSelectiveStreamReader.java",
    "search": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        int streamPosition = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = dataStream.next();\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }",
    "replace": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        if (positionCount > 0 && presentStream == null && positions[positionCount - 1] - positions[0] == positionCount - 1) {\n            int startPosition = positions[0];\n            skip(startPosition);\n            dataStream.nextBytes(values, 0, positionCount);\n            outputPositionCount = positionCount;\n            return startPosition + positionCount;\n        }\n\n        int streamPosition = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = dataStream.next();\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }"
  },
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/stream/ByteInputStream.java",
    "search": "    public byte next()\n            throws IOException\n    {\n        if (offset == length) {\n            readNextBlock();\n        }\n        return buffer[offset++];\n    }",
    "replace": "    public byte next()\n            throws IOException\n    {\n        if (offset == length) {\n            readNextBlock();\n        }\n        return buffer[offset++];\n    }\n\n    public void nextBytes(byte[] data, int offset, int length)\n            throws IOException\n    {\n        while (length > 0) {\n            if (this.offset == this.length) {\n                readNextBlock();\n            }\n            int chunk = Math.min(length, this.length - this.offset);\n            System.arraycopy(buffer, this.offset, data, offset, chunk);\n            this.offset += chunk;\n            offset += chunk;\n            length -= chunk;\n        }\n    }"
  }
]
```