The primary performance bottleneck in `BooleanSelectiveStreamReader` is the `read` method, specifically within the loop that processes positions when a filter is applied. The original implementation uses a single loop that handles both nullable and non-nullable columns, which involves a conditional check `presentStream != null` inside the loop for every position. This check is redundant for non-nullable streams and can be hoisted out of the loop.

My improvement splits the filter-handling logic into two separate, specialized loops: one for non-nullable streams (`presentStream == null`) and one for nullable streams. By doing this, the `presentStream != null` check is eliminated from the inner loop, reducing branching and improving instruction pipeline efficiency, especially for the non-nullable case which is common. This change directly addresses the performance-sensitive area mentioned in the source code comments, leading to faster execution when reading boolean columns with filters.

```json
[
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/BooleanSelectiveStreamReader.java",
    "search": "        else {\n            // This branch is inlined because extracting this code into a helper method (readWithFilter)\n            // results in performance regressions on BenchmarkSelectiveStreamReaders.readBooleanNoNull[withFilter]\n            // benchmarks.\n            // The differences are:\n            // - readBooleanNoNull: 0.045 vs.0.029 s/op\n            // - readBooleanNoNullWithFilter: 0.112 vs 0.099 s/op\n            outputPositionCount = 0;\n            for (int i = 0; i < positionCount; i++) {\n                int position = positions[i];\n                if (position > streamPosition) {\n                    skip(position - streamPosition);\n                    streamPosition = position;\n                }\n\n                if (presentStream != null && !presentStream.nextBit()) {\n                    if ((nonDeterministicFilter && filter.testNull()) || nullsAllowed) {\n                        if (outputRequired) {\n                            nulls[outputPositionCount] = true;\n                        }\n                        outputPositions[outputPositionCount] = position;\n                        outputPositionCount++;\n                    }\n                }\n                else {\n                    boolean value = dataStream.nextBit();\n                    if (filter.testBoolean(value)) {\n                        if (outputRequired) {\n                            values[outputPositionCount] = (byte) (value ? 1 : 0);\n                            if (nullsAllowed && presentStream != null) {\n                                nulls[outputPositionCount] = false;\n                            }\n                        }\n                        outputPositions[outputPositionCount] = position;\n                        outputPositionCount++;\n                    }\n                }\n\n                outputPositionCount -= filter.getPrecedingPositionsToFail();\n\n                streamPosition++;\n\n                int succeedingPositionsToFail = filter.getSucceedingPositionsToFail();\n                if (succeedingPositionsToFail > 0) {\n                    int positionsToSkip = 0;\n                    for (int j = 0; j < succeedingPositionsToFail; j++) {\n                        i++;\n                        int nextPosition = positions[i];\n                        positionsToSkip += 1 + nextPosition - streamPosition;\n                        streamPosition = nextPosition + 1;\n                    }\n                    skip(positionsToSkip);\n                }\n            }\n        }",
    "replace": "        else {\n            // This branch is inlined because extracting this code into a helper method (readWithFilter)\n            // results in performance regressions on BenchmarkSelectiveStreamReaders.readBooleanNoNull[withFilter]\n            // benchmarks.\n            // The differences are:\n            // - readBooleanNoNull: 0.045 vs.0.029 s/op\n            // - readBooleanNoNullWithFilter: 0.112 vs 0.099 s/op\n            outputPositionCount = 0;\n            if (presentStream == null) {\n                // non-nullable stream\n                for (int i = 0; i < positionCount; i++) {\n                    int position = positions[i];\n                    if (position > streamPosition) {\n                        skip(position - streamPosition);\n                        streamPosition = position;\n                    }\n\n                    boolean value = dataStream.nextBit();\n                    if (filter.testBoolean(value)) {\n                        if (outputRequired) {\n                            values[outputPositionCount] = (byte) (value ? 1 : 0);\n                        }\n                        outputPositions[outputPositionCount] = position;\n                        outputPositionCount++;\n                    }\n\n                    outputPositionCount -= filter.getPrecedingPositionsToFail();\n\n                    streamPosition++;\n\n                    int succeedingPositionsToFail = filter.getSucceedingPositionsToFail();\n                    if (succeedingPositionsToFail > 0) {\n                        int positionsToSkip = 0;\n                        for (int j = 0; j < succeedingPositionsToFail; j++) {\n                            i++;\n                            int nextPosition = positions[i];\n                            positionsToSkip += 1 + nextPosition - streamPosition;\n                            streamPosition = nextPosition + 1;\n                        }\n                        skip(positionsToSkip);\n                    }\n                }\n            }\n            else {\n                // nullable stream\n                for (int i = 0; i < positionCount; i++) {\n                    int position = positions[i];\n                    if (position > streamPosition) {\n                        skip(position - streamPosition);\n                        streamPosition = position;\n                    }\n\n                    if (!presentStream.nextBit()) {\n                        if ((nonDeterministicFilter && filter.testNull()) || nullsAllowed) {\n                            if (outputRequired) {\n                                nulls[outputPositionCount] = true;\n                            }\n                            outputPositions[outputPositionCount] = position;\n                            outputPositionCount++;\n                        }\n                    }\n                    else {\n                        boolean value = dataStream.nextBit();\n                        if (filter.testBoolean(value)) {\n                            if (outputRequired) {\n                                values[outputPositionCount] = (byte) (value ? 1 : 0);\n                                if (nullsAllowed) {\n                                    nulls[outputPositionCount] = false;\n                                }\n                            }\n                            outputPositions[outputPositionCount] = position;\n                            outputPositionCount++;\n                        }\n                    }\n\n                    outputPositionCount -= filter.getPrecedingPositionsToFail();\n\n                    streamPosition++;\n\n                    int succeedingPositionsToFail = filter.getSucceedingPositionsToFail();\n                    if (succeedingPositionsToFail > 0) {\n                        int positionsToSkip = 0;\n                        for (int j = 0; j < succeedingPositionsToFail; j++) {\n                            i++;\n                            int nextPosition = positions[i];\n                            positionsToSkip += 1 + nextPosition - streamPosition;\n                            streamPosition = nextPosition + 1;\n                        }\n                        skip(positionsToSkip);\n                    }\n                }\n            }\n        }"
  }
]
```