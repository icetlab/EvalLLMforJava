The performance of `readNoFilter()` is suboptimal for the common case of reading a contiguous block of rows where no nulls are present. The current implementation iterates through each position, checks for gaps, and checks for nulls within the loop.

To improve this, I will introduce a fast path specifically for reading contiguous non-null data. This fast path will:
1.  Check if the positions to be read are contiguous and if there is no `presentStream` (indicating no nulls).
2.  If these conditions are met, it performs a single `skip()` operation to get to the start of the block.
3.  It then enters a simplified loop that only reads boolean values without any conditional checks for position gaps or nulls.

This change reduces branching and overhead within the read loop, leading to better performance for this specific but frequent scenario.

```json
[
  {
    "filepath": "../presto/presto-orc/src/main/java/com/facebook/presto/orc/reader/BooleanSelectiveStreamReader.java",
    "search": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        int streamPosition = 0;\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = (byte) (dataStream.nextBit() ? 1 : 0);\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }",
    "replace": "    private int readNoFilter(int[] positions, int positionCount)\n            throws IOException\n    {\n        // filter == null implies outputRequired == true\n        int streamPosition = 0;\n\n        // Fast path for contiguous positions and no nulls.\n        if (presentStream == null && positionCount > 0 && positions[positionCount - 1] - positions[0] == positionCount - 1) {\n            int startPosition = positions[0];\n            if (startPosition > streamPosition) {\n                skip(startPosition - streamPosition);\n                streamPosition = startPosition;\n            }\n\n            for (int i = 0; i < positionCount; i++) {\n                values[i] = (byte) (dataStream.nextBit() ? 1 : 0);\n            }\n\n            streamPosition += positionCount;\n            outputPositionCount = positionCount;\n            return streamPosition;\n        }\n\n        // The slow path for non-contiguous positions or when nulls are present.\n        for (int i = 0; i < positionCount; i++) {\n            int position = positions[i];\n            if (position > streamPosition) {\n                skip(position - streamPosition);\n                streamPosition = position;\n            }\n\n            if (presentStream != null && !presentStream.nextBit()) {\n                nulls[i] = true;\n            }\n            else {\n                values[i] = (byte) (dataStream.nextBit() ? 1 : 0);\n                if (presentStream != null) {\n                    nulls[i] = false;\n                }\n            }\n            streamPosition++;\n        }\n        outputPositionCount = positionCount;\n        return streamPosition;\n    }"
  }
]
```