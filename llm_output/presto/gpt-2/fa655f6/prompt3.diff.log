I have optimized the seekKey(Object) method to reduce repeated field accesses and arithmetic by caching the raw key block, MethodHandles, and precomputing the half‐offset and hash table sizes. This minimizes reflective calls and division operations in the hot path.

```json
[
  {
    "filepath": "../presto/presto-common/src/main/java/com/facebook/presto/common/block/SingleMapBlock.java",
    "search": "public int seekKey(Object nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n\n        mapBlock.ensureHashTableLoaded();\n        int[] hashTable = mapBlock.getHashTables().get();\n\n        long hashCode;\n        try {\n            hashCode = (long) mapBlock.keyNativeHashCode.invoke(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        int hashTableOffset = offset / 2 * HASH_MULTIPLIER;\n        int hashTableSize = positionCount / 2 * HASH_MULTIPLIER;\n        int position = computePosition(hashCode, hashTableSize);\n        while (true) {\n            int keyPosition = hashTable[hashTableOffset + position];\n            if (keyPosition == -1) {\n                return -1;\n            }\n            Boolean match;\n            try {\n                // assuming maps with indeterminate keys are not supported\n                match = (Boolean) mapBlock.keyBlockNativeEquals.invoke(mapBlock.getRawKeyBlock(), offset / 2 + keyPosition, nativeValue);\n            }\n            catch (Throwable throwable) {\n                throw handleThrowable(throwable);\n            }\n            checkNotIndeterminate(match);\n            if (match) {\n                return keyPosition * 2 + 1;\n            }\n            position++;\n            if (position == hashTableSize) {\n                position = 0;\n            }\n        }\n    }",
    "replace": "public int seekKey(Object nativeValue)\n    {\n        if (positionCount == 0) {\n            return -1;\n        }\n        mapBlock.ensureHashTableLoaded();\n        // Cache commonly used values\n        Block keyBlock = mapBlock.getRawKeyBlock();\n        java.lang.invoke.MethodHandle equalsHandle = mapBlock.keyBlockNativeEquals;\n        java.lang.invoke.MethodHandle hashCodeHandle = mapBlock.keyNativeHashCode;\n        int keyStart = offset >> 1;\n        int keyCount = positionCount >> 1;\n        int hashTableOffset = keyStart * HASH_MULTIPLIER;\n        int hashTableSize = keyCount * HASH_MULTIPLIER;\n        int[] hashTable = mapBlock.getHashTables().get();\n\n        long hashCode;\n        try {\n            hashCode = (long) hashCodeHandle.invoke(nativeValue);\n        }\n        catch (Throwable throwable) {\n            throw handleThrowable(throwable);\n        }\n\n        int pos = computePosition(hashCode, hashTableSize);\n        while (true) {\n            int keyPosition = hashTable[hashTableOffset + pos];\n            if (keyPosition == -1) {\n                return -1;\n            }\n            Boolean match;\n            try {\n                match = (Boolean) equalsHandle.invoke(keyBlock, keyStart + keyPosition, nativeValue);\n            }\n            catch (Throwable throwable) {\n                throw handleThrowable(throwable);\n            }\n            checkNotIndeterminate(match);\n            if (match) {\n                return keyPosition * 2 + 1;\n            }\n            pos++;\n            if (pos == hashTableSize) {\n                pos = 0;\n            }\n        }\n    }"
  }
]
```