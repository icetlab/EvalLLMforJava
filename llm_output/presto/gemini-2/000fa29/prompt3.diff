diff --git a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java
index 30e0088e35..0aeb5fcb54 100644
--- a/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java
+++ b/presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java
@@ -462,9 +462,12 @@ public class OptimizedPartitionedOutputOperator
                 decodedBlocks[i] = decodeBlock(flattener, blockLeaseCloser, page.getBlock(i));
             }
 
+            // Calculate serialized row sizes for the whole page.
+            final int[] pageSerializedRowSizes = getPageSerializedRowSizes(page.getPositionCount(), decodedBlocks);
+
             // Copy the data to their destination partitions and flush when the buffer is full.
             for (int i = 0; i < partitionBuffers.length; i++) {
-                partitionBuffers[i].appendData(decodedBlocks, fixedWidthRowSize, variableWidthChannels, outputBuffer);
+                partitionBuffers[i].appendData(decodedBlocks, fixedWidthRowSize, variableWidthChannels, outputBuffer, pageSerializedRowSizes);
             }
 
             // Return all borrowed arrays
@@ -476,6 +479,41 @@ public class OptimizedPartitionedOutputOperator
             }
         }
 
+        private int[] getPageSerializedRowSizes(int positionCount, DecodedBlockNode[] decodedBlocks)
+        {
+            if (variableWidthChannels.isEmpty()) {
+                return null;
+            }
+
+            // Lazily create BlockEncodingBuffers for row size calculation.
+            // These buffers are temporary and are only used for size calculation.
+            // They do not hold any serialized data.
+            BlockEncodingBuffer[] rowSizeCalculationBuffers = new BlockEncodingBuffer[sourceTypes.size()];
+            for (int i = 0; i < sourceTypes.size(); i++) {
+                rowSizeCalculationBuffers[i] = createBlockEncodingBuffers(decodedBlocks[i]);
+            }
+
+            int[] allPositions = new int[positionCount];
+            for (int i = 0; i < positionCount; i++) {
+                allPositions[i] = i;
+            }
+
+            for (int i = 0; i < sourceTypes.size(); i++) {
+                rowSizeCalculationBuffers[i].setupDecodedBlocksAndPositions(decodedBlocks[i], allPositions, positionCount);
+            }
+
+            int[] pageSerializedRowSizes = new int[positionCount];
+
+            for (int channel : variableWidthChannels) {
+                rowSizeCalculationBuffers[channel].accumulateSerializedRowSizes(pageSerializedRowSizes);
+            }
+
+            for (int i = 0; i < positionCount; i++) {
+                pageSerializedRowSizes[i] += fixedWidthRowSize;
+            }
+            return pageSerializedRowSizes;
+        }
+
         public void flush()
         {
             for (int i = 0; i < partitionBuffers.length; i++) {
@@ -541,7 +579,6 @@ public class OptimizedPartitionedOutputOperator
         private final int channelCount;
 
         private int[] positions;   // the default positions array for top level BlockEncodingBuffer
-        private int[] serializedRowSizes;  // The sizes of the rows in bytes if they were serialized
         private int positionCount;  // number of positions to be copied for this partition
         private BlockEncodingBuffer[] blockEncodingBuffers;
 
@@ -570,7 +607,7 @@ public class OptimizedPartitionedOutputOperator
             positions[positionCount++] = position;
         }
 
-        private void appendData(DecodedBlockNode[] decodedBlocks, int fixedWidthRowSize, List<Integer> variableWidthChannels, OutputBuffer outputBuffer)
+        private void appendData(DecodedBlockNode[] decodedBlocks, int fixedWidthRowSize, List<Integer> variableWidthChannels, OutputBuffer outputBuffer, int[] pageSerializedRowSizes)
         {
             if (decodedBlocks.length != channelCount) {
                 throw new IllegalArgumentException(format("Unexpected number of decoded blocks %d. It should be %d.", decodedBlocks.length, channelCount));
@@ -591,12 +628,10 @@ public class OptimizedPartitionedOutputOperator
                 blockEncodingBuffers[i].setupDecodedBlocksAndPositions(decodedBlocks[i], positions, positionCount);
             }
 
-            populateSerializedRowSizes(fixedWidthRowSize, variableWidthChannels);
-
             // Due to the limitation of buffer size, we append the data batch by batch
             int offset = 0;
             do {
-                int batchSize = calculateNextBatchSize(fixedWidthRowSize, variableWidthChannels, offset);
+                int batchSize = calculateNextBatchSize(fixedWidthRowSize, variableWidthChannels, offset, pageSerializedRowSizes);
 
                 for (int i = 0; i < channelCount; i++) {
                     blockEncodingBuffers[i].setNextBatch(offset, batchSize);
@@ -626,27 +661,7 @@ public class OptimizedPartitionedOutputOperator
             }
         }
 
-        /**
-         * Calculate the row sizes in bytes and write them to serializedRowSizes.
-         */
-        private void populateSerializedRowSizes(int fixedWidthRowSize, List<Integer> variableWidthChannels)
-        {
-            if (variableWidthChannels.isEmpty()) {
-                return;
-            }
-
-            serializedRowSizes = ensureCapacity(serializedRowSizes, positionCount, SMALL, INITIALIZE);
-
-            for (int i : variableWidthChannels) {
-                blockEncodingBuffers[i].accumulateSerializedRowSizes(serializedRowSizes);
-            }
-
-            for (int i = 0; i < positionCount; i++) {
-                serializedRowSizes[i] += fixedWidthRowSize;
-            }
-        }
-
-        private int calculateNextBatchSize(int fixedWidthRowSize, List<Integer> variableWidthChannels, int startPosition)
+        private int calculateNextBatchSize(int fixedWidthRowSize, List<Integer> variableWidthChannels, int startPosition, int[] pageSerializedRowSizes)
         {
             int bytesRemaining = capacity - getSerializedBuffersSizeInBytes();
 
@@ -659,9 +674,9 @@ public class OptimizedPartitionedOutputOperator
                 return positionCount - startPosition;
             }
 
-            verify(serializedRowSizes != null);
+            verify(pageSerializedRowSizes != null);
             for (int i = startPosition; i < positionCount; i++) {
-                bytesRemaining -= serializedRowSizes[i];
+                bytesRemaining -= pageSerializedRowSizes[positions[i]];
 
                 if (bytesRemaining <= 0) {
                     bufferFull = true;
@@ -696,7 +711,7 @@ public class OptimizedPartitionedOutputOperator
 
         private long getRetainedSizeInBytes()
         {
-            long size = INSTANCE_SIZE + sizeOf(positions) + sizeOf(serializedRowSizes);
+            long size = INSTANCE_SIZE + sizeOf(positions);
 
             // Some destination partitions might get 0 rows. In that case the BlockEncodingBuffer won't be created.
             if (blockEncodingBuffers != null) {
