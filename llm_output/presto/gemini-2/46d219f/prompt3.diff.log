The `map_concat` function's performance is improved by addressing memory allocation and redundant method calls.

The original implementation provided oversized capacity estimates for both the `TypedSet` (used for tracking keys) and the `BlockBuilder` (used for constructing the result map). The number of entries in a map block is half its position count, but the full position count was used for initialization, leading to a twofold over-allocation of memory.

The improved version corrects this by calculating the expected number of entries (`positionCount / 2`) and using this accurate value for initialization. Additionally, it caches the results of `leftMap.getPositionCount()` and `rightMap.getPositionCount()` in local variables to avoid repeated method calls within the loops, further streamlining the execution. These changes reduce memory pressure and make the function more efficient.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapConcatFunction.java",
    "search": "    public static Block mapConcat(\n            @TypeParameter(\"K\") Type keyType,\n            @TypeParameter(\"V\") Type valueType,\n            @SqlType(\"map(K,V)\") Block leftMap,\n            @SqlType(\"map(K,V)\") Block rightMap)\n    {\n        TypedSet typedSet = new TypedSet(keyType, rightMap.getPositionCount());\n        BlockBuilder blockBuilder = new InterleavedBlockBuilder(ImmutableList.of(keyType, valueType), new BlockBuilderStatus(), leftMap.getPositionCount() + rightMap.getPositionCount());\n        for (int i = 0; i < rightMap.getPositionCount(); i += 2) {\n            typedSet.add(rightMap, i);\n            keyType.appendTo(rightMap, i, blockBuilder);\n            valueType.appendTo(rightMap, i + 1, blockBuilder);\n        }\n        for (int i = 0; i < leftMap.getPositionCount(); i += 2) {\n            if (!typedSet.contains(leftMap, i)) {\n                keyType.appendTo(leftMap, i, blockBuilder);\n                valueType.appendTo(leftMap, i + 1, blockBuilder);\n            }\n        }\n        return blockBuilder.build();\n    }",
    "replace": "    public static Block mapConcat(\n            @TypeParameter(\"K\") Type keyType,\n            @TypeParameter(\"V\") Type valueType,\n            @SqlType(\"map(K,V)\") Block leftMap,\n            @SqlType(\"map(K,V)\") Block rightMap)\n    {\n        int rightMapPositionCount = rightMap.getPositionCount();\n        int leftMapPositionCount = leftMap.getPositionCount();\n        TypedSet typedSet = new TypedSet(keyType, rightMapPositionCount / 2);\n        BlockBuilder blockBuilder = new InterleavedBlockBuilder(ImmutableList.of(keyType, valueType), new BlockBuilderStatus(), (leftMapPositionCount + rightMapPositionCount) / 2);\n        for (int i = 0; i < rightMapPositionCount; i += 2) {\n            typedSet.add(rightMap, i);\n            keyType.appendTo(rightMap, i, blockBuilder);\n            valueType.appendTo(rightMap, i + 1, blockBuilder);\n        }\n        for (int i = 0; i < leftMapPositionCount; i += 2) {\n            if (!typedSet.contains(leftMap, i)) {\n                keyType.appendTo(leftMap, i, blockBuilder);\n                valueType.appendTo(leftMap, i + 1, blockBuilder);\n            }\n        }\n        return blockBuilder.build();\n    }"
  }
]
```