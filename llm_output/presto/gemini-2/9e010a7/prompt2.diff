diff --git a/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java b/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java
index c586b38f12..2cf50e17d8 100644
--- a/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java
+++ b/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java
@@ -63,6 +63,28 @@ public final class MapToMapCast
             SqlFunctionProperties.class,
             Block.class);
 
+    private static final MethodHandle MAP_CAST_NO_KEY_CHANGE = methodHandle(
+            MapToMapCast.class,
+            "mapCastNoKeyChange",
+            MethodHandle.class,
+            Type.class,
+            SqlFunctionProperties.class,
+            Block.class);
+
+    private static final MethodHandle MAP_CAST_NO_VALUE_CHANGE = methodHandle(
+            MapToMapCast.class,
+            "mapCastNoValueChange",
+            MethodHandle.class,
+            Type.class,
+            SqlFunctionProperties.class,
+            Block.class);
+
+    private static final MethodHandle MAP_CAST_NO_CHANGE = methodHandle(
+            MapToMapCast.class,
+            "mapCastNoChange",
+            Type.class,
+            Block.class);
+
     private static final MethodHandle CHECK_LONG_IS_NOT_NULL = methodHandle(MapToMapCast.class, "checkLongIsNotNull", Long.class);
     private static final MethodHandle CHECK_DOUBLE_IS_NOT_NULL = methodHandle(MapToMapCast.class, "checkDoubleIsNotNull", Double.class);
     private static final MethodHandle CHECK_BOOLEAN_IS_NOT_NULL = methodHandle(MapToMapCast.class, "checkBooleanIsNotNull", Boolean.class);
@@ -92,9 +114,27 @@ public final class MapToMapCast
                         TypeSignatureParameter.of(toKeyType.getTypeSignature()),
                         TypeSignatureParameter.of(toValueType.getTypeSignature())));
 
+        boolean keyCastIsNoOp = fromKeyType.equals(toKeyType);
+        boolean valueCastIsNoOp = fromValueType.equals(toValueType);
+
+        MethodHandle target;
+        if (keyCastIsNoOp && valueCastIsNoOp) {
+            target = MethodHandles.insertArguments(MAP_CAST_NO_CHANGE, 0, toMapType);
+            target = MethodHandles.dropArguments(target, 0, SqlFunctionProperties.class);
+        }
+        else if (keyCastIsNoOp) {
+            MethodHandle valueProcessor = buildProcessor(functionAndTypeManager, fromValueType, toValueType, false);
+            target = MethodHandles.insertArguments(MAP_CAST_NO_KEY_CHANGE, 0, valueProcessor, toMapType);
+        }
+        else if (valueCastIsNoOp) {
+            MethodHandle keyProcessor = buildProcessor(functionAndTypeManager, fromKeyType, toKeyType, true);
+            target = MethodHandles.insertArguments(MAP_CAST_NO_VALUE_CHANGE, 0, keyProcessor, toMapType);
+        }
+        else {
             MethodHandle keyProcessor = buildProcessor(functionAndTypeManager, fromKeyType, toKeyType, true);
             MethodHandle valueProcessor = buildProcessor(functionAndTypeManager, fromValueType, toValueType, false);
-        MethodHandle target = MethodHandles.insertArguments(METHOD_HANDLE, 0, keyProcessor, valueProcessor, toMapType);
+            target = MethodHandles.insertArguments(METHOD_HANDLE, 0, keyProcessor, valueProcessor, toMapType);
+        }
         return new BuiltInScalarFunctionImplementation(true, ImmutableList.of(valueTypeArgumentProperty(RETURN_NULL_ON_NULL)), target);
     }
 
@@ -205,6 +245,126 @@ public final class MapToMapCast
         return value;
     }
 
+    @UsedByGeneratedCode
+    public static Block mapCastNoKeyChange(
+            MethodHandle valueProcessFunction,
+            Type toMapType,
+            SqlFunctionProperties properties,
+            Block fromMap)
+    {
+        checkState(toMapType.getTypeParameters().size() == 2, "Expect two type parameters for toMapType");
+        Type toKeyType = toMapType.getTypeParameters().get(0);
+        TypedSet typedSet = new TypedSet(toKeyType, fromMap.getPositionCount() / 2, "map-to-map cast");
+
+        BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);
+        BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();
+        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {
+            if (fromMap.isNull(i)) {
+                throw new PrestoException(INVALID_CAST_ARGUMENT, "map key is null");
+            }
+            if (typedSet.add(fromMap, i)) {
+                toKeyType.appendTo(fromMap, i, blockBuilder);
+                if (fromMap.isNull(i + 1)) {
+                    blockBuilder.appendNull();
+                    continue;
+                }
+
+                try {
+                    valueProcessFunction.invokeExact(fromMap, i + 1, properties, blockBuilder);
+                }
+                catch (Throwable t) {
+                    throw internalError(t);
+                }
+            }
+            else {
+                // if there are duplicated keys, fail it!
+                throw new PrestoException(INVALID_CAST_ARGUMENT, "duplicate keys");
+            }
+        }
+
+        mapBlockBuilder.closeEntry();
+        return (Block) toMapType.getObject(mapBlockBuilder, mapBlockBuilder.getPositionCount() - 1);
+    }
+
+    @UsedByGeneratedCode
+    public static Block mapCastNoValueChange(
+            MethodHandle keyProcessFunction,
+            Type toMapType,
+            SqlFunctionProperties properties,
+            Block fromMap)
+    {
+        checkState(toMapType.getTypeParameters().size() == 2, "Expect two type parameters for toMapType");
+        Type toKeyType = toMapType.getTypeParameters().get(0);
+        Type toValueType = toMapType.getTypeParameters().get(1);
+        TypedSet typedSet = new TypedSet(toKeyType, fromMap.getPositionCount() / 2, "map-to-map cast");
+        BlockBuilder keyBlockBuilder = toKeyType.createBlockBuilder(null, fromMap.getPositionCount() / 2);
+        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {
+            try {
+                keyProcessFunction.invokeExact(fromMap, i, properties, keyBlockBuilder);
+            }
+            catch (Throwable t) {
+                throw internalError(t);
+            }
+        }
+        Block keyBlock = keyBlockBuilder.build();
+
+        BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);
+        BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();
+        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {
+            if (typedSet.add(keyBlock, i / 2)) {
+                toKeyType.appendTo(keyBlock, i / 2, blockBuilder);
+                if (fromMap.isNull(i + 1)) {
+                    blockBuilder.appendNull();
+                }
+                else {
+                    toValueType.appendTo(fromMap, i + 1, blockBuilder);
+                }
+            }
+            else {
+                // if there are duplicated keys, fail it!
+                throw new PrestoException(INVALID_CAST_ARGUMENT, "duplicate keys");
+            }
+        }
+
+        mapBlockBuilder.closeEntry();
+        return (Block) toMapType.getObject(mapBlockBuilder, mapBlockBuilder.getPositionCount() - 1);
+    }
+
+    @UsedByGeneratedCode
+    public static Block mapCastNoChange(
+            Type toMapType,
+            Block fromMap)
+    {
+        checkState(toMapType.getTypeParameters().size() == 2, "Expect two type parameters for toMapType");
+        Type toKeyType = toMapType.getTypeParameters().get(0);
+        Type toValueType = toMapType.getTypeParameters().get(1);
+        TypedSet typedSet = new TypedSet(toKeyType, fromMap.getPositionCount() / 2, "map-to-map cast");
+
+        BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);
+        BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();
+        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {
+            if (fromMap.isNull(i)) {
+                throw new PrestoException(INVALID_CAST_ARGUMENT, "map key is null");
+            }
+            if (typedSet.add(fromMap, i)) {
+                toKeyType.appendTo(fromMap, i, blockBuilder);
+                if (fromMap.isNull(i + 1)) {
+                    blockBuilder.appendNull();
+                }
+                else {
+                    toValueType.appendTo(fromMap, i + 1, blockBuilder);
+                }
+            }
+            else {
+                // if there are duplicated keys, fail it!
+                throw new PrestoException(INVALID_CAST_ARGUMENT, "duplicate keys");
+            }
+        }
+
+        mapBlockBuilder.closeEntry();
+        return (Block) toMapType.getObject(mapBlockBuilder, mapBlockBuilder.getPositionCount() - 1);
+    }
+
     @UsedByGeneratedCode
     public static Block mapCast(
             MethodHandle keyProcessFunction,
