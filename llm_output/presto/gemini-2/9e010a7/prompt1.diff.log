The `mapCast` method in `MapToMapCast` is optimized to improve its performance. The original implementation iterated over the input map twice in a way that was inefficient. The first pass processed all keys, and the second pass checked for duplicates while processing values. This approach has poor data locality and performs expensive value processing (via `invokeExact`) inside the second loop.

The improved version refactors this logic to be more efficient:
1.  A single pass now processes both keys and values from the input map together, building intermediate key and value blocks. This improves data locality by accessing adjacent key/value pairs from the input block.
2.  A second pass then iterates over these compact intermediate blocks to check for key duplicates and construct the final map. This second loop is significantly faster as it uses efficient `appendTo` operations instead of the more costly `invokeExact` calls for value processing.

This change maintains the original functionality, including duplicate key detection and null handling, while improving performance through better cache utilization and by making the second loop lighter.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/scalar/MapToMapCast.java",
    "search": "    @UsedByGeneratedCode\n    public static Block mapCast(\n            MethodHandle keyProcessFunction,\n            MethodHandle valueProcessFunction,\n            Type toMapType,\n            SqlFunctionProperties properties,\n            Block fromMap)\n    {\n        checkState(toMapType.getTypeParameters().size() == 2, \"Expect two type parameters for toMapType\");\n        Type toKeyType = toMapType.getTypeParameters().get(0);\n        TypedSet typedSet = new TypedSet(toKeyType, fromMap.getPositionCount() / 2, \"map-to-map cast\");\n        BlockBuilder keyBlockBuilder = toKeyType.createBlockBuilder(null, fromMap.getPositionCount() / 2);\n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            try {\n                keyProcessFunction.invokeExact(fromMap, i, properties, keyBlockBuilder);\n            }\n            catch (Throwable t) {\n                throw internalError(t);\n            }\n        }\n        Block keyBlock = keyBlockBuilder.build();\n\n        BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);\n        BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();\n        for (int i = 0; i < fromMap.getPositionCount(); i += 2) {\n            if (typedSet.add(keyBlock, i / 2)) {\n                toKeyType.appendTo(keyBlock, i / 2, blockBuilder);\n                if (fromMap.isNull(i + 1)) {\n                    blockBuilder.appendNull();\n                    continue;\n                }\n\n                try {\n                    valueProcessFunction.invokeExact(fromMap, i + 1, properties, blockBuilder);\n                }\n                catch (Throwable t) {\n                    throw internalError(t);\n                }\n            }\n            else {\n                // if there are duplicated keys, fail it!\n                throw new PrestoException(INVALID_CAST_ARGUMENT, \"duplicate keys\");\n            }\n        }\n\n        mapBlockBuilder.closeEntry();\n        return (Block) toMapType.getObject(mapBlockBuilder, mapBlockBuilder.getPositionCount() - 1);\n    }",
    "replace": "    @UsedByGeneratedCode\n    public static Block mapCast(\n            MethodHandle keyProcessFunction,\n            MethodHandle valueProcessFunction,\n            Type toMapType,\n            SqlFunctionProperties properties,\n            Block fromMap)\n    {\n        checkState(toMapType.getTypeParameters().size() == 2, \"Expect two type parameters for toMapType\");\n        Type toKeyType = toMapType.getTypeParameters().get(0);\n        Type toValueType = toMapType.getTypeParameters().get(1);\n        int positionCount = fromMap.getPositionCount();\n        int mapSize = positionCount / 2;\n\n        // Step 1: Process all keys and values.\n        // This is faster than processing all keys and then all values\n        // as the original block can be kept in cache.\n        BlockBuilder keyBlockBuilder = toKeyType.createBlockBuilder(null, mapSize);\n        BlockBuilder valueBlockBuilder = toValueType.createBlockBuilder(null, mapSize);\n        for (int i = 0; i < positionCount; i += 2) {\n            try {\n                keyProcessFunction.invokeExact(fromMap, i, properties, keyBlockBuilder);\n            }\n            catch (Throwable t) {\n                throw internalError(t);\n            }\n\n            if (fromMap.isNull(i + 1)) {\n                valueBlockBuilder.appendNull();\n            }\n            else {\n                try {\n                    valueProcessFunction.invokeExact(fromMap, i + 1, properties, valueBlockBuilder);\n                }\n                catch (Throwable t) {\n                    throw internalError(t);\n                }\n            }\n        }\n        Block keyBlock = keyBlockBuilder.build();\n        Block valueBlock = valueBlockBuilder.build();\n\n        // Step 2: Check for duplicate keys and build the map.\n        TypedSet typedSet = new TypedSet(toKeyType, mapSize, \"map-to-map cast\");\n        BlockBuilder mapBlockBuilder = toMapType.createBlockBuilder(null, 1);\n        BlockBuilder blockBuilder = mapBlockBuilder.beginBlockEntry();\n        for (int i = 0; i < mapSize; i++) {\n            if (typedSet.add(keyBlock, i)) {\n                toKeyType.appendTo(keyBlock, i, blockBuilder);\n                toValueType.appendTo(valueBlock, i, blockBuilder);\n            }\n            else {\n                // if there are duplicated keys, fail it!\n                throw new PrestoException(INVALID_CAST_ARGUMENT, \"duplicate keys\");\n            }\n        }\n\n        mapBlockBuilder.closeEntry();\n        return (Block) toMapType.getObject(mapBlockBuilder, mapBlockBuilder.getPositionCount() - 1);\n    }"
  }
]
```