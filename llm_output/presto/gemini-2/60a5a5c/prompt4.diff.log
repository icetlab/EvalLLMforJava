The performance issue is related to repeated memory allocation for compression and decompression buffers within the `PagesSerde` class. Every call to `serialize` or `deserialize` allocates a new `ByteBuffer`, which can lead to garbage collection pressure and performance degradation, especially when processing many small pages.

To address this, I will modify `PagesSerde` to reuse `ByteBuffer` instances for both compression and decompression. I will introduce two new fields, `compressionBuffer` and `decompressionBuffer`, to hold these reusable buffers. In the `serialize` and `deserialize` methods, instead of allocating new buffers on each invocation, the code will check if the existing buffers are sufficient. If a buffer is null or too small, a new one will be allocated. Otherwise, the existing buffer will be cleared and reused. This change avoids frequent allocations and reduces GC overhead, improving overall performance.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/execution/buffer/PagesSerde.java",
    "search": "    private final Optional<Decompressor> decompressor;\n    private final Optional<SpillCipher> spillCipher;",
    "replace": "    private final Optional<Decompressor> decompressor;\n    private final Optional<SpillCipher> spillCipher;\n\n    private ByteBuffer compressionBuffer;\n    private ByteBuffer decompressionBuffer;"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/execution/buffer/PagesSerde.java",
    "search": "        if (compressor.isPresent()) {\n            ByteBuffer compressionBuffer = ByteBuffer.allocate(compressor.get().maxCompressedLength(uncompressedSize));\n            compressor.get().compress(slice.toByteBuffer(), compressionBuffer);\n            compressionBuffer.flip();\n            if ((((double) compressionBuffer.remaining()) / uncompressedSize) <= MINIMUM_COMPRESSION_RATIO) {\n                slice = Slices.wrappedBuffer(compressionBuffer);\n                markers = COMPRESSED.set(markers);\n            }\n        }",
    "replace": "        if (compressor.isPresent()) {\n            int maxCompressedLength = compressor.get().maxCompressedLength(uncompressedSize);\n            if (compressionBuffer == null || compressionBuffer.capacity() < maxCompressedLength) {\n                compressionBuffer = ByteBuffer.allocate(maxCompressedLength);\n            }\n            else {\n                compressionBuffer.clear();\n            }\n            compressor.get().compress(slice.toByteBuffer(), compressionBuffer);\n            compressionBuffer.flip();\n            if ((((double) compressionBuffer.remaining()) / uncompressedSize) <= MINIMUM_COMPRESSION_RATIO) {\n                slice = Slices.wrappedBuffer(compressionBuffer);\n                markers = COMPRESSED.set(markers);\n            }\n        }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/execution/buffer/PagesSerde.java",
    "search": "        if (COMPRESSED.isSet(serializedPage.getPageCodecMarkers())) {\n            checkState(decompressor.isPresent(), \"Page is compressed, but decompressor is missing\");\n\n            int uncompressedSize = serializedPage.getUncompressedSizeInBytes();\n            ByteBuffer decompressionBuffer = ByteBuffer.allocate(uncompressedSize);\n\n            decompressor.get().decompress(slice.toByteBuffer(), decompressionBuffer);\n            decompressionBuffer.flip();\n            checkState(decompressionBuffer.remaining() == uncompressedSize);\n\n            slice = Slices.wrappedBuffer(decompressionBuffer);\n        }",
    "replace": "        if (COMPRESSED.isSet(serializedPage.getPageCodecMarkers())) {\n            checkState(decompressor.isPresent(), \"Page is compressed, but decompressor is missing\");\n\n            int uncompressedSize = serializedPage.getUncompressedSizeInBytes();\n            if (decompressionBuffer == null || decompressionBuffer.capacity() < uncompressedSize) {\n                decompressionBuffer = ByteBuffer.allocate(uncompressedSize);\n            }\n            else {\n                decompressionBuffer.clear();\n            }\n            decompressionBuffer.limit(uncompressedSize);\n\n            decompressor.get().decompress(slice.toByteBuffer(), decompressionBuffer);\n            decompressionBuffer.flip();\n            checkState(decompressionBuffer.remaining() == uncompressedSize);\n\n            slice = Slices.wrappedBuffer(decompressionBuffer);\n        }"
  }
]
```