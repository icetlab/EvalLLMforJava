I will improve the performance of the provided Java code by focusing on two main areas: reducing object allocations and optimizing data processing loops.

In `PagesSerde.java`, I will introduce buffer reuse for compression and decompression operations. By caching and resizing `ByteBuffer` instances as needed, we can significantly reduce the garbage collection pressure caused by frequent allocations within the `serialize` and `deserialize` methods, which are often on the critical path for data exchange.

In `PartitionedOutputOperator.java`, I will refactor the `PagePartitioner.partitionPage` method. The original implementation processes rows one by one, leading to potentially poor cache performance due to random access patterns when dispatching rows to different partition builders. The improved version will first determine the partition for each row and group row positions by their target partition. This allows for batch-appending rows to each `PageBuilder`, leading to better data locality and CPU cache utilization. Additionally, I will replace a `Stream.map().collect()` pattern in the `flush` method with a more direct loop-based approach to minimize overhead during page serialization.

```json
[
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/execution/buffer/PagesSerde.java",
    "search": "public class PagesSerde\n{\n    private static final double MINIMUM_COMPRESSION_RATIO = 0.8;",
    "replace": "public class PagesSerde\n{\n    private static final double MINIMUM_COMPRESSION_RATIO = 0.8;\n\n    private ByteBuffer compressionBuffer;\n    private ByteBuffer decompressionBuffer;"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/execution/buffer/PagesSerde.java",
    "search": "if (compressor.isPresent()) {\n            ByteBuffer compressionBuffer = ByteBuffer.allocate(compressor.get().maxCompressedLength(uncompressedSize));\n            compressor.get().compress(slice.toByteBuffer(), compressionBuffer);\n            compressionBuffer.flip();\n            if ((((double) compressionBuffer.remaining()) / uncompressedSize) <= MINIMUM_COMPRESSION_RATIO) {\n                slice = Slices.wrappedBuffer(compressionBuffer);\n                markers = COMPRESSED.set(markers);\n            }\n        }",
    "replace": "if (compressor.isPresent()) {\n            int maxCompressedLength = compressor.get().maxCompressedLength(uncompressedSize);\n            if (compressionBuffer == null || compressionBuffer.capacity() < maxCompressedLength) {\n                compressionBuffer = ByteBuffer.allocate(maxCompressedLength);\n            }\n            compressionBuffer.clear();\n\n            compressor.get().compress(slice.toByteBuffer(), compressionBuffer);\n            compressionBuffer.flip();\n            if ((((double) compressionBuffer.remaining()) / uncompressedSize) <= MINIMUM_COMPRESSION_RATIO) {\n                slice = Slices.wrappedBuffer(compressionBuffer);\n                markers = COMPRESSED.set(markers);\n            }\n        }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/execution/buffer/PagesSerde.java",
    "search": "if (COMPRESSED.isSet(serializedPage.getPageCodecMarkers())) {\n            checkState(decompressor.isPresent(), \"Page is compressed, but decompressor is missing\");\n\n            int uncompressedSize = serializedPage.getUncompressedSizeInBytes();\n            ByteBuffer decompressionBuffer = ByteBuffer.allocate(uncompressedSize);\n\n            decompressor.get().decompress(slice.toByteBuffer(), decompressionBuffer);\n            decompressionBuffer.flip();\n            checkState(decompressionBuffer.remaining() == uncompressedSize);\n\n            slice = Slices.wrappedBuffer(decompressionBuffer);\n        }",
    "replace": "if (COMPRESSED.isSet(serializedPage.getPageCodecMarkers())) {\n            checkState(decompressor.isPresent(), \"Page is compressed, but decompressor is missing\");\n\n            int uncompressedSize = serializedPage.getUncompressedSizeInBytes();\n            if (decompressionBuffer == null || decompressionBuffer.capacity() < uncompressedSize) {\n                decompressionBuffer = ByteBuffer.allocate(uncompressedSize);\n            }\n            decompressionBuffer.clear();\n            decompressionBuffer.limit(uncompressedSize);\n\n            decompressor.get().decompress(slice.toByteBuffer(), decompressionBuffer);\n            decompressionBuffer.flip();\n            checkState(decompressionBuffer.remaining() == uncompressedSize);\n\n            slice = Slices.wrappedBuffer(decompressionBuffer);\n        }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/PartitionedOutputOperator.java",
    "search": "import com.google.common.util.concurrent.ListenableFuture;\nimport io.airlift.units.DataSize;",
    "replace": "import com.google.common.util.concurrent.ListenableFuture;\nimport io.airlift.units.DataSize;\n\nimport java.util.ArrayList;"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/PartitionedOutputOperator.java",
    "search": "private final PageBuilder[] pageBuilders;\n        private final boolean replicatesAnyRow;",
    "replace": "private final PageBuilder[] pageBuilders;\n        private final List<Integer>[] positionsByPartition;\n        private final List<Integer> replicatedPositions;\n        private final boolean replicatesAnyRow;"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/PartitionedOutputOperator.java",
    "search": "this.pageBuilders = new PageBuilder[partitionCount];\n            for (int i = 0; i < partitionCount; i++) {\n                pageBuilders[i] = PageBuilder.withMaxPageSize(pageSize, sourceTypes);\n            }",
    "replace": "this.pageBuilders = new PageBuilder[partitionCount];\n            this.positionsByPartition = new List[partitionCount];\n            this.replicatedPositions = new ArrayList<>();\n            for (int i = 0; i < partitionCount; i++) {\n                pageBuilders[i] = PageBuilder.withMaxPageSize(pageSize, sourceTypes);\n                positionsByPartition[i] = new ArrayList<>();\n            }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/PartitionedOutputOperator.java",
    "search": "public void partitionPage(Page page)\n        {\n            requireNonNull(page, \"page is null\");\n\n            Page partitionFunctionArgs = getPartitionFunctionArguments(page);\n            for (int position = 0; position < page.getPositionCount(); position++) {\n                boolean shouldReplicate = (replicatesAnyRow && !hasAnyRowBeenReplicated) ||\n                        nullChannel.isPresent() && page.getBlock(nullChannel.getAsInt()).isNull(position);\n                if (shouldReplicate) {\n                    for (PageBuilder pageBuilder : pageBuilders) {\n                        appendRow(pageBuilder, page, position);\n                    }\n                    hasAnyRowBeenReplicated = true;\n                }\n                else {\n                    int partition = partitionFunction.getPartition(partitionFunctionArgs, position);\n                    appendRow(pageBuilders[partition], page, position);\n                }\n            }\n            flush(false);\n        }",
    "replace": "public void partitionPage(Page page)\n        {\n            requireNonNull(page, \"page is null\");\n            int positionCount = page.getPositionCount();\n            if (positionCount == 0) {\n                return;\n            }\n\n            // 1. clear and prepare for partitioning\n            for (List<Integer> list : positionsByPartition) {\n                list.clear();\n            }\n            replicatedPositions.clear();\n\n            Page partitionFunctionArgs = getPartitionFunctionArguments(page);\n            Block nullChannelBlock = nullChannel.isPresent() ? page.getBlock(nullChannel.getAsInt()) : null;\n\n            // 2. group positions by partition\n            for (int position = 0; position < positionCount; position++) {\n                boolean shouldReplicate = (replicatesAnyRow && !hasAnyRowBeenReplicated) ||\n                        (nullChannelBlock != null && nullChannelBlock.isNull(position));\n\n                if (shouldReplicate) {\n                    replicatedPositions.add(position);\n                    hasAnyRowBeenReplicated = true;\n                }\n                else {\n                    int partition = partitionFunction.getPartition(partitionFunctionArgs, position);\n                    positionsByPartition[partition].add(position);\n                }\n            }\n\n            // 3. append rows to page builders\n            // append replicated rows\n            if (!replicatedPositions.isEmpty()) {\n                for (int position : replicatedPositions) {\n                    for (PageBuilder pageBuilder : pageBuilders) {\n                        appendRow(pageBuilder, page, position);\n                    }\n                }\n            }\n\n            // append partitioned rows\n            for (int partition = 0; partition < pageBuilders.length; partition++) {\n                List<Integer> positions = positionsByPartition[partition];\n                if (!positions.isEmpty()) {\n                    PageBuilder pageBuilder = pageBuilders[partition];\n                    for (int position : positions) {\n                        appendRow(pageBuilder, page, position);\n                    }\n                }\n            }\n\n            flush(false);\n        }"
  },
  {
    "filepath": "../presto/presto-main/src/main/java/com/facebook/presto/operator/PartitionedOutputOperator.java",
    "search": "List<SerializedPage> serializedPages = splitPage(pagePartition, DEFAULT_MAX_PAGE_SIZE_IN_BYTES).stream()\n                            .map(serde::serialize)\n                            .collect(toImmutableList());",
    "replace": "List<Page> splitPages = splitPage(pagePartition, DEFAULT_MAX_PAGE_SIZE_IN_BYTES);\n                    List<SerializedPage> serializedPages = new ArrayList<>(splitPages.size());\n                    for (Page p : splitPages) {\n                        serializedPages.add(serde.serialize(p));\n                    }"
  }
]
```