I optimized checkedAdd by replacing expensive cardinality computations with a simple contains check, avoiding getCardinality calls and speeding up duplicate checks.

```json
[
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java",
    "search": "public boolean checkedAdd(final int x) {\n    final char hb = Util.highbits(x);\n    final int i = highLowContainer.getIndex(hb);\n    if (i >= 0) {\n      Container c = highLowContainer.getContainerAtIndex(i);\n      int oldCard = c.getCardinality();\n      // we need to keep the newContainer if a switch between containers type\n      // occur, in order to get the new cardinality\n      Container newCont = c.add(Util.lowbits(x));\n      highLowContainer.setContainerAtIndex(i, newCont);\n      if (newCont.getCardinality() > oldCard) {\n        return true;\n      }\n    } else {\n      final ArrayContainer newac = new ArrayContainer();\n      highLowContainer.insertNewKeyValueAt(-i - 1, hb, newac.add(Util.lowbits(x)));\n      return true;\n    }\n    return false;\n  }",
    "replace": "public boolean checkedAdd(final int x) {\n    final char hb = Util.highbits(x);\n    final char lb = Util.lowbits(x);\n    final int i = highLowContainer.getIndex(hb);\n    if (i >= 0) {\n      Container c = highLowContainer.getContainerAtIndex(i);\n      boolean present = c.contains(lb);\n      Container newCont = c.add(lb);\n      highLowContainer.setContainerAtIndex(i, newCont);\n      return !present;\n    } else {\n      final ArrayContainer newac = new ArrayContainer();\n      highLowContainer.insertNewKeyValueAt(-i - 1, hb, newac.add(lb));\n      return true;\n    }\n  }"
  }
]
```