Iâ€™ve replaced the manual iteration and removal of excess values in `topK` with a call to the optimized `limit(n)` method, reducing overhead and leveraging internal batch operations for faster trimming of the result set.

```json
[
  {
    "filepath": "../RoaringBitmap/bsi/src/main/java/org/roaringbitmap/bsi/buffer/BitSliceIndexBase.java",
    "search": "MutableRoaringBitmap F = ImmutableRoaringBitmap.or(G, E);\n    long n = F.getLongCardinality() - k;\n    if (n > 0) {\n      // TODO: make faster\n      IntIterator i = F.getIntIterator();\n      MutableRoaringBitmap turnoff = new MutableRoaringBitmap();\n      while (i.hasNext() && n > 0) {\n        turnoff.add(i.next());\n        --n;\n      }\n      F.andNot(turnoff);\n    }",
    "replace": "MutableRoaringBitmap F = ImmutableRoaringBitmap.or(G, E);\n    long n = F.getLongCardinality() - k;\n    if (n > 0) {\n      MutableRoaringBitmap turnoff = F.limit((int) n);\n      F.andNot(turnoff);\n    }"
  }
]
```