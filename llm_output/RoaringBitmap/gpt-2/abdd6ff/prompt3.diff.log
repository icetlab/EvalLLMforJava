Iâ€™ve optimized the hot paths in BitSliceIndexBase by replacing the Stream-based summation in sum() with a simple loop to eliminate lambda overhead, and by using the built-in limit() method in topK() to bulk-remove the unwanted elements instead of manual iteration.

```json
[
  {
    "filepath": "../RoaringBitmap/bsi/src/main/java/org/roaringbitmap/bsi/buffer/BitSliceIndexBase.java",
    "search": "Long sum = IntStream.range(0, this.bitCount())\n        .mapToLong(x -> (long) (1 << x) * ImmutableRoaringBitmap.andCardinality(this.bA[x], foundSet))\n        .sum();",
    "replace": "long sum = 0L;\nfor (int x = 0; x < this.bitCount(); x++) {\n    sum += (1L << x) * ImmutableRoaringBitmap.andCardinality(this.bA[x], foundSet);\n}"
  },
  {
    "filepath": "../RoaringBitmap/bsi/src/main/java/org/roaringbitmap/bsi/buffer/BitSliceIndexBase.java",
    "search": "if (n > 0) {\n      // TODO: make faster\n      IntIterator i = F.getIntIterator();\n      MutableRoaringBitmap turnoff = new MutableRoaringBitmap();\n      while (i.hasNext() && n > 0) {\n        turnoff.add(i.next());\n        --n;\n      }\n      F.andNot(turnoff);\n    }",
    "replace": "if (n > 0) {\n      MutableRoaringBitmap turnoff = F.limit((int) n);\n      F.andNot(turnoff);\n    }"
  }
]
```