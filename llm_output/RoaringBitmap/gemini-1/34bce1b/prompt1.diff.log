The primary performance improvement is in the `shiftLeftFromSpecifiedPosition` method. The original implementation converted the integer to a byte array, performed a `System.arraycopy`, and then converted it back to an integer. This process involves object allocation and is relatively slow. The new implementation achieves the same result using bitwise operations directly on the integer, which is significantly more efficient by avoiding object allocations and method calls.

```json
[
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/longlong/IntegerUtil.java",
    "search": "  public static int shiftLeftFromSpecifiedPosition(int v, int pos, int count) {\n    byte[] initialVal = toBDBytes(v);\n    System.arraycopy(initialVal, pos + 1, initialVal, pos, count);\n    return fromBDBytes(initialVal);\n  }",
    "replace": "  public static int shiftLeftFromSpecifiedPosition(int v, int pos, int count) {\n    if (count == 0) {\n      return v;\n    }\n    // This bitwise implementation is a faster equivalent of the previous byte array-based one.\n    // It avoids object allocation. The original System.arraycopy implies pos + count <= 3.\n\n    long rawMask = (1L << (count * 8)) - 1;\n\n    // Mask for the source bytes to be shifted left. This is `count` bytes starting at `pos + 1`.\n    int sourceShift = (3 - pos - count) * 8;\n    int sourceMask = (int) (rawMask << sourceShift);\n\n    // The hole mask is the source mask shifted left by one byte.\n    int holeMask = sourceMask << 8;\n\n    // Clear the hole area, then OR with the shifted source bytes.\n    return (v & ~holeMask) | ((v & sourceMask) << 8);\n  }"
  }
]
```