The current implementation of `shiftLeftFromSpecifiedPosition` is suboptimal because it converts an integer to a byte array, performs an array copy, and then converts the byte array back to an integer. This involves unnecessary object allocations and method calls.

My improvement replaces this process with a pure bitwise manipulation approach. It calculates masks for the different byte segments of the integer, shifts the relevant parts, and combines them back into a new integer. This avoids heap allocations for the byte array and the overhead of `toBDBytes`, `fromBDBytes`, and `System.arraycopy`, resulting in a significant performance gain.

```json
[
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/longlong/IntegerUtil.java",
    "search": "  public static int shiftLeftFromSpecifiedPosition(int v, int pos, int count) {\n    byte[] initialVal = toBDBytes(v);\n    System.arraycopy(initialVal, pos + 1, initialVal, pos, count);\n    return fromBDBytes(initialVal);\n  }",
    "replace": "  public static int shiftLeftFromSpecifiedPosition(int v, int pos, int count) {\n    if (count == 0) {\n      return v;\n    }\n    int highMask = pos == 0 ? 0 : (-1 << (32 - pos * 8));\n    int lowBytesCount = 4 - (pos + count);\n    int lowMask = lowBytesCount <= 0 ? 0 : (-1 >>> (32 - lowBytesCount * 8));\n    int midMask = ~(highMask | lowMask);\n    int highPart = v & highMask;\n    int lowPart = v & lowMask;\n    int midPart = (v << 8) & midMask;\n    return highPart | midPart | lowPart;\n  }"
  }
]
```