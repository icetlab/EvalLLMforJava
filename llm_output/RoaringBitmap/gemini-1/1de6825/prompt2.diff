diff --git a/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java b/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java
index de6dddea..8d104024 100644
--- a/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java
+++ b/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java
@@ -19,16 +19,14 @@ public class Node16 extends Node {
 
   @Override
   public int getChildPos(byte k) {
-    byte[] firstBytes = LongUtils.toBDBytes(firstV);
     if (count <= 8) {
-      return Node.binarySearch(firstBytes, 0, count, k);
+      return binarySearch(firstV, count, k);
     } else {
-      int pos = Node.binarySearch(firstBytes, 0, 8, k);
+      int pos = binarySearch(firstV, 8, k);
       if (pos != ILLEGAL_IDX) {
         return pos;
       } else {
-        byte[] secondBytes = LongUtils.toBDBytes(secondV);
-        pos = Node.binarySearch(secondBytes, 0, (count - 8), k);
+        pos = binarySearch(secondV, count - 8, k);
         if (pos != ILLEGAL_IDX) {
           return 8 + pos;
         } else {
@@ -40,21 +38,17 @@ public class Node16 extends Node {
 
   @Override
   public SearchResult getNearestChildPos(byte k) {
-    byte[] firstBytes = LongUtils.toBDBytes(firstV);
     if (count <= 8) {
-      return Node.binarySearchWithResult(firstBytes, 0, count, k);
+      return binarySearchWithResult(firstV, count, k);
     } else {
-      SearchResult firstResult = Node.binarySearchWithResult(
-              firstBytes, 0, 8, k);
+      SearchResult firstResult = binarySearchWithResult(firstV, 8, k);
       // given the values are "in order" if we found a match or a value larger than
       // the target we are done.
       if (firstResult.outcome == SearchResult.Outcome.FOUND
               || firstResult.hasNextLargerPos()) {
         return firstResult;
       } else {
-        byte[] secondBytes = LongUtils.toBDBytes(secondV);
-        SearchResult secondResult = Node.binarySearchWithResult(
-                secondBytes, 0, (count - 8), k);
+        SearchResult secondResult = binarySearchWithResult(secondV, count - 8, k);
 
         switch(secondResult.outcome) {
           case FOUND:
@@ -84,15 +78,10 @@ public class Node16 extends Node {
 
   @Override
   public byte getChildKey(int pos) {
-    int posInLong;
     if (pos <= 7) {
-      posInLong = pos;
-      byte[] firstBytes = LongUtils.toBDBytes(firstV);
-      return firstBytes[posInLong];
+      return (byte) (firstV >> (56 - pos * 8));
     } else {
-      posInLong = pos - 8;
-      byte[] secondBytes = LongUtils.toBDBytes(secondV);
-      return secondBytes[posInLong];
+      return (byte) (secondV >> (56 - (pos - 8) * 8));
     }
   }
 
@@ -134,6 +123,45 @@ public class Node16 extends Node {
     return pos >= 0 ? pos : ILLEGAL_IDX;
   }
 
+  private static int binarySearch(long val, int limit, byte k) {
+    int low = 0;
+    int high = limit - 1;
+    int k_unsigned = Byte.toUnsignedInt(k);
+    while (low <= high) {
+      int mid = (low + high) >>> 1;
+      byte midVal = (byte) (val >> (56 - mid * 8));
+      int midVal_unsigned = Byte.toUnsignedInt(midVal);
+      if (midVal_unsigned < k_unsigned) {
+        low = mid + 1;
+      } else if (midVal_unsigned > k_unsigned) {
+        high = mid - 1;
+      } else {
+        return mid;
+      }
+    }
+    return ILLEGAL_IDX;
+  }
+
+  private static SearchResult binarySearchWithResult(long val, int limit, byte k) {
+    int low = 0;
+    int high = limit - 1;
+    int k_unsigned = Byte.toUnsignedInt(k);
+    while (low <= high) {
+      int mid = (low + high) >>> 1;
+      byte midVal = (byte) (val >> (56 - mid * 8));
+      int midVal_unsigned = Byte.toUnsignedInt(midVal);
+      if (midVal_unsigned < k_unsigned) {
+        low = mid + 1;
+      } else if (midVal_unsigned > k_unsigned) {
+        high = mid - 1;
+      } else {
+        return SearchResult.found(mid);
+      }
+    }
+    // not found
+    return SearchResult.notFound(high, low < limit ? low : ILLEGAL_IDX);
+  }
+
   /**
    * insert a child into the node with the key byte
    *
@@ -168,17 +196,15 @@ public class Node16 extends Node {
       return currentNode16;
     } else {
       Node48 node48 = new Node48(currentNode16.prefixLength);
-      byte[] firtBytes = LongUtils.toBDBytes(currentNode16.firstV);
       for (int i = 0; i < 8; i++) {
-        byte v = firtBytes[i];
+        byte v = (byte) (currentNode16.firstV >> (56 - i * 8));
         int unsignedIdx = Byte.toUnsignedInt(v);
         //i won't be beyond 48
         Node48.setOneByte(unsignedIdx, (byte) i, node48.childIndex);
         node48.children[i] = currentNode16.children[i];
       }
-      byte[] secondBytes = LongUtils.toBDBytes(currentNode16.secondV);
       for (int i = 8; i < currentNode16.count; i++) {
-        byte v = secondBytes[i - 8];
+        byte v = (byte) (currentNode16.secondV >> (56 - (i - 8) * 8));
         int unsignedIdx = Byte.toUnsignedInt(v);
         //i won't be beyond 48
         Node48.setOneByte(unsignedIdx, (byte) i, node48.childIndex);
