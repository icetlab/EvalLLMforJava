The performance issue is that `checkedAdd` can be slow for `RunContainer`s, as it involves computing the container's cardinality, which can be an expensive operation. This is particularly noticeable when many of the values being added are already present in the bitmap.

My improvement introduces a specialized fast path for `RunContainer` and `MappeableRunContainer`. For these container types, checking for the existence of a value with `contains()` is much cheaper than calculating cardinality.

The improved logic is as follows:
1.  If the container is a `RunContainer`, first use `contains()` to check if the value is already present.
2.  If it is, we can immediately return `false` without any expensive calculations.
3.  If it's not present, we proceed to add the value and return `true`, as we know an element has been added. This avoids the need to compute and compare cardinalities.
4.  For all other container types, the original logic of comparing cardinalities before and after the addition is retained.

This change significantly improves the performance of `checkedAdd` for `RunContainer`-heavy bitmaps, especially in scenarios with many duplicate additions, by avoiding unnecessary cardinality computations. The changes are applied to both `RoaringBitmap` and `MutableRoaringBitmap`.

```json
[
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java",
    "search": "if (i >= 0) {\n      Container c = highLowContainer.getContainerAtIndex(i);\n      int oldCard = c.getCardinality();\n      // we need to keep the newContainer if a switch between containers type\n      // occur, in order to get the new cardinality\n      Container newCont = c.add(Util.lowbits(x));\n      highLowContainer.setContainerAtIndex(i, newCont);\n      if (newCont.getCardinality() > oldCard) {\n        return true;\n      }\n    }",
    "replace": "if (i >= 0) {\n      Container c = highLowContainer.getContainerAtIndex(i);\n      if (c instanceof RunContainer) {\n        if (c.contains(Util.lowbits(x))) {\n          return false;\n        }\n        highLowContainer.setContainerAtIndex(i, c.add(Util.lowbits(x)));\n        return true;\n      }\n      int oldCard = c.getCardinality();\n      // we need to keep the newContainer if a switch between containers type\n      // occur, in order to get the new cardinality\n      Container newCont = c.add(Util.lowbits(x));\n      highLowContainer.setContainerAtIndex(i, newCont);\n      if (newCont.getCardinality() > oldCard) {\n        return true;\n      }\n    }"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MutableRoaringBitmap.java",
    "search": "if (i >= 0) {\n      MappeableContainer C = highLowContainer.getContainerAtIndex(i);\n      int oldcard = C.getCardinality();\n      C = C.add(BufferUtil.lowbits(x));\n      getMappeableRoaringArray().setContainerAtIndex(i, C);\n      return C.getCardinality() > oldcard;\n    }",
    "replace": "if (i >= 0) {\n      MappeableContainer c = highLowContainer.getContainerAtIndex(i);\n      if (c instanceof MappeableRunContainer) {\n        if (c.contains(BufferUtil.lowbits(x))) {\n          return false;\n        }\n        getMappeableRoaringArray().setContainerAtIndex(i, c.add(BufferUtil.lowbits(x)));\n        return true;\n      }\n      int oldcard = c.getCardinality();\n      c = c.add(BufferUtil.lowbits(x));\n      getMappeableRoaringArray().setContainerAtIndex(i, c);\n      return c.getCardinality() > oldcard;\n    }"
  }
]
```