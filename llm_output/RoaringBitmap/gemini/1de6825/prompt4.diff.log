This optimization improves performance by avoiding the creation of intermediate byte arrays from `long` primitives. Instead of converting `long` values to `byte[]` to access individual bytes, I've modified the code to directly extract bytes using bitwise shift operations. This approach is applied to several methods (`getChildPos`, `getNearestChildPos`, `getChildKey`, and `insert`) where such conversions were a bottleneck.

To support this, I've introduced two private helper methods, `binarySearch` and `binarySearchWithResult`, which perform binary searches directly on `long` values, mimicking the behavior of the original byte array-based searches. These helpers use unsigned byte comparison to maintain correctness, as confirmed by the unit tests. This change reduces memory allocations and improves data access speed, leading to better overall performance.

```json
[
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java",
    "search": "  @Override\n  public byte getChildKey(int pos) {\n    int posInLong;\n    if (pos <= 7) {\n      posInLong = pos;\n      byte[] firstBytes = LongUtils.toBDBytes(firstV);\n      return firstBytes[posInLong];\n    } else {\n      posInLong = pos - 8;\n      byte[] secondBytes = LongUtils.toBDBytes(secondV);\n      return secondBytes[posInLong];\n    }\n  }",
    "replace": "  @Override\n  public byte getChildKey(int pos) {\n    if (pos <= 7) {\n      return (byte) (firstV >>> ((7 - pos) << 3));\n    } else {\n      int posInLong = pos - 8;\n      return (byte) (secondV >>> ((7 - posInLong) << 3));\n    }\n  }"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java",
    "search": "      Node48 node48 = new Node48(currentNode16.prefixLength);\n      byte[] firtBytes = LongUtils.toBDBytes(currentNode16.firstV);\n      for (int i = 0; i < 8; i++) {\n        byte v = firtBytes[i];\n        int unsignedIdx = Byte.toUnsignedInt(v);\n        //i won't be beyond 48\n        Node48.setOneByte(unsignedIdx, (byte) i, node48.childIndex);\n        node48.children[i] = currentNode16.children[i];\n      }\n      byte[] secondBytes = LongUtils.toBDBytes(currentNode16.secondV);\n      for (int i = 8; i < currentNode16.count; i++) {\n        byte v = secondBytes[i - 8];\n        int unsignedIdx = Byte.toUnsignedInt(v);\n        //i won't be beyond 48\n        Node48.setOneByte(unsignedIdx, (byte) i, node48.childIndex);\n        node48.children[i] = currentNode16.children[i];\n      }",
    "replace": "      Node48 node48 = new Node48(currentNode16.prefixLength);\n      for (int i = 0; i < 8; i++) {\n        byte v = (byte) (currentNode16.firstV >>> ((7 - i) << 3));\n        int unsignedIdx = Byte.toUnsignedInt(v);\n        //i won't be beyond 48\n        Node48.setOneByte(unsignedIdx, (byte) i, node48.childIndex);\n        node48.children[i] = currentNode16.children[i];\n      }\n      for (int i = 8; i < currentNode16.count; i++) {\n        byte v = (byte) (currentNode16.secondV >>> ((7 - (i - 8)) << 3));\n        int unsignedIdx = Byte.toUnsignedInt(v);\n        //i won't be beyond 48\n        Node48.setOneByte(unsignedIdx, (byte) i, node48.childIndex);\n        node48.children[i] = currentNode16.children[i];\n      }"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java",
    "search": "  public void replaceChildren(Node[] children) {\n    int pos = this.getNextLargerPos(ILLEGAL_IDX);\n    int offset = 0;\n    while (pos != ILLEGAL_IDX) {\n      this.children[pos] = children[offset];\n      pos = this.getNextLargerPos(pos);\n      offset++;\n    }\n  }\n}",
    "replace": "  public void replaceChildren(Node[] children) {\n    int pos = this.getNextLargerPos(ILLEGAL_IDX);\n    int offset = 0;\n    while (pos != ILLEGAL_IDX) {\n      this.children[pos] = children[offset];\n      pos = this.getNextLargerPos(pos);\n      offset++;\n    }\n  }\n\n  private static int binarySearch(long l, int fromIndex, int toIndex, byte key) {\n    int low = fromIndex;\n    int high = toIndex - 1;\n    int unsignedKey = Byte.toUnsignedInt(key);\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      byte midVal = (byte) (l >>> ((7 - mid) << 3));\n      int unsignedMidVal = Byte.toUnsignedInt(midVal);\n      if (unsignedMidVal < unsignedKey) {\n        low = mid + 1;\n      } else if (unsignedMidVal > unsignedKey) {\n        high = mid - 1;\n      } else {\n        return mid; // key found\n      }\n    }\n    return ILLEGAL_IDX; // key not found.\n  }\n\n  private static SearchResult binarySearchWithResult(long l, int fromIndex, int toIndex, byte key) {\n    int low = fromIndex;\n    int high = toIndex - 1;\n    int nextSmaller = -1;\n    int nextLarger = -1;\n    int unsignedKey = Byte.toUnsignedInt(key);\n\n    while (low <= high) {\n      int mid = (low + high) >>> 1;\n      byte midVal = (byte) (l >>> ((7 - mid) << 3));\n      int unsignedMidVal = Byte.toUnsignedInt(midVal);\n\n      if (unsignedMidVal < unsignedKey) {\n        nextSmaller = mid;\n        low = mid + 1;\n      } else if (unsignedMidVal > unsignedKey) {\n        nextLarger = mid;\n        high = mid - 1;\n      } else {\n        return SearchResult.found(mid);\n      }\n    }\n    return SearchResult.notFound(nextSmaller, nextLarger);\n  }\n}"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java",
    "search": "  @Override\n  public int getChildPos(byte k) {\n    byte[] firstBytes = LongUtils.toBDBytes(firstV);\n    if (count <= 8) {\n      return Node.binarySearch(firstBytes, 0, count, k);\n    } else {\n      int pos = Node.binarySearch(firstBytes, 0, 8, k);\n      if (pos != ILLEGAL_IDX) {\n        return pos;\n      } else {\n        byte[] secondBytes = LongUtils.toBDBytes(secondV);\n        pos = Node.binarySearch(secondBytes, 0, (count - 8), k);\n        if (pos != ILLEGAL_IDX) {\n          return 8 + pos;\n        } else {\n          return ILLEGAL_IDX;\n        }\n      }\n    }\n  }",
    "replace": "  @Override\n  public int getChildPos(byte k) {\n    if (count <= 8) {\n      return binarySearch(firstV, 0, count, k);\n    } else {\n      int pos = binarySearch(firstV, 0, 8, k);\n      if (pos != ILLEGAL_IDX) {\n        return pos;\n      } else {\n        pos = binarySearch(secondV, 0, (count - 8), k);\n        if (pos != ILLEGAL_IDX) {\n          return 8 + pos;\n        } else {\n          return ILLEGAL_IDX;\n        }\n      }\n    }\n  }"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java",
    "search": "  @Override\n  public SearchResult getNearestChildPos(byte k) {\n    byte[] firstBytes = LongUtils.toBDBytes(firstV);\n    if (count <= 8) {\n      return Node.binarySearchWithResult(firstBytes, 0, count, k);\n    } else {\n      SearchResult firstResult = Node.binarySearchWithResult(\n              firstBytes, 0, 8, k);\n      // given the values are \"in order\" if we found a match or a value larger than\n      // the target we are done.\n      if (firstResult.outcome == SearchResult.Outcome.FOUND\n              || firstResult.hasNextLargerPos()) {\n        return firstResult;\n      } else {\n        byte[] secondBytes = LongUtils.toBDBytes(secondV);\n        SearchResult secondResult = Node.binarySearchWithResult(\n                secondBytes, 0, (count - 8), k);\n\n        switch(secondResult.outcome) {\n          case FOUND:\n            return SearchResult.found(8 + secondResult.getKeyPos());\n          case NOT_FOUND:\n            int lowPos = secondResult.getNextSmallerPos();\n            int highPos = secondResult.getNextLargerPos();\n            // don't map -1 into the legal range by adding 8!\n            if (lowPos>=0){ lowPos += 8;}\n            if (highPos>=0){ highPos += 8;}\n\n            if(firstResult.hasNextLargerPos() == false && secondResult.hasNextSmallerPos() == false)\n            {\n              // this happens when the result is in the gap of the two ranges, the correct\n              // \"smaller value\" is that of first result.\n              lowPos = firstResult.getNextSmallerPos();\n            }\n\n            return SearchResult.notFound( lowPos, highPos);\n\n          default:\n            throw new IllegalStateException(\"There only two possible search outcomes\");\n        }\n      }\n    }\n  }",
    "replace": "  @Override\n  public SearchResult getNearestChildPos(byte k) {\n    if (count <= 8) {\n      return binarySearchWithResult(firstV, 0, count, k);\n    } else {\n      SearchResult firstResult = binarySearchWithResult(\n              firstV, 0, 8, k);\n      // given the values are \"in order\" if we found a match or a value larger than\n      // the target we are done.\n      if (firstResult.outcome == SearchResult.Outcome.FOUND\n              || firstResult.hasNextLargerPos()) {\n        return firstResult;\n      } else {\n        SearchResult secondResult = binarySearchWithResult(\n                secondV, 0, (count - 8), k);\n\n        switch(secondResult.outcome) {\n          case FOUND:\n            return SearchResult.found(8 + secondResult.getKeyPos());\n          case NOT_FOUND:\n            int lowPos = secondResult.getNextSmallerPos();\n            int highPos = secondResult.getNextLargerPos();\n            // don't map -1 into the legal range by adding 8!\n            if (lowPos>=0){ lowPos += 8;}\n            if (highPos>=0){ highPos += 8;}\n\n            if(firstResult.hasNextLargerPos() == false && secondResult.hasNextSmallerPos() == false)\n            {\n              // this happens when the result is in the gap of the two ranges, the correct\n              // \"smaller value\" is that of first result.\n              lowPos = firstResult.getNextSmallerPos();\n            }\n\n            return SearchResult.notFound( lowPos, highPos);\n\n          default:\n            throw new IllegalStateException(\"There only two possible search outcomes\");\n        }\n      }\n    }\n  }"
  }
]
```