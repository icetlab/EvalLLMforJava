diff --git a/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java b/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java
index de6dddea..ed9708a6 100644
--- a/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java
+++ b/RoaringBitmap/src/main/java/org/roaringbitmap/art/Node16.java
@@ -19,80 +19,53 @@ public class Node16 extends Node {
 
   @Override
   public int getChildPos(byte k) {
-    byte[] firstBytes = LongUtils.toBDBytes(firstV);
-    if (count <= 8) {
-      return Node.binarySearch(firstBytes, 0, count, k);
+    int low = 0;
+    int high = count - 1;
+    int keyVal = Byte.toUnsignedInt(k);
+    while (low <= high) {
+      int mid = (low + high) >>> 1;
+      int midVal = Byte.toUnsignedInt(getChildKey(mid));
+      if (midVal < keyVal) {
+        low = mid + 1;
+      } else if (midVal > keyVal) {
+        high = mid - 1;
       } else {
-      int pos = Node.binarySearch(firstBytes, 0, 8, k);
-      if (pos != ILLEGAL_IDX) {
-        return pos;
-      } else {
-        byte[] secondBytes = LongUtils.toBDBytes(secondV);
-        pos = Node.binarySearch(secondBytes, 0, (count - 8), k);
-        if (pos != ILLEGAL_IDX) {
-          return 8 + pos;
-        } else {
-          return ILLEGAL_IDX;
-        }
+        return mid;
       }
     }
+    return ILLEGAL_IDX;
   }
 
   @Override
   public SearchResult getNearestChildPos(byte k) {
-    byte[] firstBytes = LongUtils.toBDBytes(firstV);
-    if (count <= 8) {
-      return Node.binarySearchWithResult(firstBytes, 0, count, k);
-    } else {
-      SearchResult firstResult = Node.binarySearchWithResult(
-              firstBytes, 0, 8, k);
-      // given the values are "in order" if we found a match or a value larger than
-      // the target we are done.
-      if (firstResult.outcome == SearchResult.Outcome.FOUND
-              || firstResult.hasNextLargerPos()) {
-        return firstResult;
+    int low = 0;
+    int high = count - 1;
+    int keyVal = Byte.toUnsignedInt(k);
+
+    while (low <= high) {
+      int mid = (low + high) >>> 1;
+      int midVal = Byte.toUnsignedInt(getChildKey(mid));
+
+      if (midVal < keyVal) {
+        low = mid + 1;
+      } else if (midVal > keyVal) {
+        high = mid - 1;
       } else {
-        byte[] secondBytes = LongUtils.toBDBytes(secondV);
-        SearchResult secondResult = Node.binarySearchWithResult(
-                secondBytes, 0, (count - 8), k);
-
-        switch(secondResult.outcome) {
-          case FOUND:
-            return SearchResult.found(8 + secondResult.getKeyPos());
-          case NOT_FOUND:
-            int lowPos = secondResult.getNextSmallerPos();
-            int highPos = secondResult.getNextLargerPos();
-            // don't map -1 into the legal range by adding 8!
-            if (lowPos>=0){ lowPos += 8;}
-            if (highPos>=0){ highPos += 8;}
-
-            if(firstResult.hasNextLargerPos() == false && secondResult.hasNextSmallerPos() == false)
-            {
-              // this happens when the result is in the gap of the two ranges, the correct
-              // "smaller value" is that of first result.
-              lowPos = firstResult.getNextSmallerPos();
-            }
-
-            return SearchResult.notFound( lowPos, highPos);
-
-          default:
-            throw new IllegalStateException("There only two possible search outcomes");
-        }
+        return SearchResult.found(mid); // key found
       }
     }
+    // key not found.
+    int nextLargerPos = (low < count) ? low : ILLEGAL_IDX;
+    int nextSmallerPos = (high >= 0) ? high : ILLEGAL_IDX;
+    return SearchResult.notFound(nextSmallerPos, nextLargerPos);
   }
 
   @Override
   public byte getChildKey(int pos) {
-    int posInLong;
-    if (pos <= 7) {
-      posInLong = pos;
-      byte[] firstBytes = LongUtils.toBDBytes(firstV);
-      return firstBytes[posInLong];
+    if (pos < 8) {
+      return (byte) (firstV >> (8 * (7 - pos)));
     } else {
-      posInLong = pos - 8;
-      byte[] secondBytes = LongUtils.toBDBytes(secondV);
-      return secondBytes[posInLong];
+      return (byte) (secondV >> (8 * (15 - pos)));
     }
   }
 
@@ -148,7 +121,6 @@ public class Node16 extends Node {
       //first
       byte[] bytes = LongUtils.toBDBytes(currentNode16.firstV);
       bytes[currentNode16.count] = key;
-      currentNode16.firstV = LongUtils.fromBDBytes(bytes);
       currentNode16.children[currentNode16.count] = child;
       sortSmallByteArray(bytes, currentNode16.children, 0, currentNode16.count);
       currentNode16.count++;
