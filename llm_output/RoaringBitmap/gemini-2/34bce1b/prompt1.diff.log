My analysis indicates that the `shiftLeftFromSpecifiedPosition` method in `IntegerUtil.java` is a performance bottleneck. Its current implementation involves converting an integer to a byte array, performing a `System.arraycopy`, and then converting the byte array back to an integer. This process includes multiple method calls and heap allocations for the byte array, which can be inefficient, especially if called frequently.

To improve performance, I will replace this implementation with a purely bitwise-operation-based approach. This new implementation will achieve the same byte-shifting logic without any object allocations or expensive method calls. It manipulates the integer's bits directly using masks and shifts to achieve the desired outcome.

Additionally, the original method implicitly throws an `IndexOutOfBoundsException` for invalid `pos` and `count` arguments due to the underlying `System.arraycopy`. To preserve this behavior, I will add explicit boundary checks that throw an `IndexOutOfBoundsException` for the same invalid argument combinations, ensuring functional equivalence with the original code.

```json
[
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/longlong/IntegerUtil.java",
    "search": "  public static int shiftLeftFromSpecifiedPosition(int v, int pos, int count) {\n    byte[] initialVal = toBDBytes(v);\n    System.arraycopy(initialVal, pos + 1, initialVal, pos, count);\n    return fromBDBytes(initialVal);\n  }",
    "replace": "  public static int shiftLeftFromSpecifiedPosition(int v, int pos, int count) {\n    // The original implementation's use of System.arraycopy implies bounds checks.\n    // For a byte[4] array, this means pos >= 0, count >= 0, and pos + count <= 3.\n    if (pos < 0 || count < 0 || pos + count > 3) {\n      throw new IndexOutOfBoundsException();\n    }\n\n    if (count == 0) {\n      return v;\n    }\n\n    // Create a mask for the bytes that will be replaced (from pos to pos+count-1).\n    long replaceMaskLong = ((1L << (count * 8)) - 1) << ((4 - pos - count) * 8);\n    int replaceMask = (int) replaceMaskLong;\n\n    // The source mask can be derived by shifting the replace mask.\n    int sourceMask = (int) (replaceMaskLong >>> 8);\n\n    int clearedV = v & ~replaceMask;\n    int shiftedSourcePart = (v & sourceMask) << 8;\n\n    return clearedV | shiftedSourcePart;\n  }"
  }
]
```