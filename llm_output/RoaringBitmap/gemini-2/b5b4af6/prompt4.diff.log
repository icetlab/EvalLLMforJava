The performance of `getCardinality()` in `RunContainer` and `MappeableRunContainer` is improved by optimizing the summation loop. The original implementation iterated through each run, adding `length` to a running total. The new approach first initializes a counter with the number of runs and then iterates to add `length - 1` for each run. This reduces the number of addition operations by `nbrruns`.

Additionally, the loop is unrolled to process four runs per iteration, which can reduce loop overhead and improve instruction-level parallelism. For `MappeableRunContainer`, a fast path is introduced for heap-backed `CharBuffer`s to access the underlying array directly, which avoids the overhead of `get()` method calls in the loop.

```json
[
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/RunContainer.getCardinalityg",
    "search": "  @Override\n  public int getCardinality() {\n    int card = 0;\n    for (int i = 0; i < this.nbrruns; ++i) {\n      card += (this.valueslength[2 * i + 1] & 0xFFFF) + 1;\n    }\n    return card;\n  }",
    "replace": "  @Override\n  public int getCardinality() {\n    int card = this.nbrruns;\n    int i = 0;\n    for (; i + 3 < this.nbrruns; i += 4) {\n      card += this.valueslength[2 * i + 1];\n      card += this.valueslength[2 * (i + 1) + 1];\n      card += this.valueslength[2 * (i + 2) + 1];\n      card += this.valueslength[2 * (i + 3) + 1];\n    }\n    for (; i < this.nbrruns; ++i) {\n      card += this.valueslength[2 * i + 1];\n    }\n    return card;\n  }"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MappeableRunContainer.getCardinalityg",
    "search": "  @Override\n  public int getCardinality() {\n    int card = 0;\n    for (int i = 0; i < this.nbrruns; ++i) {\n      card += (this.valueslength.get(2 * i + 1) & 0xFFFF) + 1;\n    }\n    return card;\n  }",
    "replace": "  @Override\n  public int getCardinality() {\n    if (this.valueslength.hasArray()) {\n      char[] vl = this.valueslength.array();\n      int offset = this.valueslength.arrayOffset();\n      int card = this.nbrruns;\n      int i = 0;\n      for (; i + 3 < this.nbrruns; i += 4) {\n        card += vl[offset + 2 * i + 1];\n        card += vl[offset + 2 * (i + 1) + 1];\n        card += vl[offset + 2 * (i + 2) + 1];\n        card += vl[offset + 2 * (i + 3) + 1];\n      }\n      for (; i < this.nbrruns; ++i) {\n        card += vl[offset + 2 * i + 1];\n      }\n      return card;\n    } else {\n      int card = this.nbrruns;\n      int i = 0;\n      for (; i + 3 < this.nbrruns; i += 4) {\n        card += this.valueslength.get(2 * i + 1);\n        card += this.valueslength.get(2 * (i + 1) + 1);\n        card += this.valueslength.get(2 * (i + 2) + 1);\n        card += this.valueslength.get(2 * (i + 3) + 1);\n      }\n      for (; i < this.nbrruns; ++i) {\n        card += this.valueslength.get(2 * i + 1);\n      }\n      return card;\n    }\n  }"
  }
]
```