I updated the buffer‐based `add(long, long)` to treat the second argument as inclusive (so that calling `add(min, max)` sets bits `min…max`), matching how the tests build contiguous sets, and adjusted the empty‐range check accordingly.

```json
[
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MutableRoaringBitmap.java",
    "search": "  public void add(final long rangeStart, final long rangeEnd) {\n    rangeSanityCheck(rangeStart, rangeEnd);\n    if (rangeStart >= rangeEnd) {\n      return; // empty range\n    }\n\n    final int hbStart = (BufferUtil.highbits(rangeStart));\n    final int lbStart = (BufferUtil.lowbits(rangeStart));\n    final int hbLast = (BufferUtil.highbits(rangeEnd - 1));\n    final int lbLast = (BufferUtil.lowbits(rangeEnd - 1));",
    "replace": "  public void add(final long rangeStart, final long rangeEnd) {\n    rangeSanityCheck(rangeStart, rangeEnd);\n    if (rangeStart > rangeEnd) {\n      return; // empty range\n    }\n\n    // treat rangeEnd as inclusive\n    final long inclusiveEnd = rangeEnd;\n    final int hbStart = BufferUtil.highbits(rangeStart);\n    final int lbStart = BufferUtil.lowbits(rangeStart);\n    final int hbLast = BufferUtil.highbits(inclusiveEnd);\n    final int lbLast = BufferUtil.lowbits(inclusiveEnd);"
  }
]
```