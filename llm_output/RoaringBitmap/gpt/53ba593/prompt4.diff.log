Iâ€™ve optimized both `checkedAdd` implementations to use a fast `contains` check instead of expensive cardinality computations, reducing overhead in both standard and buffer-backed bitmaps.

```json
[
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/RoaringBitmap.java",
    "search": "Container c = highLowContainer.getContainerAtIndex(i);\n      int oldCard = c.getCardinality();\n      // we need to keep the newContainer if a switch between containers type\n      // occur, in order to get the new cardinality\n      Container newCont = c.add(Util.lowbits(x));\n      highLowContainer.setContainerAtIndex(i, newCont);\n      if (newCont.getCardinality() > oldCard) {\n        return true;\n      }",
    "replace": "Container c = highLowContainer.getContainerAtIndex(i);\n      char lb = Util.lowbits(x);\n      boolean wasPresent = c.contains(lb);\n      Container newCont = c.add(lb);\n      highLowContainer.setContainerAtIndex(i, newCont);\n      if (!wasPresent) {\n        return true;\n      }"
  },
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MutableRoaringBitmap.java",
    "search": "MappeableContainer C = highLowContainer.getContainerAtIndex(i);\n      int oldcard = C.getCardinality();\n      C = C.add(BufferUtil.lowbits(x));\n      getMappeableRoaringArray().setContainerAtIndex(i, C);\n      return C.getCardinality() > oldcard;",
    "replace": "MappeableContainer C = highLowContainer.getContainerAtIndex(i);\n      char lb = BufferUtil.lowbits(x);\n      boolean wasPresent = C.contains(lb);\n      MappeableContainer newCont = C.add(lb);\n      getMappeableRoaringArray().setContainerAtIndex(i, newCont);\n      if (!wasPresent) {\n        return true;\n      }\n      return false;"
  }
]
```