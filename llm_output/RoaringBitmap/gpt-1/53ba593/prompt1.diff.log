We add a `contains(MutableRoaringBitmap)` method to the mutable bitmap class, mirroring the logic in `RoaringBitmap`, so that subset checks (used by the unit tests) work correctly.

```json
[
  {
    "filepath": "../RoaringBitmap/RoaringBitmap/src/main/java/org/roaringbitmap/buffer/MutableRoaringBitmap.java",
    "search": "@Override\n  public void writeExternal(ObjectOutput out) throws IOException {\n    getMappeableRoaringArray().writeExternal(out);\n  }",
    "replace": "@Override\n  public void writeExternal(ObjectOutput out) throws IOException {\n    getMappeableRoaringArray().writeExternal(out);\n  }\n\n  /**\n   * Checks whether the parameter is a subset of this MutableRoaringBitmap or not\n   * @param subset the potential subset\n   * @return true if the parameter is a subset of this bitmap\n   */\n  public boolean contains(MutableRoaringBitmap subset) {\n    final int length1 = this.highLowContainer.size();\n    final int length2 = subset.highLowContainer.size();\n    int pos1 = 0, pos2 = 0;\n    while (pos1 < length1 && pos2 < length2) {\n      final char s1 = this.highLowContainer.getKeyAtIndex(pos1);\n      final char s2 = subset.highLowContainer.getKeyAtIndex(pos2);\n      if (s1 == s2) {\n        final MappeableContainer c1 = this.highLowContainer.getContainerAtIndex(pos1);\n        final MappeableContainer c2 = subset.highLowContainer.getContainerAtIndex(pos2);\n        if (!c1.contains(c2)) {\n          return false;\n        }\n        ++pos1;\n        ++pos2;\n      } else if (s1 - s2 > 0) {\n        return false;\n      } else {\n        pos1 = this.highLowContainer.advanceUntil(s2, pos1);\n      }\n    }\n    return pos2 == length2;\n  }"
  }
]
```