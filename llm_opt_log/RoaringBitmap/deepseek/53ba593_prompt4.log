Based on the performance issue to avoid computing cardinality for run containers when not needed, I'll optimize the `checkedAdd` method in `RoaringBitmap.java`. The key change is to avoid computing the full cardinality for run containers when we can determine if the value was added by checking the run container directly.

Here's the optimized version of `RoaringBitmap.java` with the changes:

```java
/*
 * (c) the authors Licensed under the Apache License, Version 2.0.
 */

package org.roaringbitmap;

// [Previous imports remain the same...]

public class RoaringBitmap implements Cloneable, Serializable, Iterable<Integer>, Externalizable,
    ImmutableBitmapDataProvider, BitmapDataProvider, AppendableStorage<Container> {

    // [Previous code remains the same until checkedAdd method...]

    /**
     * Add the value to the container (set the value to "true"), whether it already appears or not.
     *
     * @param x integer value
     * @return true if the added int wasn't already contained in the bitmap. False otherwise.
     */
    public boolean checkedAdd(final int x) {
        final char hb = Util.highbits(x);
        final int i = highLowContainer.getIndex(hb);
        if (i >= 0) {
            Container c = highLowContainer.getContainerAtIndex(i);
            if (c instanceof RunContainer) {
                // For RunContainer, we can check contains first to avoid full cardinality computation
                char val = Util.lowbits(x);
                if (c.contains(val)) {
                    return false;
                }
                Container newCont = c.add(val);
                highLowContainer.setContainerAtIndex(i, newCont);
                return true;
            } else {
                int oldCard = c.getCardinality();
                Container newCont = c.add(Util.lowbits(x));
                if (newCont != c) {
                    highLowContainer.setContainerAtIndex(i, newCont);
                }
                return newCont.getCardinality() > oldCard;
            }
        } else {
            final ArrayContainer newac = new ArrayContainer();
            highLowContainer.insertNewKeyValueAt(-i - 1, hb, newac.add(Util.lowbits(x)));
            return true;
        }
    }

    // [Rest of the code remains the same...]
}
```

Key changes made:

1. In the `checkedAdd` method, we now first check if the container is a `RunContainer`.
2. For `RunContainer`, we first check if the value exists using `contains()` before adding it. This avoids computing the full cardinality which can be expensive for run containers.
3. If the value doesn't exist in the run container, we add it and return true (since we know it's a new value).
4. For other container types (ArrayContainer, BitmapContainer), we keep the original behavior of comparing cardinality before and after adding.

This optimization should significantly improve performance when dealing with run containers, as we avoid the expensive cardinality computation in cases where we can determine the value wasn't present by just checking the run container directly.

The change maintains the same functionality but is more efficient for run containers. The unit tests should continue to pass since we haven't changed the behavior, just optimized the implementation.